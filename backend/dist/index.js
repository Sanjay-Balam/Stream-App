import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/cookie/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse2;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C = function() {
    };
    C.prototype = Object.create(null);
    return C;
  })();
  function parse2(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode2;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream", EndOfStreamError, AbortError;
var init_Errors = __esm(() => {
  EndOfStreamError = class EndOfStreamError extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };
});

// node_modules/strtok3/lib/stream/Deferred.js
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
}

// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
var StreamReader;
var init_StreamReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  StreamReader = class StreamReader extends AbstractStreamReader {
    constructor(s) {
      super();
      this.s = s;
      this.deferred = null;
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.resolve(0);
        }
      });
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.abort());
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const readBuffer = this.s.read(buffer.length);
      if (readBuffer) {
        buffer.set(readBuffer);
        return readBuffer.length;
      }
      const request = {
        buffer,
        mayBeLess,
        deferred: new Deferred
      };
      this.deferred = request.deferred;
      this.s.once("readable", () => {
        this.readDeferred(request);
      });
      return request.deferred.promise;
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.buffer.length);
      if (readBuffer) {
        request.buffer.set(readBuffer);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.interrupted = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
    async abort() {
      this.reject(new AbortError);
    }
    async close() {
      return this.abort();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
  WebStreamReader = class WebStreamReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
  WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
    }
    writeChunk(target, chunk) {
      const written = Math.min(chunk.length, target.length);
      target.set(chunk.subarray(0, written));
      if (written < chunk.length) {
        this.buffer = chunk.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer, this.buffer);
      }
      while (totalBytesRead < buffer.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError;
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error) {
    if (error instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err) {
          if (options?.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
  BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError;
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };
});

// node_modules/strtok3/lib/BlobTokenizer.js
var init_BlobTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/core.js
function fromStream(stream, options) {
  const streamReader = new StreamReader(stream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await streamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_stream();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_BlobTokenizer();
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "node:fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  FileTokenizer = class FileTokenizer extends AbstractTokenizer {
    static async fromFile(sourceFilePath) {
      const fileHandle = await fsOpen(sourceFilePath, "r");
      const stat = await fileHandle.stat();
      return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
      super(options);
      this.fileHandle = fileHandle;
      this.fileInfo = options.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      if (normOptions.length === 0)
        return 0;
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      await this.fileHandle.close();
      return super.close();
    }
    setPosition(position) {
      this.position = position;
    }
    supportsRandomAccess() {
      return true;
    }
  };
});

// node_modules/strtok3/lib/index.js
import { stat as fsStat } from "node:fs/promises";
async function fromStream2(stream, options) {
  const rst = fromStream(stream, options);
  if (stream.path) {
    const stat = await fsStat(stream.path);
    rst.fileInfo.path = stream.path;
    rst.fileInfo.size = stat.size;
  }
  return rst;
}
var fromFile;
var init_lib = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}

class StringType2 {
  constructor(len, encoding) {
    this.len = len;
    if (encoding && encoding.toLowerCase() === "windows-1252") {
      this.decoder = StringType2.decodeWindows1252;
    } else {
      const textDecoder = new TextDecoder(encoding);
      this.decoder = (bytes) => textDecoder.decode(bytes);
    }
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return this.decoder(bytes);
  }
  static decodeWindows1252(bytes) {
    let result = "";
    for (let i = 0;i < bytes.length; i++) {
      const byte = bytes[i];
      result += byte < 128 || byte >= 160 ? String.fromCharCode(byte) : StringType2.win1252Map[byte - 128];
    }
    return result;
  }
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib2 = __esm(() => {
  init_ieee754();
  UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
  StringType2.win1252Map = "€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ";
});

// node_modules/fflate/esm/index.mjs
import { createRequire as createRequire2 } from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (;i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1;i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0;i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0;i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
}, flt, i, i, i, i, fdt, i, flrm, fdrm, max = function(a) {
  var m = a[0];
  for (var i = 1;i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0;i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0;i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, et, gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
}, gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_esm = __esm(() => {
  require2 = createRequire2("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib2();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i = buffer.length - 4;i >= 0; i--) {
      if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType2(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType2(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i = 0;i <= bufferLength - portionLength; i++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var import_debug, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib3 = __esm(() => {
  init_lib2();
  init_esm();
  import_debug = __toESM(require_src(), 1);
  init_ZipToken();
  debug = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
  init_lib2();
  uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
  return new FileTypeParser(options).fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer, options) {
  return new FileTypeParser(options).fromTokenizer(tokenizer);
}

class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType2(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType2(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType2(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType2(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType2(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType2(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {
        }
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) {
          return type;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var reasonableDetectionSizeInBytes = 4100, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib2();
  init_core();
  init_lib3();
  init_uint8array_extras();
  init_util();
  init_supported();
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
  supportedMimeTypes: () => supportedMimeTypes,
  supportedExtensions: () => supportedExtensions,
  fileTypeStream: () => fileTypeStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromBlob: () => fileTypeFromBlob,
  FileTypeParser: () => FileTypeParser2
});
import { ReadableStream as WebReadableStream } from "node:stream/web";
import { pipeline, PassThrough, Readable } from "node:stream";
async function fileTypeFromFile(path, options) {
  return new FileTypeParser2(options).fromFile(path, options);
}
async function fileTypeFromStream(stream, options) {
  return new FileTypeParser2(options).fromStream(stream);
}
async function fileTypeStream(readableStream, options = {}) {
  return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}
var FileTypeParser2;
var init_file_type = __esm(() => {
  init_lib();
  init_core2();
  init_core2();
  FileTypeParser2 = class FileTypeParser2 extends FileTypeParser {
    async fromStream(stream) {
      const tokenizer = await (stream instanceof WebReadableStream ? fromWebStream(stream, this.tokenizerOptions) : fromStream2(stream, this.tokenizerOptions));
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async fromFile(path) {
      const tokenizer = await fromFile(path);
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(readableStream, options = {}) {
      if (!(readableStream instanceof Readable)) {
        return super.toDetectionStream(readableStream, options);
      }
      const { sampleSize = reasonableDetectionSizeInBytes } = options;
      return new Promise((resolve, reject) => {
        readableStream.on("error", reject);
        readableStream.once("readable", () => {
          (async () => {
            try {
              const pass = new PassThrough;
              const outputStream = pipeline ? pipeline(readableStream, pass, () => {
              }) : readableStream.pipe(pass);
              const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
              try {
                pass.fileType = await this.fromBuffer(chunk);
              } catch (error) {
                if (error instanceof EndOfStreamError) {
                  pass.fileType = undefined;
                } else {
                  reject(error);
                }
              }
              resolve(outputStream);
            } catch (error) {
              reject(error);
            }
          })();
        });
      });
    }
  };
});

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS((exports) => {
  var TypedArrayPrototypeGetSymbolToStringTag = (() => {
    const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
    return (value) => g.call(value);
  })();
  function isUint8Array(value) {
    return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
  }
  function isAnyArrayBuffer(value) {
    return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
  }
  function isRegExp(regexp2) {
    return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
  }
  function isMap(value) {
    return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
  }
  function isDate(date2) {
    return date2 instanceof Date || Object.prototype.toString.call(date2) === "[object Date]";
  }
  function defaultInspect(x, _options) {
    return JSON.stringify(x, (k, v) => {
      if (typeof v === "bigint") {
        return { $numberLong: `${v}` };
      } else if (isMap(v)) {
        return Object.fromEntries(v);
      }
      return v;
    });
  }
  function getStylizeFunction(options) {
    const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
    if (stylizeExists) {
      return options.stylize;
    }
  }
  var BSON_MAJOR_VERSION = 6;
  var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
  var BSON_INT32_MAX = 2147483647;
  var BSON_INT32_MIN = -2147483648;
  var BSON_INT64_MAX = Math.pow(2, 63) - 1;
  var BSON_INT64_MIN = -Math.pow(2, 63);
  var JS_INT_MAX = Math.pow(2, 53);
  var JS_INT_MIN = -Math.pow(2, 53);
  var BSON_DATA_NUMBER = 1;
  var BSON_DATA_STRING = 2;
  var BSON_DATA_OBJECT = 3;
  var BSON_DATA_ARRAY = 4;
  var BSON_DATA_BINARY = 5;
  var BSON_DATA_UNDEFINED = 6;
  var BSON_DATA_OID = 7;
  var BSON_DATA_BOOLEAN = 8;
  var BSON_DATA_DATE = 9;
  var BSON_DATA_NULL = 10;
  var BSON_DATA_REGEXP = 11;
  var BSON_DATA_DBPOINTER = 12;
  var BSON_DATA_CODE = 13;
  var BSON_DATA_SYMBOL = 14;
  var BSON_DATA_CODE_W_SCOPE = 15;
  var BSON_DATA_INT = 16;
  var BSON_DATA_TIMESTAMP = 17;
  var BSON_DATA_LONG = 18;
  var BSON_DATA_DECIMAL128 = 19;
  var BSON_DATA_MIN_KEY = 255;
  var BSON_DATA_MAX_KEY = 127;
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
  var BSONType = Object.freeze({
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: -1,
    maxKey: 127
  });

  class BSONError extends Error {
    get bsonError() {
      return true;
    }
    get name() {
      return "BSONError";
    }
    constructor(message, options) {
      super(message, options);
    }
    static isBSONError(value) {
      return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
    }
  }

  class BSONVersionError extends BSONError {
    get name() {
      return "BSONVersionError";
    }
    constructor() {
      super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
    }
  }

  class BSONRuntimeError extends BSONError {
    get name() {
      return "BSONRuntimeError";
    }
    constructor(message) {
      super(message);
    }
  }

  class BSONOffsetError extends BSONError {
    get name() {
      return "BSONOffsetError";
    }
    constructor(message, offset, options) {
      super(`${message}. offset: ${offset}`, options);
      this.offset = offset;
    }
  }
  var TextDecoderFatal;
  var TextDecoderNonFatal;
  function parseUtf8(buffer2, start, end, fatal) {
    if (fatal) {
      TextDecoderFatal ??= new TextDecoder("utf8", { fatal: true });
      try {
        return TextDecoderFatal.decode(buffer2.subarray(start, end));
      } catch (cause) {
        throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
      }
    }
    TextDecoderNonFatal ??= new TextDecoder("utf8", { fatal: false });
    return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
  }
  function tryReadBasicLatin(uint8array, start, end) {
    if (uint8array.length === 0) {
      return "";
    }
    const stringByteLength = end - start;
    if (stringByteLength === 0) {
      return "";
    }
    if (stringByteLength > 20) {
      return null;
    }
    if (stringByteLength === 1 && uint8array[start] < 128) {
      return String.fromCharCode(uint8array[start]);
    }
    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
      return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
    }
    if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
      return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
    }
    const latinBytes = [];
    for (let i = start;i < end; i++) {
      const byte2 = uint8array[i];
      if (byte2 > 127) {
        return null;
      }
      latinBytes.push(byte2);
    }
    return String.fromCharCode(...latinBytes);
  }
  function tryWriteBasicLatin(destination, source, offset) {
    if (source.length === 0)
      return 0;
    if (source.length > 25)
      return null;
    if (destination.length - offset < source.length)
      return null;
    for (let charOffset = 0, destinationOffset = offset;charOffset < source.length; charOffset++, destinationOffset++) {
      const char = source.charCodeAt(charOffset);
      if (char > 127)
        return null;
      destination[destinationOffset] = char;
    }
    return source.length;
  }
  function nodejsMathRandomBytes(byteLength) {
    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  }
  var nodejsRandomBytes = (() => {
    try {
      return __require("crypto").randomBytes;
    } catch {
      return nodejsMathRandomBytes;
    }
  })();
  var nodeJsByteUtils = {
    toLocalBufferType(potentialBuffer) {
      if (Buffer.isBuffer(potentialBuffer)) {
        return potentialBuffer;
      }
      if (ArrayBuffer.isView(potentialBuffer)) {
        return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
      }
      const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return Buffer.from(potentialBuffer);
      }
      throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
    },
    allocate(size) {
      return Buffer.alloc(size);
    },
    allocateUnsafe(size) {
      return Buffer.allocUnsafe(size);
    },
    equals(a12, b) {
      return nodeJsByteUtils.toLocalBufferType(a12).equals(b);
    },
    fromNumberArray(array) {
      return Buffer.from(array);
    },
    fromBase64(base64) {
      return Buffer.from(base64, "base64");
    },
    toBase64(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
    },
    fromISO88591(codePoints) {
      return Buffer.from(codePoints, "binary");
    },
    toISO88591(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
    },
    fromHex(hex) {
      return Buffer.from(hex, "hex");
    },
    toHex(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
    },
    toUTF8(buffer2, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
      if (fatal) {
        for (let i = 0;i < string.length; i++) {
          if (string.charCodeAt(i) === 65533) {
            parseUtf8(buffer2, start, end, true);
            break;
          }
        }
      }
      return string;
    },
    utf8ByteLength(input) {
      return Buffer.byteLength(input, "utf8");
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
      if (latinBytesWritten != null) {
        return latinBytesWritten;
      }
      return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, undefined, "utf8");
    },
    randomBytes: nodejsRandomBytes,
    swap32(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
    }
  };
  function isReactNative() {
    const { navigator: navigator2 } = globalThis;
    return typeof navigator2 === "object" && navigator2.product === "ReactNative";
  }
  function webMathRandomBytes(byteLength) {
    if (byteLength < 0) {
      throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
    }
    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  }
  var webRandomBytes = (() => {
    const { crypto: crypto2 } = globalThis;
    if (crypto2 != null && typeof crypto2.getRandomValues === "function") {
      return (byteLength) => {
        return crypto2.getRandomValues(webByteUtils.allocate(byteLength));
      };
    } else {
      if (isReactNative()) {
        const { console: console2 } = globalThis;
        console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
      }
      return webMathRandomBytes;
    }
  })();
  var HEX_DIGIT = /(\d|[a-f])/i;
  var webByteUtils = {
    toLocalBufferType(potentialUint8array) {
      const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
      if (stringTag === "Uint8Array") {
        return potentialUint8array;
      }
      if (ArrayBuffer.isView(potentialUint8array)) {
        return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
      }
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return new Uint8Array(potentialUint8array);
      }
      throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
    },
    allocate(size) {
      if (typeof size !== "number") {
        throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
      }
      return new Uint8Array(size);
    },
    allocateUnsafe(size) {
      return webByteUtils.allocate(size);
    },
    equals(a12, b) {
      if (a12.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0;i < a12.byteLength; i++) {
        if (a12[i] !== b[i]) {
          return false;
        }
      }
      return true;
    },
    fromNumberArray(array) {
      return Uint8Array.from(array);
    },
    fromBase64(base64) {
      return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
    },
    toBase64(uint8array) {
      return btoa(webByteUtils.toISO88591(uint8array));
    },
    fromISO88591(codePoints) {
      return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
    },
    toISO88591(uint8array) {
      return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
    },
    fromHex(hex) {
      const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
      const buffer2 = [];
      for (let i = 0;i < evenLengthHex.length; i += 2) {
        const firstDigit = evenLengthHex[i];
        const secondDigit = evenLengthHex[i + 1];
        if (!HEX_DIGIT.test(firstDigit)) {
          break;
        }
        if (!HEX_DIGIT.test(secondDigit)) {
          break;
        }
        const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
        buffer2.push(hexDigit);
      }
      return Uint8Array.from(buffer2);
    },
    toHex(uint8array) {
      return Array.from(uint8array, (byte2) => byte2.toString(16).padStart(2, "0")).join("");
    },
    toUTF8(uint8array, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      return parseUtf8(uint8array, start, end, fatal);
    },
    utf8ByteLength(input) {
      return new TextEncoder().encode(input).byteLength;
    },
    encodeUTF8Into(uint8array, source, byteOffset) {
      const bytes = new TextEncoder().encode(source);
      uint8array.set(bytes, byteOffset);
      return bytes.byteLength;
    },
    randomBytes: webRandomBytes,
    swap32(buffer2) {
      if (buffer2.length % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0;i < buffer2.length; i += 4) {
        const byte0 = buffer2[i];
        const byte1 = buffer2[i + 1];
        const byte2 = buffer2[i + 2];
        const byte3 = buffer2[i + 3];
        buffer2[i] = byte3;
        buffer2[i + 1] = byte2;
        buffer2[i + 2] = byte1;
        buffer2[i + 3] = byte0;
      }
      return buffer2;
    }
  };
  var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
  var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;

  class BSONValue {
    get [BSON_VERSION_SYMBOL]() {
      return BSON_MAJOR_VERSION;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
      return this.inspect(depth, options, inspect);
    }
  }
  var FLOAT = new Float64Array(1);
  var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
  FLOAT[0] = -1;
  var isBigEndian = FLOAT_BYTES[7] === 0;
  var NumberUtils = {
    isBigEndian,
    getNonnegativeInt32LE(source, offset) {
      if (source[offset + 3] > 127) {
        throw new RangeError(`Size cannot be negative at offset: ${offset}`);
      }
      return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
    },
    getInt32LE(source, offset) {
      return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
    },
    getUint32LE(source, offset) {
      return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
    },
    getUint32BE(source, offset) {
      return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
    },
    getBigInt64LE(source, offset) {
      const hi = BigInt(source[offset + 4] + source[offset + 5] * 256 + source[offset + 6] * 65536 + (source[offset + 7] << 24));
      const lo = BigInt(source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216);
      return (hi << BigInt(32)) + lo;
    },
    getFloat64LE: isBigEndian ? (source, offset) => {
      FLOAT_BYTES[7] = source[offset];
      FLOAT_BYTES[6] = source[offset + 1];
      FLOAT_BYTES[5] = source[offset + 2];
      FLOAT_BYTES[4] = source[offset + 3];
      FLOAT_BYTES[3] = source[offset + 4];
      FLOAT_BYTES[2] = source[offset + 5];
      FLOAT_BYTES[1] = source[offset + 6];
      FLOAT_BYTES[0] = source[offset + 7];
      return FLOAT[0];
    } : (source, offset) => {
      FLOAT_BYTES[0] = source[offset];
      FLOAT_BYTES[1] = source[offset + 1];
      FLOAT_BYTES[2] = source[offset + 2];
      FLOAT_BYTES[3] = source[offset + 3];
      FLOAT_BYTES[4] = source[offset + 4];
      FLOAT_BYTES[5] = source[offset + 5];
      FLOAT_BYTES[6] = source[offset + 6];
      FLOAT_BYTES[7] = source[offset + 7];
      return FLOAT[0];
    },
    setInt32BE(destination, offset, value) {
      destination[offset + 3] = value;
      value >>>= 8;
      destination[offset + 2] = value;
      value >>>= 8;
      destination[offset + 1] = value;
      value >>>= 8;
      destination[offset] = value;
      return 4;
    },
    setInt32LE(destination, offset, value) {
      destination[offset] = value;
      value >>>= 8;
      destination[offset + 1] = value;
      value >>>= 8;
      destination[offset + 2] = value;
      value >>>= 8;
      destination[offset + 3] = value;
      return 4;
    },
    setBigInt64LE(destination, offset, value) {
      const mask32bits = BigInt(4294967295);
      let lo = Number(value & mask32bits);
      destination[offset] = lo;
      lo >>= 8;
      destination[offset + 1] = lo;
      lo >>= 8;
      destination[offset + 2] = lo;
      lo >>= 8;
      destination[offset + 3] = lo;
      let hi = Number(value >> BigInt(32) & mask32bits);
      destination[offset + 4] = hi;
      hi >>= 8;
      destination[offset + 5] = hi;
      hi >>= 8;
      destination[offset + 6] = hi;
      hi >>= 8;
      destination[offset + 7] = hi;
      return 8;
    },
    setFloat64LE: isBigEndian ? (destination, offset, value) => {
      FLOAT[0] = value;
      destination[offset] = FLOAT_BYTES[7];
      destination[offset + 1] = FLOAT_BYTES[6];
      destination[offset + 2] = FLOAT_BYTES[5];
      destination[offset + 3] = FLOAT_BYTES[4];
      destination[offset + 4] = FLOAT_BYTES[3];
      destination[offset + 5] = FLOAT_BYTES[2];
      destination[offset + 6] = FLOAT_BYTES[1];
      destination[offset + 7] = FLOAT_BYTES[0];
      return 8;
    } : (destination, offset, value) => {
      FLOAT[0] = value;
      destination[offset] = FLOAT_BYTES[0];
      destination[offset + 1] = FLOAT_BYTES[1];
      destination[offset + 2] = FLOAT_BYTES[2];
      destination[offset + 3] = FLOAT_BYTES[3];
      destination[offset + 4] = FLOAT_BYTES[4];
      destination[offset + 5] = FLOAT_BYTES[5];
      destination[offset + 6] = FLOAT_BYTES[6];
      destination[offset + 7] = FLOAT_BYTES[7];
      return 8;
    }
  };

  class Binary extends BSONValue {
    get _bsontype() {
      return "Binary";
    }
    constructor(buffer2, subType) {
      super();
      if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
        throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
      }
      this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer2 == null) {
        this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
        this.position = 0;
      } else {
        this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
        this.position = this.buffer.byteLength;
      }
    }
    put(byteValue) {
      if (typeof byteValue === "string" && byteValue.length !== 1) {
        throw new BSONError("only accepts single character String");
      } else if (typeof byteValue !== "number" && byteValue.length !== 1)
        throw new BSONError("only accepts single character Uint8Array or Array");
      let decodedByte;
      if (typeof byteValue === "string") {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === "number") {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
    write(sequence, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === "string") {
        throw new BSONError("input cannot be string");
      }
    }
    read(position, length) {
      length = length && length > 0 ? length : this.position;
      const end = position + length;
      return this.buffer.subarray(position, end > this.position ? this.position : end);
    }
    value() {
      return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
    }
    length() {
      return this.position;
    }
    toJSON() {
      return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.buffer.subarray(0, this.position));
      if (encoding === "base64")
        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      if (encoding === "utf8" || encoding === "utf-8")
        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
    }
    toExtendedJSON(options) {
      options = options || {};
      if (this.sub_type === Binary.SUBTYPE_VECTOR) {
        validateBinaryVector(this);
      }
      const base64String = ByteUtils.toBase64(this.buffer);
      const subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? "0" + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? "0" + subType : subType
        }
      };
    }
    toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.subarray(0, this.position));
      }
      throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`);
    }
    static createFromHexString(hex, subType) {
      return new Binary(ByteUtils.fromHex(hex), subType);
    }
    static createFromBase64(base64, subType) {
      return new Binary(ByteUtils.fromBase64(base64), subType);
    }
    static fromExtendedJSON(doc, options) {
      options = options || {};
      let data;
      let type;
      if ("$binary" in doc) {
        if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== "string") {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ("$uuid" in doc) {
        type = 4;
        data = UUID.bytesFromString(doc.$uuid);
      }
      if (!data) {
        throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      const base64Arg = inspect(base64, options);
      const subTypeArg = inspect(this.sub_type, options);
      return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
    }
    toInt8Array() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.Int8) {
        throw new BSONError("Binary datatype field is not Int8");
      }
      validateBinaryVector(this);
      return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    }
    toFloat32Array() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.Float32) {
        throw new BSONError("Binary datatype field is not Float32");
      }
      validateBinaryVector(this);
      const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      if (NumberUtils.isBigEndian)
        ByteUtils.swap32(floatBytes);
      return new Float32Array(floatBytes.buffer);
    }
    toPackedBits() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {
        throw new BSONError("Binary datatype field is not packed bit");
      }
      validateBinaryVector(this);
      return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    }
    toBits() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {
        throw new BSONError("Binary datatype field is not packed bit");
      }
      validateBinaryVector(this);
      const byteCount = this.length() - 2;
      const bitCount = byteCount * 8 - this.buffer[1];
      const bits2 = new Int8Array(bitCount);
      for (let bitOffset = 0;bitOffset < bits2.length; bitOffset++) {
        const byteOffset = bitOffset / 8 | 0;
        const byte2 = this.buffer[byteOffset + 2];
        const shift = 7 - bitOffset % 8;
        const bit = byte2 >> shift & 1;
        bits2[bitOffset] = bit;
      }
      return bits2;
    }
    static fromInt8Array(array) {
      const buffer2 = ByteUtils.allocate(array.byteLength + 2);
      buffer2[0] = Binary.VECTOR_TYPE.Int8;
      buffer2[1] = 0;
      const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      buffer2.set(intBytes, 2);
      const bin = new this(buffer2, this.SUBTYPE_VECTOR);
      validateBinaryVector(bin);
      return bin;
    }
    static fromFloat32Array(array) {
      const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
      binaryBytes[0] = Binary.VECTOR_TYPE.Float32;
      binaryBytes[1] = 0;
      const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      binaryBytes.set(floatBytes, 2);
      if (NumberUtils.isBigEndian)
        ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
      const bin = new this(binaryBytes, this.SUBTYPE_VECTOR);
      validateBinaryVector(bin);
      return bin;
    }
    static fromPackedBits(array, padding = 0) {
      const buffer2 = ByteUtils.allocate(array.byteLength + 2);
      buffer2[0] = Binary.VECTOR_TYPE.PackedBit;
      buffer2[1] = padding;
      buffer2.set(array, 2);
      const bin = new this(buffer2, this.SUBTYPE_VECTOR);
      validateBinaryVector(bin);
      return bin;
    }
    static fromBits(bits2) {
      const byteLength = bits2.length + 7 >>> 3;
      const bytes = new Uint8Array(byteLength + 2);
      bytes[0] = Binary.VECTOR_TYPE.PackedBit;
      const remainder = bits2.length % 8;
      bytes[1] = remainder === 0 ? 0 : 8 - remainder;
      for (let bitOffset = 0;bitOffset < bits2.length; bitOffset++) {
        const byteOffset = bitOffset >>> 3;
        const bit = bits2[bitOffset];
        if (bit !== 0 && bit !== 1) {
          throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits2[bitOffset]}`);
        }
        if (bit === 0)
          continue;
        const shift = 7 - bitOffset % 8;
        bytes[byteOffset + 2] |= bit << shift;
      }
      return new this(bytes, Binary.SUBTYPE_VECTOR);
    }
  }
  Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  Binary.BUFFER_SIZE = 256;
  Binary.SUBTYPE_DEFAULT = 0;
  Binary.SUBTYPE_FUNCTION = 1;
  Binary.SUBTYPE_BYTE_ARRAY = 2;
  Binary.SUBTYPE_UUID_OLD = 3;
  Binary.SUBTYPE_UUID = 4;
  Binary.SUBTYPE_MD5 = 5;
  Binary.SUBTYPE_ENCRYPTED = 6;
  Binary.SUBTYPE_COLUMN = 7;
  Binary.SUBTYPE_SENSITIVE = 8;
  Binary.SUBTYPE_VECTOR = 9;
  Binary.SUBTYPE_USER_DEFINED = 128;
  Binary.VECTOR_TYPE = Object.freeze({
    Int8: 3,
    Float32: 39,
    PackedBit: 16
  });
  function validateBinaryVector(vector) {
    if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
      return;
    const size = vector.position;
    const datatype = vector.buffer[0];
    const padding = vector.buffer[1];
    if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
      throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
    }
    if (datatype === Binary.VECTOR_TYPE.Float32) {
      if (size !== 0 && size - 2 !== 0 && (size - 2) % 4 !== 0) {
        throw new BSONError("Invalid Vector: Float32 vector must contain a multiple of 4 bytes");
      }
    }
    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
      throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
    }
    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
      throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
    }
  }
  var UUID_BYTE_LENGTH = 16;
  var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
  var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

  class UUID extends Binary {
    constructor(input) {
      let bytes;
      if (input == null) {
        bytes = UUID.generate();
      } else if (input instanceof UUID) {
        bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
        bytes = ByteUtils.toLocalBufferType(input);
      } else if (typeof input === "string") {
        bytes = UUID.bytesFromString(input);
      } else {
        throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      }
      super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
    }
    toHexString(includeDashes = true) {
      if (includeDashes) {
        return [
          ByteUtils.toHex(this.buffer.subarray(0, 4)),
          ByteUtils.toHex(this.buffer.subarray(4, 6)),
          ByteUtils.toHex(this.buffer.subarray(6, 8)),
          ByteUtils.toHex(this.buffer.subarray(8, 10)),
          ByteUtils.toHex(this.buffer.subarray(10, 16))
        ].join("-");
      }
      return ByteUtils.toHex(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.id);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch {
        return false;
      }
    }
    toBinary() {
      return new Binary(this.id, Binary.SUBTYPE_UUID);
    }
    static generate() {
      const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      return bytes;
    }
    static isValid(input) {
      if (!input) {
        return false;
      }
      if (typeof input === "string") {
        return UUID.isValidUUIDString(input);
      }
      if (isUint8Array(input)) {
        return input.byteLength === UUID_BYTE_LENGTH;
      }
      return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
    }
    static createFromHexString(hexString) {
      const buffer2 = UUID.bytesFromString(hexString);
      return new UUID(buffer2);
    }
    static createFromBase64(base64) {
      return new UUID(ByteUtils.fromBase64(base64));
    }
    static bytesFromString(representation) {
      if (!UUID.isValidUUIDString(representation)) {
        throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
      }
      return ByteUtils.fromHex(representation.replace(/-/g, ""));
    }
    static isValidUUIDString(representation) {
      return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new UUID(${inspect(this.toHexString(), options)})`;
    }
  }

  class Code extends BSONValue {
    get _bsontype() {
      return "Code";
    }
    constructor(code, scope) {
      super();
      this.code = code.toString();
      this.scope = scope ?? null;
    }
    toJSON() {
      if (this.scope != null) {
        return { code: this.code, scope: this.scope };
      }
      return { code: this.code };
    }
    toExtendedJSON() {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    }
    static fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      let parametersString = inspect(this.code, options);
      const multiLineFn = parametersString.includes(`
`);
      if (this.scope != null) {
        parametersString += `,${multiLineFn ? `
` : " "}${inspect(this.scope, options)}`;
      }
      const endingNewline = multiLineFn && this.scope === null;
      return `new Code(${multiLineFn ? `
` : ""}${parametersString}${endingNewline ? `
` : ""})`;
    }
  }
  function isDBRefLike(value) {
    return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || ("$db" in value) && typeof value.$db === "string");
  }

  class DBRef extends BSONValue {
    get _bsontype() {
      return "DBRef";
    }
    constructor(collection, oid, db, fields) {
      super();
      const parts = collection.split(".");
      if (parts.length === 2) {
        db = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db;
      this.fields = fields || {};
    }
    get namespace() {
      return this.collection;
    }
    set namespace(value) {
      this.collection = value;
    }
    toJSON() {
      const o = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null)
        o.$db = this.db;
      return o;
    }
    toExtendedJSON(options) {
      options = options || {};
      let o = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o;
      }
      if (this.db)
        o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    }
    static fromExtendedJSON(doc) {
      const copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const args = [
        inspect(this.namespace, options),
        inspect(this.oid, options),
        ...this.db ? [inspect(this.db, options)] : [],
        ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
      ];
      args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
      return `new DBRef(${args.join(", ")})`;
    }
  }
  function removeLeadingZerosAndExplicitPlus(str) {
    if (str === "") {
      return str;
    }
    let startIndex = 0;
    const isNegative = str[startIndex] === "-";
    const isExplicitlyPositive = str[startIndex] === "+";
    if (isExplicitlyPositive || isNegative) {
      startIndex += 1;
    }
    let foundInsignificantZero = false;
    for (;startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
      foundInsignificantZero = true;
    }
    if (!foundInsignificantZero) {
      return isExplicitlyPositive ? str.slice(1) : str;
    }
    return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
  }
  function validateStringCharacters(str, radix) {
    radix = radix ?? 10;
    const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
    const regex2 = new RegExp(`[^-+${validCharacters}]`, "i");
    return regex2.test(str) ? false : str;
  }
  var wasm = undefined;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch {
  }
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  var MAX_INT64_STRING_LENGTH = 20;
  var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;

  class Long extends BSONValue {
    get _bsontype() {
      return "Long";
    }
    get __isLong__() {
      return true;
    }
    constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
      super();
      const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
      const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
      const res = typeof lowOrValue === "string" ? Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
      this.low = res.low;
      this.high = res.high;
      this.unsigned = res.unsigned;
    }
    static fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    static fromInt(value, unsigned) {
      let obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    static fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value < 0)
          return Long.UZERO;
        if (value >= TWO_PWR_64_DBL)
          return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -9223372036854776000)
          return Long.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return Long.MAX_VALUE;
      }
      if (value < 0)
        return Long.fromNumber(-value, unsigned).neg();
      return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    static fromBigInt(value, unsigned) {
      const FROM_BIGINT_BIT_MASK = BigInt(4294967295);
      const FROM_BIGINT_BIT_SHIFT = BigInt(32);
      return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
    }
    static _fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw new BSONError("empty string");
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      let p;
      if ((p = str.indexOf("-")) > 0)
        throw new BSONError("interior hyphen");
      else if (p === 0) {
        return Long._fromString(str.substring(1), unsigned, radix).neg();
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 8));
      let result = Long.ZERO;
      for (let i = 0;i < str.length; i += 8) {
        const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          const power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    static fromStringStrict(str, unsignedOrRadix, radix) {
      let unsigned = false;
      if (typeof unsignedOrRadix === "number") {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      radix ??= 10;
      if (str.trim() !== str) {
        throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
      }
      if (!validateStringCharacters(str, radix)) {
        throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
      }
      const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
      const result = Long._fromString(cleanedStr, unsigned, radix);
      if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
        throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
      }
      return result;
    }
    static fromString(str, unsignedOrRadix, radix) {
      let unsigned = false;
      if (typeof unsignedOrRadix === "number") {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      radix ??= 10;
      if (str === "NaN" && radix < 24) {
        return Long.ZERO;
      } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
        return Long.ZERO;
      }
      return Long._fromString(str, unsigned, radix);
    }
    static fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
    static fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
    static fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
    static isLong(value) {
      return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
    }
    static fromValue(val, unsigned) {
      if (typeof val === "number")
        return Long.fromNumber(val, unsigned);
      if (typeof val === "string")
        return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    add(addend) {
      if (!Long.isLong(addend))
        addend = Long.fromValue(addend);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = addend.high >>> 16;
      const b32 = addend.high & 65535;
      const b16 = addend.low >>> 16;
      const b00 = addend.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    and(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
    compare(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.eq(other))
        return 0;
      const thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    comp(other) {
      return this.compare(other);
    }
    divide(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (divisor.isZero())
        throw new BSONError("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Long.UZERO : Long.ZERO;
      let approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
            return Long.MIN_VALUE;
          else if (divisor.eq(Long.MIN_VALUE))
            return Long.ONE;
          else {
            const halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE))
          return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return Long.UZERO;
        if (divisor.gt(this.shru(1)))
          return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        const log2 = Math.ceil(Math.log(approx) / Math.LN2);
        const delta2 = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        let approxRes = Long.fromNumber(approx);
        let approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta2;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
    div(divisor) {
      return this.divide(divisor);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    eq(other) {
      return this.equals(other);
    }
    getHighBits() {
      return this.high;
    }
    getHighBitsUnsigned() {
      return this.high >>> 0;
    }
    getLowBits() {
      return this.low;
    }
    getLowBitsUnsigned() {
      return this.low >>> 0;
    }
    getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      const val = this.high !== 0 ? this.high : this.low;
      let bit;
      for (bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) !== 0)
          break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    greaterThan(other) {
      return this.comp(other) > 0;
    }
    gt(other) {
      return this.greaterThan(other);
    }
    greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
    gte(other) {
      return this.greaterThanOrEqual(other);
    }
    ge(other) {
      return this.greaterThanOrEqual(other);
    }
    isEven() {
      return (this.low & 1) === 0;
    }
    isNegative() {
      return !this.unsigned && this.high < 0;
    }
    isOdd() {
      return (this.low & 1) === 1;
    }
    isPositive() {
      return this.unsigned || this.high >= 0;
    }
    isZero() {
      return this.high === 0 && this.low === 0;
    }
    lessThan(other) {
      return this.comp(other) < 0;
    }
    lt(other) {
      return this.lessThan(other);
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    lte(other) {
      return this.lessThanOrEqual(other);
    }
    modulo(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (wasm) {
        const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
    mod(divisor) {
      return this.modulo(divisor);
    }
    rem(divisor) {
      return this.modulo(divisor);
    }
    multiply(multiplier) {
      if (this.isZero())
        return Long.ZERO;
      if (!Long.isLong(multiplier))
        multiplier = Long.fromValue(multiplier);
      if (wasm) {
        const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return Long.ZERO;
      if (this.eq(Long.MIN_VALUE))
        return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE))
        return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))
        return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = multiplier.high >>> 16;
      const b32 = multiplier.high & 65535;
      const b16 = multiplier.low >>> 16;
      const b00 = multiplier.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    mul(multiplier) {
      return this.multiply(multiplier);
    }
    negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE))
        return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
    neg() {
      return this.negate();
    }
    not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
    notEquals(other) {
      return !this.equals(other);
    }
    neq(other) {
      return this.notEquals(other);
    }
    ne(other) {
      return this.notEquals(other);
    }
    or(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
    shiftLeft(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
    shl(numBits) {
      return this.shiftLeft(numBits);
    }
    shiftRight(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
    shr(numBits) {
      return this.shiftRight(numBits);
    }
    shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        const high = this.high;
        if (numBits < 32) {
          const low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return Long.fromBits(high, 0, this.unsigned);
        else
          return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
    shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    subtract(subtrahend) {
      if (!Long.isLong(subtrahend))
        subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
    sub(subtrahend) {
      return this.subtract(subtrahend);
    }
    toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
    toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    toBigInt() {
      return BigInt(this.toString());
    }
    toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
    toBytesLE() {
      const hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    toBytesBE() {
      const hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    }
    toSigned() {
      if (!this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, false);
    }
    toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      let rem = this;
      let result = "";
      while (true) {
        const remDiv = rem.div(radixToPower);
        const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        let digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    }
    toUnsigned() {
      if (this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, true);
    }
    xor(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
    eqz() {
      return this.isZero();
    }
    le(other) {
      return this.lessThanOrEqual(other);
    }
    toExtendedJSON(options) {
      if (options && options.relaxed)
        return this.toNumber();
      return { $numberLong: this.toString() };
    }
    static fromExtendedJSON(doc, options) {
      const { useBigInt64 = false, relaxed = true } = { ...options };
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError("$numberLong string is too long");
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`);
      }
      if (useBigInt64) {
        const bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      const longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const longVal = inspect(this.toString(), options);
      const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
      return `new Long(${longVal}${unsignedVal})`;
    }
  }
  Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
  Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.ZERO = Long.fromInt(0);
  Long.UZERO = Long.fromInt(0, true);
  Long.ONE = Long.fromInt(1);
  Long.UONE = Long.fromInt(1, true);
  Long.NEG_ONE = Long.fromInt(-1);
  Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = ByteUtils.fromNumberArray([
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;
  function isDigit(value) {
    return !isNaN(parseInt(value, 10));
  }
  function divideu128(value) {
    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
    let _rem = Long.fromNumber(0);
    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
      return { quotient: value, rem: _rem };
    }
    for (let i = 0;i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low;
      _rem = _rem.modulo(DIVISOR);
    }
    return { quotient: value, rem: _rem };
  }
  function multiply64x2(left, right) {
    if (!left && !right) {
      return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
    }
    const leftHigh = left.shiftRightUnsigned(32);
    const leftLow = new Long(left.getLowBits(), 0);
    const rightHigh = right.shiftRightUnsigned(32);
    const rightLow = new Long(right.getLowBits(), 0);
    let productHigh = leftHigh.multiply(rightHigh);
    let productMid = leftHigh.multiply(rightLow);
    const productMid2 = leftLow.multiply(rightHigh);
    let productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
    return { high: productHigh, low: productLow };
  }
  function lessThan(left, right) {
    const uhleft = left.high >>> 0;
    const uhright = right.high >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      const ulleft = left.low >>> 0;
      const ulright = right.low >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  }
  function invalidErr(string, message) {
    throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
  }

  class Decimal128 extends BSONValue {
    get _bsontype() {
      return "Decimal128";
    }
    constructor(bytes) {
      super();
      if (typeof bytes === "string") {
        this.bytes = Decimal128.fromString(bytes).bytes;
      } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
        if (bytes.byteLength !== 16) {
          throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
        }
        this.bytes = bytes;
      } else {
        throw new BSONError("Decimal128 must take a Buffer or string");
      }
    }
    static fromString(representation) {
      return Decimal128._fromString(representation, { allowRounding: false });
    }
    static fromStringWithRounding(representation) {
      return Decimal128._fromString(representation, { allowRounding: true });
    }
    static _fromString(representation, options) {
      let isNegative = false;
      let sawSign = false;
      let sawRadix = false;
      let foundNonZero = false;
      let significantDigits = 0;
      let nDigitsRead = 0;
      let nDigits = 0;
      let radixPosition = 0;
      let firstNonZero = 0;
      const digits = [0];
      let nDigitsStored = 0;
      let digitsInsert = 0;
      let lastDigit = 0;
      let exponent = 0;
      let significandHigh = new Long(0, 0);
      let significandLow = new Long(0, 0);
      let biasedExponent = 0;
      let index = 0;
      if (representation.length >= 7000) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      const stringMatch = representation.match(PARSE_STRING_REGEXP);
      const infMatch = representation.match(PARSE_INF_REGEXP);
      const nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      if (stringMatch) {
        const unsignedNumber = stringMatch[2];
        const e = stringMatch[4];
        const expSign = stringMatch[5];
        const expNumber = stringMatch[6];
        if (e && expNumber === undefined)
          invalidErr(representation, "missing exponent power");
        if (e && unsignedNumber === undefined)
          invalidErr(representation, "missing exponent base");
        if (e === undefined && (expSign || expNumber)) {
          invalidErr(representation, "missing e before exponent");
        }
      }
      if (representation[index] === "+" || representation[index] === "-") {
        sawSign = true;
        isNegative = representation[index++] === "-";
      }
      if (!isDigit(representation[index]) && representation[index] !== ".") {
        if (representation[index] === "i" || representation[index] === "I") {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === "N") {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === ".") {
        if (representation[index] === ".") {
          if (sawRadix)
            invalidErr(representation, "contains multiple periods");
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < MAX_DIGITS) {
          if (representation[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero)
          nDigits = nDigits + 1;
        if (sawRadix)
          radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      if (representation[index] === "e" || representation[index] === "E") {
        const match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index])
        return new Decimal128(NAN_BUFFER);
      if (!nDigitsStored) {
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit >= MAX_DIGITS) {
          if (significantDigits === 0) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
        exponent = exponent - 1;
      }
      if (options.allowRounding) {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0 && significantDigits < nDigitsStored) {
            exponent = EXPONENT_MIN;
            significantDigits = 0;
            break;
          }
          if (nDigitsStored < nDigits) {
            nDigits = nDigits - 1;
          } else {
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            const digitsString = digits.join("");
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          let endOfString = nDigitsRead;
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          let roundBit = 0;
          if (roundDigit >= 5) {
            roundBit = 1;
            if (roundDigit === 5) {
              roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
              for (let i = firstNonZero + lastDigit + 2;i < endOfString; i++) {
                if (parseInt(representation[i], 10)) {
                  roundBit = 1;
                  break;
                }
              }
            }
          }
          if (roundBit) {
            let dIdx = lastDigit;
            for (;dIdx >= 0; dIdx--) {
              if (++digits[dIdx] > 9) {
                digits[dIdx] = 0;
                if (dIdx === 0) {
                  if (exponent < EXPONENT_MAX) {
                    exponent = exponent + 1;
                    digits[dIdx] = 1;
                  } else {
                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                  }
                }
              } else {
                break;
              }
            }
          }
        }
      } else {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MIN;
              break;
            }
            invalidErr(representation, "exponent underflow");
          }
          if (nDigitsStored < nDigits) {
            if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            nDigits = nDigits - 1;
          } else {
            if (digits[lastDigit] !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          if (roundDigit !== 0) {
            invalidErr(representation, "inexact rounding");
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit < 17) {
        let dIdx = 0;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        let dIdx = 0;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString("9223372036854775808"));
      }
      const buffer2 = ByteUtils.allocateUnsafe(16);
      index = 0;
      buffer2[index++] = dec.low.low & 255;
      buffer2[index++] = dec.low.low >> 8 & 255;
      buffer2[index++] = dec.low.low >> 16 & 255;
      buffer2[index++] = dec.low.low >> 24 & 255;
      buffer2[index++] = dec.low.high & 255;
      buffer2[index++] = dec.low.high >> 8 & 255;
      buffer2[index++] = dec.low.high >> 16 & 255;
      buffer2[index++] = dec.low.high >> 24 & 255;
      buffer2[index++] = dec.high.low & 255;
      buffer2[index++] = dec.high.low >> 8 & 255;
      buffer2[index++] = dec.high.low >> 16 & 255;
      buffer2[index++] = dec.high.low >> 24 & 255;
      buffer2[index++] = dec.high.high & 255;
      buffer2[index++] = dec.high.high >> 8 & 255;
      buffer2[index++] = dec.high.high >> 16 & 255;
      buffer2[index++] = dec.high.high >> 24 & 255;
      return new Decimal128(buffer2);
    }
    toString() {
      let biased_exponent;
      let significand_digits = 0;
      const significand = new Array(36);
      for (let i = 0;i < significand.length; i++)
        significand[i] = 0;
      let index = 0;
      let is_zero = false;
      let significand_msb;
      let significand128 = { parts: [0, 0, 0, 0] };
      let j, k;
      const string = [];
      index = 0;
      const buffer2 = this.bytes;
      const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      index = 0;
      const dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string.push("-");
      }
      const combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      const exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3;k >= 0; k--) {
          let least_digits = 0;
          const result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits)
            continue;
          for (j = 8;j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      const scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push(`${0}`);
          if (exponent > 0)
            string.push(`E+${exponent}`);
          else if (exponent < 0)
            string.push(`E${exponent}`);
          return string.join("");
        }
        string.push(`${significand[index++]}`);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (let i = 0;i < significand_digits; i++) {
          string.push(`${significand[index++]}`);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push(`+${scientific_exponent}`);
        } else {
          string.push(`${scientific_exponent}`);
        }
      } else {
        if (exponent >= 0) {
          for (let i = 0;i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
        } else {
          let radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (let i = 0;i < radix_position; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (let i = 0;i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(`${significand[index++]}`);
          }
        }
      }
      return string.join("");
    }
    toJSON() {
      return { $numberDecimal: this.toString() };
    }
    toExtendedJSON() {
      return { $numberDecimal: this.toString() };
    }
    static fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const d128string = inspect(this.toString(), options);
      return `new Decimal128(${d128string})`;
    }
  }

  class Double extends BSONValue {
    get _bsontype() {
      return "Double";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    static fromString(value) {
      const coercedValue = Number(value);
      if (value === "NaN")
        return new Double(NaN);
      if (value === "Infinity")
        return new Double(Infinity);
      if (value === "-Infinity")
        return new Double(-Infinity);
      if (!Number.isFinite(coercedValue)) {
        throw new BSONError(`Input: ${value} is not representable as a Double`);
      }
      if (value.trim() !== value) {
        throw new BSONError(`Input: '${value}' contains whitespace`);
      }
      if (value === "") {
        throw new BSONError(`Input is an empty string`);
      }
      if (/[^-0-9.+eE]/.test(value)) {
        throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
      }
      return new Double(coercedValue);
    }
    valueOf() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: "-0.0" };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
    static fromExtendedJSON(doc, options) {
      const doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Double(${inspect(this.value, options)})`;
    }
  }

  class Int32 extends BSONValue {
    get _bsontype() {
      return "Int32";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value | 0;
    }
    static fromString(value) {
      const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
      const coercedValue = Number(value);
      if (BSON_INT32_MAX < coercedValue) {
        throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
      } else if (BSON_INT32_MIN > coercedValue) {
        throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
      } else if (!Number.isSafeInteger(coercedValue)) {
        throw new BSONError(`Input: '${value}' is not a safe integer`);
      } else if (coercedValue.toString() !== cleanedValue) {
        throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
      }
      return new Int32(coercedValue);
    }
    valueOf() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy))
        return this.value;
      return { $numberInt: this.value.toString() };
    }
    static fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Int32(${inspect(this.value, options)})`;
    }
  }

  class MaxKey extends BSONValue {
    get _bsontype() {
      return "MaxKey";
    }
    toExtendedJSON() {
      return { $maxKey: 1 };
    }
    static fromExtendedJSON() {
      return new MaxKey;
    }
    inspect() {
      return "new MaxKey()";
    }
  }

  class MinKey extends BSONValue {
    get _bsontype() {
      return "MinKey";
    }
    toExtendedJSON() {
      return { $minKey: 1 };
    }
    static fromExtendedJSON() {
      return new MinKey;
    }
    inspect() {
      return "new MinKey()";
    }
  }
  var PROCESS_UNIQUE = null;
  var __idCache = new WeakMap;

  class ObjectId2 extends BSONValue {
    get _bsontype() {
      return "ObjectId";
    }
    constructor(inputId) {
      super();
      let workingId;
      if (typeof inputId === "object" && inputId && "id" in inputId) {
        if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
          throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
        }
        if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
          workingId = ByteUtils.fromHex(inputId.toHexString());
        } else {
          workingId = inputId.id;
        }
      } else {
        workingId = inputId;
      }
      if (workingId == null || typeof workingId === "number") {
        this.buffer = ObjectId2.generate(typeof workingId === "number" ? workingId : undefined);
      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
        this.buffer = ByteUtils.toLocalBufferType(workingId);
      } else if (typeof workingId === "string") {
        if (ObjectId2.validateHexString(workingId)) {
          this.buffer = ByteUtils.fromHex(workingId);
          if (ObjectId2.cacheHexString) {
            __idCache.set(this, workingId);
          }
        } else {
          throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
        }
      } else {
        throw new BSONError("Argument passed in does not match the accepted types");
      }
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
      if (ObjectId2.cacheHexString) {
        __idCache.set(this, ByteUtils.toHex(value));
      }
    }
    static validateHexString(string) {
      if (string?.length !== 24)
        return false;
      for (let i = 0;i < 24; i++) {
        const char = string.charCodeAt(i);
        if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
          continue;
        }
        return false;
      }
      return true;
    }
    toHexString() {
      if (ObjectId2.cacheHexString) {
        const __id = __idCache.get(this);
        if (__id)
          return __id;
      }
      const hexString = ByteUtils.toHex(this.id);
      if (ObjectId2.cacheHexString) {
        __idCache.set(this, hexString);
      }
      return hexString;
    }
    static getInc() {
      return ObjectId2.index = (ObjectId2.index + 1) % 16777215;
    }
    static generate(time) {
      if (typeof time !== "number") {
        time = Math.floor(Date.now() / 1000);
      }
      const inc = ObjectId2.getInc();
      const buffer2 = ByteUtils.allocateUnsafe(12);
      NumberUtils.setInt32BE(buffer2, 0, time);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer2[4] = PROCESS_UNIQUE[0];
      buffer2[5] = PROCESS_UNIQUE[1];
      buffer2[6] = PROCESS_UNIQUE[2];
      buffer2[7] = PROCESS_UNIQUE[3];
      buffer2[8] = PROCESS_UNIQUE[4];
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    }
    toString(encoding) {
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      if (encoding === "hex")
        return this.toHexString();
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    static is(variable) {
      return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
    }
    equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (ObjectId2.is(otherId)) {
        return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
      }
      if (typeof otherId === "string") {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
        const otherIdString = otherId.toHexString();
        const thisIdString = this.toHexString();
        return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
    getTimestamp() {
      const timestamp = new Date;
      const time = NumberUtils.getUint32BE(this.buffer, 0);
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    }
    static createPk() {
      return new ObjectId2;
    }
    serializeInto(uint8array, index) {
      uint8array[index] = this.buffer[0];
      uint8array[index + 1] = this.buffer[1];
      uint8array[index + 2] = this.buffer[2];
      uint8array[index + 3] = this.buffer[3];
      uint8array[index + 4] = this.buffer[4];
      uint8array[index + 5] = this.buffer[5];
      uint8array[index + 6] = this.buffer[6];
      uint8array[index + 7] = this.buffer[7];
      uint8array[index + 8] = this.buffer[8];
      uint8array[index + 9] = this.buffer[9];
      uint8array[index + 10] = this.buffer[10];
      uint8array[index + 11] = this.buffer[11];
      return 12;
    }
    static createFromTime(time) {
      const buffer2 = ByteUtils.allocate(12);
      for (let i = 11;i >= 4; i--)
        buffer2[i] = 0;
      NumberUtils.setInt32BE(buffer2, 0, time);
      return new ObjectId2(buffer2);
    }
    static createFromHexString(hexString) {
      if (hexString?.length !== 24) {
        throw new BSONError("hex string must be 24 characters");
      }
      return new ObjectId2(ByteUtils.fromHex(hexString));
    }
    static createFromBase64(base64) {
      if (base64?.length !== 16) {
        throw new BSONError("base64 string must be 16 characters");
      }
      return new ObjectId2(ByteUtils.fromBase64(base64));
    }
    static isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "string")
        return ObjectId2.validateHexString(id);
      try {
        new ObjectId2(id);
        return true;
      } catch {
        return false;
      }
    }
    toExtendedJSON() {
      if (this.toHexString)
        return { $oid: this.toHexString() };
      return { $oid: this.toString("hex") };
    }
    static fromExtendedJSON(doc) {
      return new ObjectId2(doc.$oid);
    }
    isCached() {
      return ObjectId2.cacheHexString && __idCache.has(this);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new ObjectId(${inspect(this.toHexString(), options)})`;
    }
  }
  ObjectId2.index = Math.floor(Math.random() * 16777215);
  function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
    let totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
      }
      for (const key of Object.keys(object)) {
        totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  }
  function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
    if (typeof value?.toBSON === "function") {
      value = value.toBSON();
    }
    switch (typeof value) {
      case "string":
        return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
      case "number":
        if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
      case "object":
        if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        } else if (value._bsontype === "ObjectId") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
        } else if (value instanceof Date || isDate(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
        } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (value._bsontype === "Decimal128") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
        } else if (value._bsontype === "Code") {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
          }
        } else if (value._bsontype === "Binary") {
          const binary = value;
          if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
          }
        } else if (value._bsontype === "Symbol") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
        } else if (value._bsontype === "DBRef") {
          const ordered_values = Object.assign({
            $ref: value.collection,
            $id: value.oid
          }, value.fields);
          if (value.db != null) {
            ordered_values["$db"] = value.db;
          }
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value instanceof RegExp || isRegExp(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else if (value._bsontype === "BSONRegExp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (serializeFunctions) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
        }
        return 0;
      case "bigint":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      case "symbol":
        return 0;
      default:
        throw new BSONError(`Unrecognized JS type: ${typeof value}`);
    }
  }
  function alphabetize(str) {
    return str.split("").sort().join("");
  }

  class BSONRegExp extends BSONValue {
    get _bsontype() {
      return "BSONRegExp";
    }
    constructor(pattern, options) {
      super();
      this.pattern = pattern;
      this.options = alphabetize(options ?? "");
      if (this.pattern.indexOf("\x00") !== -1) {
        throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
      }
      if (this.options.indexOf("\x00") !== -1) {
        throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
      }
      for (let i = 0;i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
        }
      }
    }
    static parseOptions(options) {
      return options ? options.split("").sort().join("") : "";
    }
    toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return { $regularExpression: { pattern: this.pattern, options: this.options } };
    }
    static fromExtendedJSON(doc) {
      if ("$regex" in doc) {
        if (typeof doc.$regex !== "string") {
          if (doc.$regex._bsontype === "BSONRegExp") {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ("$regularExpression" in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
    }
    inspect(depth, options, inspect) {
      const stylize = getStylizeFunction(options) ?? ((v) => v);
      inspect ??= defaultInspect;
      const pattern = stylize(inspect(this.pattern), "regexp");
      const flags = stylize(inspect(this.options), "regexp");
      return `new BSONRegExp(${pattern}, ${flags})`;
    }
  }

  class BSONSymbol extends BSONValue {
    get _bsontype() {
      return "BSONSymbol";
    }
    constructor(value) {
      super();
      this.value = value;
    }
    valueOf() {
      return this.value;
    }
    toString() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON() {
      return { $symbol: this.value };
    }
    static fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new BSONSymbol(${inspect(this.value, options)})`;
    }
  }
  var LongWithoutOverridesClass = Long;

  class Timestamp extends LongWithoutOverridesClass {
    get _bsontype() {
      return "Timestamp";
    }
    get i() {
      return this.low >>> 0;
    }
    get t() {
      return this.high >>> 0;
    }
    constructor(low) {
      if (low == null) {
        super(0, 0, true);
      } else if (typeof low === "bigint") {
        super(low, true);
      } else if (Long.isLong(low)) {
        super(low.low, low.high, true);
      } else if (typeof low === "object" && "t" in low && "i" in low) {
        if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
        }
        if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
        }
        const t2 = Number(low.t);
        const i = Number(low.i);
        if (t2 < 0 || Number.isNaN(t2)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
        }
        if (i < 0 || Number.isNaN(i)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
        }
        if (t2 > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
        }
        if (i > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
        }
        super(i, t2, true);
      } else {
        throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
      }
    }
    toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
    static fromInt(value) {
      return new Timestamp(Long.fromInt(value, true));
    }
    static fromNumber(value) {
      return new Timestamp(Long.fromNumber(value, true));
    }
    static fromBits(lowBits, highBits) {
      return new Timestamp({ i: lowBits, t: highBits });
    }
    static fromString(str, optRadix) {
      return new Timestamp(Long.fromString(str, true, optRadix));
    }
    toExtendedJSON() {
      return { $timestamp: { t: this.t, i: this.i } };
    }
    static fromExtendedJSON(doc) {
      const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      const t2 = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({ t: t2, i });
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const t2 = inspect(this.t, options);
      const i = inspect(this.i, options);
      return `new Timestamp({ t: ${t2}, i: ${i} })`;
    }
  }
  Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
  var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
  var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
  function internalDeserialize(buffer2, options, isArray) {
    options = options == null ? {} : options;
    const index = options && options.index ? options.index : 0;
    const size = NumberUtils.getInt32LE(buffer2, index);
    if (size < 5) {
      throw new BSONError(`bson size must be >= 5, is ${size}`);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
      throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
      throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
    }
    if (size + index > buffer2.byteLength) {
      throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
    }
    if (buffer2[index + size - 1] !== 0) {
      throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer2, index, options, isArray);
  }
  var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
  function deserializeObject(buffer2, index, options, isArray = false) {
    const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    const raw = options["raw"] == null ? false : options["raw"];
    const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    const promoteBuffers = options.promoteBuffers ?? false;
    const promoteLongs = options.promoteLongs ?? true;
    const promoteValues = options.promoteValues ?? true;
    const useBigInt64 = options.useBigInt64 ?? false;
    if (useBigInt64 && !promoteValues) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    if (useBigInt64 && !promoteLongs) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    const validation = options.validation == null ? { utf8: true } : options.validation;
    let globalUTFValidation = true;
    let validationSetting;
    let utf8KeysSet;
    const utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === "boolean") {
      validationSetting = utf8ValidatedKeys;
    } else {
      globalUTFValidation = false;
      const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
        return utf8ValidatedKeys[key];
      });
      if (utf8ValidationValues.length === 0) {
        throw new BSONError("UTF-8 validation setting cannot be empty");
      }
      if (typeof utf8ValidationValues[0] !== "boolean") {
        throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
      }
      validationSetting = utf8ValidationValues[0];
      if (!utf8ValidationValues.every((item) => item === validationSetting)) {
        throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
      }
    }
    if (!globalUTFValidation) {
      utf8KeysSet = new Set;
      for (const key of Object.keys(utf8ValidatedKeys)) {
        utf8KeysSet.add(key);
      }
    }
    const startIndex = index;
    if (buffer2.length < 5)
      throw new BSONError("corrupt bson message < 5 bytes long");
    const size = NumberUtils.getInt32LE(buffer2, index);
    index += 4;
    if (size < 5 || size > buffer2.length)
      throw new BSONError("corrupt bson message");
    const object = isArray ? [] : {};
    let arrayIndex = 0;
    let isPossibleDBRef = isArray ? false : null;
    while (true) {
      const elementType = buffer2[index++];
      if (elementType === 0)
        break;
      let i = index;
      while (buffer2[i] !== 0 && i < buffer2.length) {
        i++;
      }
      if (i >= buffer2.byteLength)
        throw new BSONError("Bad BSON Document: illegal CString");
      const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i, false);
      let shouldValidateKey = true;
      if (globalUTFValidation || utf8KeysSet?.has(name)) {
        shouldValidateKey = validationSetting;
      } else {
        shouldValidateKey = !validationSetting;
      }
      if (isPossibleDBRef !== false && name[0] === "$") {
        isPossibleDBRef = allowedDBRefKeys.test(name);
      }
      let value;
      index = i + 1;
      if (elementType === BSON_DATA_STRING) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_OID) {
        const oid = ByteUtils.allocateUnsafe(12);
        for (let i2 = 0;i2 < 12; i2++)
          oid[i2] = buffer2[index + i2];
        value = new ObjectId2(oid);
        index = index + 12;
      } else if (elementType === BSON_DATA_INT && promoteValues === false) {
        value = new Int32(NumberUtils.getInt32LE(buffer2, index));
        index += 4;
      } else if (elementType === BSON_DATA_INT) {
        value = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
      } else if (elementType === BSON_DATA_NUMBER) {
        value = NumberUtils.getFloat64LE(buffer2, index);
        index += 8;
        if (promoteValues === false)
          value = new Double(value);
      } else if (elementType === BSON_DATA_DATE) {
        const lowBits = NumberUtils.getInt32LE(buffer2, index);
        const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
        index += 8;
        value = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON_DATA_BOOLEAN) {
        if (buffer2[index] !== 0 && buffer2[index] !== 1)
          throw new BSONError("illegal boolean type value");
        value = buffer2[index++] === 1;
      } else if (elementType === BSON_DATA_OBJECT) {
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        if (objectSize <= 0 || objectSize > buffer2.length - index)
          throw new BSONError("bad embedded document length in bson");
        if (raw) {
          value = buffer2.subarray(index, index + objectSize);
        } else {
          let objectOptions = options;
          if (!globalUTFValidation) {
            objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, objectOptions, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON_DATA_ARRAY) {
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        let arrayOptions = options;
        const stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = { ...options, raw: true };
        }
        if (!globalUTFValidation) {
          arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
        }
        value = deserializeObject(buffer2, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer2[index - 1] !== 0)
          throw new BSONError("invalid array terminator byte");
        if (index !== stopIndex)
          throw new BSONError("corrupted array bson");
      } else if (elementType === BSON_DATA_UNDEFINED) {
        value = undefined;
      } else if (elementType === BSON_DATA_NULL) {
        value = null;
      } else if (elementType === BSON_DATA_LONG) {
        if (useBigInt64) {
          value = NumberUtils.getBigInt64LE(buffer2, index);
          index += 8;
        } else {
          const lowBits = NumberUtils.getInt32LE(buffer2, index);
          const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
          index += 8;
          const long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            value = long;
          }
        }
      } else if (elementType === BSON_DATA_DECIMAL128) {
        const bytes = ByteUtils.allocateUnsafe(16);
        for (let i2 = 0;i2 < 16; i2++)
          bytes[i2] = buffer2[index + i2];
        index = index + 16;
        value = new Decimal128(bytes);
      } else if (elementType === BSON_DATA_BINARY) {
        let binarySize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        const totalBinarySize = binarySize;
        const subType = buffer2[index++];
        if (binarySize < 0)
          throw new BSONError("Negative binary type element size found");
        if (binarySize > buffer2.byteLength)
          throw new BSONError("Binary type size larger than document size");
        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found for subtype 0x02");
          if (binarySize > totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
          if (binarySize < totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
        }
        if (promoteBuffers && promoteValues) {
          value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
        } else {
          value = new Binary(buffer2.subarray(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
            value = value.toUUID();
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        const optionsArray = new Array(regExpOptions.length);
        for (i = 0;i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case "m":
              optionsArray[i] = "m";
              break;
            case "s":
              optionsArray[i] = "g";
              break;
            case "i":
              optionsArray[i] = "i";
              break;
          }
        }
        value = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        value = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON_DATA_SYMBOL) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = promoteValues ? symbol : new BSONSymbol(symbol);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_TIMESTAMP) {
        value = new Timestamp({
          i: NumberUtils.getUint32LE(buffer2, index),
          t: NumberUtils.getUint32LE(buffer2, index + 4)
        });
        index += 8;
      } else if (elementType === BSON_DATA_MIN_KEY) {
        value = new MinKey;
      } else if (elementType === BSON_DATA_MAX_KEY) {
        value = new MaxKey;
      } else if (elementType === BSON_DATA_CODE) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = new Code(functionString);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
        const totalSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new BSONError("code_w_scope total size shorter minimum expected length");
        }
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        const scopeObject = deserializeObject(buffer2, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too long, clips outer document");
        }
        value = new Code(functionString, scopeObject);
      } else if (elementType === BSON_DATA_DBPOINTER) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
          throw new BSONError("bad string length in bson");
        const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const oidBuffer = ByteUtils.allocateUnsafe(12);
        for (let i2 = 0;i2 < 12; i2++)
          oidBuffer[i2] = buffer2[index + i2];
        const oid = new ObjectId2(oidBuffer);
        index = index + 12;
        value = new DBRef(namespace, oid);
      } else {
        throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
      }
      if (name === "__proto__") {
        Object.defineProperty(object, name, {
          value,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        object[name] = value;
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new BSONError("corrupt array bson");
      throw new BSONError("corrupt object bson");
    }
    if (!isPossibleDBRef)
      return object;
    if (isDBRefLike(object)) {
      const copy = Object.assign({}, object);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
  }
  var regexp = /\x00/;
  var ignoreKeys = new Set(["$db", "$ref", "$id", "$clusterTime"]);
  function serializeString(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_STRING;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes + 1;
    buffer2[index - 1] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
    NumberUtils.setInt32LE(buffer2, index, size + 1);
    index = index + 4 + size;
    buffer2[index++] = 0;
    return index;
  }
  function serializeNumber(buffer2, key, value, index) {
    const isNegativeZero = Object.is(value, -0);
    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
    buffer2[index++] = type;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (type === BSON_DATA_INT) {
      index += NumberUtils.setInt32LE(buffer2, index, value);
    } else {
      index += NumberUtils.setFloat64LE(buffer2, index, value);
    }
    return index;
  }
  function serializeBigInt(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_LONG;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index += numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setBigInt64LE(buffer2, index, value);
    return index;
  }
  function serializeNull(buffer2, key, _, index) {
    buffer2[index++] = BSON_DATA_NULL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  }
  function serializeBoolean(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BOOLEAN;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value ? 1 : 0;
    return index;
  }
  function serializeDate(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DATE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const dateInMilis = Long.fromNumber(value.getTime());
    const lowBits = dateInMilis.getLowBits();
    const highBits = dateInMilis.getHighBits();
    index += NumberUtils.setInt32LE(buffer2, index, lowBits);
    index += NumberUtils.setInt32LE(buffer2, index, highBits);
    return index;
  }
  function serializeRegExp(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw new BSONError("value " + value.source + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
    buffer2[index++] = 0;
    if (value.ignoreCase)
      buffer2[index++] = 105;
    if (value.global)
      buffer2[index++] = 115;
    if (value.multiline)
      buffer2[index++] = 109;
    buffer2[index++] = 0;
    return index;
  }
  function serializeBSONRegExp(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
    buffer2[index++] = 0;
    const sortedOptions = value.options.split("").sort().join("");
    index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
    buffer2[index++] = 0;
    return index;
  }
  function serializeMinMax(buffer2, key, value, index) {
    if (value === null) {
      buffer2[index++] = BSON_DATA_NULL;
    } else if (value._bsontype === "MinKey") {
      buffer2[index++] = BSON_DATA_MIN_KEY;
    } else {
      buffer2[index++] = BSON_DATA_MAX_KEY;
    }
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  }
  function serializeObjectId(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_OID;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += value.serializeInto(buffer2, index);
    return index;
  }
  function serializeBuffer(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = value.length;
    index += NumberUtils.setInt32LE(buffer2, index, size);
    buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
    if (size <= 16) {
      for (let i = 0;i < size; i++)
        buffer2[index + i] = value[i];
    } else {
      buffer2.set(value, index);
    }
    index = index + size;
    return index;
  }
  function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
    if (path.has(value)) {
      throw new BSONError("Cannot convert circular structure to BSON");
    }
    path.add(value);
    buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.delete(value);
    return endIndex;
  }
  function serializeDecimal128(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DECIMAL128;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    for (let i = 0;i < 16; i++)
      buffer2[index + i] = value.bytes[i];
    return index + 16;
  }
  function serializeLong(buffer2, key, value, index) {
    buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const lowBits = value.getLowBits();
    const highBits = value.getHighBits();
    index += NumberUtils.setInt32LE(buffer2, index, lowBits);
    index += NumberUtils.setInt32LE(buffer2, index, highBits);
    return index;
  }
  function serializeInt32(buffer2, key, value, index) {
    value = value.valueOf();
    buffer2[index++] = BSON_DATA_INT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setInt32LE(buffer2, index, value);
    return index;
  }
  function serializeDouble(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_NUMBER;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setFloat64LE(buffer2, index, value.value);
    return index;
  }
  function serializeFunction(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_CODE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const functionString = value.toString();
    const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  }
  function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
    if (value.scope && typeof value.scope === "object") {
      buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      const functionString = value.code;
      index = index + 4;
      const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, codeSize);
      buffer2[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      index = endIndex - 1;
      const totalSize = endIndex - startIndex;
      startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
      buffer2[index++] = 0;
    } else {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.code.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
    }
    return index;
  }
  function serializeBinary(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const data = value.buffer;
    let size = value.position;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    index += NumberUtils.setInt32LE(buffer2, index, size);
    buffer2[index++] = value.sub_type;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      index += NumberUtils.setInt32LE(buffer2, index, size);
    }
    if (value.sub_type === Binary.SUBTYPE_VECTOR) {
      validateBinaryVector(value);
    }
    if (size <= 16) {
      for (let i = 0;i < size; i++)
        buffer2[index + i] = data[i];
    } else {
      buffer2.set(data, index);
    }
    index = index + value.position;
    return index;
  }
  function serializeSymbol(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_SYMBOL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  }
  function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path) {
    buffer2[index++] = BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    let startIndex = index;
    let output = {
      $ref: value.collection || value.namespace,
      $id: value.oid
    };
    if (value.db != null) {
      output.$db = value.db;
    }
    output = Object.assign(output, value.fields);
    const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
    const size = endIndex - startIndex;
    startIndex += NumberUtils.setInt32LE(buffer2, index, size);
    return endIndex;
  }
  function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    if (path == null) {
      if (object == null) {
        buffer2[0] = 5;
        buffer2[1] = 0;
        buffer2[2] = 0;
        buffer2[3] = 0;
        buffer2[4] = 0;
        return 5;
      }
      if (Array.isArray(object)) {
        throw new BSONError("serialize does not support an array as the root input");
      }
      if (typeof object !== "object") {
        throw new BSONError("serialize does not support non-object as the root input");
      } else if ("_bsontype" in object && typeof object._bsontype === "string") {
        throw new BSONError(`BSON types cannot be serialized as a document`);
      } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
        throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
      }
      path = new Set;
    }
    path.add(object);
    let index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        const key = `${i}`;
        let value = object[i];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (value === undefined) {
          index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    } else if (object instanceof Map || isMap(object)) {
      const iterator = object.entries();
      let done = false;
      while (!done) {
        const entry = iterator.next();
        done = !!entry.done;
        if (done)
          continue;
        const key = entry.value ? entry.value[0] : undefined;
        let value = entry.value ? entry.value[1] : undefined;
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (key.includes(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
        if (object != null && typeof object !== "object") {
          throw new BSONError("toBSON function did not return an object");
        }
      }
      for (const key of Object.keys(object)) {
        let value = object[key];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (key.includes(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    }
    path.delete(object);
    buffer2[index++] = 0;
    const size = index - startingIndex;
    startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
    return index;
  }
  function isBSONType(value) {
    return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
  }
  var keysToCodecs = {
    $oid: ObjectId2,
    $binary: Binary,
    $uuid: Binary,
    $symbol: BSONSymbol,
    $numberInt: Int32,
    $numberDecimal: Decimal128,
    $numberDouble: Double,
    $numberLong: Long,
    $minKey: MinKey,
    $maxKey: MaxKey,
    $regex: BSONRegExp,
    $regularExpression: BSONRegExp,
    $timestamp: Timestamp
  };
  function deserializeValue(value, options = {}) {
    if (typeof value === "number") {
      const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
      const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
      if (options.relaxed || options.legacy) {
        return value;
      }
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (in32BitRange) {
          return new Int32(value);
        }
        if (in64BitRange) {
          if (options.useBigInt64) {
            return BigInt(value);
          }
          return Long.fromNumber(value);
        }
      }
      return new Double(value);
    }
    if (value == null || typeof value !== "object")
      return value;
    if (value.$undefined)
      return null;
    const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
    for (let i = 0;i < keys.length; i++) {
      const c = keysToCodecs[keys[i]];
      if (c)
        return c.fromExtendedJSON(value, options);
    }
    if (value.$date != null) {
      const d = value.$date;
      const date2 = new Date;
      if (options.legacy) {
        if (typeof d === "number")
          date2.setTime(d);
        else if (typeof d === "string")
          date2.setTime(Date.parse(d));
        else if (typeof d === "bigint")
          date2.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      } else {
        if (typeof d === "string")
          date2.setTime(Date.parse(d));
        else if (Long.isLong(d))
          date2.setTime(d.toNumber());
        else if (typeof d === "number" && options.relaxed)
          date2.setTime(d);
        else if (typeof d === "bigint")
          date2.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      }
      return date2;
    }
    if (value.$code != null) {
      const copy = Object.assign({}, value);
      if (value.$scope) {
        copy.$scope = deserializeValue(value.$scope);
      }
      return Code.fromExtendedJSON(value);
    }
    if (isDBRefLike(value) || value.$dbPointer) {
      const v = value.$ref ? value : value.$dbPointer;
      if (v instanceof DBRef)
        return v;
      const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
      let valid = true;
      dollarKeys.forEach((k) => {
        if (["$ref", "$id", "$db"].indexOf(k) === -1)
          valid = false;
      });
      if (valid)
        return DBRef.fromExtendedJSON(v);
    }
    return value;
  }
  function serializeArray(array, options) {
    return array.map((v, index) => {
      options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
      try {
        return serializeValue(v, options);
      } finally {
        options.seenObjects.pop();
      }
    });
  }
  function getISOString(date2) {
    const isoStr = date2.toISOString();
    return date2.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
  }
  function serializeValue(value, options) {
    if (value instanceof Map || isMap(value)) {
      const obj = Object.create(null);
      for (const [k, v] of value) {
        if (typeof k !== "string") {
          throw new BSONError("Can only serialize maps with string keys");
        }
        obj[k] = v;
      }
      return serializeValue(obj, options);
    }
    if ((typeof value === "object" || typeof value === "function") && value !== null) {
      const index = options.seenObjects.findIndex((entry) => entry.obj === value);
      if (index !== -1) {
        const props = options.seenObjects.map((entry) => entry.propertyName);
        const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
        const alreadySeen = props[index];
        const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
        const current = props[props.length - 1];
        const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
        const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
        throw new BSONError(`Converting circular structure to EJSON:
` + `    ${leadingPart}${alreadySeen}${circularPart}${current}
` + `    ${leadingSpace}\\${dashes}/`);
      }
      options.seenObjects[options.seenObjects.length - 1].obj = value;
    }
    if (Array.isArray(value))
      return serializeArray(value, options);
    if (value === undefined)
      return null;
    if (value instanceof Date || isDate(value)) {
      const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;
      if (options.legacy) {
        return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
      }
      return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
    }
    if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return { $numberInt: value.toString() };
        }
        if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
          return { $numberLong: value.toString() };
        }
      }
      return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
    }
    if (typeof value === "bigint") {
      if (!options.relaxed) {
        return { $numberLong: BigInt.asIntN(64, value).toString() };
      }
      return Number(BigInt.asIntN(64, value));
    }
    if (value instanceof RegExp || isRegExp(value)) {
      let flags = value.flags;
      if (flags === undefined) {
        const match = value.toString().match(/[gimuy]*$/);
        if (match) {
          flags = match[0];
        }
      }
      const rx = new BSONRegExp(value.source, flags);
      return rx.toExtendedJSON(options);
    }
    if (value != null && typeof value === "object")
      return serializeDocument(value, options);
    return value;
  }
  var BSON_TYPE_MAPPINGS = {
    Binary: (o) => new Binary(o.value(), o.sub_type),
    Code: (o) => new Code(o.code, o.scope),
    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
    Decimal128: (o) => new Decimal128(o.bytes),
    Double: (o) => new Double(o.value),
    Int32: (o) => new Int32(o.value),
    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
    MaxKey: () => new MaxKey,
    MinKey: () => new MinKey,
    ObjectId: (o) => new ObjectId2(o),
    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
    BSONSymbol: (o) => new BSONSymbol(o.value),
    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
  };
  function serializeDocument(doc, options) {
    if (doc == null || typeof doc !== "object")
      throw new BSONError("not an object instance");
    const bsontype = doc._bsontype;
    if (typeof bsontype === "undefined") {
      const _doc = {};
      for (const name of Object.keys(doc)) {
        options.seenObjects.push({ propertyName: name, obj: null });
        try {
          const value = serializeValue(doc[name], options);
          if (name === "__proto__") {
            Object.defineProperty(_doc, name, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            _doc[name] = value;
          }
        } finally {
          options.seenObjects.pop();
        }
      }
      return _doc;
    } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
      throw new BSONVersionError;
    } else if (isBSONType(doc)) {
      let outDoc = doc;
      if (typeof outDoc.toExtendedJSON !== "function") {
        const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
        if (!mapper) {
          throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
        }
        outDoc = mapper(outDoc);
      }
      if (bsontype === "Code" && outDoc.scope) {
        outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
      } else if (bsontype === "DBRef" && outDoc.oid) {
        outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
      }
      return outDoc.toExtendedJSON(options);
    } else {
      throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
    }
  }
  function parse3(text, options) {
    const ejsonOptions = {
      useBigInt64: options?.useBigInt64 ?? false,
      relaxed: options?.relaxed ?? true,
      legacy: options?.legacy ?? false
    };
    return JSON.parse(text, (key, value) => {
      if (key.indexOf("\x00") !== -1) {
        throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
      }
      return deserializeValue(value, ejsonOptions);
    });
  }
  function stringify(value, replacer, space, options) {
    if (space != null && typeof space === "object") {
      options = space;
      space = 0;
    }
    if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
      options = replacer;
      replacer = undefined;
      space = 0;
    }
    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
      seenObjects: [{ propertyName: "(root)", obj: null }]
    });
    const doc = serializeValue(value, serializeOptions);
    return JSON.stringify(doc, replacer, space);
  }
  function EJSONserialize(value, options) {
    options = options || {};
    return JSON.parse(stringify(value, options));
  }
  function EJSONdeserialize(ejson, options) {
    options = options || {};
    return parse3(JSON.stringify(ejson), options);
  }
  var EJSON = Object.create(null);
  EJSON.parse = parse3;
  EJSON.stringify = stringify;
  EJSON.serialize = EJSONserialize;
  EJSON.deserialize = EJSONdeserialize;
  Object.freeze(EJSON);
  var BSONElementType = {
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: 255,
    maxKey: 127
  };
  function getSize(source, offset) {
    try {
      return NumberUtils.getNonnegativeInt32LE(source, offset);
    } catch (cause) {
      throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
    }
  }
  function findNull(bytes, offset) {
    let nullTerminatorOffset = offset;
    for (;bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
      ;
    if (nullTerminatorOffset === bytes.length - 1) {
      throw new BSONOffsetError("Null terminator not found", offset);
    }
    return nullTerminatorOffset;
  }
  function parseToElements(bytes, startOffset = 0) {
    startOffset ??= 0;
    if (bytes.length < 5) {
      throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
    }
    const documentSize = getSize(bytes, startOffset);
    if (documentSize > bytes.length - startOffset) {
      throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
    }
    if (bytes[startOffset + documentSize - 1] !== 0) {
      throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
    }
    const elements = [];
    let offset = startOffset + 4;
    while (offset <= documentSize + startOffset) {
      const type = bytes[offset];
      offset += 1;
      if (type === 0) {
        if (offset - startOffset !== documentSize) {
          throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
        }
        break;
      }
      const nameOffset = offset;
      const nameLength = findNull(bytes, offset) - nameOffset;
      offset += nameLength + 1;
      let length;
      if (type === BSONElementType.double || type === BSONElementType.long || type === BSONElementType.date || type === BSONElementType.timestamp) {
        length = 8;
      } else if (type === BSONElementType.int) {
        length = 4;
      } else if (type === BSONElementType.objectId) {
        length = 12;
      } else if (type === BSONElementType.decimal) {
        length = 16;
      } else if (type === BSONElementType.bool) {
        length = 1;
      } else if (type === BSONElementType.null || type === BSONElementType.undefined || type === BSONElementType.maxKey || type === BSONElementType.minKey) {
        length = 0;
      } else if (type === BSONElementType.regex) {
        length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
      } else if (type === BSONElementType.object || type === BSONElementType.array || type === BSONElementType.javascriptWithScope) {
        length = getSize(bytes, offset);
      } else if (type === BSONElementType.string || type === BSONElementType.binData || type === BSONElementType.dbPointer || type === BSONElementType.javascript || type === BSONElementType.symbol) {
        length = getSize(bytes, offset) + 4;
        if (type === BSONElementType.binData) {
          length += 1;
        }
        if (type === BSONElementType.dbPointer) {
          length += 12;
        }
      } else {
        throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
      }
      if (length > documentSize) {
        throw new BSONOffsetError("value reports length larger than document", offset);
      }
      elements.push([type, nameOffset, nameLength, offset, length]);
      offset += length;
    }
    return elements;
  }
  var onDemand = Object.create(null);
  onDemand.parseToElements = parseToElements;
  onDemand.ByteUtils = ByteUtils;
  onDemand.NumberUtils = NumberUtils;
  Object.freeze(onDemand);
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = ByteUtils.allocate(MAXSIZE);
  function setInternalBufferSize(size) {
    if (buffer.length < size) {
      buffer = ByteUtils.allocate(size);
    }
  }
  function serialize2(object, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = ByteUtils.allocate(minInternalBufferSize);
    }
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    return finishedBuffer;
  }
  function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const startIndex = typeof options.index === "number" ? options.index : 0;
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    return startIndex + serializationIndex - 1;
  }
  function deserialize(buffer2, options = {}) {
    return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
  }
  function calculateObjectSize(object, options = {}) {
    options = options || {};
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
  }
  function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    const bufferData = ByteUtils.toLocalBufferType(data);
    let index = startIndex;
    for (let i = 0;i < numberOfDocuments; i++) {
      const size = NumberUtils.getInt32LE(bufferData, index);
      internalOptions.index = index;
      documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
      index = index + size;
    }
    return index;
  }
  var bson = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BSONError,
    BSONOffsetError,
    BSONRegExp,
    BSONRuntimeError,
    BSONSymbol,
    BSONType,
    BSONValue,
    BSONVersionError,
    Binary,
    Code,
    DBRef,
    Decimal128,
    Double,
    EJSON,
    Int32,
    Long,
    MaxKey,
    MinKey,
    ObjectId: ObjectId2,
    Timestamp,
    UUID,
    calculateObjectSize,
    deserialize,
    deserializeStream,
    onDemand,
    serialize: serialize2,
    serializeWithBufferAndIndex,
    setInternalBufferSize
  });
  exports.BSON = bson;
  exports.BSONError = BSONError;
  exports.BSONOffsetError = BSONOffsetError;
  exports.BSONRegExp = BSONRegExp;
  exports.BSONRuntimeError = BSONRuntimeError;
  exports.BSONSymbol = BSONSymbol;
  exports.BSONType = BSONType;
  exports.BSONValue = BSONValue;
  exports.BSONVersionError = BSONVersionError;
  exports.Binary = Binary;
  exports.Code = Code;
  exports.DBRef = DBRef;
  exports.Decimal128 = Decimal128;
  exports.Double = Double;
  exports.EJSON = EJSON;
  exports.Int32 = Int32;
  exports.Long = Long;
  exports.MaxKey = MaxKey;
  exports.MinKey = MinKey;
  exports.ObjectId = ObjectId2;
  exports.Timestamp = Timestamp;
  exports.UUID = UUID;
  exports.calculateObjectSize = calculateObjectSize;
  exports.deserialize = deserialize;
  exports.deserializeStream = deserializeStream;
  exports.onDemand = onDemand;
  exports.serialize = serialize2;
  exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
  exports.setInternalBufferSize = setInternalBufferSize;
});

// node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUTF8 = exports.getBigInt64LE = exports.getFloat64LE = exports.getInt32LE = exports.UUID = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.EJSON = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSONError = exports.BSON = exports.Binary = undefined;
  exports.parseToElementsToArray = parseToElementsToArray;
  exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
  exports.resolveBSONOptions = resolveBSONOptions;
  exports.parseUtf8ValidationOption = parseUtf8ValidationOption;
  var bson_1 = require_bson();
  var bson_2 = require_bson();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_2.Binary;
  } });
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_2.BSON;
  } });
  Object.defineProperty(exports, "BSONError", { enumerable: true, get: function() {
    return bson_2.BSONError;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_2.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_2.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_2.BSONType;
  } });
  Object.defineProperty(exports, "calculateObjectSize", { enumerable: true, get: function() {
    return bson_2.calculateObjectSize;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_2.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_2.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_2.Decimal128;
  } });
  Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
    return bson_2.deserialize;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_2.Double;
  } });
  Object.defineProperty(exports, "EJSON", { enumerable: true, get: function() {
    return bson_2.EJSON;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_2.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_2.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_2.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_2.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_2.ObjectId;
  } });
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return bson_2.serialize;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_2.Timestamp;
  } });
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return bson_2.UUID;
  } });
  function parseToElementsToArray(bytes, offset) {
    const res = bson_1.BSON.onDemand.parseToElements(bytes, offset);
    return Array.isArray(res) ? res : [...res];
  }
  exports.getInt32LE = bson_1.BSON.onDemand.NumberUtils.getInt32LE;
  exports.getFloat64LE = bson_1.BSON.onDemand.NumberUtils.getFloat64LE;
  exports.getBigInt64LE = bson_1.BSON.onDemand.NumberUtils.getBigInt64LE;
  exports.toUTF8 = bson_1.BSON.onDemand.ByteUtils.toUTF8;
  function pluckBSONSerializeOptions(options) {
    const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options;
    return {
      fieldsAsRaw,
      useBigInt64,
      promoteValues,
      promoteBuffers,
      promoteLongs,
      serializeFunctions,
      ignoreUndefined,
      bsonRegExp,
      raw,
      enableUtf8Validation
    };
  }
  function resolveBSONOptions(options, parent) {
    const parentOptions = parent?.bsonOptions;
    return {
      raw: options?.raw ?? parentOptions?.raw ?? false,
      useBigInt64: options?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
      promoteLongs: options?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
      promoteValues: options?.promoteValues ?? parentOptions?.promoteValues ?? true,
      promoteBuffers: options?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
      ignoreUndefined: options?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
      bsonRegExp: options?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
      serializeFunctions: options?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
      fieldsAsRaw: options?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
      enableUtf8Validation: options?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
    };
  }
  function parseUtf8ValidationOption(options) {
    const enableUtf8Validation = options?.enableUtf8Validation;
    if (enableUtf8Validation === false) {
      return { utf8: false };
    }
    return { utf8: { writeErrors: false } };
  }
});

// node_modules/mongodb/lib/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoClientClosedError = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoOperationTimeoutError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoClientBulkWriteExecutionError = exports.MongoClientBulkWriteCursorError = exports.MongoClientBulkWriteError = exports.MongoGCPError = exports.MongoAzureError = exports.MongoOIDCError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoStalePrimaryError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = undefined;
  exports.needsRetryableWriteLabel = needsRetryableWriteLabel;
  exports.isRetryableWriteError = isRetryableWriteError;
  exports.isRetryableReadError = isRetryableReadError;
  exports.isNodeShuttingDownError = isNodeShuttingDownError;
  exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
  exports.isNetworkTimeoutError = isNetworkTimeoutError;
  exports.isResumableError = isResumableError;
  exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
  exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
  exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
  exports.MONGODB_ERROR_CODES = Object.freeze({
    HostUnreachable: 6,
    HostNotFound: 7,
    AuthenticationFailed: 18,
    NetworkTimeout: 89,
    ShutdownInProgress: 91,
    PrimarySteppedDown: 189,
    ExceededTimeLimit: 262,
    SocketException: 9001,
    NotWritablePrimary: 10107,
    InterruptedAtShutdown: 11600,
    InterruptedDueToReplStateChange: 11602,
    NotPrimaryNoSecondaryOk: 13435,
    NotPrimaryOrSecondary: 13436,
    StaleShardVersion: 63,
    StaleEpoch: 150,
    StaleConfig: 13388,
    RetryChangeStream: 234,
    FailedToSatisfyReadPreference: 133,
    CursorNotFound: 43,
    LegacyNotPrimary: 10058,
    WriteConcernTimeout: 64,
    NamespaceNotFound: 26,
    IllegalOperation: 20,
    MaxTimeMSExpired: 50,
    UnknownReplWriteConcern: 79,
    UnsatisfiableWriteConcern: 100,
    Reauthenticate: 391,
    ReadConcernMajorityNotAvailableYet: 134
  });
  exports.GET_MORE_RESUMABLE_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
    exports.MONGODB_ERROR_CODES.StaleShardVersion,
    exports.MONGODB_ERROR_CODES.StaleEpoch,
    exports.MONGODB_ERROR_CODES.StaleConfig,
    exports.MONGODB_ERROR_CODES.RetryChangeStream,
    exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
    exports.MONGODB_ERROR_CODES.CursorNotFound
  ]);
  exports.MongoErrorLabel = Object.freeze({
    RetryableWriteError: "RetryableWriteError",
    TransientTransactionError: "TransientTransactionError",
    UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
    ResumableChangeStreamError: "ResumableChangeStreamError",
    HandshakeError: "HandshakeError",
    ResetPool: "ResetPool",
    PoolRequstedRetry: "PoolRequstedRetry",
    InterruptInUseConnections: "InterruptInUseConnections",
    NoWritesPerformed: "NoWritesPerformed"
  });
  function isAggregateError(e) {
    return e != null && typeof e === "object" && "errors" in e && Array.isArray(e.errors);
  }

  class MongoError extends Error {
    get errorLabels() {
      return Array.from(this.errorLabelSet);
    }
    constructor(message, options) {
      super(message, options);
      this.errorLabelSet = new Set;
    }
    static buildErrorMessage(e) {
      if (typeof e === "string") {
        return e;
      }
      if (isAggregateError(e) && e.message.length === 0) {
        return e.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e.errors.map(({ message }) => message).join(", ");
      }
      return e != null && typeof e === "object" && "message" in e && typeof e.message === "string" ? e.message : "empty error message";
    }
    get name() {
      return "MongoError";
    }
    get errmsg() {
      return this.message;
    }
    hasErrorLabel(label) {
      return this.errorLabelSet.has(label);
    }
    addErrorLabel(label) {
      this.errorLabelSet.add(label);
    }
  }
  exports.MongoError = MongoError;

  class MongoServerError extends MongoError {
    constructor(message) {
      super(message.message || message.errmsg || message.$err || "n/a");
      if (message.errorLabels) {
        for (const label of message.errorLabels)
          this.addErrorLabel(label);
      }
      this.errorResponse = message;
      for (const name in message) {
        if (name !== "errorLabels" && name !== "errmsg" && name !== "message" && name !== "errorResponse") {
          this[name] = message[name];
        }
      }
    }
    get name() {
      return "MongoServerError";
    }
  }
  exports.MongoServerError = MongoServerError;

  class MongoDriverError extends MongoError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoDriverError";
    }
  }
  exports.MongoDriverError = MongoDriverError;

  class MongoAPIError extends MongoDriverError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoAPIError";
    }
  }
  exports.MongoAPIError = MongoAPIError;

  class MongoRuntimeError extends MongoDriverError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoRuntimeError";
    }
  }
  exports.MongoRuntimeError = MongoRuntimeError;

  class MongoStalePrimaryError extends MongoRuntimeError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoStalePrimaryError";
    }
  }
  exports.MongoStalePrimaryError = MongoStalePrimaryError;

  class MongoBatchReExecutionError extends MongoAPIError {
    constructor(message = "This batch has already been executed, create new batch to execute") {
      super(message);
    }
    get name() {
      return "MongoBatchReExecutionError";
    }
  }
  exports.MongoBatchReExecutionError = MongoBatchReExecutionError;

  class MongoDecompressionError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoDecompressionError";
    }
  }
  exports.MongoDecompressionError = MongoDecompressionError;

  class MongoNotConnectedError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoNotConnectedError";
    }
  }
  exports.MongoNotConnectedError = MongoNotConnectedError;

  class MongoTransactionError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoTransactionError";
    }
  }
  exports.MongoTransactionError = MongoTransactionError;

  class MongoExpiredSessionError extends MongoAPIError {
    constructor(message = "Cannot use a session that has ended") {
      super(message);
    }
    get name() {
      return "MongoExpiredSessionError";
    }
  }
  exports.MongoExpiredSessionError = MongoExpiredSessionError;

  class MongoKerberosError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoKerberosError";
    }
  }
  exports.MongoKerberosError = MongoKerberosError;

  class MongoAWSError extends MongoRuntimeError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoAWSError";
    }
  }
  exports.MongoAWSError = MongoAWSError;

  class MongoOIDCError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoOIDCError";
    }
  }
  exports.MongoOIDCError = MongoOIDCError;

  class MongoAzureError extends MongoOIDCError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAzureError";
    }
  }
  exports.MongoAzureError = MongoAzureError;

  class MongoGCPError extends MongoOIDCError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGCPError";
    }
  }
  exports.MongoGCPError = MongoGCPError;

  class MongoClientBulkWriteError extends MongoServerError {
    constructor(message) {
      super(message);
      this.writeConcernErrors = [];
      this.writeErrors = new Map;
    }
    get name() {
      return "MongoClientBulkWriteError";
    }
  }
  exports.MongoClientBulkWriteError = MongoClientBulkWriteError;

  class MongoClientBulkWriteCursorError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoClientBulkWriteCursorError";
    }
  }
  exports.MongoClientBulkWriteCursorError = MongoClientBulkWriteCursorError;

  class MongoClientBulkWriteExecutionError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoClientBulkWriteExecutionError";
    }
  }
  exports.MongoClientBulkWriteExecutionError = MongoClientBulkWriteExecutionError;

  class MongoChangeStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoChangeStreamError";
    }
  }
  exports.MongoChangeStreamError = MongoChangeStreamError;

  class MongoTailableCursorError extends MongoAPIError {
    constructor(message = "Tailable cursor does not support this operation") {
      super(message);
    }
    get name() {
      return "MongoTailableCursorError";
    }
  }
  exports.MongoTailableCursorError = MongoTailableCursorError;

  class MongoGridFSStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSStreamError";
    }
  }
  exports.MongoGridFSStreamError = MongoGridFSStreamError;

  class MongoGridFSChunkError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSChunkError";
    }
  }
  exports.MongoGridFSChunkError = MongoGridFSChunkError;

  class MongoUnexpectedServerResponseError extends MongoRuntimeError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoUnexpectedServerResponseError";
    }
  }
  exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;

  class MongoOperationTimeoutError extends MongoDriverError {
    get name() {
      return "MongoOperationTimeoutError";
    }
  }
  exports.MongoOperationTimeoutError = MongoOperationTimeoutError;

  class MongoCursorInUseError extends MongoAPIError {
    constructor(message = "Cursor is already initialized") {
      super(message);
    }
    get name() {
      return "MongoCursorInUseError";
    }
  }
  exports.MongoCursorInUseError = MongoCursorInUseError;

  class MongoServerClosedError extends MongoAPIError {
    constructor(message = "Server is closed") {
      super(message);
    }
    get name() {
      return "MongoServerClosedError";
    }
  }
  exports.MongoServerClosedError = MongoServerClosedError;

  class MongoCursorExhaustedError extends MongoAPIError {
    constructor(message) {
      super(message || "Cursor is exhausted");
    }
    get name() {
      return "MongoCursorExhaustedError";
    }
  }
  exports.MongoCursorExhaustedError = MongoCursorExhaustedError;

  class MongoTopologyClosedError extends MongoAPIError {
    constructor(message = "Topology is closed") {
      super(message);
    }
    get name() {
      return "MongoTopologyClosedError";
    }
  }
  exports.MongoTopologyClosedError = MongoTopologyClosedError;

  class MongoClientClosedError extends MongoAPIError {
    constructor() {
      super("Operation interrupted because client was closed");
    }
    get name() {
      return "MongoClientClosedError";
    }
  }
  exports.MongoClientClosedError = MongoClientClosedError;

  class MongoNetworkError extends MongoError {
    constructor(message, options) {
      super(message, { cause: options?.cause });
      this.beforeHandshake = !!options?.beforeHandshake;
    }
    get name() {
      return "MongoNetworkError";
    }
  }
  exports.MongoNetworkError = MongoNetworkError;

  class MongoNetworkTimeoutError extends MongoNetworkError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoNetworkTimeoutError";
    }
  }
  exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;

  class MongoParseError extends MongoDriverError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoParseError";
    }
  }
  exports.MongoParseError = MongoParseError;

  class MongoInvalidArgumentError extends MongoAPIError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoInvalidArgumentError";
    }
  }
  exports.MongoInvalidArgumentError = MongoInvalidArgumentError;

  class MongoCompatibilityError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCompatibilityError";
    }
  }
  exports.MongoCompatibilityError = MongoCompatibilityError;

  class MongoMissingCredentialsError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoMissingCredentialsError";
    }
  }
  exports.MongoMissingCredentialsError = MongoMissingCredentialsError;

  class MongoMissingDependencyError extends MongoAPIError {
    constructor(message, options) {
      super(message, options);
      this.dependencyName = options.dependencyName;
    }
    get name() {
      return "MongoMissingDependencyError";
    }
  }
  exports.MongoMissingDependencyError = MongoMissingDependencyError;

  class MongoSystemError extends MongoError {
    constructor(message, reason) {
      if (reason && reason.error) {
        super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
          cause: reason.error
        });
      } else {
        super(message);
      }
      if (reason) {
        this.reason = reason;
      }
      this.code = reason.error?.code;
    }
    get name() {
      return "MongoSystemError";
    }
  }
  exports.MongoSystemError = MongoSystemError;

  class MongoServerSelectionError extends MongoSystemError {
    constructor(message, reason) {
      super(message, reason);
    }
    get name() {
      return "MongoServerSelectionError";
    }
  }
  exports.MongoServerSelectionError = MongoServerSelectionError;

  class MongoWriteConcernError extends MongoServerError {
    constructor(result) {
      super({ ...result.writeConcernError, ...result });
      this.errInfo = result.writeConcernError.errInfo;
      this.result = result;
    }
    get name() {
      return "MongoWriteConcernError";
    }
  }
  exports.MongoWriteConcernError = MongoWriteConcernError;
  var RETRYABLE_READ_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.ReadConcernMajorityNotAvailableYet
  ]);
  var RETRYABLE_WRITE_ERROR_CODES = RETRYABLE_READ_ERROR_CODES;
  function needsRetryableWriteLabel(error, maxWireVersion, serverType) {
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (error instanceof MongoError) {
      if ((maxWireVersion >= 9 || isRetryableWriteError(error)) && !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
        return false;
      }
    }
    if (error instanceof MongoWriteConcernError) {
      if (serverType === "Mongos" && maxWireVersion < 9) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error.result.code ?? 0);
      }
      const code = error.result.writeConcernError.code ?? Number(error.code);
      return RETRYABLE_WRITE_ERROR_CODES.has(Number.isNaN(code) ? 0 : code);
    }
    if (error instanceof MongoError) {
      return RETRYABLE_WRITE_ERROR_CODES.has(Number(error.code));
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  }
  function isRetryableWriteError(error) {
    return error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError) || error.hasErrorLabel(exports.MongoErrorLabel.PoolRequstedRetry);
  }
  function isRetryableReadError(error) {
    const hasRetryableErrorCode = typeof error.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;
    if (hasRetryableErrorCode) {
      return true;
    }
    if (error instanceof MongoNetworkError) {
      return true;
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  }
  var SDAM_RECOVERING_CODES = new Set([
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
  ]);
  var SDAM_NOT_PRIMARY_CODES = new Set([
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.LegacyNotPrimary
  ]);
  var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress
  ]);
  function isRecoveringError(err2) {
    if (typeof err2.code === "number") {
      return SDAM_RECOVERING_CODES.has(err2.code);
    }
    return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err2.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err2.message);
  }
  function isNotWritablePrimaryError(err2) {
    if (typeof err2.code === "number") {
      return SDAM_NOT_PRIMARY_CODES.has(err2.code);
    }
    if (isRecoveringError(err2)) {
      return false;
    }
    return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err2.message);
  }
  function isNodeShuttingDownError(err2) {
    return !!(typeof err2.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err2.code));
  }
  function isSDAMUnrecoverableError(error) {
    if (error instanceof MongoParseError || error == null) {
      return true;
    }
    return isRecoveringError(error) || isNotWritablePrimaryError(error);
  }
  function isNetworkTimeoutError(err2) {
    return !!(err2 instanceof MongoNetworkError && err2.message.match(/timed out/));
  }
  function isResumableError(error, wireVersion) {
    if (error == null || !(error instanceof MongoError)) {
      return false;
    }
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (wireVersion != null && wireVersion >= 9) {
      if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
        return true;
      }
      return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
    }
    if (typeof error.code === "number") {
      return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
    }
    return false;
  }
});

// node_modules/mongodb/lib/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.WAITING_FOR_SUITABLE_SERVER = exports.SERVER_SELECTION_SUCCEEDED = exports.SERVER_SELECTION_FAILED = exports.SERVER_SELECTION_STARTED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = undefined;
  exports.kDecoratedKeys = exports.kDecorateResult = exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = undefined;
  exports.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
  exports.SYSTEM_INDEX_COLLECTION = "system.indexes";
  exports.SYSTEM_PROFILE_COLLECTION = "system.profile";
  exports.SYSTEM_USER_COLLECTION = "system.users";
  exports.SYSTEM_COMMAND_COLLECTION = "$cmd";
  exports.SYSTEM_JS_COLLECTION = "system.js";
  exports.ERROR = "error";
  exports.TIMEOUT = "timeout";
  exports.CLOSE = "close";
  exports.OPEN = "open";
  exports.CONNECT = "connect";
  exports.CLOSED = "closed";
  exports.ENDED = "ended";
  exports.MESSAGE = "message";
  exports.PINNED = "pinned";
  exports.UNPINNED = "unpinned";
  exports.DESCRIPTION_RECEIVED = "descriptionReceived";
  exports.SERVER_OPENING = "serverOpening";
  exports.SERVER_CLOSED = "serverClosed";
  exports.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
  exports.TOPOLOGY_OPENING = "topologyOpening";
  exports.TOPOLOGY_CLOSED = "topologyClosed";
  exports.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
  exports.SERVER_SELECTION_STARTED = "serverSelectionStarted";
  exports.SERVER_SELECTION_FAILED = "serverSelectionFailed";
  exports.SERVER_SELECTION_SUCCEEDED = "serverSelectionSucceeded";
  exports.WAITING_FOR_SUITABLE_SERVER = "waitingForSuitableServer";
  exports.CONNECTION_POOL_CREATED = "connectionPoolCreated";
  exports.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
  exports.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
  exports.CONNECTION_POOL_READY = "connectionPoolReady";
  exports.CONNECTION_CREATED = "connectionCreated";
  exports.CONNECTION_READY = "connectionReady";
  exports.CONNECTION_CLOSED = "connectionClosed";
  exports.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
  exports.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
  exports.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
  exports.CONNECTION_CHECKED_IN = "connectionCheckedIn";
  exports.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
  exports.COMMAND_STARTED = "commandStarted";
  exports.COMMAND_SUCCEEDED = "commandSucceeded";
  exports.COMMAND_FAILED = "commandFailed";
  exports.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
  exports.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
  exports.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
  exports.RESPONSE = "response";
  exports.MORE = "more";
  exports.INIT = "init";
  exports.CHANGE = "change";
  exports.END = "end";
  exports.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
  exports.HEARTBEAT_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED
  ]);
  exports.CMAP_EVENTS = Object.freeze([
    exports.CONNECTION_POOL_CREATED,
    exports.CONNECTION_POOL_READY,
    exports.CONNECTION_POOL_CLEARED,
    exports.CONNECTION_POOL_CLOSED,
    exports.CONNECTION_CREATED,
    exports.CONNECTION_READY,
    exports.CONNECTION_CLOSED,
    exports.CONNECTION_CHECK_OUT_STARTED,
    exports.CONNECTION_CHECK_OUT_FAILED,
    exports.CONNECTION_CHECKED_OUT,
    exports.CONNECTION_CHECKED_IN
  ]);
  exports.TOPOLOGY_EVENTS = Object.freeze([
    exports.SERVER_OPENING,
    exports.SERVER_CLOSED,
    exports.SERVER_DESCRIPTION_CHANGED,
    exports.TOPOLOGY_OPENING,
    exports.TOPOLOGY_CLOSED,
    exports.TOPOLOGY_DESCRIPTION_CHANGED,
    exports.ERROR,
    exports.TIMEOUT,
    exports.CLOSE
  ]);
  exports.APM_EVENTS = Object.freeze([
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED
  ]);
  exports.SERVER_RELAY_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED,
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED,
    ...exports.CMAP_EVENTS
  ]);
  exports.LOCAL_SERVER_EVENTS = Object.freeze([
    exports.CONNECT,
    exports.DESCRIPTION_RECEIVED,
    exports.CLOSED,
    exports.ENDED
  ]);
  exports.MONGO_CLIENT_EVENTS = Object.freeze([
    ...exports.CMAP_EVENTS,
    ...exports.APM_EVENTS,
    ...exports.TOPOLOGY_EVENTS,
    ...exports.HEARTBEAT_EVENTS
  ]);
  exports.LEGACY_HELLO_COMMAND = "ismaster";
  exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
  exports.kDecorateResult = Symbol.for("@@mdb.decorateDecryptionResult");
  exports.kDecoratedKeys = Symbol.for("@@mdb.decryptedKeys");
});

// node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MIN_SUPPORTED_QE_SERVER_VERSION = exports.MIN_SUPPORTED_QE_WIRE_VERSION = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = undefined;
  exports.MIN_SUPPORTED_SERVER_VERSION = "4.2";
  exports.MAX_SUPPORTED_SERVER_VERSION = "8.0";
  exports.MIN_SUPPORTED_WIRE_VERSION = 8;
  exports.MAX_SUPPORTED_WIRE_VERSION = 25;
  exports.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
  exports.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
  exports.OP_REPLY = 1;
  exports.OP_UPDATE = 2001;
  exports.OP_INSERT = 2002;
  exports.OP_QUERY = 2004;
  exports.OP_DELETE = 2006;
  exports.OP_COMPRESSED = 2012;
  exports.OP_MSG = 2013;
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadConcern = exports.ReadConcernLevel = undefined;
  exports.ReadConcernLevel = Object.freeze({
    local: "local",
    majority: "majority",
    linearizable: "linearizable",
    available: "available",
    snapshot: "snapshot"
  });

  class ReadConcern {
    constructor(level) {
      this.level = exports.ReadConcernLevel[level] ?? level;
    }
    static fromOptions(options) {
      if (options == null) {
        return;
      }
      if (options.readConcern) {
        const { readConcern } = options;
        if (readConcern instanceof ReadConcern) {
          return readConcern;
        } else if (typeof readConcern === "string") {
          return new ReadConcern(readConcern);
        } else if ("level" in readConcern && readConcern.level) {
          return new ReadConcern(readConcern.level);
        }
      }
      if (options.level) {
        return new ReadConcern(options.level);
      }
      return;
    }
    static get MAJORITY() {
      return exports.ReadConcernLevel.majority;
    }
    static get AVAILABLE() {
      return exports.ReadConcernLevel.available;
    }
    static get LINEARIZABLE() {
      return exports.ReadConcernLevel.linearizable;
    }
    static get SNAPSHOT() {
      return exports.ReadConcernLevel.snapshot;
    }
    toJSON() {
      return { level: this.level };
    }
  }
  exports.ReadConcern = ReadConcern;
});

// node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadPreference = exports.ReadPreferenceMode = undefined;
  var error_1 = require_error();
  exports.ReadPreferenceMode = Object.freeze({
    primary: "primary",
    primaryPreferred: "primaryPreferred",
    secondary: "secondary",
    secondaryPreferred: "secondaryPreferred",
    nearest: "nearest"
  });

  class ReadPreference {
    constructor(mode, tags, options) {
      if (!ReadPreference.isValid(mode)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
      }
      if (options == null && typeof tags === "object" && !Array.isArray(tags)) {
        options = tags;
        tags = undefined;
      } else if (tags && !Array.isArray(tags)) {
        throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options?.hedge;
      this.maxStalenessSeconds = undefined;
      this.minWireVersion = undefined;
      options = options ?? {};
      if (options.maxStalenessSeconds != null) {
        if (options.maxStalenessSeconds <= 0) {
          throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
        }
      }
    }
    get preference() {
      return this.mode;
    }
    static fromString(mode) {
      return new ReadPreference(mode);
    }
    static fromOptions(options) {
      if (!options)
        return;
      const readPreference = options.readPreference ?? options.session?.transaction.options.readPreference;
      const readPreferenceTags = options.readPreferenceTags;
      if (readPreference == null) {
        return;
      }
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags, {
          maxStalenessSeconds: options.maxStalenessSeconds,
          hedge: options.hedge
        });
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds,
            hedge: options.hedge
          });
        }
      }
      if (readPreferenceTags) {
        readPreference.tags = readPreferenceTags;
      }
      return readPreference;
    }
    static translate(options) {
      if (options.readPreference == null)
        return options;
      const r2 = options.readPreference;
      if (typeof r2 === "string") {
        options.readPreference = new ReadPreference(r2);
      } else if (r2 && !(r2 instanceof ReadPreference) && typeof r2 === "object") {
        const mode = r2.mode || r2.preference;
        if (mode && typeof mode === "string") {
          options.readPreference = new ReadPreference(mode, r2.tags, {
            maxStalenessSeconds: r2.maxStalenessSeconds
          });
        }
      } else if (!(r2 instanceof ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r2}`);
      }
      return options;
    }
    static isValid(mode) {
      const VALID_MODES = new Set([
        ReadPreference.PRIMARY,
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST,
        null
      ]);
      return VALID_MODES.has(mode);
    }
    isValid(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    }
    secondaryOk() {
      const NEEDS_SECONDARYOK = new Set([
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST
      ]);
      return NEEDS_SECONDARYOK.has(this.mode);
    }
    equals(readPreference) {
      return readPreference.mode === this.mode;
    }
    toJSON() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    }
  }
  exports.ReadPreference = ReadPreference;
  ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
  ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
  ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
  ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
  ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
  ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
  ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
  ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
  ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
  ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
});

// node_modules/mongodb/lib/sdam/common.js
var require_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = undefined;
  exports._advanceClusterTime = _advanceClusterTime;
  exports.STATE_CLOSING = "closing";
  exports.STATE_CLOSED = "closed";
  exports.STATE_CONNECTING = "connecting";
  exports.STATE_CONNECTED = "connected";
  exports.TopologyType = Object.freeze({
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown",
    LoadBalanced: "LoadBalanced"
  });
  exports.ServerType = Object.freeze({
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown",
    LoadBalancer: "LoadBalancer"
  });
  function _advanceClusterTime(entity, $clusterTime) {
    if (entity.clusterTime == null) {
      entity.clusterTime = $clusterTime;
    } else {
      if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
        entity.clusterTime = $clusterTime;
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js
var require_document = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OnDemandDocument = undefined;
  var bson_1 = require_bson2();
  var BSONElementOffset = {
    type: 0,
    nameOffset: 1,
    nameLength: 2,
    offset: 3,
    length: 4
  };

  class OnDemandDocument {
    constructor(bson, offset = 0, isArray = false, elements) {
      this.cache = Object.create(null);
      this.indexFound = Object.create(null);
      this.bson = bson;
      this.offset = offset;
      this.isArray = isArray;
      this.elements = elements ?? (0, bson_1.parseToElementsToArray)(this.bson, offset);
    }
    isElementName(name, element) {
      const nameLength = element[BSONElementOffset.nameLength];
      const nameOffset = element[BSONElementOffset.nameOffset];
      if (name.length !== nameLength)
        return false;
      const nameEnd = nameOffset + nameLength;
      for (let byteIndex = nameOffset, charIndex = 0;charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {
        if (this.bson[byteIndex] !== name.charCodeAt(charIndex))
          return false;
      }
      return true;
    }
    getElement(name) {
      const cachedElement = this.cache[name];
      if (cachedElement === false)
        return null;
      if (cachedElement != null) {
        return cachedElement;
      }
      if (typeof name === "number") {
        if (this.isArray) {
          if (name < this.elements.length) {
            const element = this.elements[name];
            const cachedElement2 = { element, value: undefined };
            this.cache[name] = cachedElement2;
            this.indexFound[name] = true;
            return cachedElement2;
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
      for (let index = 0;index < this.elements.length; index++) {
        const element = this.elements[index];
        if (!(index in this.indexFound) && this.isElementName(name, element)) {
          const cachedElement2 = { element, value: undefined };
          this.cache[name] = cachedElement2;
          this.indexFound[index] = true;
          return cachedElement2;
        }
      }
      this.cache[name] = false;
      return null;
    }
    toJSValue(element, as) {
      const type = element[BSONElementOffset.type];
      const offset = element[BSONElementOffset.offset];
      const length = element[BSONElementOffset.length];
      if (as !== type) {
        return null;
      }
      switch (as) {
        case bson_1.BSONType.null:
        case bson_1.BSONType.undefined:
          return null;
        case bson_1.BSONType.double:
          return (0, bson_1.getFloat64LE)(this.bson, offset);
        case bson_1.BSONType.int:
          return (0, bson_1.getInt32LE)(this.bson, offset);
        case bson_1.BSONType.long:
          return (0, bson_1.getBigInt64LE)(this.bson, offset);
        case bson_1.BSONType.bool:
          return Boolean(this.bson[offset]);
        case bson_1.BSONType.objectId:
          return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));
        case bson_1.BSONType.timestamp:
          return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));
        case bson_1.BSONType.string:
          return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);
        case bson_1.BSONType.binData: {
          const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);
          const subType = this.bson[offset + 4];
          if (subType === 2) {
            const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);
            if (subType2BinarySize < 0)
              throw new bson_1.BSONError("Negative binary type element size found for subtype 0x02");
            if (subType2BinarySize > totalBinarySize - 4)
              throw new bson_1.BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (subType2BinarySize < totalBinarySize - 4)
              throw new bson_1.BSONError("Binary type with subtype 0x02 contains too short binary size");
            return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);
          }
          return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);
        }
        case bson_1.BSONType.date:
          return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));
        case bson_1.BSONType.object:
          return new OnDemandDocument(this.bson, offset);
        case bson_1.BSONType.array:
          return new OnDemandDocument(this.bson, offset, true);
        default:
          throw new bson_1.BSONError(`Unsupported BSON type: ${as}`);
      }
    }
    size() {
      return this.elements.length;
    }
    has(name) {
      const cachedElement = this.cache[name];
      if (cachedElement === false)
        return false;
      if (cachedElement != null)
        return true;
      return this.getElement(name) != null;
    }
    get(name, as, required) {
      const element = this.getElement(name);
      if (element == null) {
        if (required === true) {
          throw new bson_1.BSONError(`BSON element "${name}" is missing`);
        } else {
          return null;
        }
      }
      if (element.value == null) {
        const value = this.toJSValue(element.element, as);
        if (value == null) {
          if (required === true) {
            throw new bson_1.BSONError(`BSON element "${name}" is missing`);
          } else {
            return null;
          }
        }
        element.value = value;
      }
      return element.value;
    }
    getNumber(name, required) {
      const maybeBool = this.get(name, bson_1.BSONType.bool);
      const bool = maybeBool == null ? null : maybeBool ? 1 : 0;
      const maybeLong = this.get(name, bson_1.BSONType.long);
      const long = maybeLong == null ? null : Number(maybeLong);
      const result = bool ?? long ?? this.get(name, bson_1.BSONType.int) ?? this.get(name, bson_1.BSONType.double);
      if (required === true && result == null) {
        throw new bson_1.BSONError(`BSON element "${name}" is missing`);
      }
      return result;
    }
    toObject(options) {
      return (0, bson_1.deserialize)(this.bson, {
        ...options,
        index: this.offset,
        allowObjectSmallerThanBufferSize: true
      });
    }
    toBytes() {
      const size = (0, bson_1.getInt32LE)(this.bson, this.offset);
      return this.bson.subarray(this.offset, this.offset + size);
    }
  }
  exports.OnDemandDocument = OnDemandDocument;
});

// node_modules/mongodb/lib/cmap/wire_protocol/responses.js
var require_responses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteCursorResponse = exports.ExplainedCursorResponse = exports.CursorResponse = exports.MongoDBResponse = undefined;
  exports.isErrorResponse = isErrorResponse;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var document_1 = require_document();
  var BSONElementOffset = {
    type: 0,
    nameOffset: 1,
    nameLength: 2,
    offset: 3,
    length: 4
  };
  function isErrorResponse(bson, elements) {
    for (let eIdx = 0;eIdx < elements.length; eIdx++) {
      const element = elements[eIdx];
      if (element[BSONElementOffset.nameLength] === 2) {
        const nameOffset = element[BSONElementOffset.nameOffset];
        if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {
          const valueOffset = element[BSONElementOffset.offset];
          const valueLength = element[BSONElementOffset.length];
          for (let i = valueOffset;i < valueOffset + valueLength; i++) {
            if (bson[i] !== 0)
              return false;
          }
          return true;
        }
      }
    }
    return true;
  }

  class MongoDBResponse extends document_1.OnDemandDocument {
    get(name, as, required) {
      try {
        return super.get(name, as, required);
      } catch (cause) {
        throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
      }
    }
    static is(value) {
      return value instanceof MongoDBResponse;
    }
    static make(bson) {
      const elements = (0, bson_1.parseToElementsToArray)(bson, 0);
      const isError = isErrorResponse(bson, elements);
      return isError ? new MongoDBResponse(bson, 0, false, elements) : new this(bson, 0, false, elements);
    }
    get isMaxTimeExpiredError() {
      const isTopLevel = this.ok === 0 && this.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
      if (isTopLevel)
        return true;
      if (this.ok === 0)
        return false;
      const isWriteConcern = this.get("writeConcernError", bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
      if (isWriteConcern)
        return true;
      const writeErrors = this.get("writeErrors", bson_1.BSONType.array);
      if (writeErrors?.size()) {
        for (let i = 0;i < writeErrors.size(); i++) {
          const isWriteError = writeErrors.get(i, bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
          if (isWriteError)
            return true;
        }
      }
      return false;
    }
    get recoveryToken() {
      return this.get("recoveryToken", bson_1.BSONType.object)?.toObject({
        promoteValues: false,
        promoteLongs: false,
        promoteBuffers: false,
        validation: { utf8: true }
      }) ?? null;
    }
    get atClusterTime() {
      return this.get("cursor", bson_1.BSONType.object)?.get("atClusterTime", bson_1.BSONType.timestamp) ?? this.get("atClusterTime", bson_1.BSONType.timestamp);
    }
    get operationTime() {
      return this.get("operationTime", bson_1.BSONType.timestamp);
    }
    get ok() {
      return this.getNumber("ok") ? 1 : 0;
    }
    get $err() {
      return this.get("$err", bson_1.BSONType.string);
    }
    get errmsg() {
      return this.get("errmsg", bson_1.BSONType.string);
    }
    get code() {
      return this.getNumber("code");
    }
    get $clusterTime() {
      if (!("clusterTime" in this)) {
        const clusterTimeDoc = this.get("$clusterTime", bson_1.BSONType.object);
        if (clusterTimeDoc == null) {
          this.clusterTime = null;
          return null;
        }
        const clusterTime = clusterTimeDoc.get("clusterTime", bson_1.BSONType.timestamp, true);
        const signature = clusterTimeDoc.get("signature", bson_1.BSONType.object)?.toObject();
        this.clusterTime = { clusterTime, signature };
      }
      return this.clusterTime ?? null;
    }
    toObject(options) {
      const exactBSONOptions = {
        ...(0, bson_1.pluckBSONSerializeOptions)(options ?? {}),
        validation: (0, bson_1.parseUtf8ValidationOption)(options)
      };
      return super.toObject(exactBSONOptions);
    }
  }
  exports.MongoDBResponse = MongoDBResponse;
  MongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));

  class CursorResponse extends MongoDBResponse {
    constructor() {
      super(...arguments);
      this._batch = null;
      this.iterated = 0;
      this._encryptedBatch = null;
    }
    static get emptyGetMore() {
      return new CursorResponse((0, bson_1.serialize)({ ok: 1, cursor: { id: 0n, nextBatch: [] } }));
    }
    static is(value) {
      return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;
    }
    get cursor() {
      return this.get("cursor", bson_1.BSONType.object, true);
    }
    get id() {
      try {
        return bson_1.Long.fromBigInt(this.cursor.get("id", bson_1.BSONType.long, true));
      } catch (cause) {
        throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
      }
    }
    get ns() {
      const namespace = this.cursor.get("ns", bson_1.BSONType.string);
      if (namespace != null)
        return (0, utils_1.ns)(namespace);
      return null;
    }
    get length() {
      return Math.max(this.batchSize - this.iterated, 0);
    }
    get encryptedBatch() {
      if (this.encryptedResponse == null)
        return null;
      if (this._encryptedBatch != null)
        return this._encryptedBatch;
      const cursor = this.encryptedResponse?.get("cursor", bson_1.BSONType.object);
      if (cursor?.has("firstBatch"))
        this._encryptedBatch = cursor.get("firstBatch", bson_1.BSONType.array, true);
      else if (cursor?.has("nextBatch"))
        this._encryptedBatch = cursor.get("nextBatch", bson_1.BSONType.array, true);
      else
        throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
      return this._encryptedBatch;
    }
    get batch() {
      if (this._batch != null)
        return this._batch;
      const cursor = this.cursor;
      if (cursor.has("firstBatch"))
        this._batch = cursor.get("firstBatch", bson_1.BSONType.array, true);
      else if (cursor.has("nextBatch"))
        this._batch = cursor.get("nextBatch", bson_1.BSONType.array, true);
      else
        throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
      return this._batch;
    }
    get batchSize() {
      return this.batch?.size();
    }
    get postBatchResumeToken() {
      return this.cursor.get("postBatchResumeToken", bson_1.BSONType.object)?.toObject({
        promoteValues: false,
        promoteLongs: false,
        promoteBuffers: false,
        validation: { utf8: true }
      }) ?? null;
    }
    shift(options) {
      if (this.iterated >= this.batchSize) {
        return null;
      }
      const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;
      const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;
      this.iterated += 1;
      if (options?.raw) {
        return result.toBytes();
      } else {
        const object = result.toObject(options);
        if (encryptedResult) {
          (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options), true);
        }
        return object;
      }
    }
    clear() {
      this.iterated = this.batchSize;
    }
  }
  exports.CursorResponse = CursorResponse;

  class ExplainedCursorResponse extends CursorResponse {
    constructor() {
      super(...arguments);
      this.isExplain = true;
      this._length = 1;
    }
    get id() {
      return bson_1.Long.fromBigInt(0n);
    }
    get batchSize() {
      return 0;
    }
    get ns() {
      return null;
    }
    get length() {
      return this._length;
    }
    shift(options) {
      if (this._length === 0)
        return null;
      this._length -= 1;
      return this.toObject(options);
    }
  }
  exports.ExplainedCursorResponse = ExplainedCursorResponse;

  class ClientBulkWriteCursorResponse extends CursorResponse {
    get insertedCount() {
      return this.get("nInserted", bson_1.BSONType.int, true);
    }
    get upsertedCount() {
      return this.get("nUpserted", bson_1.BSONType.int, true);
    }
    get matchedCount() {
      return this.get("nMatched", bson_1.BSONType.int, true);
    }
    get modifiedCount() {
      return this.get("nModified", bson_1.BSONType.int, true);
    }
    get deletedCount() {
      return this.get("nDeleted", bson_1.BSONType.int, true);
    }
    get writeConcernError() {
      return this.get("writeConcernError", bson_1.BSONType.object, false);
    }
  }
  exports.ClientBulkWriteCursorResponse = ClientBulkWriteCursorResponse;
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteConcern = exports.WRITE_CONCERN_KEYS = undefined;
  exports.throwIfWriteConcernError = throwIfWriteConcernError;
  var responses_1 = require_responses();
  var error_1 = require_error();
  exports.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];

  class WriteConcern {
    constructor(w, wtimeoutMS, journal, fsync) {
      if (w != null) {
        if (!Number.isNaN(Number(w))) {
          this.w = Number(w);
        } else {
          this.w = w;
        }
      }
      if (wtimeoutMS != null) {
        this.wtimeoutMS = this.wtimeout = wtimeoutMS;
      }
      if (journal != null) {
        this.journal = this.j = journal;
      }
      if (fsync != null) {
        this.journal = this.j = fsync ? true : false;
      }
    }
    static apply(command, writeConcern) {
      const wc = {};
      if (writeConcern.w != null)
        wc.w = writeConcern.w;
      if (writeConcern.wtimeoutMS != null)
        wc.wtimeout = writeConcern.wtimeoutMS;
      if (writeConcern.journal != null)
        wc.j = writeConcern.j;
      command.writeConcern = wc;
      return command;
    }
    static fromOptions(options, inherit) {
      if (options == null)
        return;
      inherit = inherit ?? {};
      let opts;
      if (typeof options === "string" || typeof options === "number") {
        opts = { w: options };
      } else if (options instanceof WriteConcern) {
        opts = options;
      } else {
        opts = options.writeConcern;
      }
      const parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;
      const mergedOpts = { ...parentOpts, ...opts };
      const { w = undefined, wtimeout = undefined, j = undefined, fsync = undefined, journal = undefined, wtimeoutMS = undefined } = mergedOpts;
      if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
        return new WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
      }
      return;
    }
  }
  exports.WriteConcern = WriteConcern;
  function throwIfWriteConcernError(response) {
    if (typeof response === "object" && response != null) {
      const writeConcernError = responses_1.MongoDBResponse.is(response) && response.has("writeConcernError") ? response.toObject() : !responses_1.MongoDBResponse.is(response) && ("writeConcernError" in response) ? response : null;
      if (writeConcernError != null) {
        throw new error_1.MongoWriteConcernError(writeConcernError);
      }
    }
  }
});

// node_modules/mongodb/lib/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kDispose = exports.randomBytes = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = exports.DOCUMENT_DB_CHECK = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ByteUtils = undefined;
  exports.isUint8Array = isUint8Array;
  exports.hostMatchesWildcards = hostMatchesWildcards;
  exports.normalizeHintField = normalizeHintField;
  exports.isObject = isObject2;
  exports.mergeOptions = mergeOptions;
  exports.filterOptions = filterOptions;
  exports.applyRetryableWrites = applyRetryableWrites;
  exports.isPromiseLike = isPromiseLike;
  exports.decorateWithCollation = decorateWithCollation;
  exports.decorateWithReadConcern = decorateWithReadConcern;
  exports.getTopology = getTopology;
  exports.ns = ns;
  exports.makeCounter = makeCounter;
  exports.uuidV4 = uuidV4;
  exports.maxWireVersion = maxWireVersion;
  exports.arrayStrictEqual = arrayStrictEqual;
  exports.errorStrictEqual = errorStrictEqual;
  exports.makeStateMachine = makeStateMachine;
  exports.now = now;
  exports.calculateDurationInMs = calculateDurationInMs;
  exports.hasAtomicOperators = hasAtomicOperators;
  exports.resolveTimeoutOptions = resolveTimeoutOptions;
  exports.resolveOptions = resolveOptions;
  exports.isSuperset = isSuperset;
  exports.isHello = isHello;
  exports.setDifference = setDifference;
  exports.isRecord = isRecord;
  exports.emitWarning = emitWarning;
  exports.emitWarningOnce = emitWarningOnce;
  exports.enumToString = enumToString;
  exports.supportsRetryableWrites = supportsRetryableWrites;
  exports.shuffle = shuffle;
  exports.commandSupportsReadConcern = commandSupportsReadConcern;
  exports.compareObjectId = compareObjectId;
  exports.parseInteger = parseInteger;
  exports.parseUnsignedInteger = parseUnsignedInteger;
  exports.checkParentDomainMatch = checkParentDomainMatch;
  exports.get = get;
  exports.request = request;
  exports.isHostMatch = isHostMatch;
  exports.promiseWithResolvers = promiseWithResolvers;
  exports.squashError = squashError;
  exports.once = once;
  exports.maybeAddIdToDocuments = maybeAddIdToDocuments;
  exports.fileIsAccessible = fileIsAccessible;
  exports.csotMin = csotMin;
  exports.noop = noop;
  exports.decorateDecryptionResult = decorateDecryptionResult;
  exports.addAbortListener = addAbortListener;
  exports.abortable = abortable;
  var crypto2 = __require("crypto");
  var fs_1 = __require("fs");
  var http = __require("http");
  var timers_1 = __require("timers");
  var url = __require("url");
  var url_1 = __require("url");
  var util_1 = __require("util");
  var bson_1 = require_bson2();
  var constants_1 = require_constants2();
  var constants_2 = require_constants();
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common2();
  var write_concern_1 = require_write_concern();
  exports.ByteUtils = {
    toLocalBufferType(buffer) {
      return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    },
    equals(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
    },
    compare(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
    },
    toBase64(uint8array) {
      return exports.ByteUtils.toLocalBufferType(uint8array).toString("base64");
    }
  };
  function isUint8Array(value) {
    return value != null && typeof value === "object" && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Uint8Array";
  }
  function hostMatchesWildcards(host, wildcards) {
    for (const wildcard of wildcards) {
      if (host === wildcard || wildcard.startsWith("*.") && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith("*/") && host?.endsWith(wildcard.substring(2, wildcard.length))) {
        return true;
      }
    }
    return false;
  }
  function normalizeHintField(hint) {
    let finalHint = undefined;
    if (typeof hint === "string") {
      finalHint = hint;
    } else if (Array.isArray(hint)) {
      finalHint = {};
      hint.forEach((param) => {
        finalHint[param] = 1;
      });
    } else if (hint != null && typeof hint === "object") {
      finalHint = {};
      for (const name in hint) {
        finalHint[name] = hint[name];
      }
    }
    return finalHint;
  }
  var TO_STRING = (object) => Object.prototype.toString.call(object);
  function isObject2(arg) {
    return TO_STRING(arg) === "[object Object]";
  }
  function mergeOptions(target, source) {
    return { ...target, ...source };
  }
  function filterOptions(options, names) {
    const filterOptions2 = {};
    for (const name in options) {
      if (names.includes(name)) {
        filterOptions2[name] = options[name];
      }
    }
    return filterOptions2;
  }
  function applyRetryableWrites(target, db) {
    if (db && db.s.options?.retryWrites) {
      target.retryWrites = true;
    }
    return target;
  }
  function isPromiseLike(value) {
    return value != null && typeof value === "object" && "then" in value && typeof value.then === "function";
  }
  function decorateWithCollation(command, target, options) {
    const capabilities = getTopology(target).capabilities;
    if (options.collation && typeof options.collation === "object") {
      if (capabilities && capabilities.commandsTakeCollation) {
        command.collation = options.collation;
      } else {
        throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
      }
    }
  }
  function decorateWithReadConcern(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
      return;
    }
    const readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
      Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
      Object.assign(command, { readConcern });
    }
  }
  function getTopology(provider) {
    if ("topology" in provider && provider.topology) {
      return provider.topology;
    } else if ("client" in provider && provider.client.topology) {
      return provider.client.topology;
    }
    throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
  }
  function ns(ns2) {
    return MongoDBNamespace.fromString(ns2);
  }

  class MongoDBNamespace {
    constructor(db, collection) {
      this.db = db;
      this.collection = collection === "" ? undefined : collection;
    }
    toString() {
      return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
      return new MongoDBCollectionNamespace(this.db, collection);
    }
    static fromString(namespace) {
      if (typeof namespace !== "string" || namespace === "") {
        throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
      }
      const [db, ...collectionParts] = namespace.split(".");
      const collection = collectionParts.join(".");
      return new MongoDBNamespace(db, collection === "" ? undefined : collection);
    }
  }
  exports.MongoDBNamespace = MongoDBNamespace;

  class MongoDBCollectionNamespace extends MongoDBNamespace {
    constructor(db, collection) {
      super(db, collection);
      this.collection = collection;
    }
    static fromString(namespace) {
      return super.fromString(namespace);
    }
  }
  exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
  function* makeCounter(seed = 0) {
    let count = seed;
    while (true) {
      const newCount = count;
      count += 1;
      yield newCount;
    }
  }
  function uuidV4() {
    const result = crypto2.randomBytes(16);
    result[6] = result[6] & 15 | 64;
    result[8] = result[8] & 63 | 128;
    return result;
  }
  function maxWireVersion(topologyOrServer) {
    if (topologyOrServer) {
      if (topologyOrServer.loadBalanced || topologyOrServer.serverApi?.version) {
        return constants_1.MAX_SUPPORTED_WIRE_VERSION;
      }
      if (topologyOrServer.hello) {
        return topologyOrServer.hello.maxWireVersion;
      }
      if ("lastHello" in topologyOrServer && typeof topologyOrServer.lastHello === "function") {
        const lastHello = topologyOrServer.lastHello();
        if (lastHello) {
          return lastHello.maxWireVersion;
        }
      }
      if (topologyOrServer.description && "maxWireVersion" in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
        return topologyOrServer.description.maxWireVersion;
      }
    }
    return 0;
  }
  function arrayStrictEqual(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
      return false;
    }
    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
  }
  function errorStrictEqual(lhs, rhs) {
    if (lhs === rhs) {
      return true;
    }
    if (!lhs || !rhs) {
      return lhs === rhs;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
      return false;
    }
    if (lhs.message !== rhs.message) {
      return false;
    }
    return true;
  }
  function makeStateMachine(stateTable) {
    return function stateTransition(target, newState) {
      const legalStates = stateTable[target.s.state];
      if (legalStates && legalStates.indexOf(newState) < 0) {
        throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
      }
      target.emit("stateChanged", target.s.state, newState);
      target.s.state = newState;
    };
  }
  function now() {
    const hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1e6);
  }
  function calculateDurationInMs(started) {
    if (typeof started !== "number") {
      return -1;
    }
    const elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
  }
  function hasAtomicOperators(doc, options) {
    if (Array.isArray(doc)) {
      for (const document2 of doc) {
        if (hasAtomicOperators(document2)) {
          return true;
        }
      }
      return false;
    }
    const keys = Object.keys(doc);
    if (options?.ignoreUndefined) {
      let allUndefined = true;
      for (const key of keys) {
        if (doc[key] !== undefined) {
          allUndefined = false;
          break;
        }
      }
      if (allUndefined) {
        throw new error_1.MongoInvalidArgumentError("Update operations require that all atomic operators have defined values, but none were provided.");
      }
    }
    return keys.length > 0 && keys[0][0] === "$";
  }
  function resolveTimeoutOptions(client, options) {
    const { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS } = client.s.options;
    return { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS, ...options };
  }
  function resolveOptions(parent, options) {
    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
    const timeoutMS = options?.timeoutMS ?? parent?.timeoutMS;
    const session = options?.session;
    if (!session?.inTransaction()) {
      const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;
      if (readConcern) {
        result.readConcern = readConcern;
      }
      let writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;
      if (writeConcern) {
        if (timeoutMS != null) {
          writeConcern = write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...writeConcern,
              wtimeout: undefined,
              wtimeoutMS: undefined
            }
          });
        }
        result.writeConcern = writeConcern;
      }
    }
    result.timeoutMS = timeoutMS;
    const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;
    if (readPreference) {
      result.readPreference = readPreference;
    }
    const isConvenientTransaction = session?.explicit && session?.timeoutContext != null;
    if (isConvenientTransaction && options?.timeoutMS != null) {
      throw new error_1.MongoInvalidArgumentError("An operation cannot be given a timeoutMS setting when inside a withTransaction call that has a timeoutMS setting");
    }
    return result;
  }
  function isSuperset(set2, subset) {
    set2 = Array.isArray(set2) ? new Set(set2) : set2;
    subset = Array.isArray(subset) ? new Set(subset) : subset;
    for (const elem of subset) {
      if (!set2.has(elem)) {
        return false;
      }
    }
    return true;
  }
  function isHello(doc) {
    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
  }
  function setDifference(setA, setB) {
    const difference = new Set(setA);
    for (const elem of setB) {
      difference.delete(elem);
    }
    return difference;
  }
  var HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
  function isRecord(value, requiredKeys = undefined) {
    if (!isObject2(value)) {
      return false;
    }
    const ctor = value.constructor;
    if (ctor && ctor.prototype) {
      if (!isObject2(ctor.prototype)) {
        return false;
      }
      if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
        return false;
      }
    }
    if (requiredKeys) {
      const keys = Object.keys(value);
      return isSuperset(keys, requiredKeys);
    }
    return true;
  }

  class List {
    get length() {
      return this.count;
    }
    get [Symbol.toStringTag]() {
      return "List";
    }
    constructor() {
      this.count = 0;
      this.head = {
        next: null,
        prev: null,
        value: null
      };
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    toArray() {
      return Array.from(this);
    }
    toString() {
      return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
    }
    *[Symbol.iterator]() {
      for (const node of this.nodes()) {
        yield node.value;
      }
    }
    *nodes() {
      let ptr = this.head.next;
      while (ptr !== this.head) {
        const { next } = ptr;
        yield ptr;
        ptr = next;
      }
    }
    push(value) {
      this.count += 1;
      const newNode = {
        next: this.head,
        prev: this.head.prev,
        value
      };
      this.head.prev.next = newNode;
      this.head.prev = newNode;
    }
    pushMany(iterable) {
      for (const value of iterable) {
        this.push(value);
      }
    }
    unshift(value) {
      this.count += 1;
      const newNode = {
        next: this.head.next,
        prev: this.head,
        value
      };
      this.head.next.prev = newNode;
      this.head.next = newNode;
    }
    remove(node) {
      if (node === this.head || this.length === 0) {
        return null;
      }
      this.count -= 1;
      const prevNode = node.prev;
      const nextNode = node.next;
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
      return node.value;
    }
    shift() {
      return this.remove(this.head.next);
    }
    pop() {
      return this.remove(this.head.prev);
    }
    prune(filter) {
      for (const node of this.nodes()) {
        if (filter(node.value)) {
          this.remove(node);
        }
      }
    }
    clear() {
      this.count = 0;
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    first() {
      return this.head.next.value;
    }
    last() {
      return this.head.prev.value;
    }
  }
  exports.List = List;

  class BufferPool {
    constructor() {
      this.buffers = new List;
      this.totalByteLength = 0;
    }
    get length() {
      return this.totalByteLength;
    }
    append(buffer) {
      this.buffers.push(buffer);
      this.totalByteLength += buffer.length;
    }
    getInt32() {
      if (this.totalByteLength < 4) {
        return null;
      }
      const firstBuffer = this.buffers.first();
      if (firstBuffer != null && firstBuffer.byteLength >= 4) {
        return firstBuffer.readInt32LE(0);
      }
      const top4Bytes = this.read(4);
      const value = top4Bytes.readInt32LE(0);
      this.totalByteLength += 4;
      this.buffers.unshift(top4Bytes);
      return value;
    }
    read(size) {
      if (typeof size !== "number" || size < 0) {
        throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
      }
      if (size > this.totalByteLength) {
        return Buffer.alloc(0);
      }
      const result = Buffer.allocUnsafe(size);
      for (let bytesRead = 0;bytesRead < size; ) {
        const buffer = this.buffers.shift();
        if (buffer == null) {
          break;
        }
        const bytesRemaining = size - bytesRead;
        const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
        const bytes = buffer.subarray(0, bytesReadable);
        result.set(bytes, bytesRead);
        bytesRead += bytesReadable;
        this.totalByteLength -= bytesReadable;
        if (bytesReadable < buffer.byteLength) {
          this.buffers.unshift(buffer.subarray(bytesReadable));
        }
      }
      return result;
    }
  }
  exports.BufferPool = BufferPool;

  class HostAddress {
    constructor(hostString) {
      this.host = undefined;
      this.port = undefined;
      this.socketPath = undefined;
      this.isIPv6 = false;
      const escapedHost = hostString.split(" ").join("%20");
      if (escapedHost.endsWith(".sock")) {
        this.socketPath = decodeURIComponent(escapedHost);
        return;
      }
      const urlString = `iLoveJS://${escapedHost}`;
      let url2;
      try {
        url2 = new url_1.URL(urlString);
      } catch (urlError) {
        const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
        runtimeError.cause = urlError;
        throw runtimeError;
      }
      const hostname = url2.hostname;
      const port = url2.port;
      let normalized = decodeURIComponent(hostname).toLowerCase();
      if (normalized.startsWith("[") && normalized.endsWith("]")) {
        this.isIPv6 = true;
        normalized = normalized.substring(1, hostname.length - 1);
      }
      this.host = normalized.toLowerCase();
      if (typeof port === "number") {
        this.port = port;
      } else if (typeof port === "string" && port !== "") {
        this.port = Number.parseInt(port, 10);
      } else {
        this.port = 27017;
      }
      if (this.port === 0) {
        throw new error_1.MongoParseError("Invalid port (zero) with hostname");
      }
      Object.freeze(this);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new HostAddress('${this.toString()}')`;
    }
    toString() {
      if (typeof this.host === "string") {
        if (this.isIPv6) {
          return `[${this.host}]:${this.port}`;
        }
        return `${this.host}:${this.port}`;
      }
      return `${this.socketPath}`;
    }
    static fromString(s) {
      return new HostAddress(s);
    }
    static fromHostPort(host, port) {
      if (host.includes(":")) {
        host = `[${host}]`;
      }
      return HostAddress.fromString(`${host}:${port}`);
    }
    static fromSrvRecord({ name, port }) {
      return HostAddress.fromHostPort(name, port);
    }
    toHostPort() {
      if (this.socketPath) {
        return { host: this.socketPath, port: 0 };
      }
      const host = this.host ?? "";
      const port = this.port ?? 0;
      return { host, port };
    }
  }
  exports.HostAddress = HostAddress;
  exports.DEFAULT_PK_FACTORY = {
    createPk() {
      return new bson_1.ObjectId;
    }
  };
  exports.MONGODB_WARNING_CODE = "MONGODB DRIVER";
  function emitWarning(message) {
    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
  }
  var emittedWarnings = new Set;
  function emitWarningOnce(message) {
    if (!emittedWarnings.has(message)) {
      emittedWarnings.add(message);
      return emitWarning(message);
    }
  }
  function enumToString(en) {
    return Object.values(en).join(", ");
  }
  function supportsRetryableWrites(server) {
    if (!server) {
      return false;
    }
    if (server.loadBalanced) {
      return true;
    }
    if (server.description.logicalSessionTimeoutMinutes != null) {
      if (server.description.type !== common_1.ServerType.Standalone) {
        return true;
      }
    }
    return false;
  }
  function shuffle(sequence, limit = 0) {
    const items = Array.from(sequence);
    if (limit > items.length) {
      throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
    }
    let remainingItemsToShuffle = items.length;
    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
    while (remainingItemsToShuffle > lowerBound) {
      const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
      remainingItemsToShuffle -= 1;
      const swapHold = items[remainingItemsToShuffle];
      items[remainingItemsToShuffle] = items[randomIndex];
      items[randomIndex] = swapHold;
    }
    return limit % items.length === 0 ? items : items.slice(lowerBound);
  }
  function commandSupportsReadConcern(command) {
    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
      return true;
    }
    return false;
  }
  function compareObjectId(oid1, oid2) {
    if (oid1 == null && oid2 == null) {
      return 0;
    }
    if (oid1 == null) {
      return -1;
    }
    if (oid2 == null) {
      return 1;
    }
    return exports.ByteUtils.compare(oid1.id, oid2.id);
  }
  function parseInteger(value) {
    if (typeof value === "number")
      return Math.trunc(value);
    const parsedValue = Number.parseInt(String(value), 10);
    return Number.isNaN(parsedValue) ? null : parsedValue;
  }
  function parseUnsignedInteger(value) {
    const parsedInt = parseInteger(value);
    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
  }
  function checkParentDomainMatch(address, srvHost) {
    const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
    const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
    const allCharacterBeforeFirstDot = /^.*?\./;
    const srvIsLessThanThreeParts = normalizedSrvHost.split(".").length < 3;
    const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
    let srvHostDomain = srvIsLessThanThreeParts ? normalizedSrvHost : `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
    if (!srvHostDomain.startsWith(".")) {
      srvHostDomain = "." + srvHostDomain;
    }
    if (srvIsLessThanThreeParts && normalizedAddress.split(".").length <= normalizedSrvHost.split(".").length) {
      throw new error_1.MongoAPIError("Server record does not have at least one more domain level than parent URI");
    }
    if (!addressDomain.endsWith(srvHostDomain)) {
      throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
    }
  }
  function get(url2, options = {}) {
    return new Promise((resolve, reject) => {
      let timeoutId;
      const request2 = http.get(url2, options, (response) => {
        response.setEncoding("utf8");
        let body = "";
        response.on("data", (chunk) => body += chunk);
        response.on("end", () => {
          (0, timers_1.clearTimeout)(timeoutId);
          resolve({ status: response.statusCode, body });
        });
      }).on("error", (error) => {
        (0, timers_1.clearTimeout)(timeoutId);
        reject(error);
      }).end();
      timeoutId = (0, timers_1.setTimeout)(() => {
        request2.destroy(new error_1.MongoNetworkTimeoutError(`request timed out after 10 seconds`));
      }, 1e4);
    });
  }
  async function request(uri2, options = {}) {
    return await new Promise((resolve, reject) => {
      const requestOptions = {
        method: "GET",
        timeout: 1e4,
        json: true,
        ...url.parse(uri2),
        ...options
      };
      const req = http.request(requestOptions, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => {
          data += d;
        });
        res.once("end", () => {
          if (options.json === false) {
            resolve(data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            resolve(parsed);
          } catch {
            reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.once("timeout", () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri2} timed out after ${options.timeout} ms`)));
      req.once("error", (error) => reject(error));
      req.end();
    });
  }
  exports.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
  exports.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
  exports.DOCUMENT_DB_MSG = "You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb";
  exports.COSMOS_DB_MSG = "You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb";
  function isHostMatch(match, host) {
    return host && match.test(host.toLowerCase()) ? true : false;
  }
  function promiseWithResolvers() {
    let resolve;
    let reject;
    const promise = new Promise(function withResolversExecutor(promiseResolve, promiseReject) {
      resolve = promiseResolve;
      reject = promiseReject;
    });
    return { promise, resolve, reject };
  }
  function squashError(_error) {
    return;
  }
  exports.randomBytes = (0, util_1.promisify)(crypto2.randomBytes);
  async function once(ee, name, options) {
    options?.signal?.throwIfAborted();
    const { promise, resolve, reject } = promiseWithResolvers();
    const onEvent = (data) => resolve(data);
    const onError = (error) => reject(error);
    const abortListener = addAbortListener(options?.signal, function() {
      reject(this.reason);
    });
    ee.once(name, onEvent).once("error", onError);
    try {
      return await promise;
    } finally {
      ee.off(name, onEvent);
      ee.off("error", onError);
      abortListener?.[exports.kDispose]();
    }
  }
  function maybeAddIdToDocuments(coll, docOrDocs, options) {
    const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options?.forceServerObjectId;
    if (forceServerObjectId === true) {
      return docOrDocs;
    }
    const transform2 = (doc) => {
      if (doc._id == null) {
        doc._id = coll.s.pkFactory.createPk();
      }
      return doc;
    };
    return Array.isArray(docOrDocs) ? docOrDocs.map(transform2) : transform2(docOrDocs);
  }
  async function fileIsAccessible(fileName, mode) {
    try {
      await fs_1.promises.access(fileName, mode);
      return true;
    } catch {
      return false;
    }
  }
  function csotMin(duration1, duration2) {
    if (duration1 === 0)
      return duration2;
    if (duration2 === 0)
      return duration1;
    return Math.min(duration1, duration2);
  }
  function noop() {
    return;
  }
  function decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall = true) {
    if (isTopLevelDecorateCall) {
      if (Buffer.isBuffer(original)) {
        original = (0, bson_1.deserialize)(original);
      }
      if (Buffer.isBuffer(decrypted)) {
        throw new error_1.MongoRuntimeError("Expected result of decryption to be deserialized BSON object");
      }
    }
    if (!decrypted || typeof decrypted !== "object")
      return;
    for (const k of Object.keys(decrypted)) {
      const originalValue = original[k];
      if (originalValue && originalValue._bsontype === "Binary" && originalValue.sub_type === 6) {
        if (!decrypted[constants_2.kDecoratedKeys]) {
          Object.defineProperty(decrypted, constants_2.kDecoratedKeys, {
            value: [],
            configurable: true,
            enumerable: false,
            writable: false
          });
        }
        decrypted[constants_2.kDecoratedKeys].push(k);
        continue;
      }
      decorateDecryptionResult(decrypted[k], originalValue, false);
    }
  }
  exports.kDispose = Symbol.dispose ?? Symbol("dispose");
  function addAbortListener(signal, listener) {
    if (signal == null)
      return;
    signal.addEventListener("abort", listener, { once: true });
    return { [exports.kDispose]: () => signal.removeEventListener("abort", listener) };
  }
  async function abortable(promise, { signal }) {
    if (signal == null) {
      return await promise;
    }
    const { promise: aborted, reject } = promiseWithResolvers();
    const abortListener = signal.aborted ? reject(signal.reason) : addAbortListener(signal, function() {
      reject(this.reason);
    });
    try {
      return await Promise.race([promise, aborted]);
    } finally {
      abortListener?.[exports.kDispose]();
    }
  }
});

// node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = undefined;
  exports.parseSeverityFromString = parseSeverityFromString;
  exports.createStdioLogger = createStdioLogger;
  exports.stringifyWithMaxLen = stringifyWithMaxLen;
  exports.defaultLogTransform = defaultLogTransform;
  var util_1 = __require("util");
  var bson_1 = require_bson2();
  var constants_1 = require_constants();
  var utils_1 = require_utils();
  exports.SeverityLevel = Object.freeze({
    EMERGENCY: "emergency",
    ALERT: "alert",
    CRITICAL: "critical",
    ERROR: "error",
    WARNING: "warn",
    NOTICE: "notice",
    INFORMATIONAL: "info",
    DEBUG: "debug",
    TRACE: "trace",
    OFF: "off"
  });
  exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1000;

  class SeverityLevelMap extends Map {
    constructor(entries) {
      const newEntries = [];
      for (const [level, value] of entries) {
        newEntries.push([value, level]);
      }
      newEntries.push(...entries);
      super(newEntries);
    }
    getNumericSeverityLevel(severity) {
      return this.get(severity);
    }
    getSeverityLevelName(level) {
      return this.get(level);
    }
  }
  exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
    [exports.SeverityLevel.OFF, -Infinity],
    [exports.SeverityLevel.EMERGENCY, 0],
    [exports.SeverityLevel.ALERT, 1],
    [exports.SeverityLevel.CRITICAL, 2],
    [exports.SeverityLevel.ERROR, 3],
    [exports.SeverityLevel.WARNING, 4],
    [exports.SeverityLevel.NOTICE, 5],
    [exports.SeverityLevel.INFORMATIONAL, 6],
    [exports.SeverityLevel.DEBUG, 7],
    [exports.SeverityLevel.TRACE, 8]
  ]);
  exports.MongoLoggableComponent = Object.freeze({
    COMMAND: "command",
    TOPOLOGY: "topology",
    SERVER_SELECTION: "serverSelection",
    CONNECTION: "connection",
    CLIENT: "client"
  });
  function parseSeverityFromString(s) {
    const validSeverities = Object.values(exports.SeverityLevel);
    const lowerSeverity = s?.toLowerCase();
    if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
      return lowerSeverity;
    }
    return null;
  }
  function createStdioLogger(stream) {
    return {
      write: (0, util_1.promisify)((log, cb) => {
        const logLine = (0, util_1.inspect)(log, { compact: true, breakLength: Infinity });
        stream.write(`${logLine}
`, "utf-8", cb);
        return;
      })
    };
  }
  function resolveLogPath({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
    if (typeof mongodbLogPath === "string" && /^stderr$/i.test(mongodbLogPath)) {
      return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
    }
    if (typeof mongodbLogPath === "string" && /^stdout$/i.test(mongodbLogPath)) {
      return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
    }
    if (typeof mongodbLogPath === "object" && typeof mongodbLogPath?.write === "function") {
      return { mongodbLogPath, mongodbLogPathIsStdErr: false };
    }
    if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
      return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
    }
    if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
      return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
    }
    return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
  }
  function resolveSeverityConfiguration(clientOption, environmentOption, defaultSeverity) {
    return parseSeverityFromString(clientOption) ?? parseSeverityFromString(environmentOption) ?? defaultSeverity;
  }
  function compareSeverity(s0, s1) {
    const s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s0);
    const s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
    return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
  }
  function stringifyWithMaxLen(value, maxDocumentLength, options = {}) {
    let strToTruncate = "";
    let currentLength = 0;
    const maxDocumentLengthEnsurer = function maxDocumentLengthEnsurer(key, value2) {
      if (currentLength >= maxDocumentLength) {
        return;
      }
      if (key === "") {
        currentLength += 1;
        return value2;
      }
      currentLength += key.length + 4;
      if (value2 == null)
        return value2;
      switch (typeof value2) {
        case "string":
          currentLength += value2.length + 2;
          break;
        case "number":
        case "bigint":
          currentLength += String(value2).length;
          break;
        case "boolean":
          currentLength += value2 ? 4 : 5;
          break;
        case "object":
          if ((0, utils_1.isUint8Array)(value2)) {
            currentLength += 22 + value2.byteLength + value2.byteLength * 0.33 + 18 | 0;
          } else if ("_bsontype" in value2) {
            const v = value2;
            switch (v._bsontype) {
              case "Int32":
                currentLength += String(v.value).length;
                break;
              case "Double":
                currentLength += (v.value | 0) === v.value ? String(v.value).length + 2 : String(v.value).length;
                break;
              case "Long":
                currentLength += v.toString().length;
                break;
              case "ObjectId":
                currentLength += 35;
                break;
              case "MaxKey":
              case "MinKey":
                currentLength += 13;
                break;
              case "Binary":
                currentLength += 22 + value2.position + value2.position * 0.33 + 18 | 0;
                break;
              case "Timestamp":
                currentLength += 19 + String(v.t).length + 5 + String(v.i).length + 2;
                break;
              case "Code":
                if (v.scope == null) {
                  currentLength += v.code.length + 10 + 2;
                } else {
                  currentLength += v.code.length + 10 + 11;
                }
                break;
              case "BSONRegExp":
                currentLength += 34 + v.pattern.length + 13 + v.options.length + 3;
                break;
            }
          }
      }
      return value2;
    };
    if (typeof value === "string") {
      strToTruncate = value;
    } else if (typeof value === "function") {
      strToTruncate = value.name;
    } else {
      try {
        if (maxDocumentLength !== 0) {
          strToTruncate = bson_1.EJSON.stringify(value, maxDocumentLengthEnsurer, 0, options);
        } else {
          strToTruncate = bson_1.EJSON.stringify(value, options);
        }
      } catch (e) {
        strToTruncate = `Extended JSON serialization failed with: ${e.message}`;
      }
    }
    if (maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength && strToTruncate.charCodeAt(maxDocumentLength - 1) !== strToTruncate.codePointAt(maxDocumentLength - 1)) {
      maxDocumentLength--;
      if (maxDocumentLength === 0) {
        return "";
      }
    }
    return maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength ? `${strToTruncate.slice(0, maxDocumentLength)}...` : strToTruncate;
  }
  function isLogConvertible(obj) {
    const objAsLogConvertible = obj;
    return objAsLogConvertible.toLog !== undefined && typeof objAsLogConvertible.toLog === "function";
  }
  function attachServerSelectionFields(log, serverSelectionEvent, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
    const { selector, operation, topologyDescription, message } = serverSelectionEvent;
    log.selector = stringifyWithMaxLen(selector, maxDocumentLength);
    log.operation = operation;
    log.topologyDescription = stringifyWithMaxLen(topologyDescription, maxDocumentLength);
    log.message = message;
    return log;
  }
  function attachCommandFields(log, commandEvent) {
    log.commandName = commandEvent.commandName;
    log.requestId = commandEvent.requestId;
    log.driverConnectionId = commandEvent.connectionId;
    const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    if (commandEvent?.serviceId) {
      log.serviceId = commandEvent.serviceId.toHexString();
    }
    log.databaseName = commandEvent.databaseName;
    log.serverConnectionId = commandEvent.serverConnectionId;
    return log;
  }
  function attachConnectionFields(log, event) {
    const { host, port } = utils_1.HostAddress.fromString(event.address).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    return log;
  }
  function attachSDAMFields(log, sdamEvent) {
    log.topologyId = sdamEvent.topologyId;
    return log;
  }
  function attachServerHeartbeatFields(log, serverHeartbeatEvent) {
    const { awaited, connectionId } = serverHeartbeatEvent;
    log.awaited = awaited;
    log.driverConnectionId = serverHeartbeatEvent.connectionId;
    const { host, port } = utils_1.HostAddress.fromString(connectionId).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    return log;
  }
  function defaultLogTransform(logObject, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
    let log = Object.create(null);
    switch (logObject.name) {
      case constants_1.SERVER_SELECTION_STARTED:
        log = attachServerSelectionFields(log, logObject, maxDocumentLength);
        return log;
      case constants_1.SERVER_SELECTION_FAILED:
        log = attachServerSelectionFields(log, logObject, maxDocumentLength);
        log.failure = logObject.failure?.message;
        return log;
      case constants_1.SERVER_SELECTION_SUCCEEDED:
        log = attachServerSelectionFields(log, logObject, maxDocumentLength);
        log.serverHost = logObject.serverHost;
        log.serverPort = logObject.serverPort;
        return log;
      case constants_1.WAITING_FOR_SUITABLE_SERVER:
        log = attachServerSelectionFields(log, logObject, maxDocumentLength);
        log.remainingTimeMS = logObject.remainingTimeMS;
        return log;
      case constants_1.COMMAND_STARTED:
        log = attachCommandFields(log, logObject);
        log.message = "Command started";
        log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength, { relaxed: true });
        log.databaseName = logObject.databaseName;
        return log;
      case constants_1.COMMAND_SUCCEEDED:
        log = attachCommandFields(log, logObject);
        log.message = "Command succeeded";
        log.durationMS = logObject.duration;
        log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
        return log;
      case constants_1.COMMAND_FAILED:
        log = attachCommandFields(log, logObject);
        log.message = "Command failed";
        log.durationMS = logObject.duration;
        log.failure = logObject.failure?.message ?? "(redacted)";
        return log;
      case constants_1.CONNECTION_POOL_CREATED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool created";
        if (logObject.options) {
          const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
          log = {
            ...log,
            maxIdleTimeMS,
            minPoolSize,
            maxPoolSize,
            maxConnecting,
            waitQueueTimeoutMS
          };
        }
        return log;
      case constants_1.CONNECTION_POOL_READY:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool ready";
        return log;
      case constants_1.CONNECTION_POOL_CLEARED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool cleared";
        if (logObject.serviceId?._bsontype === "ObjectId") {
          log.serviceId = logObject.serviceId?.toHexString();
        }
        return log;
      case constants_1.CONNECTION_POOL_CLOSED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool closed";
        return log;
      case constants_1.CONNECTION_CREATED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection created";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_READY:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection ready";
        log.driverConnectionId = logObject.connectionId;
        log.durationMS = logObject.durationMS;
        return log;
      case constants_1.CONNECTION_CLOSED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection closed";
        log.driverConnectionId = logObject.connectionId;
        switch (logObject.reason) {
          case "stale":
            log.reason = "Connection became stale because the pool was cleared";
            break;
          case "idle":
            log.reason = "Connection has been available but unused for longer than the configured max idle time";
            break;
          case "error":
            log.reason = "An error occurred while using the connection";
            if (logObject.error) {
              log.error = logObject.error;
            }
            break;
          case "poolClosed":
            log.reason = "Connection pool was closed";
            break;
          default:
            log.reason = `Unknown close reason: ${logObject.reason}`;
        }
        return log;
      case constants_1.CONNECTION_CHECK_OUT_STARTED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checkout started";
        return log;
      case constants_1.CONNECTION_CHECK_OUT_FAILED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checkout failed";
        switch (logObject.reason) {
          case "poolClosed":
            log.reason = "Connection pool was closed";
            break;
          case "timeout":
            log.reason = "Wait queue timeout elapsed without a connection becoming available";
            break;
          case "connectionError":
            log.reason = "An error occurred while trying to establish a new connection";
            if (logObject.error) {
              log.error = logObject.error;
            }
            break;
          default:
            log.reason = `Unknown close reason: ${logObject.reason}`;
        }
        log.durationMS = logObject.durationMS;
        return log;
      case constants_1.CONNECTION_CHECKED_OUT:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checked out";
        log.driverConnectionId = logObject.connectionId;
        log.durationMS = logObject.durationMS;
        return log;
      case constants_1.CONNECTION_CHECKED_IN:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checked in";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.SERVER_OPENING:
        log = attachSDAMFields(log, logObject);
        log = attachConnectionFields(log, logObject);
        log.message = "Starting server monitoring";
        return log;
      case constants_1.SERVER_CLOSED:
        log = attachSDAMFields(log, logObject);
        log = attachConnectionFields(log, logObject);
        log.message = "Stopped server monitoring";
        return log;
      case constants_1.SERVER_HEARTBEAT_STARTED:
        log = attachSDAMFields(log, logObject);
        log = attachServerHeartbeatFields(log, logObject);
        log.message = "Server heartbeat started";
        return log;
      case constants_1.SERVER_HEARTBEAT_SUCCEEDED:
        log = attachSDAMFields(log, logObject);
        log = attachServerHeartbeatFields(log, logObject);
        log.message = "Server heartbeat succeeded";
        log.durationMS = logObject.duration;
        log.serverConnectionId = logObject.serverConnectionId;
        log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
        return log;
      case constants_1.SERVER_HEARTBEAT_FAILED:
        log = attachSDAMFields(log, logObject);
        log = attachServerHeartbeatFields(log, logObject);
        log.message = "Server heartbeat failed";
        log.durationMS = logObject.duration;
        log.failure = logObject.failure?.message;
        return log;
      case constants_1.TOPOLOGY_OPENING:
        log = attachSDAMFields(log, logObject);
        log.message = "Starting topology monitoring";
        return log;
      case constants_1.TOPOLOGY_CLOSED:
        log = attachSDAMFields(log, logObject);
        log.message = "Stopped topology monitoring";
        return log;
      case constants_1.TOPOLOGY_DESCRIPTION_CHANGED:
        log = attachSDAMFields(log, logObject);
        log.message = "Topology description changed";
        log.previousDescription = log.reply = stringifyWithMaxLen(logObject.previousDescription, maxDocumentLength);
        log.newDescription = log.reply = stringifyWithMaxLen(logObject.newDescription, maxDocumentLength);
        return log;
      default:
        for (const [key, value] of Object.entries(logObject)) {
          if (value != null)
            log[key] = value;
        }
    }
    return log;
  }

  class MongoLogger {
    constructor(options) {
      this.pendingLog = null;
      this.error = this.log.bind(this, "error");
      this.warn = this.log.bind(this, "warn");
      this.info = this.log.bind(this, "info");
      this.debug = this.log.bind(this, "debug");
      this.trace = this.log.bind(this, "trace");
      this.componentSeverities = options.componentSeverities;
      this.maxDocumentLength = options.maxDocumentLength;
      this.logDestination = options.logDestination;
      this.logDestinationIsStdErr = options.logDestinationIsStdErr;
      this.severities = this.createLoggingSeverities();
    }
    createLoggingSeverities() {
      const severities = Object();
      for (const component of Object.values(exports.MongoLoggableComponent)) {
        severities[component] = {};
        for (const severityLevel of Object.values(exports.SeverityLevel)) {
          severities[component][severityLevel] = compareSeverity(severityLevel, this.componentSeverities[component]) <= 0;
        }
      }
      return severities;
    }
    turnOffSeverities() {
      for (const component of Object.values(exports.MongoLoggableComponent)) {
        this.componentSeverities[component] = exports.SeverityLevel.OFF;
        for (const severityLevel of Object.values(exports.SeverityLevel)) {
          this.severities[component][severityLevel] = false;
        }
      }
    }
    logWriteFailureHandler(error) {
      if (this.logDestinationIsStdErr) {
        this.turnOffSeverities();
        this.clearPendingLog();
        return;
      }
      this.logDestination = createStdioLogger(process.stderr);
      this.logDestinationIsStdErr = true;
      this.clearPendingLog();
      this.error(exports.MongoLoggableComponent.CLIENT, {
        toLog: function() {
          return {
            message: "User input for mongodbLogPath is now invalid. Logging is halted.",
            error: error.message
          };
        }
      });
      this.turnOffSeverities();
      this.clearPendingLog();
    }
    clearPendingLog() {
      this.pendingLog = null;
    }
    willLog(component, severity) {
      if (severity === exports.SeverityLevel.OFF)
        return false;
      return this.severities[component][severity];
    }
    log(severity, component, message) {
      if (!this.willLog(component, severity))
        return;
      let logMessage = { t: new Date, c: component, s: severity };
      if (typeof message === "string") {
        logMessage.message = message;
      } else if (typeof message === "object") {
        if (isLogConvertible(message)) {
          logMessage = { ...logMessage, ...message.toLog() };
        } else {
          logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
        }
      }
      if ((0, utils_1.isPromiseLike)(this.pendingLog)) {
        this.pendingLog = this.pendingLog.then(() => this.logDestination.write(logMessage)).then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
        return;
      }
      try {
        const logResult = this.logDestination.write(logMessage);
        if ((0, utils_1.isPromiseLike)(logResult)) {
          this.pendingLog = logResult.then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
        }
      } catch (error) {
        this.logWriteFailureHandler(error);
      }
    }
    static resolveOptions(envOptions, clientOptions) {
      const resolvedLogPath = resolveLogPath(envOptions, clientOptions);
      const combinedOptions = {
        ...envOptions,
        ...clientOptions,
        mongodbLogPath: resolvedLogPath.mongodbLogPath,
        mongodbLogPathIsStdErr: resolvedLogPath.mongodbLogPathIsStdErr
      };
      const defaultSeverity = resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.default, combinedOptions.MONGODB_LOG_ALL, exports.SeverityLevel.OFF);
      return {
        componentSeverities: {
          command: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.command, combinedOptions.MONGODB_LOG_COMMAND, defaultSeverity),
          topology: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.topology, combinedOptions.MONGODB_LOG_TOPOLOGY, defaultSeverity),
          serverSelection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.serverSelection, combinedOptions.MONGODB_LOG_SERVER_SELECTION, defaultSeverity),
          connection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.connection, combinedOptions.MONGODB_LOG_CONNECTION, defaultSeverity),
          client: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.client, combinedOptions.MONGODB_LOG_CLIENT, defaultSeverity),
          default: defaultSeverity
        },
        maxDocumentLength: combinedOptions.mongodbLogMaxDocumentLength ?? (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ?? 1000,
        logDestination: combinedOptions.mongodbLogPath,
        logDestinationIsStdErr: combinedOptions.mongodbLogPathIsStdErr
      };
    }
  }
  exports.MongoLogger = MongoLogger;
});

// node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationToken = exports.TypedEventEmitter = undefined;
  var events_1 = __require("events");
  var mongo_logger_1 = require_mongo_logger();
  var utils_1 = require_utils();

  class TypedEventEmitter extends events_1.EventEmitter {
    emitAndLog(event, ...args) {
      this.emit(event, ...args);
      if (this.component)
        this.mongoLogger?.debug(this.component, args[0]);
    }
    emitAndLogHeartbeat(event, topologyId, serverConnectionId, ...args) {
      this.emit(event, ...args);
      if (this.component) {
        const loggableHeartbeatEvent = {
          topologyId,
          serverConnectionId: serverConnectionId ?? null,
          ...args[0]
        };
        this.mongoLogger?.debug(this.component, loggableHeartbeatEvent);
      }
    }
    emitAndLogCommand(monitorCommands, event, databaseName, connectionEstablished, ...args) {
      if (monitorCommands) {
        this.emit(event, ...args);
      }
      if (connectionEstablished) {
        const loggableCommandEvent = {
          databaseName,
          ...args[0]
        };
        this.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.COMMAND, loggableCommandEvent);
      }
    }
  }
  exports.TypedEventEmitter = TypedEventEmitter;

  class CancellationToken extends TypedEventEmitter {
    constructor(...args) {
      super(...args);
      this.on("error", utils_1.noop);
    }
  }
  exports.CancellationToken = CancellationToken;
});

// node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MIN_SECONDARY_WRITE_WIRE_VERSION = undefined;
  exports.writableServerSelector = writableServerSelector;
  exports.sameServerSelector = sameServerSelector;
  exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
  exports.readPreferenceServerSelector = readPreferenceServerSelector;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common2();
  var IDLE_WRITE_PERIOD = 1e4;
  var SMALLEST_MAX_STALENESS_SECONDS = 90;
  exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
  function writableServerSelector() {
    return function writableServer(topologyDescription, servers) {
      return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
    };
  }
  function sameServerSelector(description) {
    return function sameServerSelector(topologyDescription, servers) {
      if (!description)
        return [];
      return servers.filter((sd) => {
        return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
      });
    };
  }
  function secondaryWritableServerSelector(wireVersion, readPreference) {
    if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
      return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
    }
    return readPreferenceServerSelector(readPreference);
  }
  function maxStalenessReducer(readPreference, topologyDescription, servers) {
    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
      return servers;
    }
    const maxStaleness = readPreference.maxStalenessSeconds;
    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;
    if (maxStaleness < maxStalenessVariance) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
    }
    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
      const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
      return servers.reduce((result, server) => {
        const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
      if (servers.length === 0) {
        return servers;
      }
      const sMax = servers.reduce((max2, s) => s.lastWriteDate > max2.lastWriteDate ? s : max2);
      return servers.reduce((result, server) => {
        const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    return servers;
  }
  function tagSetMatch(tagSet, serverTags) {
    const keys = Object.keys(tagSet);
    const serverTagKeys = Object.keys(serverTags);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
        return false;
      }
    }
    return true;
  }
  function tagSetReducer(readPreference, servers) {
    if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
      return servers;
    }
    for (let i = 0;i < readPreference.tags.length; ++i) {
      const tagSet = readPreference.tags[i];
      const serversMatchingTagset = servers.reduce((matched, server) => {
        if (tagSetMatch(tagSet, server.tags))
          matched.push(server);
        return matched;
      }, []);
      if (serversMatchingTagset.length) {
        return serversMatchingTagset;
      }
    }
    return [];
  }
  function latencyWindowReducer(topologyDescription, servers) {
    const low = servers.reduce((min, server) => Math.min(server.roundTripTime, min), Infinity);
    const high = low + topologyDescription.localThresholdMS;
    return servers.reduce((result, server) => {
      if (server.roundTripTime <= high && server.roundTripTime >= low)
        result.push(server);
      return result;
    }, []);
  }
  function primaryFilter(server) {
    return server.type === common_1.ServerType.RSPrimary;
  }
  function secondaryFilter(server) {
    return server.type === common_1.ServerType.RSSecondary;
  }
  function nearestFilter(server) {
    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
  }
  function knownFilter(server) {
    return server.type !== common_1.ServerType.Unknown;
  }
  function loadBalancerFilter(server) {
    return server.type === common_1.ServerType.LoadBalancer;
  }
  function readPreferenceServerSelector(readPreference) {
    if (!readPreference.isValid()) {
      throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
    }
    return function readPreferenceServers(topologyDescription, servers, deprioritized = []) {
      const commonWireVersion = topologyDescription.commonWireVersion;
      if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
        throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
      }
      if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
        return servers.filter(loadBalancerFilter);
      }
      if (topologyDescription.type === common_1.TopologyType.Unknown) {
        return [];
      }
      if (topologyDescription.type === common_1.TopologyType.Single) {
        return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
      }
      if (topologyDescription.type === common_1.TopologyType.Sharded) {
        const filtered = servers.filter((server) => {
          return !deprioritized.includes(server);
        });
        const selectable = filtered.length > 0 ? filtered : deprioritized;
        return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));
      }
      const mode = readPreference.mode;
      if (mode === read_preference_1.ReadPreference.PRIMARY) {
        return servers.filter(primaryFilter);
      }
      if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
        const result = servers.filter(primaryFilter);
        if (result.length) {
          return result;
        }
      }
      const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
      const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
      if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
        return servers.filter(primaryFilter);
      }
      return selectedServers;
    };
  }
});

// node_modules/mongodb/lib/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LegacyTimeoutContext = exports.CSOTTimeoutContext = exports.TimeoutContext = exports.Timeout = exports.TimeoutError = undefined;
  var timers_1 = __require("timers");
  var error_1 = require_error();
  var utils_1 = require_utils();

  class TimeoutError extends Error {
    get name() {
      return "TimeoutError";
    }
    constructor(message, options) {
      super(message, options);
      this.duration = options.duration;
    }
    static is(error) {
      return error != null && typeof error === "object" && "name" in error && error.name === "TimeoutError";
    }
  }
  exports.TimeoutError = TimeoutError;

  class Timeout extends Promise {
    get remainingTime() {
      if (this.timedOut)
        return 0;
      if (this.duration === 0)
        return Infinity;
      return this.start + this.duration - Math.trunc(performance.now());
    }
    get timeElapsed() {
      return Math.trunc(performance.now()) - this.start;
    }
    constructor(executor = () => null, options) {
      const duration = options?.duration ?? 0;
      const unref = !!options?.unref;
      const rejection = options?.rejection;
      if (duration < 0) {
        throw new error_1.MongoInvalidArgumentError("Cannot create a Timeout with a negative duration");
      }
      let reject;
      super((_, promiseReject) => {
        reject = promiseReject;
        executor(utils_1.noop, promiseReject);
      });
      this.ended = null;
      this.timedOut = false;
      this.cleared = false;
      this.duration = duration;
      this.start = Math.trunc(performance.now());
      if (rejection == null && this.duration > 0) {
        this.id = (0, timers_1.setTimeout)(() => {
          this.ended = Math.trunc(performance.now());
          this.timedOut = true;
          reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));
        }, this.duration);
        if (typeof this.id.unref === "function" && unref) {
          this.id.unref();
        }
      } else if (rejection != null) {
        this.ended = Math.trunc(performance.now());
        this.timedOut = true;
        reject(rejection);
      }
    }
    clear() {
      (0, timers_1.clearTimeout)(this.id);
      this.id = undefined;
      this.timedOut = false;
      this.cleared = true;
    }
    throwIfExpired() {
      if (this.timedOut) {
        this.then(undefined, utils_1.squashError);
        throw new TimeoutError("Timed out", { duration: this.duration });
      }
    }
    static expires(duration, unref) {
      return new Timeout(undefined, { duration, unref });
    }
    static reject(rejection) {
      return new Timeout(undefined, { duration: 0, unref: true, rejection });
    }
  }
  exports.Timeout = Timeout;
  function isLegacyTimeoutContextOptions(v) {
    return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "waitQueueTimeoutMS" in v && typeof v.waitQueueTimeoutMS === "number";
  }
  function isCSOTTimeoutContextOptions(v) {
    return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "timeoutMS" in v && typeof v.timeoutMS === "number";
  }

  class TimeoutContext {
    static create(options) {
      if (options.session?.timeoutContext != null)
        return options.session?.timeoutContext;
      if (isCSOTTimeoutContextOptions(options))
        return new CSOTTimeoutContext(options);
      else if (isLegacyTimeoutContextOptions(options))
        return new LegacyTimeoutContext(options);
      else
        throw new error_1.MongoRuntimeError("Unrecognized options");
    }
  }
  exports.TimeoutContext = TimeoutContext;

  class CSOTTimeoutContext extends TimeoutContext {
    constructor(options) {
      super();
      this.minRoundTripTime = 0;
      this.start = Math.trunc(performance.now());
      this.timeoutMS = options.timeoutMS;
      this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
      this.socketTimeoutMS = options.socketTimeoutMS;
      this.clearServerSelectionTimeout = false;
    }
    get maxTimeMS() {
      return this.remainingTimeMS - this.minRoundTripTime;
    }
    get remainingTimeMS() {
      const timePassed = Math.trunc(performance.now()) - this.start;
      return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;
    }
    csotEnabled() {
      return true;
    }
    get serverSelectionTimeout() {
      if (typeof this._serverSelectionTimeout !== "object" || this._serverSelectionTimeout?.cleared) {
        const { remainingTimeMS, serverSelectionTimeoutMS } = this;
        if (remainingTimeMS <= 0)
          return Timeout.reject(new error_1.MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`));
        const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 && (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;
        if (usingServerSelectionTimeoutMS) {
          this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);
        } else {
          if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {
            this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);
          } else {
            this._serverSelectionTimeout = null;
          }
        }
      }
      return this._serverSelectionTimeout;
    }
    get connectionCheckoutTimeout() {
      if (typeof this._connectionCheckoutTimeout !== "object" || this._connectionCheckoutTimeout?.cleared) {
        if (typeof this._serverSelectionTimeout === "object") {
          this._connectionCheckoutTimeout = this._serverSelectionTimeout;
        } else {
          throw new error_1.MongoRuntimeError("Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira");
        }
      }
      return this._connectionCheckoutTimeout;
    }
    get timeoutForSocketWrite() {
      const { remainingTimeMS } = this;
      if (!Number.isFinite(remainingTimeMS))
        return null;
      if (remainingTimeMS > 0)
        return Timeout.expires(remainingTimeMS);
      return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket write"));
    }
    get timeoutForSocketRead() {
      const { remainingTimeMS } = this;
      if (!Number.isFinite(remainingTimeMS))
        return null;
      if (remainingTimeMS > 0)
        return Timeout.expires(remainingTimeMS);
      return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket read"));
    }
    refresh() {
      this.start = Math.trunc(performance.now());
      this.minRoundTripTime = 0;
      this._serverSelectionTimeout?.clear();
      this._connectionCheckoutTimeout?.clear();
    }
    clear() {
      this._serverSelectionTimeout?.clear();
      this._connectionCheckoutTimeout?.clear();
    }
    getRemainingTimeMSOrThrow(message) {
      const { remainingTimeMS } = this;
      if (remainingTimeMS <= 0)
        throw new error_1.MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);
      return remainingTimeMS;
    }
    clone() {
      const timeoutContext = new CSOTTimeoutContext({
        timeoutMS: this.timeoutMS,
        serverSelectionTimeoutMS: this.serverSelectionTimeoutMS
      });
      timeoutContext.start = this.start;
      return timeoutContext;
    }
    refreshed() {
      return new CSOTTimeoutContext(this);
    }
    addMaxTimeMSToCommand(command, options) {
      if (options.omitMaxTimeMS)
        return;
      const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;
      if (maxTimeMS > 0 && Number.isFinite(maxTimeMS))
        command.maxTimeMS = maxTimeMS;
    }
    getSocketTimeoutMS() {
      return 0;
    }
  }
  exports.CSOTTimeoutContext = CSOTTimeoutContext;

  class LegacyTimeoutContext extends TimeoutContext {
    constructor(options) {
      super();
      this.options = options;
      this.clearServerSelectionTimeout = true;
    }
    csotEnabled() {
      return false;
    }
    get serverSelectionTimeout() {
      if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)
        return Timeout.expires(this.options.serverSelectionTimeoutMS);
      return null;
    }
    get connectionCheckoutTimeout() {
      if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)
        return Timeout.expires(this.options.waitQueueTimeoutMS);
      return null;
    }
    get timeoutForSocketWrite() {
      return null;
    }
    get timeoutForSocketRead() {
      return null;
    }
    refresh() {
      return;
    }
    clear() {
      return;
    }
    get maxTimeMS() {
      return null;
    }
    refreshed() {
      return new LegacyTimeoutContext(this.options);
    }
    addMaxTimeMSToCommand(_command, _options) {
    }
    getSocketTimeoutMS() {
      return this.options.socketTimeoutMS;
    }
  }
  exports.LegacyTimeoutContext = LegacyTimeoutContext;
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractOperation = exports.Aspect = undefined;
  exports.defineAspects = defineAspects;
  var bson_1 = require_bson2();
  var read_preference_1 = require_read_preference();
  exports.Aspect = {
    READ_OPERATION: Symbol("READ_OPERATION"),
    WRITE_OPERATION: Symbol("WRITE_OPERATION"),
    RETRYABLE: Symbol("RETRYABLE"),
    EXPLAINABLE: Symbol("EXPLAINABLE"),
    SKIP_COLLATION: Symbol("SKIP_COLLATION"),
    CURSOR_CREATING: Symbol("CURSOR_CREATING"),
    MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER"),
    COMMAND_BATCHING: Symbol("COMMAND_BATCHING")
  };

  class AbstractOperation {
    constructor(options = {}) {
      this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : read_preference_1.ReadPreference.fromOptions(options) ?? read_preference_1.ReadPreference.primary;
      this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
      this._session = options.session != null ? options.session : undefined;
      this.options = options;
      this.bypassPinningCheck = !!options.bypassPinningCheck;
      this.trySecondaryWrite = false;
    }
    hasAspect(aspect) {
      const ctor = this.constructor;
      if (ctor.aspects == null) {
        return false;
      }
      return ctor.aspects.has(aspect);
    }
    get session() {
      return this._session;
    }
    clearSession() {
      this._session = undefined;
    }
    resetBatch() {
      return true;
    }
    get canRetryRead() {
      return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.READ_OPERATION);
    }
    get canRetryWrite() {
      return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.WRITE_OPERATION);
    }
  }
  exports.AbstractOperation = AbstractOperation;
  function defineAspects(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
      aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, "aspects", {
      value: aspects,
      writable: false
    });
    return aspects;
  }
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeOperation = executeOperation;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var server_selection_1 = require_server_selection();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var operation_1 = require_operation();
  var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
  var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
  async function executeOperation(client, operation, timeoutContext) {
    if (!(operation instanceof operation_1.AbstractOperation)) {
      throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
    }
    const topology = client.topology == null ? await (0, utils_1.abortable)(autoConnect(client), operation.options) : client.topology;
    let session = operation.session;
    let owner;
    if (session == null) {
      owner = Symbol();
      session = client.startSession({ owner, explicit: false });
    } else if (session.hasEnded) {
      throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
      throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
    } else if (session.client !== client) {
      throw new error_1.MongoInvalidArgumentError("ClientSession must be from the same MongoClient");
    }
    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
    const inTransaction = !!session?.inTransaction();
    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === "runCommand")) {
      throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
    }
    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
      session.unpin();
    }
    timeoutContext ??= timeout_1.TimeoutContext.create({
      session,
      serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,
      waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,
      timeoutMS: operation.options.timeoutMS
    });
    try {
      return await tryOperation(operation, {
        topology,
        timeoutContext,
        session,
        readPreference
      });
    } finally {
      if (session?.owner != null && session.owner === owner) {
        await session.endSession();
      }
    }
  }
  async function autoConnect(client) {
    if (client.topology == null) {
      if (client.s.hasBeenClosed) {
        throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
      }
      client.s.options.__skipPingOnConnect = true;
      try {
        await client.connect();
        if (client.topology == null) {
          throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
        }
        return client.topology;
      } finally {
        delete client.s.options.__skipPingOnConnect;
      }
    }
    return client.topology;
  }
  async function tryOperation(operation, { topology, timeoutContext, session, readPreference }) {
    let selector;
    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
      selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
    } else if (operation.trySecondaryWrite) {
      selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
    } else {
      selector = readPreference;
    }
    let server = await topology.selectServer(selector, {
      session,
      operationName: operation.commandName,
      timeoutContext,
      signal: operation.options.signal
    });
    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    const inTransaction = session?.inTransaction() ?? false;
    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
    const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
    const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);
    if (hasWriteAspect && willRetryWrite && session != null) {
      operation.options.willRetryWrite = true;
      session.incrementTransactionNumber();
    }
    const maxTries = willRetry ? timeoutContext.csotEnabled() ? Infinity : 2 : 1;
    let previousOperationError;
    let previousServer;
    for (let tries = 0;tries < maxTries; tries++) {
      if (previousOperationError) {
        if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
          throw new error_1.MongoServerError({
            message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
            errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
            originalError: previousOperationError
          });
        }
        if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {
          throw previousOperationError;
        }
        if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError))
          throw previousOperationError;
        if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError))
          throw previousOperationError;
        if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {
          session.unpin({ force: true, forceClear: true });
        }
        server = await topology.selectServer(selector, {
          session,
          operationName: operation.commandName,
          previousServer,
          signal: operation.options.signal
        });
        if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {
          throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
        }
      }
      try {
        if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {
          operation.resetBatch();
        }
        return await operation.execute(server, session, timeoutContext);
      } catch (operationError) {
        if (!(operationError instanceof error_1.MongoError))
          throw operationError;
        if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
          throw previousOperationError;
        }
        previousServer = server.description;
        previousOperationError = operationError;
        timeoutContext.clear();
      }
    }
    throw previousOperationError ?? new error_1.MongoRuntimeError("Tried to propagate retryability error, but no error was found.");
  }
});

// node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetMoreOperation = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var operation_1 = require_operation();

  class GetMoreOperation extends operation_1.AbstractOperation {
    constructor(ns, cursorId, server, options) {
      super(options);
      this.options = options;
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    get commandName() {
      return "getMore";
    }
    async execute(server, _session, timeoutContext) {
      if (server !== this.server) {
        throw new error_1.MongoRuntimeError("Getmore must run on the same server operation began on");
      }
      if (this.cursorId == null || this.cursorId.isZero()) {
        throw new error_1.MongoRuntimeError("Unable to iterate cursor with no id");
      }
      const collection = this.ns.collection;
      if (collection == null) {
        throw new error_1.MongoRuntimeError("A collection name must be determined before getMore");
      }
      const getMoreCmd = {
        getMore: this.cursorId,
        collection
      };
      if (typeof this.options.batchSize === "number") {
        getMoreCmd.batchSize = Math.abs(this.options.batchSize);
      }
      if (typeof this.options.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
      }
      if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
        getMoreCmd.comment = this.options.comment;
      }
      const commandOptions = {
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch",
        timeoutContext,
        ...this.options
      };
      return await server.command(this.ns, getMoreCmd, commandOptions, responses_1.CursorResponse);
    }
  }
  exports.GetMoreOperation = GetMoreOperation;
  (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KillCursorsOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var operation_1 = require_operation();

  class KillCursorsOperation extends operation_1.AbstractOperation {
    constructor(cursorId, ns, server, options) {
      super(options);
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    get commandName() {
      return "killCursors";
    }
    async execute(server, session, timeoutContext) {
      if (server !== this.server) {
        throw new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on");
      }
      const killCursors = this.ns.collection;
      if (killCursors == null) {
        throw new error_1.MongoRuntimeError("A collection name must be determined before killCursors");
      }
      const killCursorsCommand = {
        killCursors,
        cursors: [this.cursorId]
      };
      try {
        await server.command(this.ns, killCursorsCommand, {
          session,
          timeoutContext
        });
      } catch (error) {
        (0, utils_1.squashError)(error);
      }
    }
  }
  exports.KillCursorsOperation = KillCursorsOperation;
  (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common3();

  class OrderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, true);
    }
    addToOperationsList(batchType, document2) {
      const bsonSize = BSON.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize)
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        this.s.currentBatchSize = 0;
        this.s.currentBatchSizeBytes = 0;
      }
      if (batchType === common_1.BatchType.INSERT) {
        this.s.bulkResult.insertedIds.push({
          index: this.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentBatch.operations.push(document2);
      this.s.currentBatchSize += 1;
      this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      this.s.currentIndex += 1;
      return this;
    }
  }
  exports.OrderedBulkOperation = OrderedBulkOperation;
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnorderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common3();

  class UnorderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, false);
    }
    handleWriteError(writeResult) {
      if (this.s.batches.length) {
        return;
      }
      return super.handleWriteError(writeResult);
    }
    addToOperationsList(batchType, document2) {
      const bsonSize = BSON.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      }
      this.s.currentBatch = undefined;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentBatch = this.s.currentInsertBatch;
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentBatch = this.s.currentUpdateBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentBatch = this.s.currentRemoveBatch;
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.operations.push(document2);
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentIndex = this.s.currentIndex + 1;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentInsertBatch = this.s.currentBatch;
        this.s.bulkResult.insertedIds.push({
          index: this.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentUpdateBatch = this.s.currentBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentRemoveBatch = this.s.currentBatch;
      }
      this.s.currentBatch.size += 1;
      this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return this;
    }
  }
  exports.UnorderedBulkOperation = UnorderedBulkOperation;
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.DB_AGGREGATE_COLLECTION = 1;
  var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;

  class AggregateOperation extends command_1.CommandOperation {
    constructor(ns, pipeline2, options) {
      super(undefined, { ...options, dbName: ns.db });
      this.options = { ...options };
      this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
      this.pipeline = pipeline2;
      this.hasWriteStage = false;
      if (typeof options?.out === "string") {
        this.pipeline = this.pipeline.concat({ $out: options.out });
        this.hasWriteStage = true;
      } else if (pipeline2.length > 0) {
        const finalStage = pipeline2[pipeline2.length - 1];
        if (finalStage.$out || finalStage.$merge) {
          this.hasWriteStage = true;
        }
      }
      if (this.hasWriteStage) {
        this.trySecondaryWrite = true;
      } else {
        delete this.options.writeConcern;
      }
      if (this.explain && this.writeConcern) {
        throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
      }
      if (options?.cursor != null && typeof options.cursor !== "object") {
        throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
      }
    }
    get commandName() {
      return "aggregate";
    }
    get canRetryRead() {
      return !this.hasWriteStage;
    }
    addToPipeline(stage) {
      this.pipeline.push(stage);
    }
    async execute(server, session, timeoutContext) {
      const options = this.options;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const command = { aggregate: this.target, pipeline: this.pipeline };
      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = undefined;
      }
      if (this.hasWriteStage && this.writeConcern) {
        write_concern_1.WriteConcern.apply(command, this.writeConcern);
      }
      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        command.allowDiskUse = options.allowDiskUse;
      }
      if (options.hint) {
        command.hint = options.hint;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      command.cursor = options.cursor || {};
      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }
      return await super.executeCommand(server, session, command, timeoutContext, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
    }
  }
  exports.AggregateOperation = AggregateOperation;
  (0, operation_1.defineAspects)(AggregateOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregationCursor = undefined;
  var error_1 = require_error();
  var explain_1 = require_explain();
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class AggregationCursor extends explain_1.ExplainableCursor {
    constructor(client, namespace, pipeline2 = [], options = {}) {
      super(client, namespace, options);
      this.pipeline = pipeline2;
      this.aggregateOptions = options;
      const lastStage = this.pipeline[this.pipeline.length - 1];
      if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (lastStage?.$merge != null || lastStage?.$out != null))
        throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this.aggregateOptions);
      delete clonedOptions.session;
      return new AggregationCursor(this.client, this.namespace, this.pipeline, {
        ...clonedOptions
      });
    }
    map(transform2) {
      return super.map(transform2);
    }
    async _initialize(session) {
      const options = {
        ...this.aggregateOptions,
        ...this.cursorOptions,
        session,
        signal: this.signal
      };
      if (options.explain) {
        try {
          (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
        } catch {
          throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in aggregateOptions");
        }
      }
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, options);
      const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, this.timeoutContext);
      return { server: aggregateOperation.server, session, response };
    }
    async explain(verbosity, options) {
      const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
      return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
        ...this.aggregateOptions,
        ...this.cursorOptions,
        ...timeout,
        explain: explain ?? true
      }))).shift(this.deserializationOptions);
    }
    addStage(stage) {
      this.throwIfInitialized();
      if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (stage.$out != null || stage.$merge != null)) {
        throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
      }
      this.pipeline.push(stage);
      return this;
    }
    group($group) {
      return this.addStage({ $group });
    }
    limit($limit) {
      return this.addStage({ $limit });
    }
    match($match) {
      return this.addStage({ $match });
    }
    out($out) {
      return this.addStage({ $out });
    }
    project($project) {
      return this.addStage({ $project });
    }
    lookup($lookup) {
      return this.addStage({ $lookup });
    }
    redact($redact) {
      return this.addStage({ $redact });
    }
    skip($skip) {
      return this.addStage({ $skip });
    }
    sort($sort) {
      return this.addStage({ $sort });
    }
    unwind($unwind) {
      return this.addStage({ $unwind });
    }
    geoNear($geoNear) {
      return this.addStage({ $geoNear });
    }
  }
  exports.AggregationCursor = AggregationCursor;
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class CountOperation extends command_1.CommandOperation {
    constructor(namespace, filter, options) {
      super({ s: { namespace } }, options);
      this.options = options;
      this.collectionName = namespace.collection;
      this.query = filter;
    }
    get commandName() {
      return "count";
    }
    async execute(server, session, timeoutContext) {
      const options = this.options;
      const cmd = {
        count: this.collectionName,
        query: this.query
      };
      if (typeof options.limit === "number") {
        cmd.limit = options.limit;
      }
      if (typeof options.skip === "number") {
        cmd.skip = options.skip;
      }
      if (options.hint != null) {
        cmd.hint = options.hint;
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      const result = await super.executeCommand(server, session, cmd, timeoutContext);
      return result ? result.n : 0;
    }
  }
  exports.CountOperation = CountOperation;
  (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/sort.js
var require_sort = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatSort = formatSort;
  var error_1 = require_error();
  function prepareDirection(direction = 1) {
    const value = `${direction}`.toLowerCase();
    if (isMeta(direction))
      return direction;
    switch (value) {
      case "ascending":
      case "asc":
      case "1":
        return 1;
      case "descending":
      case "desc":
      case "-1":
        return -1;
      default:
        throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
    }
  }
  function isMeta(t2) {
    return typeof t2 === "object" && t2 != null && "$meta" in t2 && typeof t2.$meta === "string";
  }
  function isPair(t2) {
    if (Array.isArray(t2) && t2.length === 2) {
      try {
        prepareDirection(t2[1]);
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }
  function isDeep(t2) {
    return Array.isArray(t2) && Array.isArray(t2[0]);
  }
  function isMap(t2) {
    return t2 instanceof Map && t2.size > 0;
  }
  function isReadonlyArray(value) {
    return Array.isArray(value);
  }
  function pairToMap(v) {
    return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
  }
  function deepToMap(t2) {
    const sortEntries = t2.map(([k, v]) => [`${k}`, prepareDirection(v)]);
    return new Map(sortEntries);
  }
  function stringsToMap(t2) {
    const sortEntries = t2.map((key) => [`${key}`, 1]);
    return new Map(sortEntries);
  }
  function objectToMap(t2) {
    const sortEntries = Object.entries(t2).map(([k, v]) => [
      `${k}`,
      prepareDirection(v)
    ]);
    return new Map(sortEntries);
  }
  function mapToMap(t2) {
    const sortEntries = Array.from(t2).map(([k, v]) => [
      `${k}`,
      prepareDirection(v)
    ]);
    return new Map(sortEntries);
  }
  function formatSort(sort, direction) {
    if (sort == null)
      return;
    if (typeof sort === "string")
      return new Map([[sort, prepareDirection(direction)]]);
    if (typeof sort !== "object") {
      throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
    }
    if (!isReadonlyArray(sort)) {
      if (isMap(sort))
        return mapToMap(sort);
      if (Object.keys(sort).length)
        return objectToMap(sort);
      return;
    }
    if (!sort.length)
      return;
    if (isDeep(sort))
      return deepToMap(sort);
    if (isPair(sort))
      return pairToMap(sort);
    return stringsToMap(sort);
  }
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOperation = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var explain_1 = require_explain();
  var read_concern_1 = require_read_concern();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class FindOperation extends command_1.CommandOperation {
    constructor(ns, filter = {}, options = {}) {
      super(undefined, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.ns = ns;
      if (typeof filter !== "object" || Array.isArray(filter)) {
        throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
      }
      this.filter = filter != null && filter._bsontype === "ObjectId" ? { _id: filter } : filter;
    }
    get commandName() {
      return "find";
    }
    async execute(server, session, timeoutContext) {
      this.server = server;
      const options = this.options;
      let findCommand = makeFindCommand(this.ns, this.filter, options);
      if (this.explain) {
        (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
        findCommand = (0, explain_1.decorateWithExplain)(findCommand, this.explain);
      }
      return await server.command(this.ns, findCommand, {
        ...this.options,
        ...this.bsonOptions,
        documentsReturnedIn: "firstBatch",
        session,
        timeoutContext
      }, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
    }
  }
  exports.FindOperation = FindOperation;
  function makeFindCommand(ns, filter, options) {
    const findCommand = {
      find: ns.collection,
      filter
    };
    if (options.sort) {
      findCommand.sort = (0, sort_1.formatSort)(options.sort);
    }
    if (options.projection) {
      let projection = options.projection;
      if (projection && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      findCommand.projection = projection;
    }
    if (options.hint) {
      findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
    }
    if (typeof options.skip === "number") {
      findCommand.skip = options.skip;
    }
    if (typeof options.limit === "number") {
      if (options.limit < 0) {
        findCommand.limit = -options.limit;
        findCommand.singleBatch = true;
      } else {
        findCommand.limit = options.limit;
      }
    }
    if (typeof options.batchSize === "number") {
      if (options.batchSize < 0) {
        if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
          findCommand.limit = -options.batchSize;
        }
        findCommand.singleBatch = true;
      } else {
        findCommand.batchSize = options.batchSize;
      }
    }
    if (typeof options.singleBatch === "boolean") {
      findCommand.singleBatch = options.singleBatch;
    }
    if (options.comment !== undefined) {
      findCommand.comment = options.comment;
    }
    if (typeof options.maxTimeMS === "number") {
      findCommand.maxTimeMS = options.maxTimeMS;
    }
    const readConcern = read_concern_1.ReadConcern.fromOptions(options);
    if (readConcern) {
      findCommand.readConcern = readConcern.toJSON();
    }
    if (options.max) {
      findCommand.max = options.max;
    }
    if (options.min) {
      findCommand.min = options.min;
    }
    if (typeof options.returnKey === "boolean") {
      findCommand.returnKey = options.returnKey;
    }
    if (typeof options.showRecordId === "boolean") {
      findCommand.showRecordId = options.showRecordId;
    }
    if (typeof options.tailable === "boolean") {
      findCommand.tailable = options.tailable;
    }
    if (typeof options.oplogReplay === "boolean") {
      findCommand.oplogReplay = options.oplogReplay;
    }
    if (typeof options.timeout === "boolean") {
      findCommand.noCursorTimeout = !options.timeout;
    } else if (typeof options.noCursorTimeout === "boolean") {
      findCommand.noCursorTimeout = options.noCursorTimeout;
    }
    if (typeof options.awaitData === "boolean") {
      findCommand.awaitData = options.awaitData;
    }
    if (typeof options.allowPartialResults === "boolean") {
      findCommand.allowPartialResults = options.allowPartialResults;
    }
    if (options.collation) {
      findCommand.collation = options.collation;
    }
    if (typeof options.allowDiskUse === "boolean") {
      findCommand.allowDiskUse = options.allowDiskUse;
    }
    if (options.let) {
      findCommand.let = options.let;
    }
    return findCommand;
  }
  (0, operation_1.defineAspects)(FindOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindCursor = exports.FLAGS = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var explain_1 = require_explain();
  var count_1 = require_count();
  var execute_operation_1 = require_execute_operation();
  var find_1 = require_find();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  exports.FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];

  class FindCursor extends explain_1.ExplainableCursor {
    constructor(client, namespace, filter = {}, options = {}) {
      super(client, namespace, options);
      this.numReturned = 0;
      this.cursorFilter = filter;
      this.findOptions = options;
      if (options.sort != null) {
        this.findOptions.sort = (0, sort_1.formatSort)(options.sort);
      }
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);
      delete clonedOptions.session;
      return new FindCursor(this.client, this.namespace, this.cursorFilter, {
        ...clonedOptions
      });
    }
    map(transform2) {
      return super.map(transform2);
    }
    async _initialize(session) {
      const options = {
        ...this.findOptions,
        ...this.cursorOptions,
        session,
        signal: this.signal
      };
      if (options.explain) {
        try {
          (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
        } catch {
          throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in findOptions");
        }
      }
      const findOperation = new find_1.FindOperation(this.namespace, this.cursorFilter, options);
      const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation, this.timeoutContext);
      this.numReturned = response.batchSize;
      return { server: findOperation.server, session, response };
    }
    async getMore(batchSize) {
      const numReturned = this.numReturned;
      if (numReturned) {
        const limit = this.findOptions.limit;
        batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
        if (batchSize <= 0) {
          try {
            await this.close();
          } catch (error) {
            (0, utils_1.squashError)(error);
          }
          return responses_1.CursorResponse.emptyGetMore;
        }
      }
      const response = await super.getMore(batchSize);
      this.numReturned = this.numReturned + response.batchSize;
      return response;
    }
    async count(options) {
      (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
      if (typeof options === "boolean") {
        throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
      }
      return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {
        ...this.findOptions,
        ...this.cursorOptions,
        ...options
      }));
    }
    async explain(verbosity, options) {
      const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
      return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {
        ...this.findOptions,
        ...this.cursorOptions,
        ...timeout,
        explain: explain ?? true
      }))).shift(this.deserializationOptions);
    }
    filter(filter) {
      this.throwIfInitialized();
      this.cursorFilter = filter;
      return this;
    }
    hint(hint) {
      this.throwIfInitialized();
      this.findOptions.hint = hint;
      return this;
    }
    min(min) {
      this.throwIfInitialized();
      this.findOptions.min = min;
      return this;
    }
    max(max2) {
      this.throwIfInitialized();
      this.findOptions.max = max2;
      return this;
    }
    returnKey(value) {
      this.throwIfInitialized();
      this.findOptions.returnKey = value;
      return this;
    }
    showRecordId(value) {
      this.throwIfInitialized();
      this.findOptions.showRecordId = value;
      return this;
    }
    addQueryModifier(name, value) {
      this.throwIfInitialized();
      if (name[0] !== "$") {
        throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
      }
      const field = name.substr(1);
      switch (field) {
        case "comment":
          this.findOptions.comment = value;
          break;
        case "explain":
          this.findOptions.explain = value;
          break;
        case "hint":
          this.findOptions.hint = value;
          break;
        case "max":
          this.findOptions.max = value;
          break;
        case "maxTimeMS":
          this.findOptions.maxTimeMS = value;
          break;
        case "min":
          this.findOptions.min = value;
          break;
        case "orderby":
          this.findOptions.sort = (0, sort_1.formatSort)(value);
          break;
        case "query":
          this.cursorFilter = value;
          break;
        case "returnKey":
          this.findOptions.returnKey = value;
          break;
        case "showDiskLoc":
          this.findOptions.showRecordId = value;
          break;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
      }
      return this;
    }
    comment(value) {
      this.throwIfInitialized();
      this.findOptions.comment = value;
      return this;
    }
    maxAwaitTimeMS(value) {
      this.throwIfInitialized();
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
      }
      this.findOptions.maxAwaitTimeMS = value;
      return this;
    }
    maxTimeMS(value) {
      this.throwIfInitialized();
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this.findOptions.maxTimeMS = value;
      return this;
    }
    project(value) {
      this.throwIfInitialized();
      this.findOptions.projection = value;
      return this;
    }
    sort(sort, direction) {
      this.throwIfInitialized();
      if (this.findOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
      }
      this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);
      return this;
    }
    allowDiskUse(allow = true) {
      this.throwIfInitialized();
      if (!this.findOptions.sort) {
        throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
      }
      if (!allow) {
        this.findOptions.allowDiskUse = false;
        return this;
      }
      this.findOptions.allowDiskUse = true;
      return this;
    }
    collation(value) {
      this.throwIfInitialized();
      this.findOptions.collation = value;
      return this;
    }
    limit(value) {
      this.throwIfInitialized();
      if (this.findOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
      }
      this.findOptions.limit = value;
      return this;
    }
    skip(value) {
      this.throwIfInitialized();
      if (this.findOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
      }
      this.findOptions.skip = value;
      return this;
    }
  }
  exports.FindCursor = FindCursor;
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListIndexesOperation = exports.DropIndexOperation = exports.CreateIndexesOperation = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();
  var VALID_INDEX_OPTIONS = new Set([
    "background",
    "unique",
    "name",
    "partialFilterExpression",
    "sparse",
    "hidden",
    "expireAfterSeconds",
    "storageEngine",
    "collation",
    "version",
    "weights",
    "default_language",
    "language_override",
    "textIndexVersion",
    "2dsphereIndexVersion",
    "bits",
    "min",
    "max",
    "bucketSize",
    "wildcardProjection"
  ]);
  function isIndexDirection(x) {
    return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
  }
  function isSingleIndexTuple(t2) {
    return Array.isArray(t2) && t2.length === 2 && isIndexDirection(t2[1]);
  }
  function constructIndexDescriptionMap(indexSpec) {
    const key = new Map;
    const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
    for (const spec of indexSpecs) {
      if (typeof spec === "string") {
        key.set(spec, 1);
      } else if (Array.isArray(spec)) {
        key.set(spec[0], spec[1] ?? 1);
      } else if (spec instanceof Map) {
        for (const [property, value] of spec) {
          key.set(property, value);
        }
      } else if ((0, utils_1.isObject)(spec)) {
        for (const [property, value] of Object.entries(spec)) {
          key.set(property, value);
        }
      }
    }
    return key;
  }
  function resolveIndexDescription(description) {
    const validProvidedOptions = Object.entries(description).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName));
    return Object.fromEntries(validProvidedOptions.map(([name, value]) => name === "version" ? ["v", value] : [name, value]));
  }

  class CreateIndexesOperation extends command_1.CommandOperation {
    constructor(parent, collectionName, indexes, options) {
      super(parent, options);
      this.options = options ?? {};
      this.collectionName = collectionName;
      this.indexes = indexes.map((userIndex) => {
        const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
        const name = userIndex.name ?? Array.from(key).flat().join("_");
        const validIndexOptions = resolveIndexDescription(userIndex);
        return {
          ...validIndexOptions,
          name,
          key
        };
      });
    }
    static fromIndexDescriptionArray(parent, collectionName, indexes, options) {
      return new CreateIndexesOperation(parent, collectionName, indexes, options);
    }
    static fromIndexSpecification(parent, collectionName, indexSpec, options = {}) {
      const key = constructIndexDescriptionMap(indexSpec);
      const description = { ...options, key };
      return new CreateIndexesOperation(parent, collectionName, [description], options);
    }
    get commandName() {
      return "createIndexes";
    }
    async execute(server, session, timeoutContext) {
      const options = this.options;
      const indexes = this.indexes;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cmd = { createIndexes: this.collectionName, indexes };
      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          throw new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4");
        }
        cmd.commitQuorum = options.commitQuorum;
      }
      this.options.collation = undefined;
      await super.executeCommand(server, session, cmd, timeoutContext);
      const indexNames = indexes.map((index) => index.name || "");
      return indexNames;
    }
  }
  exports.CreateIndexesOperation = CreateIndexesOperation;

  class DropIndexOperation extends command_1.CommandOperation {
    constructor(collection, indexName, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.indexName = indexName;
    }
    get commandName() {
      return "dropIndexes";
    }
    async execute(server, session, timeoutContext) {
      const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
      return await super.executeCommand(server, session, cmd, timeoutContext);
    }
  }
  exports.DropIndexOperation = DropIndexOperation;

  class ListIndexesOperation extends command_1.CommandOperation {
    constructor(collection, options) {
      super(collection, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.collectionNamespace = collection.s.namespace;
    }
    get commandName() {
      return "listIndexes";
    }
    async execute(server, session, timeoutContext) {
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
      const command = { listIndexes: this.collectionNamespace.collection, cursor };
      if (serverWireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return await super.executeCommand(server, session, command, timeoutContext, responses_1.CursorResponse);
    }
  }
  exports.ListIndexesOperation = ListIndexesOperation;
  (0, operation_1.defineAspects)(ListIndexesOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
  (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListIndexesCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
    constructor(collection, options) {
      super(collection.client, collection.s.namespace, options);
      this.parent = collection;
      this.options = options;
    }
    clone() {
      return new ListIndexesCursor(this.parent, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const operation = new indexes_1.ListIndexesOperation(this.parent, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
      return { server: operation.server, session, response };
    }
  }
  exports.ListIndexesCursor = ListIndexesCursor;
});

// node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js
var require_list_search_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListSearchIndexesCursor = undefined;
  var aggregation_cursor_1 = require_aggregation_cursor();

  class ListSearchIndexesCursor extends aggregation_cursor_1.AggregationCursor {
    constructor({ fullNamespace: ns, client }, name, options = {}) {
      const pipeline2 = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
      super(client, ns, pipeline2, options);
    }
  }
  exports.ListSearchIndexesCursor = ListSearchIndexesCursor;
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkWriteOperation = undefined;
  var operation_1 = require_operation();

  class BulkWriteOperation extends operation_1.AbstractOperation {
    constructor(collection, operations, options) {
      super(options);
      this.options = options;
      this.collection = collection;
      this.operations = operations;
    }
    get commandName() {
      return "bulkWrite";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const operations = this.operations;
      const options = {
        ...this.options,
        ...this.bsonOptions,
        readPreference: this.readPreference,
        timeoutContext
      };
      const bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options);
      for (let i = 0;i < operations.length; i++) {
        bulk.raw(operations[i]);
      }
      return await bulk.execute({ ...options, session });
    }
  }
  exports.BulkWriteOperation = BulkWriteOperation;
  (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DistinctOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DistinctOperation extends command_1.CommandOperation {
    constructor(collection, key, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.key = key;
      this.query = query;
    }
    get commandName() {
      return "distinct";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const key = this.key;
      const query = this.query;
      const options = this.options;
      const cmd = {
        distinct: coll.collectionName,
        key,
        query
      };
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.comment !== "undefined") {
        cmd.comment = options.comment;
      }
      if (options.hint != null) {
        cmd.hint = options.hint;
      }
      (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
      (0, utils_1.decorateWithCollation)(cmd, coll, options);
      const result = await super.executeCommand(server, session, cmd, timeoutContext);
      return this.explain ? result : result.values;
    }
  }
  exports.DistinctOperation = DistinctOperation;
  (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropDatabaseOperation = exports.DropCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DropCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.db = db;
      this.options = options;
      this.name = name;
    }
    get commandName() {
      return "drop";
    }
    async execute(server, session, timeoutContext) {
      const db = this.db;
      const options = this.options;
      const name = this.name;
      const encryptedFieldsMap = db.client.s.options.autoEncryption?.encryptedFieldsMap;
      let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
      if (!encryptedFields && encryptedFieldsMap) {
        const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
      }
      if (encryptedFields) {
        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
        for (const collectionName of [escCollection, ecocCollection]) {
          const dropOp = new DropCollectionOperation(db, collectionName);
          try {
            await dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
          } catch (err2) {
            if (!(err2 instanceof error_1.MongoServerError) || err2.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
              throw err2;
            }
          }
        }
      }
      return await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
    }
    async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
      await super.executeCommand(server, session, { drop: this.name }, timeoutContext);
      return true;
    }
  }
  exports.DropCollectionOperation = DropCollectionOperation;

  class DropDatabaseOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    get commandName() {
      return "dropDatabase";
    }
    async execute(server, session, timeoutContext) {
      await super.executeCommand(server, session, { dropDatabase: 1 }, timeoutContext);
      return true;
    }
  }
  exports.DropDatabaseOperation = DropDatabaseOperation;
  (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EstimatedDocumentCountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class EstimatedDocumentCountOperation extends command_1.CommandOperation {
    constructor(collection, options = {}) {
      super(collection, options);
      this.options = options;
      this.collectionName = collection.collectionName;
    }
    get commandName() {
      return "count";
    }
    async execute(server, session, timeoutContext) {
      const cmd = { count: this.collectionName };
      if (typeof this.options.maxTimeMS === "number") {
        cmd.maxTimeMS = this.options.maxTimeMS;
      }
      if (this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      const response = await super.executeCommand(server, session, cmd, timeoutContext);
      return response?.n || 0;
    }
  }
  exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
  (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.FindAndModifyOperation = exports.ReturnDocument = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.ReturnDocument = Object.freeze({
    BEFORE: "before",
    AFTER: "after"
  });
  function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
    cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;
    cmdBase.upsert = options.upsert === true;
    if (options.bypassDocumentValidation === true) {
      cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    return cmdBase;
  }

  class FindAndModifyOperation extends command_1.CommandOperation {
    constructor(collection, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.cmdBase = {
        remove: false,
        new: false,
        upsert: false
      };
      options.includeResultMetadata ??= false;
      const sort = (0, sort_1.formatSort)(options.sort);
      if (sort) {
        this.cmdBase.sort = sort;
      }
      if (options.projection) {
        this.cmdBase.fields = options.projection;
      }
      if (options.maxTimeMS) {
        this.cmdBase.maxTimeMS = options.maxTimeMS;
      }
      if (options.writeConcern) {
        this.cmdBase.writeConcern = options.writeConcern;
      }
      if (options.let) {
        this.cmdBase.let = options.let;
      }
      if (options.comment !== undefined) {
        this.cmdBase.comment = options.comment;
      }
      this.readPreference = read_preference_1.ReadPreference.primary;
      this.collection = collection;
      this.query = query;
    }
    get commandName() {
      return "findAndModify";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const query = this.query;
      const options = { ...this.options, ...this.bsonOptions };
      const cmd = {
        findAndModify: coll.collectionName,
        query,
        ...this.cmdBase
      };
      (0, utils_1.decorateWithCollation)(cmd, coll, options);
      if (options.hint) {
        const unacknowledgedWrite = this.writeConcern?.w === 0;
        if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
          throw new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands");
        }
        cmd.hint = options.hint;
      }
      const result = await super.executeCommand(server, session, cmd, timeoutContext);
      return options.includeResultMetadata ? result : result.value ?? null;
    }
  }
  exports.FindAndModifyOperation = FindAndModifyOperation;

  class FindOneAndDeleteOperation extends FindAndModifyOperation {
    constructor(collection, filter, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      super(collection, filter, options);
      this.cmdBase.remove = true;
    }
  }
  exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;

  class FindOneAndReplaceOperation extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (replacement == null || typeof replacement !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
      }
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = replacement;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
    }
  }
  exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;

  class FindOneAndUpdateOperation extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
      }
      if (!(0, utils_1.hasAtomicOperators)(update, options)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = update;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
      if (options.arrayFilters) {
        this.cmdBase.arrayFilters = options.arrayFilters;
      }
    }
  }
  exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
  (0, operation_1.defineAspects)(FindAndModifyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE
  ]);
});

// node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var bulk_write_1 = require_bulk_write();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class InsertOperation extends command_1.CommandOperation {
    constructor(ns, documents, options) {
      super(undefined, options);
      this.options = { ...options, checkKeys: options.checkKeys ?? false };
      this.ns = ns;
      this.documents = documents;
    }
    get commandName() {
      return "insert";
    }
    async execute(server, session, timeoutContext) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        insert: this.ns.collection,
        documents: this.documents,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      return await super.executeCommand(server, session, command, timeoutContext);
    }
  }
  exports.InsertOperation = InsertOperation;

  class InsertOneOperation extends InsertOperation {
    constructor(collection, doc, options) {
      super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options), options);
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors) {
        throw new error_1.MongoServerError(res.writeErrors[0]);
      }
      return {
        acknowledged: this.writeConcern?.w !== 0,
        insertedId: this.documents[0]._id
      };
    }
  }
  exports.InsertOneOperation = InsertOneOperation;

  class InsertManyOperation extends operation_1.AbstractOperation {
    constructor(collection, docs, options) {
      super(options);
      if (!Array.isArray(docs)) {
        throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
      }
      this.options = options;
      this.collection = collection;
      this.docs = docs;
    }
    get commandName() {
      return "insert";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map((document2) => ({
        insertOne: { document: document2 }
      })), options);
      try {
        const res = await bulkWriteOperation.execute(server, session, timeoutContext);
        return {
          acknowledged: writeConcern?.w !== 0,
          insertedCount: res.insertedCount,
          insertedIds: res.insertedIds
        };
      } catch (err2) {
        if (err2 && err2.message === "Operation must be an object with an operation key") {
          throw new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
        }
        throw err2;
      }
    }
  }
  exports.InsertManyOperation = InsertManyOperation;
  (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsCappedOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class IsCappedOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session) {
      const coll = this.collection;
      const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
      if (collection == null || collection.options == null) {
        throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
      }
      return !!collection.options?.capped;
    }
  }
  exports.IsCappedOperation = IsCappedOperation;
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionsOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class OptionsOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session) {
      const coll = this.collection;
      const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
      if (collection == null || collection.options == null) {
        throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
      }
      return collection.options;
    }
  }
  exports.OptionsOperation = OptionsOperation;
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RenameOperation = undefined;
  var collection_1 = require_collection();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RenameOperation extends command_1.CommandOperation {
    constructor(collection, newName, options) {
      super(collection, options);
      this.collection = collection;
      this.newName = newName;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    get commandName() {
      return "renameCollection";
    }
    async execute(server, session, timeoutContext) {
      const renameCollection = this.collection.namespace;
      const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
      const dropTarget = typeof this.options.dropTarget === "boolean" ? this.options.dropTarget : false;
      const command = {
        renameCollection,
        to: toCollection,
        dropTarget
      };
      await super.executeCommand(server, session, command, timeoutContext);
      return new collection_1.Collection(this.collection.s.db, this.newName, this.collection.s.options);
    }
  }
  exports.RenameOperation = RenameOperation;
  (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/search_indexes/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateSearchIndexesOperation = undefined;
  var operation_1 = require_operation();

  class CreateSearchIndexesOperation extends operation_1.AbstractOperation {
    constructor(collection, descriptions) {
      super();
      this.collection = collection;
      this.descriptions = descriptions;
    }
    get commandName() {
      return "createSearchIndexes";
    }
    async execute(server, session, timeoutContext) {
      const namespace = this.collection.fullNamespace;
      const command = {
        createSearchIndexes: namespace.collection,
        indexes: this.descriptions
      };
      const res = await server.command(namespace, command, {
        session,
        timeoutContext
      });
      const indexesCreated = res?.indexesCreated ?? [];
      return indexesCreated.map(({ name }) => name);
    }
  }
  exports.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/drop.js
var require_drop2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropSearchIndexOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class DropSearchIndexOperation extends operation_1.AbstractOperation {
    constructor(collection, name) {
      super();
      this.collection = collection;
      this.name = name;
    }
    get commandName() {
      return "dropSearchIndex";
    }
    async execute(server, session, timeoutContext) {
      const namespace = this.collection.fullNamespace;
      const command = {
        dropSearchIndex: namespace.collection
      };
      if (typeof this.name === "string") {
        command.name = this.name;
      }
      try {
        await server.command(namespace, command, { session, timeoutContext });
      } catch (error) {
        const isNamespaceNotFoundError = error instanceof error_1.MongoServerError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound;
        if (!isNamespaceNotFoundError) {
          throw error;
        }
      }
    }
  }
  exports.DropSearchIndexOperation = DropSearchIndexOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/update.js
var require_update = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateSearchIndexOperation = undefined;
  var operation_1 = require_operation();

  class UpdateSearchIndexOperation extends operation_1.AbstractOperation {
    constructor(collection, name, definition) {
      super();
      this.collection = collection;
      this.name = name;
      this.definition = definition;
    }
    get commandName() {
      return "updateSearchIndex";
    }
    async execute(server, session, timeoutContext) {
      const namespace = this.collection.fullNamespace;
      const command = {
        updateSearchIndex: namespace.collection,
        name: this.name,
        definition: this.definition
      };
      await server.command(namespace, command, { session, timeoutContext });
      return;
    }
  }
  exports.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
});

// node_modules/mongodb/lib/operations/update.js
var require_update2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = undefined;
  exports.makeUpdateStatement = makeUpdateStatement;
  var error_1 = require_error();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class UpdateOperation extends command_1.CommandOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get commandName() {
      return "update";
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.multi == null || op.multi === false);
    }
    async execute(server, session, timeoutContext) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        update: this.ns.collection,
        updates: this.statements,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o) => o.hint)) {
          throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
        }
      }
      const res = await super.executeCommand(server, session, command, timeoutContext);
      return res;
    }
  }
  exports.UpdateOperation = UpdateOperation;

  class UpdateOneOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: false })], options);
      if (!(0, utils_1.hasAtomicOperators)(update, options)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.UpdateOneOperation = UpdateOneOperation;

  class UpdateManyOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: true })], options);
      if (!(0, utils_1.hasAtomicOperators)(update, options)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.UpdateManyOperation = UpdateManyOperation;

  class ReplaceOneOperation extends UpdateOperation {
    constructor(collection, filter, replacement, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options, multi: false })], options);
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.ReplaceOneOperation = ReplaceOneOperation;
  function makeUpdateStatement(filter, update, options) {
    if (filter == null || typeof filter !== "object") {
      throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
    }
    if (update == null || typeof update !== "object") {
      throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
    }
    const op = { q: filter, u: update };
    if (typeof options.upsert === "boolean") {
      op.upsert = options.upsert;
    }
    if (options.multi) {
      op.multi = options.multi;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    if (options.arrayFilters) {
      op.arrayFilters = options.arrayFilters;
    }
    if (options.collation) {
      op.collation = options.collation;
    }
    if (!options.multi && options.sort != null) {
      op.sort = (0, sort_1.formatSort)(options.sort);
    }
    return op;
  }
  (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
  (0, operation_1.defineAspects)(UpdateOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(UpdateManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(ReplaceOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/collection.js
var require_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Collection = undefined;
  var bson_1 = require_bson2();
  var ordered_1 = require_ordered();
  var unordered_1 = require_unordered();
  var change_stream_1 = require_change_stream();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var find_cursor_1 = require_find_cursor();
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  var list_search_indexes_cursor_1 = require_list_search_indexes_cursor();
  var error_1 = require_error();
  var bulk_write_1 = require_bulk_write();
  var count_1 = require_count();
  var delete_1 = require_delete();
  var distinct_1 = require_distinct();
  var drop_1 = require_drop();
  var estimated_document_count_1 = require_estimated_document_count();
  var execute_operation_1 = require_execute_operation();
  var find_and_modify_1 = require_find_and_modify();
  var indexes_1 = require_indexes();
  var insert_1 = require_insert();
  var is_capped_1 = require_is_capped();
  var options_operation_1 = require_options_operation();
  var rename_1 = require_rename();
  var create_1 = require_create();
  var drop_2 = require_drop2();
  var update_1 = require_update();
  var update_2 = require_update2();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();

  class Collection {
    constructor(db, name, options) {
      this.s = {
        db,
        options,
        namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
        pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      };
      this.client = db.client;
    }
    get dbName() {
      return this.s.namespace.db;
    }
    get collectionName() {
      return this.s.namespace.collection;
    }
    get namespace() {
      return this.fullNamespace.toString();
    }
    get fullNamespace() {
      return this.s.namespace;
    }
    get readConcern() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }
      return this.s.writeConcern;
    }
    get hint() {
      return this.s.collectionHint;
    }
    set hint(v) {
      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
    }
    get timeoutMS() {
      return this.s.options.timeoutMS;
    }
    async insertOne(doc, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));
    }
    async insertMany(docs, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async bulkWrite(operations, options) {
      if (!Array.isArray(operations)) {
        throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
      }
      return await (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async updateOne(filter, update, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async replaceOne(filter, replacement, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async updateMany(filter, update, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteOne(filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteMany(filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async rename(newName, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, (0, utils_1.resolveOptions)(undefined, {
        ...options,
        readPreference: read_preference_1.ReadPreference.PRIMARY
      })));
    }
    async drop(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));
    }
    async findOne(filter = {}, options = {}) {
      const cursor = this.find(filter, options).limit(-1).batchSize(1);
      const res = await cursor.next();
      await cursor.close();
      return res;
    }
    find(filter = {}, options = {}) {
      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async options(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async isCapped(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(indexSpec, options) {
      const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));
      return indexes[0];
    }
    async createIndexes(indexSpecs, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexDescriptionArray(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options, maxTimeMS: undefined })));
    }
    async dropIndex(indexName, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
        ...(0, utils_1.resolveOptions)(this, options),
        readPreference: read_preference_1.ReadPreference.primary
      }));
    }
    async dropIndexes(options) {
      try {
        await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, "*", (0, utils_1.resolveOptions)(this, options)));
        return true;
      } catch (error) {
        if (error instanceof error_1.MongoOperationTimeoutError)
          throw error;
        return false;
      }
    }
    listIndexes(options) {
      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
    }
    async indexExists(indexes, options) {
      const indexNames = Array.isArray(indexes) ? indexes : [indexes];
      const allIndexes = new Set(await this.listIndexes(options).map(({ name }) => name).toArray());
      return indexNames.every((name) => allIndexes.has(name));
    }
    async indexInformation(options) {
      return await this.indexes({
        ...options,
        full: options?.full ?? false
      });
    }
    async estimatedDocumentCount(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async countDocuments(filter = {}, options = {}) {
      const pipeline2 = [];
      pipeline2.push({ $match: filter });
      if (typeof options.skip === "number") {
        pipeline2.push({ $skip: options.skip });
      }
      if (typeof options.limit === "number") {
        pipeline2.push({ $limit: options.limit });
      }
      pipeline2.push({ $group: { _id: 1, n: { $sum: 1 } } });
      const cursor = this.aggregate(pipeline2, options);
      const doc = await cursor.next();
      await cursor.close();
      return doc?.n ?? 0;
    }
    async distinct(key, filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexes(options) {
      const indexes = await this.listIndexes(options).toArray();
      const full = options?.full ?? true;
      if (full) {
        return indexes;
      }
      const object = Object.fromEntries(indexes.map(({ name, key }) => [name, Object.entries(key)]));
      return object;
    }
    async findOneAndDelete(filter, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndReplace(filter, replacement, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndUpdate(filter, update, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    aggregate(pipeline2 = [], options) {
      if (!Array.isArray(pipeline2)) {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
      }
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline2, (0, utils_1.resolveOptions)(this, options));
    }
    watch(pipeline2 = [], options = {}) {
      if (!Array.isArray(pipeline2)) {
        options = pipeline2;
        pipeline2 = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline2, (0, utils_1.resolveOptions)(this, options));
    }
    initializeUnorderedBulkOp(options) {
      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    initializeOrderedBulkOp(options) {
      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    async count(filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    listSearchIndexes(indexNameOrOptions, options) {
      options = typeof indexNameOrOptions === "object" ? indexNameOrOptions : options == null ? {} : options;
      const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === "object" ? null : indexNameOrOptions;
      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
    }
    async createSearchIndex(description) {
      const [index] = await this.createSearchIndexes([description]);
      return index;
    }
    async createSearchIndexes(descriptions) {
      return await (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
    }
    async dropSearchIndex(name) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
    }
    async updateSearchIndex(name, definition) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
    }
  }
  exports.Collection = Collection;
});

// node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStreamCursor = undefined;
  var change_stream_1 = require_change_stream();
  var constants_1 = require_constants();
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, pipeline2 = [], options = {}) {
      super(client, namespace, { ...options, tailable: true, awaitData: true });
      this.pipeline = pipeline2;
      this.changeStreamCursorOptions = options;
      this._resumeToken = null;
      this.startAtOperationTime = options.startAtOperationTime ?? null;
      if (options.startAfter) {
        this.resumeToken = options.startAfter;
      } else if (options.resumeAfter) {
        this.resumeToken = options.resumeAfter;
      }
    }
    set resumeToken(token) {
      this._resumeToken = token;
      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
    }
    get resumeToken() {
      return this._resumeToken;
    }
    get resumeOptions() {
      const options = {
        ...this.changeStreamCursorOptions
      };
      for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
        delete options[key];
      }
      if (this.resumeToken != null) {
        if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
          options.startAfter = this.resumeToken;
        } else {
          options.resumeAfter = this.resumeToken;
        }
      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
        options.startAtOperationTime = this.startAtOperationTime;
      }
      return options;
    }
    cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
        this.resumeToken = this.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }
      this.hasReceived = true;
    }
    _processBatch(response) {
      const { postBatchResumeToken } = response;
      if (postBatchResumeToken) {
        this.postBatchResumeToken = postBatchResumeToken;
        if (response.batchSize === 0) {
          this.resumeToken = postBatchResumeToken;
        }
      }
    }
    clone() {
      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
        ...this.cursorOptions,
        ...this.changeStreamCursorOptions,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, this.timeoutContext);
      const server = aggregateOperation.server;
      this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
      if (this.startAtOperationTime == null && this.changeStreamCursorOptions.resumeAfter == null && this.changeStreamCursorOptions.startAfter == null && this.maxWireVersion >= 7) {
        this.startAtOperationTime = response.operationTime;
      }
      this._processBatch(response);
      this.emit(constants_1.INIT, response);
      this.emit(constants_1.RESPONSE);
      return { server, session, response };
    }
    async getMore(batchSize) {
      const response = await super.getMore(batchSize);
      this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
      this._processBatch(response);
      this.emit(change_stream_1.ChangeStream.MORE, response);
      this.emit(change_stream_1.ChangeStream.RESPONSE);
      return response;
    }
  }
  exports.ChangeStreamCursor = ChangeStreamCursor;
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListDatabasesOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListDatabasesOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options ?? {};
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    get commandName() {
      return "listDatabases";
    }
    async execute(server, session, timeoutContext) {
      const cmd = { listDatabases: 1 };
      if (typeof this.options.nameOnly === "boolean") {
        cmd.nameOnly = this.options.nameOnly;
      }
      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }
      if (typeof this.options.authorizedDatabases === "boolean") {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      }
      if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      return await super.executeCommand(server, session, cmd, timeoutContext);
    }
  }
  exports.ListDatabasesOperation = ListDatabasesOperation;
  (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoveUserOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RemoveUserOperation extends command_1.CommandOperation {
    constructor(db, username, options) {
      super(db, options);
      this.options = options;
      this.username = username;
    }
    get commandName() {
      return "dropUser";
    }
    async execute(server, session, timeoutContext) {
      await super.executeCommand(server, session, { dropUser: this.username }, timeoutContext);
      return true;
    }
  }
  exports.RemoveUserOperation = RemoveUserOperation;
  (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunAdminCommandOperation = exports.RunCommandOperation = undefined;
  var utils_1 = require_utils();
  var operation_1 = require_operation();

  class RunCommandOperation extends operation_1.AbstractOperation {
    constructor(parent, command, options) {
      super(options);
      this.command = command;
      this.options = options;
      this.ns = parent.s.namespace.withCollection("$cmd");
    }
    get commandName() {
      return "runCommand";
    }
    async execute(server, session, timeoutContext) {
      this.server = server;
      const res = await server.command(this.ns, this.command, {
        ...this.options,
        readPreference: this.readPreference,
        session,
        timeoutContext
      }, this.options.responseType);
      return res;
    }
  }
  exports.RunCommandOperation = RunCommandOperation;

  class RunAdminCommandOperation extends operation_1.AbstractOperation {
    constructor(command, options) {
      super(options);
      this.command = command;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    get commandName() {
      return "runCommand";
    }
    async execute(server, session, timeoutContext) {
      this.server = server;
      const res = await server.command(this.ns, this.command, {
        ...this.options,
        readPreference: this.readPreference,
        session,
        timeoutContext
      });
      return res;
    }
  }
  exports.RunAdminCommandOperation = RunAdminCommandOperation;
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidateCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ValidateCollectionOperation extends command_1.CommandOperation {
    constructor(admin, collectionName, options) {
      const command = { validate: collectionName };
      const keys = Object.keys(options);
      for (let i = 0;i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
          command[keys[i]] = options[keys[i]];
        }
      }
      super(admin.s.db, options);
      this.options = options;
      this.command = command;
      this.collectionName = collectionName;
    }
    get commandName() {
      return "validate";
    }
    async execute(server, session, timeoutContext) {
      const collectionName = this.collectionName;
      const doc = await super.executeCommand(server, session, this.command, timeoutContext);
      if (doc.result != null && typeof doc.result !== "string")
        throw new error_1.MongoUnexpectedServerResponseError("Error with validation data");
      if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
        throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
      if (doc.valid != null && !doc.valid)
        throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
      return doc;
    }
  }
  exports.ValidateCollectionOperation = ValidateCollectionOperation;
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Admin = undefined;
  var bson_1 = require_bson2();
  var execute_operation_1 = require_execute_operation();
  var list_databases_1 = require_list_databases();
  var remove_user_1 = require_remove_user();
  var run_command_1 = require_run_command();
  var validate_collection_1 = require_validate_collection();

  class Admin {
    constructor(db) {
      this.s = { db };
    }
    async command(command, options) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunAdminCommandOperation(command, {
        ...(0, bson_1.resolveBSONOptions)(options),
        session: options?.session,
        readPreference: options?.readPreference,
        timeoutMS: options?.timeoutMS ?? this.s.db.timeoutMS
      }));
    }
    async buildInfo(options) {
      return await this.command({ buildinfo: 1 }, options);
    }
    async serverInfo(options) {
      return await this.command({ buildinfo: 1 }, options);
    }
    async serverStatus(options) {
      return await this.command({ serverStatus: 1 }, options);
    }
    async ping(options) {
      return await this.command({ ping: 1 }, options);
    }
    async removeUser(username, options) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: "admin", ...options }));
    }
    async validateCollection(collectionName, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options));
    }
    async listDatabases(options) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, { timeoutMS: this.s.db.timeoutMS, ...options }));
    }
    async replSetGetStatus(options) {
      return await this.command({ replSetGetStatus: 1 }, options);
    }
  }
  exports.Admin = Admin;
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsOperation = undefined;
  var responses_1 = require_responses();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListCollectionsOperation extends command_1.CommandOperation {
    constructor(db, filter, options) {
      super(db, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.db = db;
      this.filter = filter;
      this.nameOnly = !!this.options.nameOnly;
      this.authorizedCollections = !!this.options.authorizedCollections;
      if (typeof this.options.batchSize === "number") {
        this.batchSize = this.options.batchSize;
      }
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session, timeoutContext) {
      return await super.executeCommand(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), timeoutContext, responses_1.CursorResponse);
    }
    generateCommand(wireVersion) {
      const command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? { batchSize: this.batchSize } : {},
        nameOnly: this.nameOnly,
        authorizedCollections: this.authorizedCollections
      };
      if (wireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return command;
    }
  }
  exports.ListCollectionsOperation = ListCollectionsOperation;
  (0, operation_1.defineAspects)(ListCollectionsOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var list_collections_1 = require_list_collections();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
    constructor(db, filter, options) {
      super(db.client, db.s.namespace, options);
      this.parent = db;
      this.filter = filter;
      this.options = options;
    }
    clone() {
      return new ListCollectionsCursor(this.parent, this.filter, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
        ...this.cursorOptions,
        ...this.options,
        session,
        signal: this.signal
      });
      const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
      return { server: operation.server, session, response };
    }
  }
  exports.ListCollectionsCursor = ListCollectionsCursor;
});

// node_modules/mongodb/lib/cursor/run_command_cursor.js
var require_run_command_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunCommandCursor = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var run_command_1 = require_run_command();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class RunCommandCursor extends abstract_cursor_1.AbstractCursor {
    setComment(comment) {
      this.getMoreOptions.comment = comment;
      return this;
    }
    setMaxTimeMS(maxTimeMS) {
      this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
      return this;
    }
    setBatchSize(batchSize) {
      this.getMoreOptions.batchSize = batchSize;
      return this;
    }
    clone() {
      throw new error_1.MongoAPIError("Clone not supported, create a new cursor with db.runCursorCommand");
    }
    withReadConcern(_) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support readConcern it must be attached to the command being run");
    }
    addCursorFlag(_, __) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support cursor flags, they must be attached to the command being run");
    }
    maxTimeMS(_) {
      throw new error_1.MongoAPIError("maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()");
    }
    batchSize(_) {
      throw new error_1.MongoAPIError("batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()");
    }
    constructor(db, command, options = {}) {
      super(db.client, (0, utils_1.ns)(db.namespace), options);
      this.getMoreOptions = {};
      this.db = db;
      this.command = Object.freeze({ ...command });
    }
    async _initialize(session) {
      const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
        ...this.cursorOptions,
        session,
        readPreference: this.cursorOptions.readPreference,
        responseType: responses_1.CursorResponse
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, operation, this.timeoutContext);
      return {
        server: operation.server,
        session,
        response
      };
    }
    async getMore(_batchSize) {
      if (!this.session) {
        throw new error_1.MongoRuntimeError("Unexpected null session. A cursor creating command should have set this");
      }
      const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
        ...this.cursorOptions,
        session: this.session,
        ...this.getMoreOptions
      });
      return await (0, execute_operation_1.executeOperation)(this.client, getMoreOperation, this.timeoutContext);
    }
  }
  exports.RunCommandCursor = RunCommandCursor;
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CollectionsOperation = undefined;
  var collection_1 = require_collection();
  var operation_1 = require_operation();

  class CollectionsOperation extends operation_1.AbstractOperation {
    constructor(db, options) {
      super(options);
      this.options = options;
      this.db = db;
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session) {
      const documents = await this.db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray();
      const collections = [];
      for (const { name } of documents) {
        if (!name.includes("$")) {
          collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
        }
      }
      return collections;
    }
  }
  exports.CollectionsOperation = CollectionsOperation;
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateCollectionOperation = undefined;
  var constants_1 = require_constants2();
  var collection_1 = require_collection();
  var error_1 = require_error();
  var command_1 = require_command();
  var indexes_1 = require_indexes();
  var operation_1 = require_operation();
  var ILLEGAL_COMMAND_FIELDS = new Set([
    "w",
    "wtimeout",
    "timeoutMS",
    "j",
    "fsync",
    "autoIndexId",
    "pkFactory",
    "raw",
    "readPreference",
    "session",
    "readConcern",
    "writeConcern",
    "raw",
    "fieldsAsRaw",
    "useBigInt64",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bsonRegExp",
    "serializeFunctions",
    "ignoreUndefined",
    "enableUtf8Validation"
  ]);
  var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";

  class CreateCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.options = options;
      this.db = db;
      this.name = name;
    }
    get commandName() {
      return "create";
    }
    async execute(server, session, timeoutContext) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const encryptedFields = options.encryptedFields ?? db.client.s.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
      if (encryptedFields) {
        if (!server.loadBalanced && server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
          throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
        }
        const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
        const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
        for (const collectionName of [escCollection, ecocCollection]) {
          const createOp = new CreateCollectionOperation(db, collectionName, {
            clusteredIndex: {
              key: { _id: 1 },
              unique: true
            }
          });
          await createOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
        }
        if (!options.encryptedFields) {
          this.options = { ...this.options, encryptedFields };
        }
      }
      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
      if (encryptedFields) {
        const createIndexOp = indexes_1.CreateIndexesOperation.fromIndexSpecification(db, name, { __safeContent__: 1 }, {});
        await createIndexOp.execute(server, session, timeoutContext);
      }
      return coll;
    }
    async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const cmd = { create: name };
      for (const n2 in options) {
        if (options[n2] != null && typeof options[n2] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n2)) {
          cmd[n2] = options[n2];
        }
      }
      await super.executeCommand(server, session, cmd, timeoutContext);
      return new collection_1.Collection(db, name, options);
    }
  }
  exports.CreateCollectionOperation = CreateCollectionOperation;
  (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProfilingLevelOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ProfilingLevelOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    get commandName() {
      return "profile";
    }
    async execute(server, session, timeoutContext) {
      const doc = await super.executeCommand(server, session, { profile: -1 }, timeoutContext);
      if (doc.ok === 1) {
        const was = doc.was;
        if (was === 0)
          return "off";
        if (was === 1)
          return "slow_only";
        if (was === 2)
          return "all";
        throw new error_1.MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);
      } else {
        throw new error_1.MongoUnexpectedServerResponseError("Error with profile command");
      }
    }
  }
  exports.ProfilingLevelOperation = ProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetProfilingLevelOperation = exports.ProfilingLevel = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var levelValues = new Set(["off", "slow_only", "all"]);
  exports.ProfilingLevel = Object.freeze({
    off: "off",
    slowOnly: "slow_only",
    all: "all"
  });

  class SetProfilingLevelOperation extends command_1.CommandOperation {
    constructor(db, level, options) {
      super(db, options);
      this.options = options;
      switch (level) {
        case exports.ProfilingLevel.off:
          this.profile = 0;
          break;
        case exports.ProfilingLevel.slowOnly:
          this.profile = 1;
          break;
        case exports.ProfilingLevel.all:
          this.profile = 2;
          break;
        default:
          this.profile = 0;
          break;
      }
      this.level = level;
    }
    get commandName() {
      return "profile";
    }
    async execute(server, session, timeoutContext) {
      const level = this.level;
      if (!levelValues.has(level)) {
        throw new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports.ProfilingLevel)}"`);
      }
      await super.executeCommand(server, session, { profile: this.profile }, timeoutContext);
      return level;
    }
  }
  exports.SetProfilingLevelOperation = SetProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DbStatsOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DbStatsOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    get commandName() {
      return "dbStats";
    }
    async execute(server, session, timeoutContext) {
      const command = { dbStats: true };
      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }
      return await super.executeCommand(server, session, command, timeoutContext);
    }
  }
  exports.DbStatsOperation = DbStatsOperation;
  (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Db = undefined;
  var admin_1 = require_admin();
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var collection_1 = require_collection();
  var CONSTANTS = require_constants();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var list_collections_cursor_1 = require_list_collections_cursor();
  var run_command_cursor_1 = require_run_command_cursor();
  var error_1 = require_error();
  var collections_1 = require_collections();
  var create_collection_1 = require_create_collection();
  var drop_1 = require_drop();
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var profiling_level_1 = require_profiling_level();
  var remove_user_1 = require_remove_user();
  var rename_1 = require_rename();
  var run_command_1 = require_run_command();
  var set_profiling_level_1 = require_set_profiling_level();
  var stats_1 = require_stats();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var DB_OPTIONS_ALLOW_LIST = [
    "writeConcern",
    "readPreference",
    "readPreferenceTags",
    "native_parser",
    "forceServerObjectId",
    "pkFactory",
    "serializeFunctions",
    "raw",
    "authSource",
    "ignoreUndefined",
    "readConcern",
    "retryMiliSeconds",
    "numberOfRetries",
    "useBigInt64",
    "promoteBuffers",
    "promoteLongs",
    "bsonRegExp",
    "enableUtf8Validation",
    "promoteValues",
    "compression",
    "retryWrites",
    "timeoutMS"
  ];

  class Db {
    constructor(client, databaseName, options) {
      options = options ?? {};
      options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
      if (typeof databaseName === "string" && databaseName.includes(".")) {
        throw new error_1.MongoInvalidArgumentError(`Database names cannot contain the character '.'`);
      }
      this.s = {
        options,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
        pkFactory: options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        namespace: new utils_1.MongoDBNamespace(databaseName)
      };
      this.client = client;
    }
    get databaseName() {
      return this.s.namespace.db;
    }
    get options() {
      return this.s.options;
    }
    get secondaryOk() {
      return this.s.readPreference?.preference !== "primary" || false;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.client.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get namespace() {
      return this.s.namespace.toString();
    }
    get timeoutMS() {
      return this.s.options?.timeoutMS;
    }
    async createCollection(name, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async command(command, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, (0, utils_1.resolveOptions)(undefined, {
        ...(0, bson_1.resolveBSONOptions)(options),
        timeoutMS: options?.timeoutMS ?? this.timeoutMS,
        session: options?.session,
        readPreference: options?.readPreference,
        signal: options?.signal
      })));
    }
    aggregate(pipeline2 = [], options) {
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline2, (0, utils_1.resolveOptions)(this, options));
    }
    admin() {
      return new admin_1.Admin(this);
    }
    collection(name, options = {}) {
      if (typeof options === "function") {
        throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
      }
      return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
    }
    async stats(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    listCollections(filter = {}, options = {}) {
      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async renameCollection(fromCollection, toCollection, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, (0, utils_1.resolveOptions)(undefined, {
        ...options,
        new_collection: true,
        readPreference: read_preference_1.ReadPreference.primary
      })));
    }
    async dropCollection(name, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async dropDatabase(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async collections(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(name, indexSpec, options) {
      const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, name, indexSpec, options));
      return indexes[0];
    }
    async removeUser(username, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)));
    }
    async setProfilingLevel(level, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)));
    }
    async profilingLevel(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexInformation(name, options) {
      return await this.collection(name).indexInformation((0, utils_1.resolveOptions)(this, options));
    }
    watch(pipeline2 = [], options = {}) {
      if (!Array.isArray(pipeline2)) {
        options = pipeline2;
        pipeline2 = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline2, (0, utils_1.resolveOptions)(this, options));
    }
    runCursorCommand(command, options) {
      return new run_command_cursor_1.RunCommandCursor(this, command, options);
    }
  }
  exports.Db = Db;
  Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
  Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
  Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
  Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
  Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
  Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStream = undefined;
  var collection_1 = require_collection();
  var constants_1 = require_constants();
  var abstract_cursor_1 = require_abstract_cursor();
  var change_stream_cursor_1 = require_change_stream_cursor();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_types_1 = require_mongo_types();
  var resource_management_1 = require_resource_management();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var CHANGE_STREAM_OPTIONS = [
    "resumeAfter",
    "startAfter",
    "startAtOperationTime",
    "fullDocument",
    "fullDocumentBeforeChange",
    "showExpandedEvents"
  ];
  var CHANGE_DOMAIN_TYPES = {
    COLLECTION: Symbol("Collection"),
    DATABASE: Symbol("Database"),
    CLUSTER: Symbol("Cluster")
  };
  var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
  var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
  var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";

  class ChangeStream extends mongo_types_1.TypedEventEmitter {
    async asyncDispose() {
      await this.close();
    }
    constructor(parent, pipeline2 = [], options = {}) {
      super();
      this.pipeline = pipeline2;
      this.options = { ...options };
      let serverSelectionTimeoutMS;
      delete this.options.writeConcern;
      if (parent instanceof collection_1.Collection) {
        this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
        serverSelectionTimeoutMS = parent.s.db.client.options.serverSelectionTimeoutMS;
      } else if (parent instanceof db_1.Db) {
        this.type = CHANGE_DOMAIN_TYPES.DATABASE;
        serverSelectionTimeoutMS = parent.client.options.serverSelectionTimeoutMS;
      } else if (parent instanceof mongo_client_1.MongoClient) {
        this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
        serverSelectionTimeoutMS = parent.options.serverSelectionTimeoutMS;
      } else {
        throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
      }
      this.contextOwner = Symbol();
      this.parent = parent;
      this.namespace = parent.s.namespace;
      if (!this.options.readPreference && parent.readPreference) {
        this.options.readPreference = parent.readPreference;
      }
      this.cursor = this._createChangeStreamCursor(options);
      this.isClosed = false;
      this.mode = false;
      this.on("newListener", (eventName) => {
        if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
          this._streamEvents(this.cursor);
        }
      });
      this.on("removeListener", (eventName) => {
        if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
          this.cursorStream?.removeAllListeners("data");
        }
      });
      if (this.options.timeoutMS != null) {
        this.timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS: this.options.timeoutMS,
          serverSelectionTimeoutMS
        });
      }
    }
    get resumeToken() {
      return this.cursor?.resumeToken;
    }
    async hasNext() {
      this._setIsIterator();
      this.timeoutContext?.refresh();
      try {
        while (true) {
          try {
            const hasNext = await this.cursor.hasNext();
            return hasNext;
          } catch (error) {
            try {
              await this._processErrorIteratorMode(error, this.cursor.id != null);
            } catch (error2) {
              if (error2 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                throw error2;
              }
              try {
                await this.close();
              } catch (error3) {
                (0, utils_1.squashError)(error3);
              }
              throw error2;
            }
          }
        }
      } finally {
        this.timeoutContext?.clear();
      }
    }
    async next() {
      this._setIsIterator();
      this.timeoutContext?.refresh();
      try {
        while (true) {
          try {
            const change = await this.cursor.next();
            const processedChange = this._processChange(change ?? null);
            return processedChange;
          } catch (error) {
            try {
              await this._processErrorIteratorMode(error, this.cursor.id != null);
            } catch (error2) {
              if (error2 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                throw error2;
              }
              try {
                await this.close();
              } catch (error3) {
                (0, utils_1.squashError)(error3);
              }
              throw error2;
            }
          }
        }
      } finally {
        this.timeoutContext?.clear();
      }
    }
    async tryNext() {
      this._setIsIterator();
      this.timeoutContext?.refresh();
      try {
        while (true) {
          try {
            const change = await this.cursor.tryNext();
            return change ?? null;
          } catch (error) {
            try {
              await this._processErrorIteratorMode(error, this.cursor.id != null);
            } catch (error2) {
              if (error2 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null)
                throw error2;
              try {
                await this.close();
              } catch (error3) {
                (0, utils_1.squashError)(error3);
              }
              throw error2;
            }
          }
        }
      } finally {
        this.timeoutContext?.clear();
      }
    }
    async* [Symbol.asyncIterator]() {
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          yield await this.next();
        }
      } finally {
        try {
          await this.close();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
      }
    }
    get closed() {
      return this.isClosed || this.cursor.closed;
    }
    async close() {
      this.timeoutContext?.clear();
      this.timeoutContext = undefined;
      this.isClosed = true;
      const cursor = this.cursor;
      try {
        await cursor.close();
      } finally {
        this._endStream();
      }
    }
    stream(options) {
      if (this.closed) {
        throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
      }
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    _setIsEmitter() {
      if (this.mode === "iterator") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
      }
      this.mode = "emitter";
    }
    _setIsIterator() {
      if (this.mode === "emitter") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
      }
      this.mode = "iterator";
    }
    _createChangeStreamCursor(options) {
      const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
      if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline2 = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
      const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;
      if (client == null) {
        throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
      }
      const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline2, {
        ...options,
        timeoutContext: this.timeoutContext ? new abstract_cursor_1.CursorTimeoutContext(this.timeoutContext, this.contextOwner) : undefined
      });
      for (const event of CHANGE_STREAM_EVENTS) {
        changeStreamCursor.on(event, (e) => this.emit(event, e));
      }
      if (this.listenerCount(ChangeStream.CHANGE) > 0) {
        this._streamEvents(changeStreamCursor);
      }
      return changeStreamCursor;
    }
    _closeEmitterModeWithError(error) {
      this.emit(ChangeStream.ERROR, error);
      this.close().then(undefined, utils_1.squashError);
    }
    _streamEvents(cursor) {
      this._setIsEmitter();
      const stream = this.cursorStream ?? cursor.stream();
      this.cursorStream = stream;
      stream.on("data", (change) => {
        try {
          const processedChange = this._processChange(change);
          this.emit(ChangeStream.CHANGE, processedChange);
        } catch (error) {
          this.emit(ChangeStream.ERROR, error);
        }
        this.timeoutContext?.refresh();
      });
      stream.on("error", (error) => this._processErrorStreamMode(error, this.cursor.id != null));
    }
    _endStream() {
      this.cursorStream?.removeAllListeners("data");
      this.cursorStream?.removeAllListeners("close");
      this.cursorStream?.removeAllListeners("end");
      this.cursorStream?.destroy();
      this.cursorStream = undefined;
    }
    _processChange(change) {
      if (this.isClosed) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change == null) {
        throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change && !change._id) {
        throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
      }
      this.cursor.cacheResumeToken(change._id);
      this.options.startAtOperationTime = undefined;
      return change;
    }
    _processErrorStreamMode(changeStreamError, cursorInitialized) {
      if (this.isClosed)
        return;
      if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
        this._endStream();
        this.cursor.close().then(() => this._resume(changeStreamError), (e) => {
          (0, utils_1.squashError)(e);
          return this._resume(changeStreamError);
        }).then(() => {
          if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
            this.emit(ChangeStream.ERROR, changeStreamError);
        }, () => this._closeEmitterModeWithError(changeStreamError));
      } else {
        this._closeEmitterModeWithError(changeStreamError);
      }
    }
    async _processErrorIteratorMode(changeStreamError, cursorInitialized) {
      if (this.isClosed) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
        try {
          await this.cursor.close();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
        await this._resume(changeStreamError);
        if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
          throw changeStreamError;
      } else {
        try {
          await this.close();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
        throw changeStreamError;
      }
    }
    async _resume(changeStreamError) {
      this.timeoutContext?.refresh();
      const topology = (0, utils_1.getTopology)(this.parent);
      try {
        await topology.selectServer(this.cursor.readPreference, {
          operationName: "reconnect topology in change stream",
          timeoutContext: this.timeoutContext
        });
        this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
      } catch {
        await this.close();
        throw changeStreamError;
      }
    }
  }
  exports.ChangeStream = ChangeStream;
  ChangeStream.RESPONSE = constants_1.RESPONSE;
  ChangeStream.MORE = constants_1.MORE;
  ChangeStream.INIT = constants_1.INIT;
  ChangeStream.CLOSE = constants_1.CLOSE;
  ChangeStream.CHANGE = constants_1.CHANGE;
  ChangeStream.END = constants_1.END;
  ChangeStream.ERROR = constants_1.ERROR;
  ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
  (0, resource_management_1.configureResourceManagement)(ChangeStream.prototype);
});

// node_modules/mongodb/lib/deps.js
var require_deps = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aws4 = undefined;
  exports.getKerberos = getKerberos;
  exports.getZstdLibrary = getZstdLibrary;
  exports.getAwsCredentialProvider = getAwsCredentialProvider;
  exports.getGcpMetadata = getGcpMetadata;
  exports.getSnappy = getSnappy;
  exports.getSocks = getSocks;
  exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
  var error_1 = require_error();
  function makeErrorModule(error) {
    const props = error ? { kModuleError: error } : {};
    return new Proxy(props, {
      get: (_, key) => {
        if (key === "kModuleError") {
          return error;
        }
        throw error;
      },
      set: () => {
        throw error;
      }
    });
  }
  function getKerberos() {
    let kerberos;
    try {
      kerberos = (()=>{throw new Error("Cannot require module "+"kerberos");})();
    } catch (error) {
      kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication", { cause: error, dependencyName: "kerberos" }));
    }
    return kerberos;
  }
  function getZstdLibrary() {
    let ZStandard;
    try {
      ZStandard = (()=>{throw new Error("Cannot require module "+"@mongodb-js/zstd");})();
    } catch (error) {
      ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression", { cause: error, dependencyName: "zstd" }));
    }
    return ZStandard;
  }
  function getAwsCredentialProvider() {
    try {
      const credentialProvider = (()=>{throw new Error("Cannot require module "+"@aws-sdk/credential-providers");})();
      return credentialProvider;
    } catch (error) {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found." + " Please install it to enable getting aws credentials via the official sdk.", { cause: error, dependencyName: "@aws-sdk/credential-providers" }));
    }
  }
  function getGcpMetadata() {
    try {
      const credentialProvider = (()=>{throw new Error("Cannot require module "+"gcp-metadata");})();
      return credentialProvider;
    } catch (error) {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `gcp-metadata` not found." + " Please install it to enable getting gcp credentials via the official sdk.", { cause: error, dependencyName: "gcp-metadata" }));
    }
  }
  function getSnappy() {
    try {
      const value = (()=>{throw new Error("Cannot require module "+"snappy");})();
      return value;
    } catch (error) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression", { cause: error, dependencyName: "snappy" });
      return { kModuleError };
    }
  }
  function getSocks() {
    try {
      const value = (()=>{throw new Error("Cannot require module "+"socks");})();
      return value;
    } catch (error) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `socks` not found. Please install it to connections over a SOCKS5 proxy", { cause: error, dependencyName: "socks" });
      return { kModuleError };
    }
  }
  exports.aws4 = loadAws4();
  function loadAws4() {
    let aws4;
    try {
      aws4 = (()=>{throw new Error("Cannot require module "+"aws4");})();
    } catch (error) {
      aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication", { cause: error, dependencyName: "aws4" }));
    }
    return aws4;
  }
  function getMongoDBClientEncryption() {
    let mongodbClientEncryption = null;
    try {
      mongodbClientEncryption = (()=>{throw new Error("Cannot require module "+"mongodb-client-encryption");})();
    } catch (error) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `mongodb-client-encryption` not found. Please install it to use auto encryption or ClientEncryption.", { cause: error, dependencyName: "mongodb-client-encryption" });
      return { kModuleError };
    }
    return mongodbClientEncryption;
  }
});

// node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuthProvider = exports.AuthContext = undefined;
  var error_1 = require_error();

  class AuthContext {
    constructor(connection, credentials, options) {
      this.reauthenticating = false;
      this.connection = connection;
      this.credentials = credentials;
      this.options = options;
    }
  }
  exports.AuthContext = AuthContext;

  class AuthProvider {
    async prepare(handshakeDoc, _authContext) {
      return handshakeDoc;
    }
    async reauth(context) {
      if (context.reauthenticating) {
        throw new error_1.MongoRuntimeError("Reauthentication already in progress.");
      }
      try {
        context.reauthenticating = true;
        await this.auth(context);
      } finally {
        context.reauthenticating = false;
      }
    }
  }
  exports.AuthProvider = AuthProvider;
});

// node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GSSAPI = exports.GSSAPICanonicalizationValue = undefined;
  exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
  exports.resolveCname = resolveCname;
  var dns = __require("dns");
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  exports.GSSAPICanonicalizationValue = Object.freeze({
    on: true,
    off: false,
    none: "none",
    forward: "forward",
    forwardAndReverse: "forwardAndReverse"
  });
  async function externalCommand(connection, command) {
    const response = await connection.command((0, utils_1.ns)("$external.$cmd"), command);
    return response;
  }
  var krb;

  class GSSAPI extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (credentials == null) {
        throw new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication");
      }
      const { username } = credentials;
      const client = await makeKerberosClient(authContext);
      const payload = await client.step("");
      const saslStartResponse = await externalCommand(connection, saslStart(payload));
      const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
      const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
      const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
      await externalCommand(connection, {
        saslContinue: 1,
        conversationId: saslContinueResponse.conversationId,
        payload: finalizePayload
      });
    }
  }
  exports.GSSAPI = GSSAPI;
  async function makeKerberosClient(authContext) {
    const { hostAddress } = authContext.options;
    const { credentials } = authContext;
    if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
      throw new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined.");
    }
    loadKrb();
    if ("kModuleError" in krb) {
      throw krb["kModuleError"];
    }
    const { initializeClient } = krb;
    const { username, password } = credentials;
    const mechanismProperties = credentials.mechanismProperties;
    const serviceName = mechanismProperties.SERVICE_NAME ?? "mongodb";
    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
    const initOptions = {};
    if (password != null) {
      Object.assign(initOptions, { user: username, password });
    }
    const spnHost = mechanismProperties.SERVICE_HOST ?? host;
    let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
    if ("SERVICE_REALM" in mechanismProperties) {
      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
    }
    return await initializeClient(spn, initOptions);
  }
  function saslStart(payload) {
    return {
      saslStart: 1,
      mechanism: "GSSAPI",
      payload,
      autoAuthorize: 1
    };
  }
  function saslContinue(payload, conversationId) {
    return {
      saslContinue: 1,
      conversationId,
      payload
    };
  }
  async function negotiate(client, retries, payload) {
    try {
      const response = await client.step(payload);
      return response || "";
    } catch (error) {
      if (retries === 0) {
        throw error;
      }
      return await negotiate(client, retries - 1, payload);
    }
  }
  async function finalize(client, user, payload) {
    const response = await client.unwrap(payload);
    return await client.wrap(response || "", { user });
  }
  async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
      return host;
    }
    if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
      const { address } = await dns.promises.lookup(host);
      try {
        const results = await dns.promises.resolvePtr(address);
        return results.length > 0 ? results[0] : host;
      } catch {
        return await resolveCname(host);
      }
    } else {
      return await resolveCname(host);
    }
  }
  async function resolveCname(host) {
    try {
      const results = await dns.promises.resolveCname(host);
      return results.length > 0 ? results[0] : host;
    } catch {
      return host;
    }
  }
  function loadKrb() {
    if (!krb) {
      krb = (0, deps_1.getKerberos)();
    }
  }
});

// node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = undefined;
  exports.AuthMechanism = Object.freeze({
    MONGODB_AWS: "MONGODB-AWS",
    MONGODB_CR: "MONGODB-CR",
    MONGODB_DEFAULT: "DEFAULT",
    MONGODB_GSSAPI: "GSSAPI",
    MONGODB_PLAIN: "PLAIN",
    MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
    MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
    MONGODB_X509: "MONGODB-X509",
    MONGODB_OIDC: "MONGODB-OIDC"
  });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([
    exports.AuthMechanism.MONGODB_GSSAPI,
    exports.AuthMechanism.MONGODB_AWS,
    exports.AuthMechanism.MONGODB_OIDC,
    exports.AuthMechanism.MONGODB_X509
  ]);
});

// node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = undefined;
  var error_1 = require_error();
  var gssapi_1 = require_gssapi();
  var providers_1 = require_providers();
  function getDefaultAuthMechanism(hello) {
    if (hello) {
      if (Array.isArray(hello.saslSupportedMechs)) {
        return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
      }
    }
    return providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
  }
  var ALLOWED_ENVIRONMENT_NAMES = [
    "test",
    "azure",
    "gcp",
    "k8s"
  ];
  var ALLOWED_HOSTS_ERROR = "Auth mechanism property ALLOWED_HOSTS must be an array of strings.";
  exports.DEFAULT_ALLOWED_HOSTS = [
    "*.mongodb.net",
    "*.mongodb-qa.net",
    "*.mongodb-dev.net",
    "*.mongodbgov.net",
    "localhost",
    "127.0.0.1",
    "::1"
  ];
  var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure or gcp.";

  class MongoCredentials {
    constructor(options) {
      this.username = options.username ?? "";
      this.password = options.password;
      this.source = options.source;
      if (!this.source && options.db) {
        this.source = options.db;
      }
      this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
      this.mechanismProperties = options.mechanismProperties || {};
      if (this.mechanism.match(/MONGODB-AWS/i)) {
        if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
          this.username = process.env.AWS_ACCESS_KEY_ID;
        }
        if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
          this.password = process.env.AWS_SECRET_ACCESS_KEY;
        }
        if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
          this.mechanismProperties = {
            ...this.mechanismProperties,
            AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
          };
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
        this.mechanismProperties = {
          ...this.mechanismProperties,
          ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
        };
      }
      Object.freeze(this.mechanismProperties);
      Object.freeze(this);
    }
    equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    resolveAuthMechanism(hello) {
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(hello),
          mechanismProperties: this.mechanismProperties
        });
      }
      return this;
    }
    validate() {
      if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
        throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        if (this.username && this.mechanismProperties.ENVIRONMENT && this.mechanismProperties.ENVIRONMENT !== "azure") {
          throw new error_1.MongoInvalidArgumentError(`username and ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' may not be used together for mechanism '${this.mechanism}'.`);
        }
        if (this.username && this.password) {
          throw new error_1.MongoInvalidArgumentError(`No password is allowed in ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' for '${this.mechanism}'.`);
        }
        if ((this.mechanismProperties.ENVIRONMENT === "azure" || this.mechanismProperties.ENVIRONMENT === "gcp") && !this.mechanismProperties.TOKEN_RESOURCE) {
          throw new error_1.MongoInvalidArgumentError(TOKEN_RESOURCE_MISSING_ERROR);
        }
        if (this.mechanismProperties.ENVIRONMENT && !ALLOWED_ENVIRONMENT_NAMES.includes(this.mechanismProperties.ENVIRONMENT)) {
          throw new error_1.MongoInvalidArgumentError(`Currently only a ENVIRONMENT in ${ALLOWED_ENVIRONMENT_NAMES.join(",")} is supported for mechanism '${this.mechanism}'.`);
        }
        if (!this.mechanismProperties.ENVIRONMENT && !this.mechanismProperties.OIDC_CALLBACK && !this.mechanismProperties.OIDC_HUMAN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError(`Either a ENVIRONMENT, OIDC_CALLBACK, or OIDC_HUMAN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.ALLOWED_HOSTS) {
          const hosts = this.mechanismProperties.ALLOWED_HOSTS;
          if (!Array.isArray(hosts)) {
            throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
          }
          for (const host of hosts) {
            if (typeof host !== "string") {
              throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
            }
          }
        }
      }
      if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
        if (this.source != null && this.source !== "$external") {
          throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
        throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
        if (this.password === "") {
          Reflect.set(this, "password", undefined);
          return;
        }
        throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
      }
      const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
      if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
        throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
      }
    }
    static merge(creds, options) {
      return new MongoCredentials({
        username: options.username ?? creds?.username ?? "",
        password: options.password ?? creds?.password ?? "",
        mechanism: options.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
        mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},
        source: options.source ?? options.db ?? creds?.source ?? "admin"
      });
    }
  }
  exports.MongoCredentials = MongoCredentials;
});

// node_modules/mongodb/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "mongodb",
    version: "6.18.0",
    description: "The official MongoDB driver for Node.js",
    main: "lib/index.js",
    files: [
      "lib",
      "src",
      "etc/prepare.js",
      "mongodb.d.ts",
      "tsconfig.json"
    ],
    types: "mongodb.d.ts",
    repository: {
      type: "git",
      url: "git@github.com:mongodb/node-mongodb-native.git"
    },
    keywords: [
      "mongodb",
      "driver",
      "official"
    ],
    author: {
      name: "The MongoDB NodeJS Team",
      email: "dbx-node@mongodb.com"
    },
    dependencies: {
      "@mongodb-js/saslprep": "^1.1.9",
      bson: "^6.10.4",
      "mongodb-connection-string-url": "^3.0.0"
    },
    peerDependencies: {
      "@aws-sdk/credential-providers": "^3.188.0",
      "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
      "gcp-metadata": "^5.2.0",
      kerberos: "^2.0.1",
      "mongodb-client-encryption": ">=6.0.0 <7",
      snappy: "^7.2.2",
      socks: "^2.7.1"
    },
    peerDependenciesMeta: {
      "@aws-sdk/credential-providers": {
        optional: true
      },
      "@mongodb-js/zstd": {
        optional: true
      },
      kerberos: {
        optional: true
      },
      snappy: {
        optional: true
      },
      "mongodb-client-encryption": {
        optional: true
      },
      "gcp-metadata": {
        optional: true
      },
      socks: {
        optional: true
      }
    },
    devDependencies: {
      "@aws-sdk/credential-providers": "^3.632.0",
      "@iarna/toml": "^2.2.5",
      "@istanbuljs/nyc-config-typescript": "^1.0.2",
      "@microsoft/api-extractor": "^7.52.5",
      "@microsoft/tsdoc-config": "^0.17.1",
      "@mongodb-js/zstd": "^2.0.1",
      "@types/chai": "^4.3.17",
      "@types/chai-subset": "^1.3.5",
      "@types/express": "^5.0.1",
      "@types/kerberos": "^1.1.5",
      "@types/mocha": "^10.0.9",
      "@types/node": "^22.15.3",
      "@types/saslprep": "^1.0.3",
      "@types/semver": "^7.7.0",
      "@types/sinon": "^17.0.4",
      "@types/sinon-chai": "^4.0.0",
      "@types/whatwg-url": "^13.0.0",
      "@typescript-eslint/eslint-plugin": "^8.31.1",
      "@typescript-eslint/parser": "^8.31.1",
      chai: "^4.4.1",
      "chai-subset": "^1.6.0",
      chalk: "^4.1.2",
      eslint: "^9.25.1",
      "eslint-config-prettier": "^10.1.2",
      "eslint-plugin-mocha": "^10.4.1",
      "eslint-plugin-prettier": "^5.2.3",
      "eslint-plugin-simple-import-sort": "^12.1.1",
      "eslint-plugin-tsdoc": "^0.4.0",
      "eslint-plugin-unused-imports": "^4.1.4",
      express: "^5.1.0",
      "gcp-metadata": "^5.3.0",
      "js-yaml": "^4.1.0",
      mocha: "^10.8.2",
      "mocha-sinon": "^2.1.2",
      "mongodb-client-encryption": "^6.4.0",
      "mongodb-legacy": "^6.1.3",
      nyc: "^15.1.0",
      prettier: "^3.5.3",
      semver: "^7.7.0",
      sinon: "^18.0.1",
      "sinon-chai": "^3.7.0",
      snappy: "^7.2.2",
      socks: "^2.8.1",
      "source-map-support": "^0.5.21",
      "ts-node": "^10.9.2",
      tsd: "^0.32.0",
      typescript: "5.8.3",
      "typescript-cached-transpile": "^0.0.6",
      "v8-heapsnapshot": "^1.3.1",
      yargs: "^17.7.2"
    },
    license: "Apache-2.0",
    engines: {
      node: ">=16.20.1"
    },
    bugs: {
      url: "https://jira.mongodb.org/projects/NODE/issues/"
    },
    homepage: "https://github.com/mongodb/node-mongodb-native",
    scripts: {
      "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
      "build:ts": "node ./node_modules/typescript/bin/tsc",
      "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs && ESLINT_USE_FLAT_CONFIG=false eslint --no-ignore --fix mongodb.d.ts lib/beta.d.ts",
      "build:docs": "./etc/docs/build.ts",
      "build:typedoc": "typedoc",
      "build:nightly": "node ./.github/scripts/nightly.mjs",
      "check:bench": "npm --prefix test/benchmarks/driver_bench start",
      "check:coverage": "nyc npm run test:all",
      "check:integration-coverage": "nyc npm run check:test",
      "check:lambda": "nyc mocha --config test/mocha_lambda.js test/integration/node-specific/examples/handler.test.js",
      "check:lambda:aws": "nyc mocha --config test/mocha_lambda.js test/integration/node-specific/examples/aws_handler.test.js",
      "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
      "check:eslint": "npm run build:dts && ESLINT_USE_FLAT_CONFIG=false eslint -v && ESLINT_USE_FLAT_CONFIG=false eslint --max-warnings=0 --ext '.js,.ts' src test",
      "check:tsd": "tsd --version && tsd",
      "check:dependencies": "mocha test/action/dependency.test.ts",
      "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
      "check:search-indexes": "nyc mocha --config test/mocha_mongodb.js test/manual/search-index-management.prose.test.ts",
      "check:test": "mocha --config test/mocha_mongodb.js test/integration",
      "check:unit": "nyc mocha test/unit",
      "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
      "check:atlas": "nyc mocha --config test/manual/mocharc.js test/manual/atlas_connectivity.test.ts",
      "check:resource-management": "nyc mocha --config test/manual/mocharc.js test/manual/resource_management.test.ts",
      "check:drivers-atlas-testing": "nyc mocha --config test/mocha_mongodb.js test/atlas/drivers_atlas_testing.test.ts",
      "check:adl": "nyc mocha --config test/mocha_mongodb.js test/manual/atlas-data-lake-testing",
      "check:aws": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_aws.test.ts",
      "check:oidc-auth": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/auth.spec.test.ts",
      "check:oidc-test": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc.prose.test.ts",
      "check:oidc-azure": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_azure.prose.05.test.ts",
      "check:oidc-gcp": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_gcp.prose.06.test.ts",
      "check:oidc-k8s": "nyc mocha --config test/mocha_mongodb.js test/integration/auth/mongodb_oidc_k8s.prose.07.test.ts",
      "check:kerberos": "nyc mocha --config test/manual/mocharc.js test/manual/kerberos.test.ts",
      "check:tls": "nyc mocha --config test/manual/mocharc.js test/manual/tls_support.test.ts",
      "check:ldap": "nyc mocha --config test/manual/mocharc.js test/manual/ldap.test.ts",
      "check:socks5": "nyc mocha --config test/manual/mocharc.js test/manual/socks5.test.ts",
      "check:csfle": "nyc mocha --config test/mocha_mongodb.js test/integration/client-side-encryption",
      "check:snappy": "nyc mocha test/unit/assorted/snappy.test.js",
      "check:x509": "nyc mocha test/manual/x509_auth.test.ts",
      "fix:eslint": "npm run check:eslint -- --fix",
      prepare: "node etc/prepare.js",
      "preview:docs": "ts-node etc/docs/preview.ts",
      test: "npm run check:lint && npm run test:all",
      "test:all": "npm run check:unit && npm run check:test",
      "update:docs": "npm run build:docs -- --yes"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        strict: true,
        target: "esnext",
        module: "commonjs",
        moduleResolution: "node"
      }
    }
  };
});

// node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LimitedSizeDocument = undefined;
  exports.makeClientMetadata = makeClientMetadata;
  exports.addContainerMetadata = addContainerMetadata;
  exports.getFAASEnv = getFAASEnv;
  var os = __require("os");
  var process2 = __require("process");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var NODE_DRIVER_VERSION = require_package().version;

  class LimitedSizeDocument {
    constructor(maxSize) {
      this.document = new Map;
      this.documentSize = 5;
      this.maxSize = maxSize;
    }
    ifItFitsItSits(key, value) {
      const newElementSize = bson_1.BSON.serialize(new Map().set(key, value)).byteLength - 5;
      if (newElementSize + this.documentSize > this.maxSize) {
        return false;
      }
      this.documentSize += newElementSize;
      this.document.set(key, value);
      return true;
    }
    toObject() {
      return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
        promoteLongs: false,
        promoteBuffers: false,
        promoteValues: false,
        useBigInt64: false
      });
    }
  }
  exports.LimitedSizeDocument = LimitedSizeDocument;
  function makeClientMetadata(options) {
    const metadataDocument = new LimitedSizeDocument(512);
    const { appName = "" } = options;
    if (appName.length > 0) {
      const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
      metadataDocument.ifItFitsItSits("application", { name: name2 });
    }
    const { name = "", version = "", platform = "" } = options.driverInfo;
    const driverInfo = {
      name: name.length > 0 ? `nodejs|${name}` : "nodejs",
      version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
    };
    if (options.additionalDriverInfo == null) {
      throw new error_1.MongoRuntimeError("Client options `additionalDriverInfo` must always default to an empty array");
    }
    for (const { name: n2 = "", version: v = "" } of options.additionalDriverInfo) {
      if (n2.length > 0) {
        driverInfo.name = `${driverInfo.name}|${n2}`;
      }
      if (v.length > 0) {
        driverInfo.version = `${driverInfo.version}|${v}`;
      }
    }
    if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
    }
    let runtimeInfo = getRuntimeInfo();
    if (platform.length > 0) {
      runtimeInfo = `${runtimeInfo}|${platform}`;
    }
    for (const { platform: p = "" } of options.additionalDriverInfo) {
      if (p.length > 0) {
        runtimeInfo = `${runtimeInfo}|${p}`;
      }
    }
    if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
    }
    const osInfo = new Map().set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
    if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
      for (const key of osInfo.keys()) {
        osInfo.delete(key);
        if (osInfo.size === 0)
          break;
        if (metadataDocument.ifItFitsItSits("os", osInfo))
          break;
      }
    }
    const faasEnv = getFAASEnv();
    if (faasEnv != null) {
      if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
        for (const key of faasEnv.keys()) {
          faasEnv.delete(key);
          if (faasEnv.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("env", faasEnv))
            break;
        }
      }
    }
    return metadataDocument.toObject();
  }
  var dockerPromise;
  async function getContainerMetadata() {
    const containerMetadata = {};
    dockerPromise ??= (0, utils_1.fileIsAccessible)("/.dockerenv");
    const isDocker = await dockerPromise;
    const { KUBERNETES_SERVICE_HOST = "" } = process2.env;
    const isKubernetes = KUBERNETES_SERVICE_HOST.length > 0 ? true : false;
    if (isDocker)
      containerMetadata.runtime = "docker";
    if (isKubernetes)
      containerMetadata.orchestrator = "kubernetes";
    return containerMetadata;
  }
  async function addContainerMetadata(originalMetadata) {
    const containerMetadata = await getContainerMetadata();
    if (Object.keys(containerMetadata).length === 0)
      return originalMetadata;
    const extendedMetadata = new LimitedSizeDocument(512);
    const extendedEnvMetadata = { ...originalMetadata?.env, container: containerMetadata };
    for (const [key, val] of Object.entries(originalMetadata)) {
      if (key !== "env") {
        extendedMetadata.ifItFitsItSits(key, val);
      } else {
        if (!extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata)) {
          extendedMetadata.ifItFitsItSits("env", val);
        }
      }
    }
    if (!("env" in originalMetadata)) {
      extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata);
    }
    return extendedMetadata.toObject();
  }
  function getFAASEnv() {
    const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
    const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
    const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
    const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
    const isVercelFaaS = VERCEL.length > 0;
    const faasEnv = new Map;
    if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
      if (VERCEL_REGION.length > 0) {
        faasEnv.set("region", VERCEL_REGION);
      }
      faasEnv.set("name", "vercel");
      return faasEnv;
    }
    if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
      if (AWS_REGION.length > 0) {
        faasEnv.set("region", AWS_REGION);
      }
      if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
        faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
      }
      faasEnv.set("name", "aws.lambda");
      return faasEnv;
    }
    if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
      faasEnv.set("name", "azure.func");
      return faasEnv;
    }
    if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
      if (FUNCTION_REGION.length > 0) {
        faasEnv.set("region", FUNCTION_REGION);
      }
      if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
        faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
      }
      if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
        faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
      }
      faasEnv.set("name", "gcp.func");
      return faasEnv;
    }
    return null;
  }
  function getRuntimeInfo() {
    if ("Deno" in globalThis) {
      const version = typeof Deno?.version?.deno === "string" ? Deno?.version?.deno : "0.0.0-unknown";
      return `Deno v${version}, ${os.endianness()}`;
    }
    if ("Bun" in globalThis) {
      const version = typeof Bun?.version === "string" ? Bun?.version : "0.0.0-unknown";
      return `Bun v${version}, ${os.endianness()}`;
    }
    return `Node.js ${process2.version}, ${os.endianness()}`;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports) => {
  function makeException(ErrorType, message, options) {
    if (options.globals) {
      ErrorType = options.globals[ErrorType.name];
    }
    return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
  }
  function toNumber(value, options) {
    if (typeof value === "bigint") {
      throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
    }
    if (!options.globals) {
      return Number(value);
    }
    return options.globals.Number(value);
  }
  function evenRound(x) {
    if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
      return censorNegativeZero(Math.floor(x));
    }
    return censorNegativeZero(Math.round(x));
  }
  function integerPart(n2) {
    return censorNegativeZero(Math.trunc(n2));
  }
  function sign(x) {
    return x < 0 ? -1 : 1;
  }
  function modulo(x, y) {
    const signMightNotMatch = x % y;
    if (sign(y) !== sign(signMightNotMatch)) {
      return signMightNotMatch + y;
    }
    return signMightNotMatch;
  }
  function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
  }
  function createIntegerConversion(bitLength, { unsigned }) {
    let lowerBound, upperBound;
    if (unsigned) {
      lowerBound = 0;
      upperBound = 2 ** bitLength - 1;
    } else {
      lowerBound = -(2 ** (bitLength - 1));
      upperBound = 2 ** (bitLength - 1) - 1;
    }
    const twoToTheBitLength = 2 ** bitLength;
    const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
    return (value, options = {}) => {
      let x = toNumber(value, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = integerPart(x);
      if (x >= lowerBound && x <= upperBound) {
        return x;
      }
      x = modulo(x, twoToTheBitLength);
      if (!unsigned && x >= twoToOneLessThanTheBitLength) {
        return x - twoToTheBitLength;
      }
      return x;
    };
  }
  function createLongLongConversion(bitLength, { unsigned }) {
    const upperBound = Number.MAX_SAFE_INTEGER;
    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
    return (value, options = {}) => {
      let x = toNumber(value, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      let xBigInt = BigInt(integerPart(x));
      xBigInt = asBigIntN(bitLength, xBigInt);
      return Number(xBigInt);
    };
  }
  exports.any = (value) => {
    return value;
  };
  exports.undefined = () => {
    return;
  };
  exports.boolean = (value) => {
    return Boolean(value);
  };
  exports.byte = createIntegerConversion(8, { unsigned: false });
  exports.octet = createIntegerConversion(8, { unsigned: true });
  exports.short = createIntegerConversion(16, { unsigned: false });
  exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
  exports.long = createIntegerConversion(32, { unsigned: false });
  exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
  exports["long long"] = createLongLongConversion(64, { unsigned: false });
  exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
  exports.double = (value, options = {}) => {
    const x = toNumber(value, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    return x;
  };
  exports["unrestricted double"] = (value, options = {}) => {
    const x = toNumber(value, options);
    return x;
  };
  exports.float = (value, options = {}) => {
    const x = toNumber(value, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    if (Object.is(x, -0)) {
      return x;
    }
    const y = Math.fround(x);
    if (!Number.isFinite(y)) {
      throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
    }
    return y;
  };
  exports["unrestricted float"] = (value, options = {}) => {
    const x = toNumber(value, options);
    if (isNaN(x)) {
      return x;
    }
    if (Object.is(x, -0)) {
      return x;
    }
    return Math.fround(x);
  };
  exports.DOMString = (value, options = {}) => {
    if (options.treatNullAsEmptyString && value === null) {
      return "";
    }
    if (typeof value === "symbol") {
      throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
    }
    const StringCtor = options.globals ? options.globals.String : String;
    return StringCtor(value);
  };
  exports.ByteString = (value, options = {}) => {
    const x = exports.DOMString(value, options);
    let c;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw makeException(TypeError, "is not a valid ByteString", options);
      }
    }
    return x;
  };
  exports.USVString = (value, options = {}) => {
    const S = exports.DOMString(value, options);
    const n2 = S.length;
    const U = [];
    for (let i = 0;i < n2; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else if (i === n2 - 1) {
        U.push(String.fromCodePoint(65533));
      } else {
        const d = S.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          const a12 = c & 1023;
          const b = d & 1023;
          U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a12 + b));
          ++i;
        } else {
          U.push(String.fromCodePoint(65533));
        }
      }
    }
    return U.join("");
  };
  exports.object = (value, options = {}) => {
    if (value === null || typeof value !== "object" && typeof value !== "function") {
      throw makeException(TypeError, "is not an object", options);
    }
    return value;
  };
  var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
  function isNonSharedArrayBuffer(value) {
    try {
      abByteLengthGetter.call(value);
      return true;
    } catch {
      return false;
    }
  }
  function isSharedArrayBuffer(value) {
    try {
      sabByteLengthGetter.call(value);
      return true;
    } catch {
      return false;
    }
  }
  function isArrayBufferDetached(value) {
    try {
      new Uint8Array(value);
      return false;
    } catch {
      return true;
    }
  }
  exports.ArrayBuffer = (value, options = {}) => {
    if (!isNonSharedArrayBuffer(value)) {
      if (options.allowShared && !isSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
      }
      throw makeException(TypeError, "is not an ArrayBuffer", options);
    }
    if (isArrayBufferDetached(value)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value;
  };
  var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
  exports.DataView = (value, options = {}) => {
    try {
      dvByteLengthGetter.call(value);
    } catch (e) {
      throw makeException(TypeError, "is not a DataView", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
    }
    return value;
  };
  var typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
  [
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray,
    Float32Array,
    Float64Array
  ].forEach((func) => {
    const { name } = func;
    const article = /^[AEIOU]/u.test(name) ? "an" : "a";
    exports[name] = (value, options = {}) => {
      if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
        throw makeException(TypeError, `is not ${article} ${name} object`, options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    };
  });
  exports.ArrayBufferView = (value, options = {}) => {
    if (!ArrayBuffer.isView(value)) {
      throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
    }
    return value;
  };
  exports.BufferSource = (value, options = {}) => {
    if (ArrayBuffer.isView(value)) {
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    }
    if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
    }
    if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
    }
    if (isArrayBufferDetached(value)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value;
  };
  exports.DOMTimeStamp = exports["unsigned long long"];
});

// node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  function isObject2(value) {
    return typeof value === "object" && value !== null || typeof value === "function";
  }
  var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  function define2(target, source) {
    for (const key of Reflect.ownKeys(source)) {
      const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
      if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
        throw new TypeError(`Cannot redefine property: ${String(key)}`);
      }
    }
  }
  function newObjectInRealm(globalObject, object) {
    const ctorRegistry = initCtorRegistry(globalObject);
    return Object.defineProperties(Object.create(ctorRegistry["%Object.prototype%"]), Object.getOwnPropertyDescriptors(object));
  }
  var wrapperSymbol = Symbol("wrapper");
  var implSymbol = Symbol("impl");
  var sameObjectCaches = Symbol("SameObject caches");
  var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  function initCtorRegistry(globalObject) {
    if (hasOwn(globalObject, ctorRegistrySymbol)) {
      return globalObject[ctorRegistrySymbol];
    }
    const ctorRegistry = Object.create(null);
    ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
    ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));
    try {
      ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval("(async function* () {})").prototype));
    } catch {
      ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
    }
    globalObject[ctorRegistrySymbol] = ctorRegistry;
    return ctorRegistry;
  }
  function getSameObject(wrapper, prop, creator) {
    if (!wrapper[sameObjectCaches]) {
      wrapper[sameObjectCaches] = Object.create(null);
    }
    if (prop in wrapper[sameObjectCaches]) {
      return wrapper[sameObjectCaches][prop];
    }
    wrapper[sameObjectCaches][prop] = creator();
    return wrapper[sameObjectCaches][prop];
  }
  function wrapperForImpl(impl) {
    return impl ? impl[wrapperSymbol] : null;
  }
  function implForWrapper(wrapper) {
    return wrapper ? wrapper[implSymbol] : null;
  }
  function tryWrapperForImpl(impl) {
    const wrapper = wrapperForImpl(impl);
    return wrapper ? wrapper : impl;
  }
  function tryImplForWrapper(wrapper) {
    const impl = implForWrapper(wrapper);
    return impl ? impl : wrapper;
  }
  var iterInternalSymbol = Symbol("internal");
  function isArrayIndexPropName(P) {
    if (typeof P !== "string") {
      return false;
    }
    const i = P >>> 0;
    if (i === 2 ** 32 - 1) {
      return false;
    }
    const s = `${i}`;
    if (P !== s) {
      return false;
    }
    return true;
  }
  var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  function isArrayBuffer(value) {
    try {
      byteLengthGetter.call(value);
      return true;
    } catch (e) {
      return false;
    }
  }
  function iteratorResult([key, value], kind) {
    let result;
    switch (kind) {
      case "key":
        result = key;
        break;
      case "value":
        result = value;
        break;
      case "key+value":
        result = [key, value];
        break;
    }
    return { value: result, done: false };
  }
  var supportsPropertyIndex = Symbol("supports property index");
  var supportedPropertyIndices = Symbol("supported property indices");
  var supportsPropertyName = Symbol("supports property name");
  var supportedPropertyNames = Symbol("supported property names");
  var indexedGet = Symbol("indexed property get");
  var indexedSetNew = Symbol("indexed property set new");
  var indexedSetExisting = Symbol("indexed property set existing");
  var namedGet = Symbol("named property get");
  var namedSetNew = Symbol("named property set new");
  var namedSetExisting = Symbol("named property set existing");
  var namedDelete = Symbol("named property delete");
  var asyncIteratorNext = Symbol("async iterator get the next iteration result");
  var asyncIteratorReturn = Symbol("async iterator return steps");
  var asyncIteratorInit = Symbol("async iterator initialization steps");
  var asyncIteratorEOI = Symbol("async iterator end of iteration");
  module.exports = exports = {
    isObject: isObject2,
    hasOwn,
    define: define2,
    newObjectInRealm,
    wrapperSymbol,
    implSymbol,
    getSameObject,
    ctorRegistrySymbol,
    initCtorRegistry,
    wrapperForImpl,
    implForWrapper,
    tryWrapperForImpl,
    tryImplForWrapper,
    iterInternalSymbol,
    isArrayBuffer,
    isArrayIndexPropName,
    supportsPropertyIndex,
    supportedPropertyIndices,
    supportsPropertyName,
    supportedPropertyNames,
    indexedGet,
    indexedSetNew,
    indexedSetExisting,
    namedGet,
    namedSetNew,
    namedSetExisting,
    namedDelete,
    asyncIteratorNext,
    asyncIteratorReturn,
    asyncIteratorInit,
    asyncIteratorEOI,
    iteratorResult
  };
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports, module) => {
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors2 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  function error(type) {
    throw new RangeError(errors2[type]);
  }
  function map3(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map3(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta2, numPoints, firstTime) {
    let k = 0;
    delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
    delta2 += floor(delta2 / numPoints);
    for (;delta2 > baseMinusTMin * tMax >> 1; k += base) {
      delta2 = floor(delta2 / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
  };
  var decode4 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n2 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t2) {
          break;
        }
        const baseMinusT = base - t2;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n2) {
        error("overflow");
      }
      n2 += floor(i / out);
      i %= out;
      output.splice(i++, 0, n2);
    }
    return String.fromCodePoint(...output);
  };
  var encode2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n2 = initialN;
    let delta2 = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m2 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n2 && currentValue < m2) {
          m2 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m2 - n2 > floor((maxInt - delta2) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta2 += (m2 - n2) * handledCPCountPlusOne;
      n2 = m2;
      for (const currentValue of input) {
        if (currentValue < n2 && ++delta2 > maxInt) {
          error("overflow");
        }
        if (currentValue === n2) {
          let q = delta2;
          for (let k = base;; k += base) {
            const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t2) {
              break;
            }
            const qMinusT = q - t2;
            const baseMinusT = base - t2;
            output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta2, handledCPCountPlusOne, handledCPCount === basicLength);
          delta2 = 0;
          ++handledCPCount;
        }
      }
      ++delta2;
      ++n2;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode4(string.slice(4).toLowerCase()) : string;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode: decode4,
    encode: encode2,
    toASCII,
    toUnicode
  };
  module.exports = punycode;
});

// node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS((exports, module) => {
  var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113B8}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
  var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{113CE}-\u{113D0}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}\u{1612F}]/u;
  var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10EC3}\u{10EC4}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10EC2}-\u{10EC4}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
  var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCEF}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
  var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D4A}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0897-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2429\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E5\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D69}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10EFC}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CC00}-\u{1CCD5}\u{1CCF0}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6C1}\u{1D6DB}\u{1D6FB}\u{1D715}\u{1D735}\u{1D74F}\u{1D76F}\u{1D789}\u{1D7A9}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10D40}-\u{10D65}\u{10D6F}-\u{10D85}\u{10D8E}\u{10D8F}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10EC2}-\u{10EC4}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1CCF0}-\u{1CCF9}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
  var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10D40}-\u{10D49}\u{10E60}-\u{10E7E}]/u;
  var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B4E-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2429\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E5\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6E}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113C0}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}-\u{113D5}\u{113D7}\u{113D8}\u{113E1}\u{113E2}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F5A}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CC00}-\u{1CCF9}\u{1CD00}-\u{1CEB3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E5D0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}-\u{1F8BB}\u{1F8C0}\u{1F8C1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA89}\u{1FA8F}-\u{1FAC6}\u{1FACE}-\u{1FADC}\u{1FADF}-\u{1FAE9}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
  var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B4E-\u1B6A\u1B74-\u1B7F\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{105C0}-\u{105F3}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11380}-\u{11389}\u{1138B}\u{1138E}\u{11390}-\u{113B5}\u{113B7}-\u{113BA}\u{113C2}\u{113C5}\u{113C7}-\u{113CA}\u{113CC}\u{113CD}\u{113CF}\u{113D1}\u{113D3}-\u{113D5}\u{113D7}\u{113D8}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{116D0}-\u{116E3}\u{11700}-\u{1171A}\u{1171E}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11BC0}-\u{11BE1}\u{11BF0}-\u{11BF9}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{13460}-\u{143FA}\u{14400}-\u{14646}\u{16100}-\u{1611D}\u{1612A}-\u{1612C}\u{16130}-\u{16139}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16D40}-\u{16D79}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18CFF}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CCD6}-\u{1CCF9}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6C0}\u{1D6C2}-\u{1D6DA}\u{1D6DC}-\u{1D6FA}\u{1D6FC}-\u{1D714}\u{1D716}-\u{1D734}\u{1D736}-\u{1D74E}\u{1D750}-\u{1D76E}\u{1D770}-\u{1D788}\u{1D78A}-\u{1D7A8}\u{1D7AA}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E5D0}-\u{1E5ED}\u{1E5F0}-\u{1E5FA}\u{1E5FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10D69}-\u{10D6D}\u{10EAB}\u{10EAC}\u{10EFC}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{113BB}-\u{113C0}\u{113CE}\u{113D0}\u{113D2}\u{113E1}\u{113E2}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11F5A}\u{13440}\u{13447}-\u{13455}\u{1611E}-\u{16129}\u{1612D}-\u{1612F}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E5EE}\u{1E5EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  module.exports = {
    combiningMarks,
    combiningClassVirama,
    validZWNJ,
    bidiDomain,
    bidiS1LTR,
    bidiS1RTL,
    bidiS2,
    bidiS3,
    bidiS4EN,
    bidiS4AN,
    bidiS5,
    bidiS6
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], 2], [[45, 46], 2], [47, 2], [[48, 57], 2], [[58, 64], 2], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 2], [[97, 122], 2], [[123, 127], 2], [[128, 159], 3], [160, 1, " "], [[161, 167], 2], [168, 1, " ̈"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 1, " ̄"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 1, " ́"], [181, 1, "μ"], [182, 2], [183, 2], [184, 1, " ̧"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1⁄4"], [189, 1, "1⁄2"], [190, 1, "3⁄4"], [191, 2], [192, 1, "à"], [193, 1, "á"], [194, 1, "â"], [195, 1, "ã"], [196, 1, "ä"], [197, 1, "å"], [198, 1, "æ"], [199, 1, "ç"], [200, 1, "è"], [201, 1, "é"], [202, 1, "ê"], [203, 1, "ë"], [204, 1, "ì"], [205, 1, "í"], [206, 1, "î"], [207, 1, "ï"], [208, 1, "ð"], [209, 1, "ñ"], [210, 1, "ò"], [211, 1, "ó"], [212, 1, "ô"], [213, 1, "õ"], [214, 1, "ö"], [215, 2], [216, 1, "ø"], [217, 1, "ù"], [218, 1, "ú"], [219, 1, "û"], [220, 1, "ü"], [221, 1, "ý"], [222, 1, "þ"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "ā"], [257, 2], [258, 1, "ă"], [259, 2], [260, 1, "ą"], [261, 2], [262, 1, "ć"], [263, 2], [264, 1, "ĉ"], [265, 2], [266, 1, "ċ"], [267, 2], [268, 1, "č"], [269, 2], [270, 1, "ď"], [271, 2], [272, 1, "đ"], [273, 2], [274, 1, "ē"], [275, 2], [276, 1, "ĕ"], [277, 2], [278, 1, "ė"], [279, 2], [280, 1, "ę"], [281, 2], [282, 1, "ě"], [283, 2], [284, 1, "ĝ"], [285, 2], [286, 1, "ğ"], [287, 2], [288, 1, "ġ"], [289, 2], [290, 1, "ģ"], [291, 2], [292, 1, "ĥ"], [293, 2], [294, 1, "ħ"], [295, 2], [296, 1, "ĩ"], [297, 2], [298, 1, "ī"], [299, 2], [300, 1, "ĭ"], [301, 2], [302, 1, "į"], [303, 2], [304, 1, "i̇"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "ĵ"], [309, 2], [310, 1, "ķ"], [[311, 312], 2], [313, 1, "ĺ"], [314, 2], [315, 1, "ļ"], [316, 2], [317, 1, "ľ"], [318, 2], [[319, 320], 1, "l·"], [321, 1, "ł"], [322, 2], [323, 1, "ń"], [324, 2], [325, 1, "ņ"], [326, 2], [327, 1, "ň"], [328, 2], [329, 1, "ʼn"], [330, 1, "ŋ"], [331, 2], [332, 1, "ō"], [333, 2], [334, 1, "ŏ"], [335, 2], [336, 1, "ő"], [337, 2], [338, 1, "œ"], [339, 2], [340, 1, "ŕ"], [341, 2], [342, 1, "ŗ"], [343, 2], [344, 1, "ř"], [345, 2], [346, 1, "ś"], [347, 2], [348, 1, "ŝ"], [349, 2], [350, 1, "ş"], [351, 2], [352, 1, "š"], [353, 2], [354, 1, "ţ"], [355, 2], [356, 1, "ť"], [357, 2], [358, 1, "ŧ"], [359, 2], [360, 1, "ũ"], [361, 2], [362, 1, "ū"], [363, 2], [364, 1, "ŭ"], [365, 2], [366, 1, "ů"], [367, 2], [368, 1, "ű"], [369, 2], [370, 1, "ų"], [371, 2], [372, 1, "ŵ"], [373, 2], [374, 1, "ŷ"], [375, 2], [376, 1, "ÿ"], [377, 1, "ź"], [378, 2], [379, 1, "ż"], [380, 2], [381, 1, "ž"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "ɓ"], [386, 1, "ƃ"], [387, 2], [388, 1, "ƅ"], [389, 2], [390, 1, "ɔ"], [391, 1, "ƈ"], [392, 2], [393, 1, "ɖ"], [394, 1, "ɗ"], [395, 1, "ƌ"], [[396, 397], 2], [398, 1, "ǝ"], [399, 1, "ə"], [400, 1, "ɛ"], [401, 1, "ƒ"], [402, 2], [403, 1, "ɠ"], [404, 1, "ɣ"], [405, 2], [406, 1, "ɩ"], [407, 1, "ɨ"], [408, 1, "ƙ"], [[409, 411], 2], [412, 1, "ɯ"], [413, 1, "ɲ"], [414, 2], [415, 1, "ɵ"], [416, 1, "ơ"], [417, 2], [418, 1, "ƣ"], [419, 2], [420, 1, "ƥ"], [421, 2], [422, 1, "ʀ"], [423, 1, "ƨ"], [424, 2], [425, 1, "ʃ"], [[426, 427], 2], [428, 1, "ƭ"], [429, 2], [430, 1, "ʈ"], [431, 1, "ư"], [432, 2], [433, 1, "ʊ"], [434, 1, "ʋ"], [435, 1, "ƴ"], [436, 2], [437, 1, "ƶ"], [438, 2], [439, 1, "ʒ"], [440, 1, "ƹ"], [[441, 443], 2], [444, 1, "ƽ"], [[445, 451], 2], [[452, 454], 1, "dž"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "ǎ"], [462, 2], [463, 1, "ǐ"], [464, 2], [465, 1, "ǒ"], [466, 2], [467, 1, "ǔ"], [468, 2], [469, 1, "ǖ"], [470, 2], [471, 1, "ǘ"], [472, 2], [473, 1, "ǚ"], [474, 2], [475, 1, "ǜ"], [[476, 477], 2], [478, 1, "ǟ"], [479, 2], [480, 1, "ǡ"], [481, 2], [482, 1, "ǣ"], [483, 2], [484, 1, "ǥ"], [485, 2], [486, 1, "ǧ"], [487, 2], [488, 1, "ǩ"], [489, 2], [490, 1, "ǫ"], [491, 2], [492, 1, "ǭ"], [493, 2], [494, 1, "ǯ"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "ǵ"], [501, 2], [502, 1, "ƕ"], [503, 1, "ƿ"], [504, 1, "ǹ"], [505, 2], [506, 1, "ǻ"], [507, 2], [508, 1, "ǽ"], [509, 2], [510, 1, "ǿ"], [511, 2], [512, 1, "ȁ"], [513, 2], [514, 1, "ȃ"], [515, 2], [516, 1, "ȅ"], [517, 2], [518, 1, "ȇ"], [519, 2], [520, 1, "ȉ"], [521, 2], [522, 1, "ȋ"], [523, 2], [524, 1, "ȍ"], [525, 2], [526, 1, "ȏ"], [527, 2], [528, 1, "ȑ"], [529, 2], [530, 1, "ȓ"], [531, 2], [532, 1, "ȕ"], [533, 2], [534, 1, "ȗ"], [535, 2], [536, 1, "ș"], [537, 2], [538, 1, "ț"], [539, 2], [540, 1, "ȝ"], [541, 2], [542, 1, "ȟ"], [543, 2], [544, 1, "ƞ"], [545, 2], [546, 1, "ȣ"], [547, 2], [548, 1, "ȥ"], [549, 2], [550, 1, "ȧ"], [551, 2], [552, 1, "ȩ"], [553, 2], [554, 1, "ȫ"], [555, 2], [556, 1, "ȭ"], [557, 2], [558, 1, "ȯ"], [559, 2], [560, 1, "ȱ"], [561, 2], [562, 1, "ȳ"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "ⱥ"], [571, 1, "ȼ"], [572, 2], [573, 1, "ƚ"], [574, 1, "ⱦ"], [[575, 576], 2], [577, 1, "ɂ"], [578, 2], [579, 1, "ƀ"], [580, 1, "ʉ"], [581, 1, "ʌ"], [582, 1, "ɇ"], [583, 2], [584, 1, "ɉ"], [585, 2], [586, 1, "ɋ"], [587, 2], [588, 1, "ɍ"], [589, 2], [590, 1, "ɏ"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "ɦ"], [690, 1, "j"], [691, 1, "r"], [692, 1, "ɹ"], [693, 1, "ɻ"], [694, 1, "ʁ"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 1, " ̆"], [729, 1, " ̇"], [730, 1, " ̊"], [731, 1, " ̨"], [732, 1, " ̃"], [733, 1, " ̋"], [734, 2], [735, 2], [736, 1, "ɣ"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "ʕ"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "̀"], [833, 1, "́"], [834, 2], [835, 1, "̓"], [836, 1, "̈́"], [837, 1, "ι"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "ͱ"], [881, 2], [882, 1, "ͳ"], [883, 2], [884, 1, "ʹ"], [885, 2], [886, 1, "ͷ"], [887, 2], [[888, 889], 3], [890, 1, " ι"], [[891, 893], 2], [894, 1, ";"], [895, 1, "ϳ"], [[896, 899], 3], [900, 1, " ́"], [901, 1, " ̈́"], [902, 1, "ά"], [903, 1, "·"], [904, 1, "έ"], [905, 1, "ή"], [906, 1, "ί"], [907, 3], [908, 1, "ό"], [909, 3], [910, 1, "ύ"], [911, 1, "ώ"], [912, 2], [913, 1, "α"], [914, 1, "β"], [915, 1, "γ"], [916, 1, "δ"], [917, 1, "ε"], [918, 1, "ζ"], [919, 1, "η"], [920, 1, "θ"], [921, 1, "ι"], [922, 1, "κ"], [923, 1, "λ"], [924, 1, "μ"], [925, 1, "ν"], [926, 1, "ξ"], [927, 1, "ο"], [928, 1, "π"], [929, 1, "ρ"], [930, 3], [931, 1, "σ"], [932, 1, "τ"], [933, 1, "υ"], [934, 1, "φ"], [935, 1, "χ"], [936, 1, "ψ"], [937, 1, "ω"], [938, 1, "ϊ"], [939, 1, "ϋ"], [[940, 961], 2], [962, 6, "σ"], [[963, 974], 2], [975, 1, "ϗ"], [976, 1, "β"], [977, 1, "θ"], [978, 1, "υ"], [979, 1, "ύ"], [980, 1, "ϋ"], [981, 1, "φ"], [982, 1, "π"], [983, 2], [984, 1, "ϙ"], [985, 2], [986, 1, "ϛ"], [987, 2], [988, 1, "ϝ"], [989, 2], [990, 1, "ϟ"], [991, 2], [992, 1, "ϡ"], [993, 2], [994, 1, "ϣ"], [995, 2], [996, 1, "ϥ"], [997, 2], [998, 1, "ϧ"], [999, 2], [1000, 1, "ϩ"], [1001, 2], [1002, 1, "ϫ"], [1003, 2], [1004, 1, "ϭ"], [1005, 2], [1006, 1, "ϯ"], [1007, 2], [1008, 1, "κ"], [1009, 1, "ρ"], [1010, 1, "σ"], [1011, 2], [1012, 1, "θ"], [1013, 1, "ε"], [1014, 2], [1015, 1, "ϸ"], [1016, 2], [1017, 1, "σ"], [1018, 1, "ϻ"], [1019, 2], [1020, 2], [1021, 1, "ͻ"], [1022, 1, "ͼ"], [1023, 1, "ͽ"], [1024, 1, "ѐ"], [1025, 1, "ё"], [1026, 1, "ђ"], [1027, 1, "ѓ"], [1028, 1, "є"], [1029, 1, "ѕ"], [1030, 1, "і"], [1031, 1, "ї"], [1032, 1, "ј"], [1033, 1, "љ"], [1034, 1, "њ"], [1035, 1, "ћ"], [1036, 1, "ќ"], [1037, 1, "ѝ"], [1038, 1, "ў"], [1039, 1, "џ"], [1040, 1, "а"], [1041, 1, "б"], [1042, 1, "в"], [1043, 1, "г"], [1044, 1, "д"], [1045, 1, "е"], [1046, 1, "ж"], [1047, 1, "з"], [1048, 1, "и"], [1049, 1, "й"], [1050, 1, "к"], [1051, 1, "л"], [1052, 1, "м"], [1053, 1, "н"], [1054, 1, "о"], [1055, 1, "п"], [1056, 1, "р"], [1057, 1, "с"], [1058, 1, "т"], [1059, 1, "у"], [1060, 1, "ф"], [1061, 1, "х"], [1062, 1, "ц"], [1063, 1, "ч"], [1064, 1, "ш"], [1065, 1, "щ"], [1066, 1, "ъ"], [1067, 1, "ы"], [1068, 1, "ь"], [1069, 1, "э"], [1070, 1, "ю"], [1071, 1, "я"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "ѡ"], [1121, 2], [1122, 1, "ѣ"], [1123, 2], [1124, 1, "ѥ"], [1125, 2], [1126, 1, "ѧ"], [1127, 2], [1128, 1, "ѩ"], [1129, 2], [1130, 1, "ѫ"], [1131, 2], [1132, 1, "ѭ"], [1133, 2], [1134, 1, "ѯ"], [1135, 2], [1136, 1, "ѱ"], [1137, 2], [1138, 1, "ѳ"], [1139, 2], [1140, 1, "ѵ"], [1141, 2], [1142, 1, "ѷ"], [1143, 2], [1144, 1, "ѹ"], [1145, 2], [1146, 1, "ѻ"], [1147, 2], [1148, 1, "ѽ"], [1149, 2], [1150, 1, "ѿ"], [1151, 2], [1152, 1, "ҁ"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "ҋ"], [1163, 2], [1164, 1, "ҍ"], [1165, 2], [1166, 1, "ҏ"], [1167, 2], [1168, 1, "ґ"], [1169, 2], [1170, 1, "ғ"], [1171, 2], [1172, 1, "ҕ"], [1173, 2], [1174, 1, "җ"], [1175, 2], [1176, 1, "ҙ"], [1177, 2], [1178, 1, "қ"], [1179, 2], [1180, 1, "ҝ"], [1181, 2], [1182, 1, "ҟ"], [1183, 2], [1184, 1, "ҡ"], [1185, 2], [1186, 1, "ң"], [1187, 2], [1188, 1, "ҥ"], [1189, 2], [1190, 1, "ҧ"], [1191, 2], [1192, 1, "ҩ"], [1193, 2], [1194, 1, "ҫ"], [1195, 2], [1196, 1, "ҭ"], [1197, 2], [1198, 1, "ү"], [1199, 2], [1200, 1, "ұ"], [1201, 2], [1202, 1, "ҳ"], [1203, 2], [1204, 1, "ҵ"], [1205, 2], [1206, 1, "ҷ"], [1207, 2], [1208, 1, "ҹ"], [1209, 2], [1210, 1, "һ"], [1211, 2], [1212, 1, "ҽ"], [1213, 2], [1214, 1, "ҿ"], [1215, 2], [1216, 1, "ӏ"], [1217, 1, "ӂ"], [1218, 2], [1219, 1, "ӄ"], [1220, 2], [1221, 1, "ӆ"], [1222, 2], [1223, 1, "ӈ"], [1224, 2], [1225, 1, "ӊ"], [1226, 2], [1227, 1, "ӌ"], [1228, 2], [1229, 1, "ӎ"], [1230, 2], [1231, 2], [1232, 1, "ӑ"], [1233, 2], [1234, 1, "ӓ"], [1235, 2], [1236, 1, "ӕ"], [1237, 2], [1238, 1, "ӗ"], [1239, 2], [1240, 1, "ә"], [1241, 2], [1242, 1, "ӛ"], [1243, 2], [1244, 1, "ӝ"], [1245, 2], [1246, 1, "ӟ"], [1247, 2], [1248, 1, "ӡ"], [1249, 2], [1250, 1, "ӣ"], [1251, 2], [1252, 1, "ӥ"], [1253, 2], [1254, 1, "ӧ"], [1255, 2], [1256, 1, "ө"], [1257, 2], [1258, 1, "ӫ"], [1259, 2], [1260, 1, "ӭ"], [1261, 2], [1262, 1, "ӯ"], [1263, 2], [1264, 1, "ӱ"], [1265, 2], [1266, 1, "ӳ"], [1267, 2], [1268, 1, "ӵ"], [1269, 2], [1270, 1, "ӷ"], [1271, 2], [1272, 1, "ӹ"], [1273, 2], [1274, 1, "ӻ"], [1275, 2], [1276, 1, "ӽ"], [1277, 2], [1278, 1, "ӿ"], [1279, 2], [1280, 1, "ԁ"], [1281, 2], [1282, 1, "ԃ"], [1283, 2], [1284, 1, "ԅ"], [1285, 2], [1286, 1, "ԇ"], [1287, 2], [1288, 1, "ԉ"], [1289, 2], [1290, 1, "ԋ"], [1291, 2], [1292, 1, "ԍ"], [1293, 2], [1294, 1, "ԏ"], [1295, 2], [1296, 1, "ԑ"], [1297, 2], [1298, 1, "ԓ"], [1299, 2], [1300, 1, "ԕ"], [1301, 2], [1302, 1, "ԗ"], [1303, 2], [1304, 1, "ԙ"], [1305, 2], [1306, 1, "ԛ"], [1307, 2], [1308, 1, "ԝ"], [1309, 2], [1310, 1, "ԟ"], [1311, 2], [1312, 1, "ԡ"], [1313, 2], [1314, 1, "ԣ"], [1315, 2], [1316, 1, "ԥ"], [1317, 2], [1318, 1, "ԧ"], [1319, 2], [1320, 1, "ԩ"], [1321, 2], [1322, 1, "ԫ"], [1323, 2], [1324, 1, "ԭ"], [1325, 2], [1326, 1, "ԯ"], [1327, 2], [1328, 3], [1329, 1, "ա"], [1330, 1, "բ"], [1331, 1, "գ"], [1332, 1, "դ"], [1333, 1, "ե"], [1334, 1, "զ"], [1335, 1, "է"], [1336, 1, "ը"], [1337, 1, "թ"], [1338, 1, "ժ"], [1339, 1, "ի"], [1340, 1, "լ"], [1341, 1, "խ"], [1342, 1, "ծ"], [1343, 1, "կ"], [1344, 1, "հ"], [1345, 1, "ձ"], [1346, 1, "ղ"], [1347, 1, "ճ"], [1348, 1, "մ"], [1349, 1, "յ"], [1350, 1, "ն"], [1351, 1, "շ"], [1352, 1, "ո"], [1353, 1, "չ"], [1354, 1, "պ"], [1355, 1, "ջ"], [1356, 1, "ռ"], [1357, 1, "ս"], [1358, 1, "վ"], [1359, 1, "տ"], [1360, 1, "ր"], [1361, 1, "ց"], [1362, 1, "ւ"], [1363, 1, "փ"], [1364, 1, "ք"], [1365, 1, "օ"], [1366, 1, "ֆ"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "եւ"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "اٴ"], [1654, 1, "وٴ"], [1655, 1, "ۇٴ"], [1656, 1, "يٴ"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2198], 3], [2199, 2], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "क़"], [2393, 1, "ख़"], [2394, 1, "ग़"], [2395, 1, "ज़"], [2396, 1, "ड़"], [2397, 1, "ढ़"], [2398, 1, "फ़"], [2399, 1, "य़"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "ড়"], [2525, 1, "ঢ়"], [2526, 3], [2527, 1, "য়"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "ਲ਼"], [2612, 3], [2613, 2], [2614, 1, "ਸ਼"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "ਖ਼"], [2650, 1, "ਗ਼"], [2651, 1, "ਜ਼"], [2652, 2], [2653, 3], [2654, 1, "ਫ਼"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "ଡ଼"], [2909, 1, "ଢ଼"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [3315, 2], [[3316, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "ํา"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "ໍາ"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [3790, 2], [3791, 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "ຫນ"], [3805, 1, "ຫມ"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "་"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "གྷ"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "ཌྷ"], [[3918, 3921], 2], [3922, 1, "དྷ"], [[3923, 3926], 2], [3927, 1, "བྷ"], [[3928, 3931], 2], [3932, 1, "ཛྷ"], [[3933, 3944], 2], [3945, 1, "ཀྵ"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "ཱི"], [3956, 2], [3957, 1, "ཱུ"], [3958, 1, "ྲྀ"], [3959, 1, "ྲཱྀ"], [3960, 1, "ླྀ"], [3961, 1, "ླཱྀ"], [[3962, 3968], 2], [3969, 1, "ཱྀ"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "ྒྷ"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "ྜྷ"], [[3998, 4001], 2], [4002, 1, "ྡྷ"], [[4003, 4006], 2], [4007, 1, "ྦྷ"], [[4008, 4011], 2], [4012, 1, "ྫྷ"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "ྐྵ"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [4256, 1, "ⴀ"], [4257, 1, "ⴁ"], [4258, 1, "ⴂ"], [4259, 1, "ⴃ"], [4260, 1, "ⴄ"], [4261, 1, "ⴅ"], [4262, 1, "ⴆ"], [4263, 1, "ⴇ"], [4264, 1, "ⴈ"], [4265, 1, "ⴉ"], [4266, 1, "ⴊ"], [4267, 1, "ⴋ"], [4268, 1, "ⴌ"], [4269, 1, "ⴍ"], [4270, 1, "ⴎ"], [4271, 1, "ⴏ"], [4272, 1, "ⴐ"], [4273, 1, "ⴑ"], [4274, 1, "ⴒ"], [4275, 1, "ⴓ"], [4276, 1, "ⴔ"], [4277, 1, "ⴕ"], [4278, 1, "ⴖ"], [4279, 1, "ⴗ"], [4280, 1, "ⴘ"], [4281, 1, "ⴙ"], [4282, 1, "ⴚ"], [4283, 1, "ⴛ"], [4284, 1, "ⴜ"], [4285, 1, "ⴝ"], [4286, 1, "ⴞ"], [4287, 1, "ⴟ"], [4288, 1, "ⴠ"], [4289, 1, "ⴡ"], [4290, 1, "ⴢ"], [4291, 1, "ⴣ"], [4292, 1, "ⴤ"], [4293, 1, "ⴥ"], [4294, 3], [4295, 1, "ⴧ"], [[4296, 4300], 3], [4301, 1, "ⴭ"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "ნ"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 7], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "Ᏸ"], [5113, 1, "Ᏹ"], [5114, 1, "Ᏺ"], [5115, 1, "Ᏻ"], [5116, 1, "Ᏼ"], [5117, 1, "Ᏽ"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6000], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 7], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6154], 2], [[6155, 6158], 7], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [6989, 3], [[6990, 6991], 2], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 2], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "в"], [7297, 1, "д"], [7298, 1, "о"], [7299, 1, "с"], [[7300, 7301], 1, "т"], [7302, 1, "ъ"], [7303, 1, "ѣ"], [7304, 1, "ꙋ"], [7305, 1, "ᲊ"], [7306, 2], [[7307, 7311], 3], [7312, 1, "ა"], [7313, 1, "ბ"], [7314, 1, "გ"], [7315, 1, "დ"], [7316, 1, "ე"], [7317, 1, "ვ"], [7318, 1, "ზ"], [7319, 1, "თ"], [7320, 1, "ი"], [7321, 1, "კ"], [7322, 1, "ლ"], [7323, 1, "მ"], [7324, 1, "ნ"], [7325, 1, "ო"], [7326, 1, "პ"], [7327, 1, "ჟ"], [7328, 1, "რ"], [7329, 1, "ს"], [7330, 1, "ტ"], [7331, 1, "უ"], [7332, 1, "ფ"], [7333, 1, "ქ"], [7334, 1, "ღ"], [7335, 1, "ყ"], [7336, 1, "შ"], [7337, 1, "ჩ"], [7338, 1, "ც"], [7339, 1, "ძ"], [7340, 1, "წ"], [7341, 1, "ჭ"], [7342, 1, "ხ"], [7343, 1, "ჯ"], [7344, 1, "ჰ"], [7345, 1, "ჱ"], [7346, 1, "ჲ"], [7347, 1, "ჳ"], [7348, 1, "ჴ"], [7349, 1, "ჵ"], [7350, 1, "ჶ"], [7351, 1, "ჷ"], [7352, 1, "ჸ"], [7353, 1, "ჹ"], [7354, 1, "ჺ"], [[7355, 7356], 3], [7357, 1, "ჽ"], [7358, 1, "ჾ"], [7359, 1, "ჿ"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "æ"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "ǝ"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "ȣ"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "ɐ"], [7493, 1, "ɑ"], [7494, 1, "ᴂ"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "ə"], [7499, 1, "ɛ"], [7500, 1, "ɜ"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "ŋ"], [7506, 1, "o"], [7507, 1, "ɔ"], [7508, 1, "ᴖ"], [7509, 1, "ᴗ"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "ᴝ"], [7514, 1, "ɯ"], [7515, 1, "v"], [7516, 1, "ᴥ"], [7517, 1, "β"], [7518, 1, "γ"], [7519, 1, "δ"], [7520, 1, "φ"], [7521, 1, "χ"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "β"], [7527, 1, "γ"], [7528, 1, "ρ"], [7529, 1, "φ"], [7530, 1, "χ"], [7531, 2], [[7532, 7543], 2], [7544, 1, "н"], [[7545, 7578], 2], [7579, 1, "ɒ"], [7580, 1, "c"], [7581, 1, "ɕ"], [7582, 1, "ð"], [7583, 1, "ɜ"], [7584, 1, "f"], [7585, 1, "ɟ"], [7586, 1, "ɡ"], [7587, 1, "ɥ"], [7588, 1, "ɨ"], [7589, 1, "ɩ"], [7590, 1, "ɪ"], [7591, 1, "ᵻ"], [7592, 1, "ʝ"], [7593, 1, "ɭ"], [7594, 1, "ᶅ"], [7595, 1, "ʟ"], [7596, 1, "ɱ"], [7597, 1, "ɰ"], [7598, 1, "ɲ"], [7599, 1, "ɳ"], [7600, 1, "ɴ"], [7601, 1, "ɵ"], [7602, 1, "ɸ"], [7603, 1, "ʂ"], [7604, 1, "ʃ"], [7605, 1, "ƫ"], [7606, 1, "ʉ"], [7607, 1, "ʊ"], [7608, 1, "ᴜ"], [7609, 1, "ʋ"], [7610, 1, "ʌ"], [7611, 1, "z"], [7612, 1, "ʐ"], [7613, 1, "ʑ"], [7614, 1, "ʒ"], [7615, 1, "θ"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "ḁ"], [7681, 2], [7682, 1, "ḃ"], [7683, 2], [7684, 1, "ḅ"], [7685, 2], [7686, 1, "ḇ"], [7687, 2], [7688, 1, "ḉ"], [7689, 2], [7690, 1, "ḋ"], [7691, 2], [7692, 1, "ḍ"], [7693, 2], [7694, 1, "ḏ"], [7695, 2], [7696, 1, "ḑ"], [7697, 2], [7698, 1, "ḓ"], [7699, 2], [7700, 1, "ḕ"], [7701, 2], [7702, 1, "ḗ"], [7703, 2], [7704, 1, "ḙ"], [7705, 2], [7706, 1, "ḛ"], [7707, 2], [7708, 1, "ḝ"], [7709, 2], [7710, 1, "ḟ"], [7711, 2], [7712, 1, "ḡ"], [7713, 2], [7714, 1, "ḣ"], [7715, 2], [7716, 1, "ḥ"], [7717, 2], [7718, 1, "ḧ"], [7719, 2], [7720, 1, "ḩ"], [7721, 2], [7722, 1, "ḫ"], [7723, 2], [7724, 1, "ḭ"], [7725, 2], [7726, 1, "ḯ"], [7727, 2], [7728, 1, "ḱ"], [7729, 2], [7730, 1, "ḳ"], [7731, 2], [7732, 1, "ḵ"], [7733, 2], [7734, 1, "ḷ"], [7735, 2], [7736, 1, "ḹ"], [7737, 2], [7738, 1, "ḻ"], [7739, 2], [7740, 1, "ḽ"], [7741, 2], [7742, 1, "ḿ"], [7743, 2], [7744, 1, "ṁ"], [7745, 2], [7746, 1, "ṃ"], [7747, 2], [7748, 1, "ṅ"], [7749, 2], [7750, 1, "ṇ"], [7751, 2], [7752, 1, "ṉ"], [7753, 2], [7754, 1, "ṋ"], [7755, 2], [7756, 1, "ṍ"], [7757, 2], [7758, 1, "ṏ"], [7759, 2], [7760, 1, "ṑ"], [7761, 2], [7762, 1, "ṓ"], [7763, 2], [7764, 1, "ṕ"], [7765, 2], [7766, 1, "ṗ"], [7767, 2], [7768, 1, "ṙ"], [7769, 2], [7770, 1, "ṛ"], [7771, 2], [7772, 1, "ṝ"], [7773, 2], [7774, 1, "ṟ"], [7775, 2], [7776, 1, "ṡ"], [7777, 2], [7778, 1, "ṣ"], [7779, 2], [7780, 1, "ṥ"], [7781, 2], [7782, 1, "ṧ"], [7783, 2], [7784, 1, "ṩ"], [7785, 2], [7786, 1, "ṫ"], [7787, 2], [7788, 1, "ṭ"], [7789, 2], [7790, 1, "ṯ"], [7791, 2], [7792, 1, "ṱ"], [7793, 2], [7794, 1, "ṳ"], [7795, 2], [7796, 1, "ṵ"], [7797, 2], [7798, 1, "ṷ"], [7799, 2], [7800, 1, "ṹ"], [7801, 2], [7802, 1, "ṻ"], [7803, 2], [7804, 1, "ṽ"], [7805, 2], [7806, 1, "ṿ"], [7807, 2], [7808, 1, "ẁ"], [7809, 2], [7810, 1, "ẃ"], [7811, 2], [7812, 1, "ẅ"], [7813, 2], [7814, 1, "ẇ"], [7815, 2], [7816, 1, "ẉ"], [7817, 2], [7818, 1, "ẋ"], [7819, 2], [7820, 1, "ẍ"], [7821, 2], [7822, 1, "ẏ"], [7823, 2], [7824, 1, "ẑ"], [7825, 2], [7826, 1, "ẓ"], [7827, 2], [7828, 1, "ẕ"], [[7829, 7833], 2], [7834, 1, "aʾ"], [7835, 1, "ṡ"], [[7836, 7837], 2], [7838, 1, "ß"], [7839, 2], [7840, 1, "ạ"], [7841, 2], [7842, 1, "ả"], [7843, 2], [7844, 1, "ấ"], [7845, 2], [7846, 1, "ầ"], [7847, 2], [7848, 1, "ẩ"], [7849, 2], [7850, 1, "ẫ"], [7851, 2], [7852, 1, "ậ"], [7853, 2], [7854, 1, "ắ"], [7855, 2], [7856, 1, "ằ"], [7857, 2], [7858, 1, "ẳ"], [7859, 2], [7860, 1, "ẵ"], [7861, 2], [7862, 1, "ặ"], [7863, 2], [7864, 1, "ẹ"], [7865, 2], [7866, 1, "ẻ"], [7867, 2], [7868, 1, "ẽ"], [7869, 2], [7870, 1, "ế"], [7871, 2], [7872, 1, "ề"], [7873, 2], [7874, 1, "ể"], [7875, 2], [7876, 1, "ễ"], [7877, 2], [7878, 1, "ệ"], [7879, 2], [7880, 1, "ỉ"], [7881, 2], [7882, 1, "ị"], [7883, 2], [7884, 1, "ọ"], [7885, 2], [7886, 1, "ỏ"], [7887, 2], [7888, 1, "ố"], [7889, 2], [7890, 1, "ồ"], [7891, 2], [7892, 1, "ổ"], [7893, 2], [7894, 1, "ỗ"], [7895, 2], [7896, 1, "ộ"], [7897, 2], [7898, 1, "ớ"], [7899, 2], [7900, 1, "ờ"], [7901, 2], [7902, 1, "ở"], [7903, 2], [7904, 1, "ỡ"], [7905, 2], [7906, 1, "ợ"], [7907, 2], [7908, 1, "ụ"], [7909, 2], [7910, 1, "ủ"], [7911, 2], [7912, 1, "ứ"], [7913, 2], [7914, 1, "ừ"], [7915, 2], [7916, 1, "ử"], [7917, 2], [7918, 1, "ữ"], [7919, 2], [7920, 1, "ự"], [7921, 2], [7922, 1, "ỳ"], [7923, 2], [7924, 1, "ỵ"], [7925, 2], [7926, 1, "ỷ"], [7927, 2], [7928, 1, "ỹ"], [7929, 2], [7930, 1, "ỻ"], [7931, 2], [7932, 1, "ỽ"], [7933, 2], [7934, 1, "ỿ"], [7935, 2], [[7936, 7943], 2], [7944, 1, "ἀ"], [7945, 1, "ἁ"], [7946, 1, "ἂ"], [7947, 1, "ἃ"], [7948, 1, "ἄ"], [7949, 1, "ἅ"], [7950, 1, "ἆ"], [7951, 1, "ἇ"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "ἐ"], [7961, 1, "ἑ"], [7962, 1, "ἒ"], [7963, 1, "ἓ"], [7964, 1, "ἔ"], [7965, 1, "ἕ"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "ἠ"], [7977, 1, "ἡ"], [7978, 1, "ἢ"], [7979, 1, "ἣ"], [7980, 1, "ἤ"], [7981, 1, "ἥ"], [7982, 1, "ἦ"], [7983, 1, "ἧ"], [[7984, 7991], 2], [7992, 1, "ἰ"], [7993, 1, "ἱ"], [7994, 1, "ἲ"], [7995, 1, "ἳ"], [7996, 1, "ἴ"], [7997, 1, "ἵ"], [7998, 1, "ἶ"], [7999, 1, "ἷ"], [[8000, 8005], 2], [[8006, 8007], 3], [8008, 1, "ὀ"], [8009, 1, "ὁ"], [8010, 1, "ὂ"], [8011, 1, "ὃ"], [8012, 1, "ὄ"], [8013, 1, "ὅ"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "ὑ"], [8026, 3], [8027, 1, "ὓ"], [8028, 3], [8029, 1, "ὕ"], [8030, 3], [8031, 1, "ὗ"], [[8032, 8039], 2], [8040, 1, "ὠ"], [8041, 1, "ὡ"], [8042, 1, "ὢ"], [8043, 1, "ὣ"], [8044, 1, "ὤ"], [8045, 1, "ὥ"], [8046, 1, "ὦ"], [8047, 1, "ὧ"], [8048, 2], [8049, 1, "ά"], [8050, 2], [8051, 1, "έ"], [8052, 2], [8053, 1, "ή"], [8054, 2], [8055, 1, "ί"], [8056, 2], [8057, 1, "ό"], [8058, 2], [8059, 1, "ύ"], [8060, 2], [8061, 1, "ώ"], [[8062, 8063], 3], [8064, 1, "ἀι"], [8065, 1, "ἁι"], [8066, 1, "ἂι"], [8067, 1, "ἃι"], [8068, 1, "ἄι"], [8069, 1, "ἅι"], [8070, 1, "ἆι"], [8071, 1, "ἇι"], [8072, 1, "ἀι"], [8073, 1, "ἁι"], [8074, 1, "ἂι"], [8075, 1, "ἃι"], [8076, 1, "ἄι"], [8077, 1, "ἅι"], [8078, 1, "ἆι"], [8079, 1, "ἇι"], [8080, 1, "ἠι"], [8081, 1, "ἡι"], [8082, 1, "ἢι"], [8083, 1, "ἣι"], [8084, 1, "ἤι"], [8085, 1, "ἥι"], [8086, 1, "ἦι"], [8087, 1, "ἧι"], [8088, 1, "ἠι"], [8089, 1, "ἡι"], [8090, 1, "ἢι"], [8091, 1, "ἣι"], [8092, 1, "ἤι"], [8093, 1, "ἥι"], [8094, 1, "ἦι"], [8095, 1, "ἧι"], [8096, 1, "ὠι"], [8097, 1, "ὡι"], [8098, 1, "ὢι"], [8099, 1, "ὣι"], [8100, 1, "ὤι"], [8101, 1, "ὥι"], [8102, 1, "ὦι"], [8103, 1, "ὧι"], [8104, 1, "ὠι"], [8105, 1, "ὡι"], [8106, 1, "ὢι"], [8107, 1, "ὣι"], [8108, 1, "ὤι"], [8109, 1, "ὥι"], [8110, 1, "ὦι"], [8111, 1, "ὧι"], [[8112, 8113], 2], [8114, 1, "ὰι"], [8115, 1, "αι"], [8116, 1, "άι"], [8117, 3], [8118, 2], [8119, 1, "ᾶι"], [8120, 1, "ᾰ"], [8121, 1, "ᾱ"], [8122, 1, "ὰ"], [8123, 1, "ά"], [8124, 1, "αι"], [8125, 1, " ̓"], [8126, 1, "ι"], [8127, 1, " ̓"], [8128, 1, " ͂"], [8129, 1, " ̈͂"], [8130, 1, "ὴι"], [8131, 1, "ηι"], [8132, 1, "ήι"], [8133, 3], [8134, 2], [8135, 1, "ῆι"], [8136, 1, "ὲ"], [8137, 1, "έ"], [8138, 1, "ὴ"], [8139, 1, "ή"], [8140, 1, "ηι"], [8141, 1, " ̓̀"], [8142, 1, " ̓́"], [8143, 1, " ̓͂"], [[8144, 8146], 2], [8147, 1, "ΐ"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "ῐ"], [8153, 1, "ῑ"], [8154, 1, "ὶ"], [8155, 1, "ί"], [8156, 3], [8157, 1, " ̔̀"], [8158, 1, " ̔́"], [8159, 1, " ̔͂"], [[8160, 8162], 2], [8163, 1, "ΰ"], [[8164, 8167], 2], [8168, 1, "ῠ"], [8169, 1, "ῡ"], [8170, 1, "ὺ"], [8171, 1, "ύ"], [8172, 1, "ῥ"], [8173, 1, " ̈̀"], [8174, 1, " ̈́"], [8175, 1, "`"], [[8176, 8177], 3], [8178, 1, "ὼι"], [8179, 1, "ωι"], [8180, 1, "ώι"], [8181, 3], [8182, 2], [8183, 1, "ῶι"], [8184, 1, "ὸ"], [8185, 1, "ό"], [8186, 1, "ὼ"], [8187, 1, "ώ"], [8188, 1, "ωι"], [8189, 1, " ́"], [8190, 1, " ̔"], [8191, 3], [[8192, 8202], 1, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "‐"], [[8210, 8214], 2], [8215, 1, " ̳"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 1, " "], [[8240, 8242], 2], [8243, 1, "′′"], [8244, 1, "′′′"], [8245, 2], [8246, 1, "‵‵"], [8247, 1, "‵‵‵"], [[8248, 8251], 2], [8252, 1, "!!"], [8253, 2], [8254, 1, " ̅"], [[8255, 8262], 2], [8263, 1, "??"], [8264, 1, "?!"], [8265, 1, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "′′′′"], [[8280, 8286], 2], [8287, 1, " "], [[8288, 8291], 7], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 7], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 1, "+"], [8315, 1, "−"], [8316, 1, "="], [8317, 1, "("], [8318, 1, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 1, "+"], [8331, 1, "−"], [8332, 1, "="], [8333, 1, "("], [8334, 1, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "ə"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 1, "a/c"], [8449, 1, "a/s"], [8450, 1, "c"], [8451, 1, "°c"], [8452, 2], [8453, 1, "c/o"], [8454, 1, "c/u"], [8455, 1, "ɛ"], [8456, 2], [8457, 1, "°f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "ħ"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "ω"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "å"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 1, "ⅎ"], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "א"], [8502, 1, "ב"], [8503, 1, "ג"], [8504, 1, "ד"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "π"], [[8509, 8510], 1, "γ"], [8511, 1, "π"], [8512, 1, "∑"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1⁄7"], [8529, 1, "1⁄9"], [8530, 1, "1⁄10"], [8531, 1, "1⁄3"], [8532, 1, "2⁄3"], [8533, 1, "1⁄5"], [8534, 1, "2⁄5"], [8535, 1, "3⁄5"], [8536, 1, "4⁄5"], [8537, 1, "1⁄6"], [8538, 1, "5⁄6"], [8539, 1, "1⁄8"], [8540, 1, "3⁄8"], [8541, 1, "5⁄8"], [8542, 1, "7⁄8"], [8543, 1, "1⁄"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 1, "ↄ"], [8580, 2], [[8581, 8584], 2], [8585, 1, "0⁄3"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "∫∫"], [8749, 1, "∫∫∫"], [8750, 2], [8751, 1, "∮∮"], [8752, 1, "∮∮∮"], [[8753, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9000], 2], [9001, 1, "〈"], [9002, 1, "〉"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9257], 2], [[9258, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 1, "(1)"], [9333, 1, "(2)"], [9334, 1, "(3)"], [9335, 1, "(4)"], [9336, 1, "(5)"], [9337, 1, "(6)"], [9338, 1, "(7)"], [9339, 1, "(8)"], [9340, 1, "(9)"], [9341, 1, "(10)"], [9342, 1, "(11)"], [9343, 1, "(12)"], [9344, 1, "(13)"], [9345, 1, "(14)"], [9346, 1, "(15)"], [9347, 1, "(16)"], [9348, 1, "(17)"], [9349, 1, "(18)"], [9350, 1, "(19)"], [9351, 1, "(20)"], [[9352, 9371], 3], [9372, 1, "(a)"], [9373, 1, "(b)"], [9374, 1, "(c)"], [9375, 1, "(d)"], [9376, 1, "(e)"], [9377, 1, "(f)"], [9378, 1, "(g)"], [9379, 1, "(h)"], [9380, 1, "(i)"], [9381, 1, "(j)"], [9382, 1, "(k)"], [9383, 1, "(l)"], [9384, 1, "(m)"], [9385, 1, "(n)"], [9386, 1, "(o)"], [9387, 1, "(p)"], [9388, 1, "(q)"], [9389, 1, "(r)"], [9390, 1, "(s)"], [9391, 1, "(t)"], [9392, 1, "(u)"], [9393, 1, "(v)"], [9394, 1, "(w)"], [9395, 1, "(x)"], [9396, 1, "(y)"], [9397, 1, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "∫∫∫∫"], [[10765, 10867], 2], [10868, 1, "::="], [10869, 1, "=="], [10870, 1, "==="], [[10871, 10971], 2], [10972, 1, "⫝̸"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "ⰰ"], [11265, 1, "ⰱ"], [11266, 1, "ⰲ"], [11267, 1, "ⰳ"], [11268, 1, "ⰴ"], [11269, 1, "ⰵ"], [11270, 1, "ⰶ"], [11271, 1, "ⰷ"], [11272, 1, "ⰸ"], [11273, 1, "ⰹ"], [11274, 1, "ⰺ"], [11275, 1, "ⰻ"], [11276, 1, "ⰼ"], [11277, 1, "ⰽ"], [11278, 1, "ⰾ"], [11279, 1, "ⰿ"], [11280, 1, "ⱀ"], [11281, 1, "ⱁ"], [11282, 1, "ⱂ"], [11283, 1, "ⱃ"], [11284, 1, "ⱄ"], [11285, 1, "ⱅ"], [11286, 1, "ⱆ"], [11287, 1, "ⱇ"], [11288, 1, "ⱈ"], [11289, 1, "ⱉ"], [11290, 1, "ⱊ"], [11291, 1, "ⱋ"], [11292, 1, "ⱌ"], [11293, 1, "ⱍ"], [11294, 1, "ⱎ"], [11295, 1, "ⱏ"], [11296, 1, "ⱐ"], [11297, 1, "ⱑ"], [11298, 1, "ⱒ"], [11299, 1, "ⱓ"], [11300, 1, "ⱔ"], [11301, 1, "ⱕ"], [11302, 1, "ⱖ"], [11303, 1, "ⱗ"], [11304, 1, "ⱘ"], [11305, 1, "ⱙ"], [11306, 1, "ⱚ"], [11307, 1, "ⱛ"], [11308, 1, "ⱜ"], [11309, 1, "ⱝ"], [11310, 1, "ⱞ"], [11311, 1, "ⱟ"], [[11312, 11358], 2], [11359, 2], [11360, 1, "ⱡ"], [11361, 2], [11362, 1, "ɫ"], [11363, 1, "ᵽ"], [11364, 1, "ɽ"], [[11365, 11366], 2], [11367, 1, "ⱨ"], [11368, 2], [11369, 1, "ⱪ"], [11370, 2], [11371, 1, "ⱬ"], [11372, 2], [11373, 1, "ɑ"], [11374, 1, "ɱ"], [11375, 1, "ɐ"], [11376, 1, "ɒ"], [11377, 2], [11378, 1, "ⱳ"], [11379, 2], [11380, 2], [11381, 1, "ⱶ"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "ȿ"], [11391, 1, "ɀ"], [11392, 1, "ⲁ"], [11393, 2], [11394, 1, "ⲃ"], [11395, 2], [11396, 1, "ⲅ"], [11397, 2], [11398, 1, "ⲇ"], [11399, 2], [11400, 1, "ⲉ"], [11401, 2], [11402, 1, "ⲋ"], [11403, 2], [11404, 1, "ⲍ"], [11405, 2], [11406, 1, "ⲏ"], [11407, 2], [11408, 1, "ⲑ"], [11409, 2], [11410, 1, "ⲓ"], [11411, 2], [11412, 1, "ⲕ"], [11413, 2], [11414, 1, "ⲗ"], [11415, 2], [11416, 1, "ⲙ"], [11417, 2], [11418, 1, "ⲛ"], [11419, 2], [11420, 1, "ⲝ"], [11421, 2], [11422, 1, "ⲟ"], [11423, 2], [11424, 1, "ⲡ"], [11425, 2], [11426, 1, "ⲣ"], [11427, 2], [11428, 1, "ⲥ"], [11429, 2], [11430, 1, "ⲧ"], [11431, 2], [11432, 1, "ⲩ"], [11433, 2], [11434, 1, "ⲫ"], [11435, 2], [11436, 1, "ⲭ"], [11437, 2], [11438, 1, "ⲯ"], [11439, 2], [11440, 1, "ⲱ"], [11441, 2], [11442, 1, "ⲳ"], [11443, 2], [11444, 1, "ⲵ"], [11445, 2], [11446, 1, "ⲷ"], [11447, 2], [11448, 1, "ⲹ"], [11449, 2], [11450, 1, "ⲻ"], [11451, 2], [11452, 1, "ⲽ"], [11453, 2], [11454, 1, "ⲿ"], [11455, 2], [11456, 1, "ⳁ"], [11457, 2], [11458, 1, "ⳃ"], [11459, 2], [11460, 1, "ⳅ"], [11461, 2], [11462, 1, "ⳇ"], [11463, 2], [11464, 1, "ⳉ"], [11465, 2], [11466, 1, "ⳋ"], [11467, 2], [11468, 1, "ⳍ"], [11469, 2], [11470, 1, "ⳏ"], [11471, 2], [11472, 1, "ⳑ"], [11473, 2], [11474, 1, "ⳓ"], [11475, 2], [11476, 1, "ⳕ"], [11477, 2], [11478, 1, "ⳗ"], [11479, 2], [11480, 1, "ⳙ"], [11481, 2], [11482, 1, "ⳛ"], [11483, 2], [11484, 1, "ⳝ"], [11485, 2], [11486, 1, "ⳟ"], [11487, 2], [11488, 1, "ⳡ"], [11489, 2], [11490, 1, "ⳣ"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "ⳬ"], [11500, 2], [11501, 1, "ⳮ"], [[11502, 11505], 2], [11506, 1, "ⳳ"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "ⵡ"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "母"], [[11936, 12018], 2], [12019, 1, "龟"], [[12020, 12031], 3], [12032, 1, "一"], [12033, 1, "丨"], [12034, 1, "丶"], [12035, 1, "丿"], [12036, 1, "乙"], [12037, 1, "亅"], [12038, 1, "二"], [12039, 1, "亠"], [12040, 1, "人"], [12041, 1, "儿"], [12042, 1, "入"], [12043, 1, "八"], [12044, 1, "冂"], [12045, 1, "冖"], [12046, 1, "冫"], [12047, 1, "几"], [12048, 1, "凵"], [12049, 1, "刀"], [12050, 1, "力"], [12051, 1, "勹"], [12052, 1, "匕"], [12053, 1, "匚"], [12054, 1, "匸"], [12055, 1, "十"], [12056, 1, "卜"], [12057, 1, "卩"], [12058, 1, "厂"], [12059, 1, "厶"], [12060, 1, "又"], [12061, 1, "口"], [12062, 1, "囗"], [12063, 1, "土"], [12064, 1, "士"], [12065, 1, "夂"], [12066, 1, "夊"], [12067, 1, "夕"], [12068, 1, "大"], [12069, 1, "女"], [12070, 1, "子"], [12071, 1, "宀"], [12072, 1, "寸"], [12073, 1, "小"], [12074, 1, "尢"], [12075, 1, "尸"], [12076, 1, "屮"], [12077, 1, "山"], [12078, 1, "巛"], [12079, 1, "工"], [12080, 1, "己"], [12081, 1, "巾"], [12082, 1, "干"], [12083, 1, "幺"], [12084, 1, "广"], [12085, 1, "廴"], [12086, 1, "廾"], [12087, 1, "弋"], [12088, 1, "弓"], [12089, 1, "彐"], [12090, 1, "彡"], [12091, 1, "彳"], [12092, 1, "心"], [12093, 1, "戈"], [12094, 1, "戶"], [12095, 1, "手"], [12096, 1, "支"], [12097, 1, "攴"], [12098, 1, "文"], [12099, 1, "斗"], [12100, 1, "斤"], [12101, 1, "方"], [12102, 1, "无"], [12103, 1, "日"], [12104, 1, "曰"], [12105, 1, "月"], [12106, 1, "木"], [12107, 1, "欠"], [12108, 1, "止"], [12109, 1, "歹"], [12110, 1, "殳"], [12111, 1, "毋"], [12112, 1, "比"], [12113, 1, "毛"], [12114, 1, "氏"], [12115, 1, "气"], [12116, 1, "水"], [12117, 1, "火"], [12118, 1, "爪"], [12119, 1, "父"], [12120, 1, "爻"], [12121, 1, "爿"], [12122, 1, "片"], [12123, 1, "牙"], [12124, 1, "牛"], [12125, 1, "犬"], [12126, 1, "玄"], [12127, 1, "玉"], [12128, 1, "瓜"], [12129, 1, "瓦"], [12130, 1, "甘"], [12131, 1, "生"], [12132, 1, "用"], [12133, 1, "田"], [12134, 1, "疋"], [12135, 1, "疒"], [12136, 1, "癶"], [12137, 1, "白"], [12138, 1, "皮"], [12139, 1, "皿"], [12140, 1, "目"], [12141, 1, "矛"], [12142, 1, "矢"], [12143, 1, "石"], [12144, 1, "示"], [12145, 1, "禸"], [12146, 1, "禾"], [12147, 1, "穴"], [12148, 1, "立"], [12149, 1, "竹"], [12150, 1, "米"], [12151, 1, "糸"], [12152, 1, "缶"], [12153, 1, "网"], [12154, 1, "羊"], [12155, 1, "羽"], [12156, 1, "老"], [12157, 1, "而"], [12158, 1, "耒"], [12159, 1, "耳"], [12160, 1, "聿"], [12161, 1, "肉"], [12162, 1, "臣"], [12163, 1, "自"], [12164, 1, "至"], [12165, 1, "臼"], [12166, 1, "舌"], [12167, 1, "舛"], [12168, 1, "舟"], [12169, 1, "艮"], [12170, 1, "色"], [12171, 1, "艸"], [12172, 1, "虍"], [12173, 1, "虫"], [12174, 1, "血"], [12175, 1, "行"], [12176, 1, "衣"], [12177, 1, "襾"], [12178, 1, "見"], [12179, 1, "角"], [12180, 1, "言"], [12181, 1, "谷"], [12182, 1, "豆"], [12183, 1, "豕"], [12184, 1, "豸"], [12185, 1, "貝"], [12186, 1, "赤"], [12187, 1, "走"], [12188, 1, "足"], [12189, 1, "身"], [12190, 1, "車"], [12191, 1, "辛"], [12192, 1, "辰"], [12193, 1, "辵"], [12194, 1, "邑"], [12195, 1, "酉"], [12196, 1, "釆"], [12197, 1, "里"], [12198, 1, "金"], [12199, 1, "長"], [12200, 1, "門"], [12201, 1, "阜"], [12202, 1, "隶"], [12203, 1, "隹"], [12204, 1, "雨"], [12205, 1, "靑"], [12206, 1, "非"], [12207, 1, "面"], [12208, 1, "革"], [12209, 1, "韋"], [12210, 1, "韭"], [12211, 1, "音"], [12212, 1, "頁"], [12213, 1, "風"], [12214, 1, "飛"], [12215, 1, "食"], [12216, 1, "首"], [12217, 1, "香"], [12218, 1, "馬"], [12219, 1, "骨"], [12220, 1, "高"], [12221, 1, "髟"], [12222, 1, "鬥"], [12223, 1, "鬯"], [12224, 1, "鬲"], [12225, 1, "鬼"], [12226, 1, "魚"], [12227, 1, "鳥"], [12228, 1, "鹵"], [12229, 1, "鹿"], [12230, 1, "麥"], [12231, 1, "麻"], [12232, 1, "黃"], [12233, 1, "黍"], [12234, 1, "黑"], [12235, 1, "黹"], [12236, 1, "黽"], [12237, 1, "鼎"], [12238, 1, "鼓"], [12239, 1, "鼠"], [12240, 1, "鼻"], [12241, 1, "齊"], [12242, 1, "齒"], [12243, 1, "龍"], [12244, 1, "龜"], [12245, 1, "龠"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 1, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "〒"], [12343, 2], [12344, 1, "十"], [12345, 1, "卄"], [12346, 1, "卅"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 1, " ゙"], [12444, 1, " ゚"], [[12445, 12446], 2], [12447, 1, "より"], [12448, 2], [[12449, 12542], 2], [12543, 1, "コト"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "ᄀ"], [12594, 1, "ᄁ"], [12595, 1, "ᆪ"], [12596, 1, "ᄂ"], [12597, 1, "ᆬ"], [12598, 1, "ᆭ"], [12599, 1, "ᄃ"], [12600, 1, "ᄄ"], [12601, 1, "ᄅ"], [12602, 1, "ᆰ"], [12603, 1, "ᆱ"], [12604, 1, "ᆲ"], [12605, 1, "ᆳ"], [12606, 1, "ᆴ"], [12607, 1, "ᆵ"], [12608, 1, "ᄚ"], [12609, 1, "ᄆ"], [12610, 1, "ᄇ"], [12611, 1, "ᄈ"], [12612, 1, "ᄡ"], [12613, 1, "ᄉ"], [12614, 1, "ᄊ"], [12615, 1, "ᄋ"], [12616, 1, "ᄌ"], [12617, 1, "ᄍ"], [12618, 1, "ᄎ"], [12619, 1, "ᄏ"], [12620, 1, "ᄐ"], [12621, 1, "ᄑ"], [12622, 1, "ᄒ"], [12623, 1, "ᅡ"], [12624, 1, "ᅢ"], [12625, 1, "ᅣ"], [12626, 1, "ᅤ"], [12627, 1, "ᅥ"], [12628, 1, "ᅦ"], [12629, 1, "ᅧ"], [12630, 1, "ᅨ"], [12631, 1, "ᅩ"], [12632, 1, "ᅪ"], [12633, 1, "ᅫ"], [12634, 1, "ᅬ"], [12635, 1, "ᅭ"], [12636, 1, "ᅮ"], [12637, 1, "ᅯ"], [12638, 1, "ᅰ"], [12639, 1, "ᅱ"], [12640, 1, "ᅲ"], [12641, 1, "ᅳ"], [12642, 1, "ᅴ"], [12643, 1, "ᅵ"], [12644, 7], [12645, 1, "ᄔ"], [12646, 1, "ᄕ"], [12647, 1, "ᇇ"], [12648, 1, "ᇈ"], [12649, 1, "ᇌ"], [12650, 1, "ᇎ"], [12651, 1, "ᇓ"], [12652, 1, "ᇗ"], [12653, 1, "ᇙ"], [12654, 1, "ᄜ"], [12655, 1, "ᇝ"], [12656, 1, "ᇟ"], [12657, 1, "ᄝ"], [12658, 1, "ᄞ"], [12659, 1, "ᄠ"], [12660, 1, "ᄢ"], [12661, 1, "ᄣ"], [12662, 1, "ᄧ"], [12663, 1, "ᄩ"], [12664, 1, "ᄫ"], [12665, 1, "ᄬ"], [12666, 1, "ᄭ"], [12667, 1, "ᄮ"], [12668, 1, "ᄯ"], [12669, 1, "ᄲ"], [12670, 1, "ᄶ"], [12671, 1, "ᅀ"], [12672, 1, "ᅇ"], [12673, 1, "ᅌ"], [12674, 1, "ᇱ"], [12675, 1, "ᇲ"], [12676, 1, "ᅗ"], [12677, 1, "ᅘ"], [12678, 1, "ᅙ"], [12679, 1, "ᆄ"], [12680, 1, "ᆅ"], [12681, 1, "ᆈ"], [12682, 1, "ᆑ"], [12683, 1, "ᆒ"], [12684, 1, "ᆔ"], [12685, 1, "ᆞ"], [12686, 1, "ᆡ"], [12687, 3], [[12688, 12689], 2], [12690, 1, "一"], [12691, 1, "二"], [12692, 1, "三"], [12693, 1, "四"], [12694, 1, "上"], [12695, 1, "中"], [12696, 1, "下"], [12697, 1, "甲"], [12698, 1, "乙"], [12699, 1, "丙"], [12700, 1, "丁"], [12701, 1, "天"], [12702, 1, "地"], [12703, 1, "人"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12773], 2], [[12774, 12782], 3], [12783, 3], [[12784, 12799], 2], [12800, 1, "(ᄀ)"], [12801, 1, "(ᄂ)"], [12802, 1, "(ᄃ)"], [12803, 1, "(ᄅ)"], [12804, 1, "(ᄆ)"], [12805, 1, "(ᄇ)"], [12806, 1, "(ᄉ)"], [12807, 1, "(ᄋ)"], [12808, 1, "(ᄌ)"], [12809, 1, "(ᄎ)"], [12810, 1, "(ᄏ)"], [12811, 1, "(ᄐ)"], [12812, 1, "(ᄑ)"], [12813, 1, "(ᄒ)"], [12814, 1, "(가)"], [12815, 1, "(나)"], [12816, 1, "(다)"], [12817, 1, "(라)"], [12818, 1, "(마)"], [12819, 1, "(바)"], [12820, 1, "(사)"], [12821, 1, "(아)"], [12822, 1, "(자)"], [12823, 1, "(차)"], [12824, 1, "(카)"], [12825, 1, "(타)"], [12826, 1, "(파)"], [12827, 1, "(하)"], [12828, 1, "(주)"], [12829, 1, "(오전)"], [12830, 1, "(오후)"], [12831, 3], [12832, 1, "(一)"], [12833, 1, "(二)"], [12834, 1, "(三)"], [12835, 1, "(四)"], [12836, 1, "(五)"], [12837, 1, "(六)"], [12838, 1, "(七)"], [12839, 1, "(八)"], [12840, 1, "(九)"], [12841, 1, "(十)"], [12842, 1, "(月)"], [12843, 1, "(火)"], [12844, 1, "(水)"], [12845, 1, "(木)"], [12846, 1, "(金)"], [12847, 1, "(土)"], [12848, 1, "(日)"], [12849, 1, "(株)"], [12850, 1, "(有)"], [12851, 1, "(社)"], [12852, 1, "(名)"], [12853, 1, "(特)"], [12854, 1, "(財)"], [12855, 1, "(祝)"], [12856, 1, "(労)"], [12857, 1, "(代)"], [12858, 1, "(呼)"], [12859, 1, "(学)"], [12860, 1, "(監)"], [12861, 1, "(企)"], [12862, 1, "(資)"], [12863, 1, "(協)"], [12864, 1, "(祭)"], [12865, 1, "(休)"], [12866, 1, "(自)"], [12867, 1, "(至)"], [12868, 1, "問"], [12869, 1, "幼"], [12870, 1, "文"], [12871, 1, "箏"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "ᄀ"], [12897, 1, "ᄂ"], [12898, 1, "ᄃ"], [12899, 1, "ᄅ"], [12900, 1, "ᄆ"], [12901, 1, "ᄇ"], [12902, 1, "ᄉ"], [12903, 1, "ᄋ"], [12904, 1, "ᄌ"], [12905, 1, "ᄎ"], [12906, 1, "ᄏ"], [12907, 1, "ᄐ"], [12908, 1, "ᄑ"], [12909, 1, "ᄒ"], [12910, 1, "가"], [12911, 1, "나"], [12912, 1, "다"], [12913, 1, "라"], [12914, 1, "마"], [12915, 1, "바"], [12916, 1, "사"], [12917, 1, "아"], [12918, 1, "자"], [12919, 1, "차"], [12920, 1, "카"], [12921, 1, "타"], [12922, 1, "파"], [12923, 1, "하"], [12924, 1, "참고"], [12925, 1, "주의"], [12926, 1, "우"], [12927, 2], [12928, 1, "一"], [12929, 1, "二"], [12930, 1, "三"], [12931, 1, "四"], [12932, 1, "五"], [12933, 1, "六"], [12934, 1, "七"], [12935, 1, "八"], [12936, 1, "九"], [12937, 1, "十"], [12938, 1, "月"], [12939, 1, "火"], [12940, 1, "水"], [12941, 1, "木"], [12942, 1, "金"], [12943, 1, "土"], [12944, 1, "日"], [12945, 1, "株"], [12946, 1, "有"], [12947, 1, "社"], [12948, 1, "名"], [12949, 1, "特"], [12950, 1, "財"], [12951, 1, "祝"], [12952, 1, "労"], [12953, 1, "秘"], [12954, 1, "男"], [12955, 1, "女"], [12956, 1, "適"], [12957, 1, "優"], [12958, 1, "印"], [12959, 1, "注"], [12960, 1, "項"], [12961, 1, "休"], [12962, 1, "写"], [12963, 1, "正"], [12964, 1, "上"], [12965, 1, "中"], [12966, 1, "下"], [12967, 1, "左"], [12968, 1, "右"], [12969, 1, "医"], [12970, 1, "宗"], [12971, 1, "学"], [12972, 1, "監"], [12973, 1, "企"], [12974, 1, "資"], [12975, 1, "協"], [12976, 1, "夜"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1月"], [12993, 1, "2月"], [12994, 1, "3月"], [12995, 1, "4月"], [12996, 1, "5月"], [12997, 1, "6月"], [12998, 1, "7月"], [12999, 1, "8月"], [13000, 1, "9月"], [13001, 1, "10月"], [13002, 1, "11月"], [13003, 1, "12月"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "ア"], [13009, 1, "イ"], [13010, 1, "ウ"], [13011, 1, "エ"], [13012, 1, "オ"], [13013, 1, "カ"], [13014, 1, "キ"], [13015, 1, "ク"], [13016, 1, "ケ"], [13017, 1, "コ"], [13018, 1, "サ"], [13019, 1, "シ"], [13020, 1, "ス"], [13021, 1, "セ"], [13022, 1, "ソ"], [13023, 1, "タ"], [13024, 1, "チ"], [13025, 1, "ツ"], [13026, 1, "テ"], [13027, 1, "ト"], [13028, 1, "ナ"], [13029, 1, "ニ"], [13030, 1, "ヌ"], [13031, 1, "ネ"], [13032, 1, "ノ"], [13033, 1, "ハ"], [13034, 1, "ヒ"], [13035, 1, "フ"], [13036, 1, "ヘ"], [13037, 1, "ホ"], [13038, 1, "マ"], [13039, 1, "ミ"], [13040, 1, "ム"], [13041, 1, "メ"], [13042, 1, "モ"], [13043, 1, "ヤ"], [13044, 1, "ユ"], [13045, 1, "ヨ"], [13046, 1, "ラ"], [13047, 1, "リ"], [13048, 1, "ル"], [13049, 1, "レ"], [13050, 1, "ロ"], [13051, 1, "ワ"], [13052, 1, "ヰ"], [13053, 1, "ヱ"], [13054, 1, "ヲ"], [13055, 1, "令和"], [13056, 1, "アパート"], [13057, 1, "アルファ"], [13058, 1, "アンペア"], [13059, 1, "アール"], [13060, 1, "イニング"], [13061, 1, "インチ"], [13062, 1, "ウォン"], [13063, 1, "エスクード"], [13064, 1, "エーカー"], [13065, 1, "オンス"], [13066, 1, "オーム"], [13067, 1, "カイリ"], [13068, 1, "カラット"], [13069, 1, "カロリー"], [13070, 1, "ガロン"], [13071, 1, "ガンマ"], [13072, 1, "ギガ"], [13073, 1, "ギニー"], [13074, 1, "キュリー"], [13075, 1, "ギルダー"], [13076, 1, "キロ"], [13077, 1, "キログラム"], [13078, 1, "キロメートル"], [13079, 1, "キロワット"], [13080, 1, "グラム"], [13081, 1, "グラムトン"], [13082, 1, "クルゼイロ"], [13083, 1, "クローネ"], [13084, 1, "ケース"], [13085, 1, "コルナ"], [13086, 1, "コーポ"], [13087, 1, "サイクル"], [13088, 1, "サンチーム"], [13089, 1, "シリング"], [13090, 1, "センチ"], [13091, 1, "セント"], [13092, 1, "ダース"], [13093, 1, "デシ"], [13094, 1, "ドル"], [13095, 1, "トン"], [13096, 1, "ナノ"], [13097, 1, "ノット"], [13098, 1, "ハイツ"], [13099, 1, "パーセント"], [13100, 1, "パーツ"], [13101, 1, "バーレル"], [13102, 1, "ピアストル"], [13103, 1, "ピクル"], [13104, 1, "ピコ"], [13105, 1, "ビル"], [13106, 1, "ファラッド"], [13107, 1, "フィート"], [13108, 1, "ブッシェル"], [13109, 1, "フラン"], [13110, 1, "ヘクタール"], [13111, 1, "ペソ"], [13112, 1, "ペニヒ"], [13113, 1, "ヘルツ"], [13114, 1, "ペンス"], [13115, 1, "ページ"], [13116, 1, "ベータ"], [13117, 1, "ポイント"], [13118, 1, "ボルト"], [13119, 1, "ホン"], [13120, 1, "ポンド"], [13121, 1, "ホール"], [13122, 1, "ホーン"], [13123, 1, "マイクロ"], [13124, 1, "マイル"], [13125, 1, "マッハ"], [13126, 1, "マルク"], [13127, 1, "マンション"], [13128, 1, "ミクロン"], [13129, 1, "ミリ"], [13130, 1, "ミリバール"], [13131, 1, "メガ"], [13132, 1, "メガトン"], [13133, 1, "メートル"], [13134, 1, "ヤード"], [13135, 1, "ヤール"], [13136, 1, "ユアン"], [13137, 1, "リットル"], [13138, 1, "リラ"], [13139, 1, "ルピー"], [13140, 1, "ルーブル"], [13141, 1, "レム"], [13142, 1, "レントゲン"], [13143, 1, "ワット"], [13144, 1, "0点"], [13145, 1, "1点"], [13146, 1, "2点"], [13147, 1, "3点"], [13148, 1, "4点"], [13149, 1, "5点"], [13150, 1, "6点"], [13151, 1, "7点"], [13152, 1, "8点"], [13153, 1, "9点"], [13154, 1, "10点"], [13155, 1, "11点"], [13156, 1, "12点"], [13157, 1, "13点"], [13158, 1, "14点"], [13159, 1, "15点"], [13160, 1, "16点"], [13161, 1, "17点"], [13162, 1, "18点"], [13163, 1, "19点"], [13164, 1, "20点"], [13165, 1, "21点"], [13166, 1, "22点"], [13167, 1, "23点"], [13168, 1, "24点"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "平成"], [13180, 1, "昭和"], [13181, 1, "大正"], [13182, 1, "明治"], [13183, 1, "株式会社"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "μa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "μf"], [13197, 1, "μg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "μl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "μm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m∕s"], [13224, 1, "m∕s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad∕s"], [13231, 1, "rad∕s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "μs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "μv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "μw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "kω"], [13249, 1, "mω"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c∕kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v∕m"], [13279, 1, "a∕m"], [13280, 1, "1日"], [13281, 1, "2日"], [13282, 1, "3日"], [13283, 1, "4日"], [13284, 1, "5日"], [13285, 1, "6日"], [13286, 1, "7日"], [13287, 1, "8日"], [13288, 1, "9日"], [13289, 1, "10日"], [13290, 1, "11日"], [13291, 1, "12日"], [13292, 1, "13日"], [13293, 1, "14日"], [13294, 1, "15日"], [13295, 1, "16日"], [13296, 1, "17日"], [13297, 1, "18日"], [13298, 1, "19日"], [13299, 1, "20日"], [13300, 1, "21日"], [13301, 1, "22日"], [13302, 1, "23日"], [13303, 1, "24日"], [13304, 1, "25日"], [13305, 1, "26日"], [13306, 1, "27日"], [13307, 1, "28日"], [13308, 1, "29日"], [13309, 1, "30日"], [13310, 1, "31日"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "ꙁ"], [42561, 2], [42562, 1, "ꙃ"], [42563, 2], [42564, 1, "ꙅ"], [42565, 2], [42566, 1, "ꙇ"], [42567, 2], [42568, 1, "ꙉ"], [42569, 2], [42570, 1, "ꙋ"], [42571, 2], [42572, 1, "ꙍ"], [42573, 2], [42574, 1, "ꙏ"], [42575, 2], [42576, 1, "ꙑ"], [42577, 2], [42578, 1, "ꙓ"], [42579, 2], [42580, 1, "ꙕ"], [42581, 2], [42582, 1, "ꙗ"], [42583, 2], [42584, 1, "ꙙ"], [42585, 2], [42586, 1, "ꙛ"], [42587, 2], [42588, 1, "ꙝ"], [42589, 2], [42590, 1, "ꙟ"], [42591, 2], [42592, 1, "ꙡ"], [42593, 2], [42594, 1, "ꙣ"], [42595, 2], [42596, 1, "ꙥ"], [42597, 2], [42598, 1, "ꙧ"], [42599, 2], [42600, 1, "ꙩ"], [42601, 2], [42602, 1, "ꙫ"], [42603, 2], [42604, 1, "ꙭ"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "ꚁ"], [42625, 2], [42626, 1, "ꚃ"], [42627, 2], [42628, 1, "ꚅ"], [42629, 2], [42630, 1, "ꚇ"], [42631, 2], [42632, 1, "ꚉ"], [42633, 2], [42634, 1, "ꚋ"], [42635, 2], [42636, 1, "ꚍ"], [42637, 2], [42638, 1, "ꚏ"], [42639, 2], [42640, 1, "ꚑ"], [42641, 2], [42642, 1, "ꚓ"], [42643, 2], [42644, 1, "ꚕ"], [42645, 2], [42646, 1, "ꚗ"], [42647, 2], [42648, 1, "ꚙ"], [42649, 2], [42650, 1, "ꚛ"], [42651, 2], [42652, 1, "ъ"], [42653, 1, "ь"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "ꜣ"], [42787, 2], [42788, 1, "ꜥ"], [42789, 2], [42790, 1, "ꜧ"], [42791, 2], [42792, 1, "ꜩ"], [42793, 2], [42794, 1, "ꜫ"], [42795, 2], [42796, 1, "ꜭ"], [42797, 2], [42798, 1, "ꜯ"], [[42799, 42801], 2], [42802, 1, "ꜳ"], [42803, 2], [42804, 1, "ꜵ"], [42805, 2], [42806, 1, "ꜷ"], [42807, 2], [42808, 1, "ꜹ"], [42809, 2], [42810, 1, "ꜻ"], [42811, 2], [42812, 1, "ꜽ"], [42813, 2], [42814, 1, "ꜿ"], [42815, 2], [42816, 1, "ꝁ"], [42817, 2], [42818, 1, "ꝃ"], [42819, 2], [42820, 1, "ꝅ"], [42821, 2], [42822, 1, "ꝇ"], [42823, 2], [42824, 1, "ꝉ"], [42825, 2], [42826, 1, "ꝋ"], [42827, 2], [42828, 1, "ꝍ"], [42829, 2], [42830, 1, "ꝏ"], [42831, 2], [42832, 1, "ꝑ"], [42833, 2], [42834, 1, "ꝓ"], [42835, 2], [42836, 1, "ꝕ"], [42837, 2], [42838, 1, "ꝗ"], [42839, 2], [42840, 1, "ꝙ"], [42841, 2], [42842, 1, "ꝛ"], [42843, 2], [42844, 1, "ꝝ"], [42845, 2], [42846, 1, "ꝟ"], [42847, 2], [42848, 1, "ꝡ"], [42849, 2], [42850, 1, "ꝣ"], [42851, 2], [42852, 1, "ꝥ"], [42853, 2], [42854, 1, "ꝧ"], [42855, 2], [42856, 1, "ꝩ"], [42857, 2], [42858, 1, "ꝫ"], [42859, 2], [42860, 1, "ꝭ"], [42861, 2], [42862, 1, "ꝯ"], [42863, 2], [42864, 1, "ꝯ"], [[42865, 42872], 2], [42873, 1, "ꝺ"], [42874, 2], [42875, 1, "ꝼ"], [42876, 2], [42877, 1, "ᵹ"], [42878, 1, "ꝿ"], [42879, 2], [42880, 1, "ꞁ"], [42881, 2], [42882, 1, "ꞃ"], [42883, 2], [42884, 1, "ꞅ"], [42885, 2], [42886, 1, "ꞇ"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "ꞌ"], [42892, 2], [42893, 1, "ɥ"], [42894, 2], [42895, 2], [42896, 1, "ꞑ"], [42897, 2], [42898, 1, "ꞓ"], [42899, 2], [[42900, 42901], 2], [42902, 1, "ꞗ"], [42903, 2], [42904, 1, "ꞙ"], [42905, 2], [42906, 1, "ꞛ"], [42907, 2], [42908, 1, "ꞝ"], [42909, 2], [42910, 1, "ꞟ"], [42911, 2], [42912, 1, "ꞡ"], [42913, 2], [42914, 1, "ꞣ"], [42915, 2], [42916, 1, "ꞥ"], [42917, 2], [42918, 1, "ꞧ"], [42919, 2], [42920, 1, "ꞩ"], [42921, 2], [42922, 1, "ɦ"], [42923, 1, "ɜ"], [42924, 1, "ɡ"], [42925, 1, "ɬ"], [42926, 1, "ɪ"], [42927, 2], [42928, 1, "ʞ"], [42929, 1, "ʇ"], [42930, 1, "ʝ"], [42931, 1, "ꭓ"], [42932, 1, "ꞵ"], [42933, 2], [42934, 1, "ꞷ"], [42935, 2], [42936, 1, "ꞹ"], [42937, 2], [42938, 1, "ꞻ"], [42939, 2], [42940, 1, "ꞽ"], [42941, 2], [42942, 1, "ꞿ"], [42943, 2], [42944, 1, "ꟁ"], [42945, 2], [42946, 1, "ꟃ"], [42947, 2], [42948, 1, "ꞔ"], [42949, 1, "ʂ"], [42950, 1, "ᶎ"], [42951, 1, "ꟈ"], [42952, 2], [42953, 1, "ꟊ"], [42954, 2], [42955, 1, "ɤ"], [42956, 1, "ꟍ"], [42957, 2], [[42958, 42959], 3], [42960, 1, "ꟑ"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "ꟗ"], [42967, 2], [42968, 1, "ꟙ"], [42969, 2], [42970, 1, "ꟛ"], [42971, 2], [42972, 1, "ƛ"], [[42973, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "ꟶ"], [42998, 2], [42999, 2], [43000, 1, "ħ"], [43001, 1, "œ"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "ꜧ"], [43869, 1, "ꬷ"], [43870, 1, "ɫ"], [43871, 1, "ꭒ"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "ʍ"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "Ꭰ"], [43889, 1, "Ꭱ"], [43890, 1, "Ꭲ"], [43891, 1, "Ꭳ"], [43892, 1, "Ꭴ"], [43893, 1, "Ꭵ"], [43894, 1, "Ꭶ"], [43895, 1, "Ꭷ"], [43896, 1, "Ꭸ"], [43897, 1, "Ꭹ"], [43898, 1, "Ꭺ"], [43899, 1, "Ꭻ"], [43900, 1, "Ꭼ"], [43901, 1, "Ꭽ"], [43902, 1, "Ꭾ"], [43903, 1, "Ꭿ"], [43904, 1, "Ꮀ"], [43905, 1, "Ꮁ"], [43906, 1, "Ꮂ"], [43907, 1, "Ꮃ"], [43908, 1, "Ꮄ"], [43909, 1, "Ꮅ"], [43910, 1, "Ꮆ"], [43911, 1, "Ꮇ"], [43912, 1, "Ꮈ"], [43913, 1, "Ꮉ"], [43914, 1, "Ꮊ"], [43915, 1, "Ꮋ"], [43916, 1, "Ꮌ"], [43917, 1, "Ꮍ"], [43918, 1, "Ꮎ"], [43919, 1, "Ꮏ"], [43920, 1, "Ꮐ"], [43921, 1, "Ꮑ"], [43922, 1, "Ꮒ"], [43923, 1, "Ꮓ"], [43924, 1, "Ꮔ"], [43925, 1, "Ꮕ"], [43926, 1, "Ꮖ"], [43927, 1, "Ꮗ"], [43928, 1, "Ꮘ"], [43929, 1, "Ꮙ"], [43930, 1, "Ꮚ"], [43931, 1, "Ꮛ"], [43932, 1, "Ꮜ"], [43933, 1, "Ꮝ"], [43934, 1, "Ꮞ"], [43935, 1, "Ꮟ"], [43936, 1, "Ꮠ"], [43937, 1, "Ꮡ"], [43938, 1, "Ꮢ"], [43939, 1, "Ꮣ"], [43940, 1, "Ꮤ"], [43941, 1, "Ꮥ"], [43942, 1, "Ꮦ"], [43943, 1, "Ꮧ"], [43944, 1, "Ꮨ"], [43945, 1, "Ꮩ"], [43946, 1, "Ꮪ"], [43947, 1, "Ꮫ"], [43948, 1, "Ꮬ"], [43949, 1, "Ꮭ"], [43950, 1, "Ꮮ"], [43951, 1, "Ꮯ"], [43952, 1, "Ꮰ"], [43953, 1, "Ꮱ"], [43954, 1, "Ꮲ"], [43955, 1, "Ꮳ"], [43956, 1, "Ꮴ"], [43957, 1, "Ꮵ"], [43958, 1, "Ꮶ"], [43959, 1, "Ꮷ"], [43960, 1, "Ꮸ"], [43961, 1, "Ꮹ"], [43962, 1, "Ꮺ"], [43963, 1, "Ꮻ"], [43964, 1, "Ꮼ"], [43965, 1, "Ꮽ"], [43966, 1, "Ꮾ"], [43967, 1, "Ꮿ"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "豈"], [63745, 1, "更"], [63746, 1, "車"], [63747, 1, "賈"], [63748, 1, "滑"], [63749, 1, "串"], [63750, 1, "句"], [[63751, 63752], 1, "龜"], [63753, 1, "契"], [63754, 1, "金"], [63755, 1, "喇"], [63756, 1, "奈"], [63757, 1, "懶"], [63758, 1, "癩"], [63759, 1, "羅"], [63760, 1, "蘿"], [63761, 1, "螺"], [63762, 1, "裸"], [63763, 1, "邏"], [63764, 1, "樂"], [63765, 1, "洛"], [63766, 1, "烙"], [63767, 1, "珞"], [63768, 1, "落"], [63769, 1, "酪"], [63770, 1, "駱"], [63771, 1, "亂"], [63772, 1, "卵"], [63773, 1, "欄"], [63774, 1, "爛"], [63775, 1, "蘭"], [63776, 1, "鸞"], [63777, 1, "嵐"], [63778, 1, "濫"], [63779, 1, "藍"], [63780, 1, "襤"], [63781, 1, "拉"], [63782, 1, "臘"], [63783, 1, "蠟"], [63784, 1, "廊"], [63785, 1, "朗"], [63786, 1, "浪"], [63787, 1, "狼"], [63788, 1, "郎"], [63789, 1, "來"], [63790, 1, "冷"], [63791, 1, "勞"], [63792, 1, "擄"], [63793, 1, "櫓"], [63794, 1, "爐"], [63795, 1, "盧"], [63796, 1, "老"], [63797, 1, "蘆"], [63798, 1, "虜"], [63799, 1, "路"], [63800, 1, "露"], [63801, 1, "魯"], [63802, 1, "鷺"], [63803, 1, "碌"], [63804, 1, "祿"], [63805, 1, "綠"], [63806, 1, "菉"], [63807, 1, "錄"], [63808, 1, "鹿"], [63809, 1, "論"], [63810, 1, "壟"], [63811, 1, "弄"], [63812, 1, "籠"], [63813, 1, "聾"], [63814, 1, "牢"], [63815, 1, "磊"], [63816, 1, "賂"], [63817, 1, "雷"], [63818, 1, "壘"], [63819, 1, "屢"], [63820, 1, "樓"], [63821, 1, "淚"], [63822, 1, "漏"], [63823, 1, "累"], [63824, 1, "縷"], [63825, 1, "陋"], [63826, 1, "勒"], [63827, 1, "肋"], [63828, 1, "凜"], [63829, 1, "凌"], [63830, 1, "稜"], [63831, 1, "綾"], [63832, 1, "菱"], [63833, 1, "陵"], [63834, 1, "讀"], [63835, 1, "拏"], [63836, 1, "樂"], [63837, 1, "諾"], [63838, 1, "丹"], [63839, 1, "寧"], [63840, 1, "怒"], [63841, 1, "率"], [63842, 1, "異"], [63843, 1, "北"], [63844, 1, "磻"], [63845, 1, "便"], [63846, 1, "復"], [63847, 1, "不"], [63848, 1, "泌"], [63849, 1, "數"], [63850, 1, "索"], [63851, 1, "參"], [63852, 1, "塞"], [63853, 1, "省"], [63854, 1, "葉"], [63855, 1, "說"], [63856, 1, "殺"], [63857, 1, "辰"], [63858, 1, "沈"], [63859, 1, "拾"], [63860, 1, "若"], [63861, 1, "掠"], [63862, 1, "略"], [63863, 1, "亮"], [63864, 1, "兩"], [63865, 1, "凉"], [63866, 1, "梁"], [63867, 1, "糧"], [63868, 1, "良"], [63869, 1, "諒"], [63870, 1, "量"], [63871, 1, "勵"], [63872, 1, "呂"], [63873, 1, "女"], [63874, 1, "廬"], [63875, 1, "旅"], [63876, 1, "濾"], [63877, 1, "礪"], [63878, 1, "閭"], [63879, 1, "驪"], [63880, 1, "麗"], [63881, 1, "黎"], [63882, 1, "力"], [63883, 1, "曆"], [63884, 1, "歷"], [63885, 1, "轢"], [63886, 1, "年"], [63887, 1, "憐"], [63888, 1, "戀"], [63889, 1, "撚"], [63890, 1, "漣"], [63891, 1, "煉"], [63892, 1, "璉"], [63893, 1, "秊"], [63894, 1, "練"], [63895, 1, "聯"], [63896, 1, "輦"], [63897, 1, "蓮"], [63898, 1, "連"], [63899, 1, "鍊"], [63900, 1, "列"], [63901, 1, "劣"], [63902, 1, "咽"], [63903, 1, "烈"], [63904, 1, "裂"], [63905, 1, "說"], [63906, 1, "廉"], [63907, 1, "念"], [63908, 1, "捻"], [63909, 1, "殮"], [63910, 1, "簾"], [63911, 1, "獵"], [63912, 1, "令"], [63913, 1, "囹"], [63914, 1, "寧"], [63915, 1, "嶺"], [63916, 1, "怜"], [63917, 1, "玲"], [63918, 1, "瑩"], [63919, 1, "羚"], [63920, 1, "聆"], [63921, 1, "鈴"], [63922, 1, "零"], [63923, 1, "靈"], [63924, 1, "領"], [63925, 1, "例"], [63926, 1, "禮"], [63927, 1, "醴"], [63928, 1, "隸"], [63929, 1, "惡"], [63930, 1, "了"], [63931, 1, "僚"], [63932, 1, "寮"], [63933, 1, "尿"], [63934, 1, "料"], [63935, 1, "樂"], [63936, 1, "燎"], [63937, 1, "療"], [63938, 1, "蓼"], [63939, 1, "遼"], [63940, 1, "龍"], [63941, 1, "暈"], [63942, 1, "阮"], [63943, 1, "劉"], [63944, 1, "杻"], [63945, 1, "柳"], [63946, 1, "流"], [63947, 1, "溜"], [63948, 1, "琉"], [63949, 1, "留"], [63950, 1, "硫"], [63951, 1, "紐"], [63952, 1, "類"], [63953, 1, "六"], [63954, 1, "戮"], [63955, 1, "陸"], [63956, 1, "倫"], [63957, 1, "崙"], [63958, 1, "淪"], [63959, 1, "輪"], [63960, 1, "律"], [63961, 1, "慄"], [63962, 1, "栗"], [63963, 1, "率"], [63964, 1, "隆"], [63965, 1, "利"], [63966, 1, "吏"], [63967, 1, "履"], [63968, 1, "易"], [63969, 1, "李"], [63970, 1, "梨"], [63971, 1, "泥"], [63972, 1, "理"], [63973, 1, "痢"], [63974, 1, "罹"], [63975, 1, "裏"], [63976, 1, "裡"], [63977, 1, "里"], [63978, 1, "離"], [63979, 1, "匿"], [63980, 1, "溺"], [63981, 1, "吝"], [63982, 1, "燐"], [63983, 1, "璘"], [63984, 1, "藺"], [63985, 1, "隣"], [63986, 1, "鱗"], [63987, 1, "麟"], [63988, 1, "林"], [63989, 1, "淋"], [63990, 1, "臨"], [63991, 1, "立"], [63992, 1, "笠"], [63993, 1, "粒"], [63994, 1, "狀"], [63995, 1, "炙"], [63996, 1, "識"], [63997, 1, "什"], [63998, 1, "茶"], [63999, 1, "刺"], [64000, 1, "切"], [64001, 1, "度"], [64002, 1, "拓"], [64003, 1, "糖"], [64004, 1, "宅"], [64005, 1, "洞"], [64006, 1, "暴"], [64007, 1, "輻"], [64008, 1, "行"], [64009, 1, "降"], [64010, 1, "見"], [64011, 1, "廓"], [64012, 1, "兀"], [64013, 1, "嗀"], [[64014, 64015], 2], [64016, 1, "塚"], [64017, 2], [64018, 1, "晴"], [[64019, 64020], 2], [64021, 1, "凞"], [64022, 1, "猪"], [64023, 1, "益"], [64024, 1, "礼"], [64025, 1, "神"], [64026, 1, "祥"], [64027, 1, "福"], [64028, 1, "靖"], [64029, 1, "精"], [64030, 1, "羽"], [64031, 2], [64032, 1, "蘒"], [64033, 2], [64034, 1, "諸"], [[64035, 64036], 2], [64037, 1, "逸"], [64038, 1, "都"], [[64039, 64041], 2], [64042, 1, "飯"], [64043, 1, "飼"], [64044, 1, "館"], [64045, 1, "鶴"], [64046, 1, "郞"], [64047, 1, "隷"], [64048, 1, "侮"], [64049, 1, "僧"], [64050, 1, "免"], [64051, 1, "勉"], [64052, 1, "勤"], [64053, 1, "卑"], [64054, 1, "喝"], [64055, 1, "嘆"], [64056, 1, "器"], [64057, 1, "塀"], [64058, 1, "墨"], [64059, 1, "層"], [64060, 1, "屮"], [64061, 1, "悔"], [64062, 1, "慨"], [64063, 1, "憎"], [64064, 1, "懲"], [64065, 1, "敏"], [64066, 1, "既"], [64067, 1, "暑"], [64068, 1, "梅"], [64069, 1, "海"], [64070, 1, "渚"], [64071, 1, "漢"], [64072, 1, "煮"], [64073, 1, "爫"], [64074, 1, "琢"], [64075, 1, "碑"], [64076, 1, "社"], [64077, 1, "祉"], [64078, 1, "祈"], [64079, 1, "祐"], [64080, 1, "祖"], [64081, 1, "祝"], [64082, 1, "禍"], [64083, 1, "禎"], [64084, 1, "穀"], [64085, 1, "突"], [64086, 1, "節"], [64087, 1, "練"], [64088, 1, "縉"], [64089, 1, "繁"], [64090, 1, "署"], [64091, 1, "者"], [64092, 1, "臭"], [[64093, 64094], 1, "艹"], [64095, 1, "著"], [64096, 1, "褐"], [64097, 1, "視"], [64098, 1, "謁"], [64099, 1, "謹"], [64100, 1, "賓"], [64101, 1, "贈"], [64102, 1, "辶"], [64103, 1, "逸"], [64104, 1, "難"], [64105, 1, "響"], [64106, 1, "頻"], [64107, 1, "恵"], [64108, 1, "\uD850\uDEEE"], [64109, 1, "舘"], [[64110, 64111], 3], [64112, 1, "並"], [64113, 1, "况"], [64114, 1, "全"], [64115, 1, "侀"], [64116, 1, "充"], [64117, 1, "冀"], [64118, 1, "勇"], [64119, 1, "勺"], [64120, 1, "喝"], [64121, 1, "啕"], [64122, 1, "喙"], [64123, 1, "嗢"], [64124, 1, "塚"], [64125, 1, "墳"], [64126, 1, "奄"], [64127, 1, "奔"], [64128, 1, "婢"], [64129, 1, "嬨"], [64130, 1, "廒"], [64131, 1, "廙"], [64132, 1, "彩"], [64133, 1, "徭"], [64134, 1, "惘"], [64135, 1, "慎"], [64136, 1, "愈"], [64137, 1, "憎"], [64138, 1, "慠"], [64139, 1, "懲"], [64140, 1, "戴"], [64141, 1, "揄"], [64142, 1, "搜"], [64143, 1, "摒"], [64144, 1, "敖"], [64145, 1, "晴"], [64146, 1, "朗"], [64147, 1, "望"], [64148, 1, "杖"], [64149, 1, "歹"], [64150, 1, "殺"], [64151, 1, "流"], [64152, 1, "滛"], [64153, 1, "滋"], [64154, 1, "漢"], [64155, 1, "瀞"], [64156, 1, "煮"], [64157, 1, "瞧"], [64158, 1, "爵"], [64159, 1, "犯"], [64160, 1, "猪"], [64161, 1, "瑱"], [64162, 1, "甆"], [64163, 1, "画"], [64164, 1, "瘝"], [64165, 1, "瘟"], [64166, 1, "益"], [64167, 1, "盛"], [64168, 1, "直"], [64169, 1, "睊"], [64170, 1, "着"], [64171, 1, "磌"], [64172, 1, "窱"], [64173, 1, "節"], [64174, 1, "类"], [64175, 1, "絛"], [64176, 1, "練"], [64177, 1, "缾"], [64178, 1, "者"], [64179, 1, "荒"], [64180, 1, "華"], [64181, 1, "蝹"], [64182, 1, "襁"], [64183, 1, "覆"], [64184, 1, "視"], [64185, 1, "調"], [64186, 1, "諸"], [64187, 1, "請"], [64188, 1, "謁"], [64189, 1, "諾"], [64190, 1, "諭"], [64191, 1, "謹"], [64192, 1, "變"], [64193, 1, "贈"], [64194, 1, "輸"], [64195, 1, "遲"], [64196, 1, "醙"], [64197, 1, "鉶"], [64198, 1, "陼"], [64199, 1, "難"], [64200, 1, "靖"], [64201, 1, "韛"], [64202, 1, "響"], [64203, 1, "頋"], [64204, 1, "頻"], [64205, 1, "鬒"], [64206, 1, "龜"], [64207, 1, "\uD84A\uDC4A"], [64208, 1, "\uD84A\uDC44"], [64209, 1, "\uD84C\uDFD5"], [64210, 1, "㮝"], [64211, 1, "䀘"], [64212, 1, "䀹"], [64213, 1, "\uD854\uDE49"], [64214, 1, "\uD857\uDCD0"], [64215, 1, "\uD85F\uDED3"], [64216, 1, "齃"], [64217, 1, "龎"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "մն"], [64276, 1, "մե"], [64277, 1, "մի"], [64278, 1, "վն"], [64279, 1, "մխ"], [[64280, 64284], 3], [64285, 1, "יִ"], [64286, 2], [64287, 1, "ײַ"], [64288, 1, "ע"], [64289, 1, "א"], [64290, 1, "ד"], [64291, 1, "ה"], [64292, 1, "כ"], [64293, 1, "ל"], [64294, 1, "ם"], [64295, 1, "ר"], [64296, 1, "ת"], [64297, 1, "+"], [64298, 1, "שׁ"], [64299, 1, "שׂ"], [64300, 1, "שּׁ"], [64301, 1, "שּׂ"], [64302, 1, "אַ"], [64303, 1, "אָ"], [64304, 1, "אּ"], [64305, 1, "בּ"], [64306, 1, "גּ"], [64307, 1, "דּ"], [64308, 1, "הּ"], [64309, 1, "וּ"], [64310, 1, "זּ"], [64311, 3], [64312, 1, "טּ"], [64313, 1, "יּ"], [64314, 1, "ךּ"], [64315, 1, "כּ"], [64316, 1, "לּ"], [64317, 3], [64318, 1, "מּ"], [64319, 3], [64320, 1, "נּ"], [64321, 1, "סּ"], [64322, 3], [64323, 1, "ףּ"], [64324, 1, "פּ"], [64325, 3], [64326, 1, "צּ"], [64327, 1, "קּ"], [64328, 1, "רּ"], [64329, 1, "שּ"], [64330, 1, "תּ"], [64331, 1, "וֹ"], [64332, 1, "בֿ"], [64333, 1, "כֿ"], [64334, 1, "פֿ"], [64335, 1, "אל"], [[64336, 64337], 1, "ٱ"], [[64338, 64341], 1, "ٻ"], [[64342, 64345], 1, "پ"], [[64346, 64349], 1, "ڀ"], [[64350, 64353], 1, "ٺ"], [[64354, 64357], 1, "ٿ"], [[64358, 64361], 1, "ٹ"], [[64362, 64365], 1, "ڤ"], [[64366, 64369], 1, "ڦ"], [[64370, 64373], 1, "ڄ"], [[64374, 64377], 1, "ڃ"], [[64378, 64381], 1, "چ"], [[64382, 64385], 1, "ڇ"], [[64386, 64387], 1, "ڍ"], [[64388, 64389], 1, "ڌ"], [[64390, 64391], 1, "ڎ"], [[64392, 64393], 1, "ڈ"], [[64394, 64395], 1, "ژ"], [[64396, 64397], 1, "ڑ"], [[64398, 64401], 1, "ک"], [[64402, 64405], 1, "گ"], [[64406, 64409], 1, "ڳ"], [[64410, 64413], 1, "ڱ"], [[64414, 64415], 1, "ں"], [[64416, 64419], 1, "ڻ"], [[64420, 64421], 1, "ۀ"], [[64422, 64425], 1, "ہ"], [[64426, 64429], 1, "ھ"], [[64430, 64431], 1, "ے"], [[64432, 64433], 1, "ۓ"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "ڭ"], [[64471, 64472], 1, "ۇ"], [[64473, 64474], 1, "ۆ"], [[64475, 64476], 1, "ۈ"], [64477, 1, "ۇٴ"], [[64478, 64479], 1, "ۋ"], [[64480, 64481], 1, "ۅ"], [[64482, 64483], 1, "ۉ"], [[64484, 64487], 1, "ې"], [[64488, 64489], 1, "ى"], [[64490, 64491], 1, "ئا"], [[64492, 64493], 1, "ئە"], [[64494, 64495], 1, "ئو"], [[64496, 64497], 1, "ئۇ"], [[64498, 64499], 1, "ئۆ"], [[64500, 64501], 1, "ئۈ"], [[64502, 64504], 1, "ئې"], [[64505, 64507], 1, "ئى"], [[64508, 64511], 1, "ی"], [64512, 1, "ئج"], [64513, 1, "ئح"], [64514, 1, "ئم"], [64515, 1, "ئى"], [64516, 1, "ئي"], [64517, 1, "بج"], [64518, 1, "بح"], [64519, 1, "بخ"], [64520, 1, "بم"], [64521, 1, "بى"], [64522, 1, "بي"], [64523, 1, "تج"], [64524, 1, "تح"], [64525, 1, "تخ"], [64526, 1, "تم"], [64527, 1, "تى"], [64528, 1, "تي"], [64529, 1, "ثج"], [64530, 1, "ثم"], [64531, 1, "ثى"], [64532, 1, "ثي"], [64533, 1, "جح"], [64534, 1, "جم"], [64535, 1, "حج"], [64536, 1, "حم"], [64537, 1, "خج"], [64538, 1, "خح"], [64539, 1, "خم"], [64540, 1, "سج"], [64541, 1, "سح"], [64542, 1, "سخ"], [64543, 1, "سم"], [64544, 1, "صح"], [64545, 1, "صم"], [64546, 1, "ضج"], [64547, 1, "ضح"], [64548, 1, "ضخ"], [64549, 1, "ضم"], [64550, 1, "طح"], [64551, 1, "طم"], [64552, 1, "ظم"], [64553, 1, "عج"], [64554, 1, "عم"], [64555, 1, "غج"], [64556, 1, "غم"], [64557, 1, "فج"], [64558, 1, "فح"], [64559, 1, "فخ"], [64560, 1, "فم"], [64561, 1, "فى"], [64562, 1, "في"], [64563, 1, "قح"], [64564, 1, "قم"], [64565, 1, "قى"], [64566, 1, "قي"], [64567, 1, "كا"], [64568, 1, "كج"], [64569, 1, "كح"], [64570, 1, "كخ"], [64571, 1, "كل"], [64572, 1, "كم"], [64573, 1, "كى"], [64574, 1, "كي"], [64575, 1, "لج"], [64576, 1, "لح"], [64577, 1, "لخ"], [64578, 1, "لم"], [64579, 1, "لى"], [64580, 1, "لي"], [64581, 1, "مج"], [64582, 1, "مح"], [64583, 1, "مخ"], [64584, 1, "مم"], [64585, 1, "مى"], [64586, 1, "مي"], [64587, 1, "نج"], [64588, 1, "نح"], [64589, 1, "نخ"], [64590, 1, "نم"], [64591, 1, "نى"], [64592, 1, "ني"], [64593, 1, "هج"], [64594, 1, "هم"], [64595, 1, "هى"], [64596, 1, "هي"], [64597, 1, "يج"], [64598, 1, "يح"], [64599, 1, "يخ"], [64600, 1, "يم"], [64601, 1, "يى"], [64602, 1, "يي"], [64603, 1, "ذٰ"], [64604, 1, "رٰ"], [64605, 1, "ىٰ"], [64606, 1, " ٌّ"], [64607, 1, " ٍّ"], [64608, 1, " َّ"], [64609, 1, " ُّ"], [64610, 1, " ِّ"], [64611, 1, " ّٰ"], [64612, 1, "ئر"], [64613, 1, "ئز"], [64614, 1, "ئم"], [64615, 1, "ئن"], [64616, 1, "ئى"], [64617, 1, "ئي"], [64618, 1, "بر"], [64619, 1, "بز"], [64620, 1, "بم"], [64621, 1, "بن"], [64622, 1, "بى"], [64623, 1, "بي"], [64624, 1, "تر"], [64625, 1, "تز"], [64626, 1, "تم"], [64627, 1, "تن"], [64628, 1, "تى"], [64629, 1, "تي"], [64630, 1, "ثر"], [64631, 1, "ثز"], [64632, 1, "ثم"], [64633, 1, "ثن"], [64634, 1, "ثى"], [64635, 1, "ثي"], [64636, 1, "فى"], [64637, 1, "في"], [64638, 1, "قى"], [64639, 1, "قي"], [64640, 1, "كا"], [64641, 1, "كل"], [64642, 1, "كم"], [64643, 1, "كى"], [64644, 1, "كي"], [64645, 1, "لم"], [64646, 1, "لى"], [64647, 1, "لي"], [64648, 1, "ما"], [64649, 1, "مم"], [64650, 1, "نر"], [64651, 1, "نز"], [64652, 1, "نم"], [64653, 1, "نن"], [64654, 1, "نى"], [64655, 1, "ني"], [64656, 1, "ىٰ"], [64657, 1, "ير"], [64658, 1, "يز"], [64659, 1, "يم"], [64660, 1, "ين"], [64661, 1, "يى"], [64662, 1, "يي"], [64663, 1, "ئج"], [64664, 1, "ئح"], [64665, 1, "ئخ"], [64666, 1, "ئم"], [64667, 1, "ئه"], [64668, 1, "بج"], [64669, 1, "بح"], [64670, 1, "بخ"], [64671, 1, "بم"], [64672, 1, "به"], [64673, 1, "تج"], [64674, 1, "تح"], [64675, 1, "تخ"], [64676, 1, "تم"], [64677, 1, "ته"], [64678, 1, "ثم"], [64679, 1, "جح"], [64680, 1, "جم"], [64681, 1, "حج"], [64682, 1, "حم"], [64683, 1, "خج"], [64684, 1, "خم"], [64685, 1, "سج"], [64686, 1, "سح"], [64687, 1, "سخ"], [64688, 1, "سم"], [64689, 1, "صح"], [64690, 1, "صخ"], [64691, 1, "صم"], [64692, 1, "ضج"], [64693, 1, "ضح"], [64694, 1, "ضخ"], [64695, 1, "ضم"], [64696, 1, "طح"], [64697, 1, "ظم"], [64698, 1, "عج"], [64699, 1, "عم"], [64700, 1, "غج"], [64701, 1, "غم"], [64702, 1, "فج"], [64703, 1, "فح"], [64704, 1, "فخ"], [64705, 1, "فم"], [64706, 1, "قح"], [64707, 1, "قم"], [64708, 1, "كج"], [64709, 1, "كح"], [64710, 1, "كخ"], [64711, 1, "كل"], [64712, 1, "كم"], [64713, 1, "لج"], [64714, 1, "لح"], [64715, 1, "لخ"], [64716, 1, "لم"], [64717, 1, "له"], [64718, 1, "مج"], [64719, 1, "مح"], [64720, 1, "مخ"], [64721, 1, "مم"], [64722, 1, "نج"], [64723, 1, "نح"], [64724, 1, "نخ"], [64725, 1, "نم"], [64726, 1, "نه"], [64727, 1, "هج"], [64728, 1, "هم"], [64729, 1, "هٰ"], [64730, 1, "يج"], [64731, 1, "يح"], [64732, 1, "يخ"], [64733, 1, "يم"], [64734, 1, "يه"], [64735, 1, "ئم"], [64736, 1, "ئه"], [64737, 1, "بم"], [64738, 1, "به"], [64739, 1, "تم"], [64740, 1, "ته"], [64741, 1, "ثم"], [64742, 1, "ثه"], [64743, 1, "سم"], [64744, 1, "سه"], [64745, 1, "شم"], [64746, 1, "شه"], [64747, 1, "كل"], [64748, 1, "كم"], [64749, 1, "لم"], [64750, 1, "نم"], [64751, 1, "نه"], [64752, 1, "يم"], [64753, 1, "يه"], [64754, 1, "ـَّ"], [64755, 1, "ـُّ"], [64756, 1, "ـِّ"], [64757, 1, "طى"], [64758, 1, "طي"], [64759, 1, "عى"], [64760, 1, "عي"], [64761, 1, "غى"], [64762, 1, "غي"], [64763, 1, "سى"], [64764, 1, "سي"], [64765, 1, "شى"], [64766, 1, "شي"], [64767, 1, "حى"], [64768, 1, "حي"], [64769, 1, "جى"], [64770, 1, "جي"], [64771, 1, "خى"], [64772, 1, "خي"], [64773, 1, "صى"], [64774, 1, "صي"], [64775, 1, "ضى"], [64776, 1, "ضي"], [64777, 1, "شج"], [64778, 1, "شح"], [64779, 1, "شخ"], [64780, 1, "شم"], [64781, 1, "شر"], [64782, 1, "سر"], [64783, 1, "صر"], [64784, 1, "ضر"], [64785, 1, "طى"], [64786, 1, "طي"], [64787, 1, "عى"], [64788, 1, "عي"], [64789, 1, "غى"], [64790, 1, "غي"], [64791, 1, "سى"], [64792, 1, "سي"], [64793, 1, "شى"], [64794, 1, "شي"], [64795, 1, "حى"], [64796, 1, "حي"], [64797, 1, "جى"], [64798, 1, "جي"], [64799, 1, "خى"], [64800, 1, "خي"], [64801, 1, "صى"], [64802, 1, "صي"], [64803, 1, "ضى"], [64804, 1, "ضي"], [64805, 1, "شج"], [64806, 1, "شح"], [64807, 1, "شخ"], [64808, 1, "شم"], [64809, 1, "شر"], [64810, 1, "سر"], [64811, 1, "صر"], [64812, 1, "ضر"], [64813, 1, "شج"], [64814, 1, "شح"], [64815, 1, "شخ"], [64816, 1, "شم"], [64817, 1, "سه"], [64818, 1, "شه"], [64819, 1, "طم"], [64820, 1, "سج"], [64821, 1, "سح"], [64822, 1, "سخ"], [64823, 1, "شج"], [64824, 1, "شح"], [64825, 1, "شخ"], [64826, 1, "طم"], [64827, 1, "ظم"], [[64828, 64829], 1, "اً"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "تجم"], [[64849, 64850], 1, "تحج"], [64851, 1, "تحم"], [64852, 1, "تخم"], [64853, 1, "تمج"], [64854, 1, "تمح"], [64855, 1, "تمخ"], [[64856, 64857], 1, "جمح"], [64858, 1, "حمي"], [64859, 1, "حمى"], [64860, 1, "سحج"], [64861, 1, "سجح"], [64862, 1, "سجى"], [[64863, 64864], 1, "سمح"], [64865, 1, "سمج"], [[64866, 64867], 1, "سمم"], [[64868, 64869], 1, "صحح"], [64870, 1, "صمم"], [[64871, 64872], 1, "شحم"], [64873, 1, "شجي"], [[64874, 64875], 1, "شمخ"], [[64876, 64877], 1, "شمم"], [64878, 1, "ضحى"], [[64879, 64880], 1, "ضخم"], [[64881, 64882], 1, "طمح"], [64883, 1, "طمم"], [64884, 1, "طمي"], [64885, 1, "عجم"], [[64886, 64887], 1, "عمم"], [64888, 1, "عمى"], [64889, 1, "غمم"], [64890, 1, "غمي"], [64891, 1, "غمى"], [[64892, 64893], 1, "فخم"], [64894, 1, "قمح"], [64895, 1, "قمم"], [64896, 1, "لحم"], [64897, 1, "لحي"], [64898, 1, "لحى"], [[64899, 64900], 1, "لجج"], [[64901, 64902], 1, "لخم"], [[64903, 64904], 1, "لمح"], [64905, 1, "محج"], [64906, 1, "محم"], [64907, 1, "محي"], [64908, 1, "مجح"], [64909, 1, "مجم"], [64910, 1, "مخج"], [64911, 1, "مخم"], [[64912, 64913], 3], [64914, 1, "مجخ"], [64915, 1, "همج"], [64916, 1, "همم"], [64917, 1, "نحم"], [64918, 1, "نحى"], [[64919, 64920], 1, "نجم"], [64921, 1, "نجى"], [64922, 1, "نمي"], [64923, 1, "نمى"], [[64924, 64925], 1, "يمم"], [64926, 1, "بخي"], [64927, 1, "تجي"], [64928, 1, "تجى"], [64929, 1, "تخي"], [64930, 1, "تخى"], [64931, 1, "تمي"], [64932, 1, "تمى"], [64933, 1, "جمي"], [64934, 1, "جحى"], [64935, 1, "جمى"], [64936, 1, "سخى"], [64937, 1, "صحي"], [64938, 1, "شحي"], [64939, 1, "ضحي"], [64940, 1, "لجي"], [64941, 1, "لمي"], [64942, 1, "يحي"], [64943, 1, "يجي"], [64944, 1, "يمي"], [64945, 1, "ممي"], [64946, 1, "قمي"], [64947, 1, "نحي"], [64948, 1, "قمح"], [64949, 1, "لحم"], [64950, 1, "عمي"], [64951, 1, "كمي"], [64952, 1, "نجح"], [64953, 1, "مخي"], [64954, 1, "لجم"], [64955, 1, "كمم"], [64956, 1, "لجم"], [64957, 1, "نجح"], [64958, 1, "جحي"], [64959, 1, "حجي"], [64960, 1, "مجي"], [64961, 1, "فمي"], [64962, 1, "بحي"], [64963, 1, "كمم"], [64964, 1, "عجم"], [64965, 1, "صمم"], [64966, 1, "سخي"], [64967, 1, "نجي"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "صلے"], [65009, 1, "قلے"], [65010, 1, "الله"], [65011, 1, "اكبر"], [65012, 1, "محمد"], [65013, 1, "صلعم"], [65014, 1, "رسول"], [65015, 1, "عليه"], [65016, 1, "وسلم"], [65017, 1, "صلى"], [65018, 1, "صلى الله عليه وسلم"], [65019, 1, "جل جلاله"], [65020, 1, "ریال"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 1, ","], [65041, 1, "、"], [65042, 3], [65043, 1, ":"], [65044, 1, ";"], [65045, 1, "!"], [65046, 1, "?"], [65047, 1, "〖"], [65048, 1, "〗"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "—"], [65074, 1, "–"], [[65075, 65076], 1, "_"], [65077, 1, "("], [65078, 1, ")"], [65079, 1, "{"], [65080, 1, "}"], [65081, 1, "〔"], [65082, 1, "〕"], [65083, 1, "【"], [65084, 1, "】"], [65085, 1, "《"], [65086, 1, "》"], [65087, 1, "〈"], [65088, 1, "〉"], [65089, 1, "「"], [65090, 1, "」"], [65091, 1, "『"], [65092, 1, "』"], [[65093, 65094], 2], [65095, 1, "["], [65096, 1, "]"], [[65097, 65100], 1, " ̅"], [[65101, 65103], 1, "_"], [65104, 1, ","], [65105, 1, "、"], [65106, 3], [65107, 3], [65108, 1, ";"], [65109, 1, ":"], [65110, 1, "?"], [65111, 1, "!"], [65112, 1, "—"], [65113, 1, "("], [65114, 1, ")"], [65115, 1, "{"], [65116, 1, "}"], [65117, 1, "〔"], [65118, 1, "〕"], [65119, 1, "#"], [65120, 1, "&"], [65121, 1, "*"], [65122, 1, "+"], [65123, 1, "-"], [65124, 1, "<"], [65125, 1, ">"], [65126, 1, "="], [65127, 3], [65128, 1, "\\"], [65129, 1, "$"], [65130, 1, "%"], [65131, 1, "@"], [[65132, 65135], 3], [65136, 1, " ً"], [65137, 1, "ـً"], [65138, 1, " ٌ"], [65139, 2], [65140, 1, " ٍ"], [65141, 3], [65142, 1, " َ"], [65143, 1, "ـَ"], [65144, 1, " ُ"], [65145, 1, "ـُ"], [65146, 1, " ِ"], [65147, 1, "ـِ"], [65148, 1, " ّ"], [65149, 1, "ـّ"], [65150, 1, " ْ"], [65151, 1, "ـْ"], [65152, 1, "ء"], [[65153, 65154], 1, "آ"], [[65155, 65156], 1, "أ"], [[65157, 65158], 1, "ؤ"], [[65159, 65160], 1, "إ"], [[65161, 65164], 1, "ئ"], [[65165, 65166], 1, "ا"], [[65167, 65170], 1, "ب"], [[65171, 65172], 1, "ة"], [[65173, 65176], 1, "ت"], [[65177, 65180], 1, "ث"], [[65181, 65184], 1, "ج"], [[65185, 65188], 1, "ح"], [[65189, 65192], 1, "خ"], [[65193, 65194], 1, "د"], [[65195, 65196], 1, "ذ"], [[65197, 65198], 1, "ر"], [[65199, 65200], 1, "ز"], [[65201, 65204], 1, "س"], [[65205, 65208], 1, "ش"], [[65209, 65212], 1, "ص"], [[65213, 65216], 1, "ض"], [[65217, 65220], 1, "ط"], [[65221, 65224], 1, "ظ"], [[65225, 65228], 1, "ع"], [[65229, 65232], 1, "غ"], [[65233, 65236], 1, "ف"], [[65237, 65240], 1, "ق"], [[65241, 65244], 1, "ك"], [[65245, 65248], 1, "ل"], [[65249, 65252], 1, "م"], [[65253, 65256], 1, "ن"], [[65257, 65260], 1, "ه"], [[65261, 65262], 1, "و"], [[65263, 65264], 1, "ى"], [[65265, 65268], 1, "ي"], [[65269, 65270], 1, "لآ"], [[65271, 65272], 1, "لأ"], [[65273, 65274], 1, "لإ"], [[65275, 65276], 1, "لا"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 1, "!"], [65282, 1, '"'], [65283, 1, "#"], [65284, 1, "$"], [65285, 1, "%"], [65286, 1, "&"], [65287, 1, "'"], [65288, 1, "("], [65289, 1, ")"], [65290, 1, "*"], [65291, 1, "+"], [65292, 1, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 1, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 1, ":"], [65307, 1, ";"], [65308, 1, "<"], [65309, 1, "="], [65310, 1, ">"], [65311, 1, "?"], [65312, 1, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 1, "["], [65340, 1, "\\"], [65341, 1, "]"], [65342, 1, "^"], [65343, 1, "_"], [65344, 1, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 1, "{"], [65372, 1, "|"], [65373, 1, "}"], [65374, 1, "~"], [65375, 1, "⦅"], [65376, 1, "⦆"], [65377, 1, "."], [65378, 1, "「"], [65379, 1, "」"], [65380, 1, "、"], [65381, 1, "・"], [65382, 1, "ヲ"], [65383, 1, "ァ"], [65384, 1, "ィ"], [65385, 1, "ゥ"], [65386, 1, "ェ"], [65387, 1, "ォ"], [65388, 1, "ャ"], [65389, 1, "ュ"], [65390, 1, "ョ"], [65391, 1, "ッ"], [65392, 1, "ー"], [65393, 1, "ア"], [65394, 1, "イ"], [65395, 1, "ウ"], [65396, 1, "エ"], [65397, 1, "オ"], [65398, 1, "カ"], [65399, 1, "キ"], [65400, 1, "ク"], [65401, 1, "ケ"], [65402, 1, "コ"], [65403, 1, "サ"], [65404, 1, "シ"], [65405, 1, "ス"], [65406, 1, "セ"], [65407, 1, "ソ"], [65408, 1, "タ"], [65409, 1, "チ"], [65410, 1, "ツ"], [65411, 1, "テ"], [65412, 1, "ト"], [65413, 1, "ナ"], [65414, 1, "ニ"], [65415, 1, "ヌ"], [65416, 1, "ネ"], [65417, 1, "ノ"], [65418, 1, "ハ"], [65419, 1, "ヒ"], [65420, 1, "フ"], [65421, 1, "ヘ"], [65422, 1, "ホ"], [65423, 1, "マ"], [65424, 1, "ミ"], [65425, 1, "ム"], [65426, 1, "メ"], [65427, 1, "モ"], [65428, 1, "ヤ"], [65429, 1, "ユ"], [65430, 1, "ヨ"], [65431, 1, "ラ"], [65432, 1, "リ"], [65433, 1, "ル"], [65434, 1, "レ"], [65435, 1, "ロ"], [65436, 1, "ワ"], [65437, 1, "ン"], [65438, 1, "゙"], [65439, 1, "゚"], [65440, 7], [65441, 1, "ᄀ"], [65442, 1, "ᄁ"], [65443, 1, "ᆪ"], [65444, 1, "ᄂ"], [65445, 1, "ᆬ"], [65446, 1, "ᆭ"], [65447, 1, "ᄃ"], [65448, 1, "ᄄ"], [65449, 1, "ᄅ"], [65450, 1, "ᆰ"], [65451, 1, "ᆱ"], [65452, 1, "ᆲ"], [65453, 1, "ᆳ"], [65454, 1, "ᆴ"], [65455, 1, "ᆵ"], [65456, 1, "ᄚ"], [65457, 1, "ᄆ"], [65458, 1, "ᄇ"], [65459, 1, "ᄈ"], [65460, 1, "ᄡ"], [65461, 1, "ᄉ"], [65462, 1, "ᄊ"], [65463, 1, "ᄋ"], [65464, 1, "ᄌ"], [65465, 1, "ᄍ"], [65466, 1, "ᄎ"], [65467, 1, "ᄏ"], [65468, 1, "ᄐ"], [65469, 1, "ᄑ"], [65470, 1, "ᄒ"], [[65471, 65473], 3], [65474, 1, "ᅡ"], [65475, 1, "ᅢ"], [65476, 1, "ᅣ"], [65477, 1, "ᅤ"], [65478, 1, "ᅥ"], [65479, 1, "ᅦ"], [[65480, 65481], 3], [65482, 1, "ᅧ"], [65483, 1, "ᅨ"], [65484, 1, "ᅩ"], [65485, 1, "ᅪ"], [65486, 1, "ᅫ"], [65487, 1, "ᅬ"], [[65488, 65489], 3], [65490, 1, "ᅭ"], [65491, 1, "ᅮ"], [65492, 1, "ᅯ"], [65493, 1, "ᅰ"], [65494, 1, "ᅱ"], [65495, 1, "ᅲ"], [[65496, 65497], 3], [65498, 1, "ᅳ"], [65499, 1, "ᅴ"], [65500, 1, "ᅵ"], [[65501, 65503], 3], [65504, 1, "¢"], [65505, 1, "£"], [65506, 1, "¬"], [65507, 1, " ̄"], [65508, 1, "¦"], [65509, 1, "¥"], [65510, 1, "₩"], [65511, 3], [65512, 1, "│"], [65513, 1, "←"], [65514, 1, "↑"], [65515, 1, "→"], [65516, 1, "↓"], [65517, 1, "■"], [65518, 1, "○"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66000, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\uD801\uDC28"], [66561, 1, "\uD801\uDC29"], [66562, 1, "\uD801\uDC2A"], [66563, 1, "\uD801\uDC2B"], [66564, 1, "\uD801\uDC2C"], [66565, 1, "\uD801\uDC2D"], [66566, 1, "\uD801\uDC2E"], [66567, 1, "\uD801\uDC2F"], [66568, 1, "\uD801\uDC30"], [66569, 1, "\uD801\uDC31"], [66570, 1, "\uD801\uDC32"], [66571, 1, "\uD801\uDC33"], [66572, 1, "\uD801\uDC34"], [66573, 1, "\uD801\uDC35"], [66574, 1, "\uD801\uDC36"], [66575, 1, "\uD801\uDC37"], [66576, 1, "\uD801\uDC38"], [66577, 1, "\uD801\uDC39"], [66578, 1, "\uD801\uDC3A"], [66579, 1, "\uD801\uDC3B"], [66580, 1, "\uD801\uDC3C"], [66581, 1, "\uD801\uDC3D"], [66582, 1, "\uD801\uDC3E"], [66583, 1, "\uD801\uDC3F"], [66584, 1, "\uD801\uDC40"], [66585, 1, "\uD801\uDC41"], [66586, 1, "\uD801\uDC42"], [66587, 1, "\uD801\uDC43"], [66588, 1, "\uD801\uDC44"], [66589, 1, "\uD801\uDC45"], [66590, 1, "\uD801\uDC46"], [66591, 1, "\uD801\uDC47"], [66592, 1, "\uD801\uDC48"], [66593, 1, "\uD801\uDC49"], [66594, 1, "\uD801\uDC4A"], [66595, 1, "\uD801\uDC4B"], [66596, 1, "\uD801\uDC4C"], [66597, 1, "\uD801\uDC4D"], [66598, 1, "\uD801\uDC4E"], [66599, 1, "\uD801\uDC4F"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\uD801\uDCD8"], [66737, 1, "\uD801\uDCD9"], [66738, 1, "\uD801\uDCDA"], [66739, 1, "\uD801\uDCDB"], [66740, 1, "\uD801\uDCDC"], [66741, 1, "\uD801\uDCDD"], [66742, 1, "\uD801\uDCDE"], [66743, 1, "\uD801\uDCDF"], [66744, 1, "\uD801\uDCE0"], [66745, 1, "\uD801\uDCE1"], [66746, 1, "\uD801\uDCE2"], [66747, 1, "\uD801\uDCE3"], [66748, 1, "\uD801\uDCE4"], [66749, 1, "\uD801\uDCE5"], [66750, 1, "\uD801\uDCE6"], [66751, 1, "\uD801\uDCE7"], [66752, 1, "\uD801\uDCE8"], [66753, 1, "\uD801\uDCE9"], [66754, 1, "\uD801\uDCEA"], [66755, 1, "\uD801\uDCEB"], [66756, 1, "\uD801\uDCEC"], [66757, 1, "\uD801\uDCED"], [66758, 1, "\uD801\uDCEE"], [66759, 1, "\uD801\uDCEF"], [66760, 1, "\uD801\uDCF0"], [66761, 1, "\uD801\uDCF1"], [66762, 1, "\uD801\uDCF2"], [66763, 1, "\uD801\uDCF3"], [66764, 1, "\uD801\uDCF4"], [66765, 1, "\uD801\uDCF5"], [66766, 1, "\uD801\uDCF6"], [66767, 1, "\uD801\uDCF7"], [66768, 1, "\uD801\uDCF8"], [66769, 1, "\uD801\uDCF9"], [66770, 1, "\uD801\uDCFA"], [66771, 1, "\uD801\uDCFB"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\uD801\uDD97"], [66929, 1, "\uD801\uDD98"], [66930, 1, "\uD801\uDD99"], [66931, 1, "\uD801\uDD9A"], [66932, 1, "\uD801\uDD9B"], [66933, 1, "\uD801\uDD9C"], [66934, 1, "\uD801\uDD9D"], [66935, 1, "\uD801\uDD9E"], [66936, 1, "\uD801\uDD9F"], [66937, 1, "\uD801\uDDA0"], [66938, 1, "\uD801\uDDA1"], [66939, 3], [66940, 1, "\uD801\uDDA3"], [66941, 1, "\uD801\uDDA4"], [66942, 1, "\uD801\uDDA5"], [66943, 1, "\uD801\uDDA6"], [66944, 1, "\uD801\uDDA7"], [66945, 1, "\uD801\uDDA8"], [66946, 1, "\uD801\uDDA9"], [66947, 1, "\uD801\uDDAA"], [66948, 1, "\uD801\uDDAB"], [66949, 1, "\uD801\uDDAC"], [66950, 1, "\uD801\uDDAD"], [66951, 1, "\uD801\uDDAE"], [66952, 1, "\uD801\uDDAF"], [66953, 1, "\uD801\uDDB0"], [66954, 1, "\uD801\uDDB1"], [66955, 3], [66956, 1, "\uD801\uDDB3"], [66957, 1, "\uD801\uDDB4"], [66958, 1, "\uD801\uDDB5"], [66959, 1, "\uD801\uDDB6"], [66960, 1, "\uD801\uDDB7"], [66961, 1, "\uD801\uDDB8"], [66962, 1, "\uD801\uDDB9"], [66963, 3], [66964, 1, "\uD801\uDDBB"], [66965, 1, "\uD801\uDDBC"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67007], 3], [[67008, 67059], 2], [[67060, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "ː"], [67458, 1, "ˑ"], [67459, 1, "æ"], [67460, 1, "ʙ"], [67461, 1, "ɓ"], [67462, 3], [67463, 1, "ʣ"], [67464, 1, "ꭦ"], [67465, 1, "ʥ"], [67466, 1, "ʤ"], [67467, 1, "ɖ"], [67468, 1, "ɗ"], [67469, 1, "ᶑ"], [67470, 1, "ɘ"], [67471, 1, "ɞ"], [67472, 1, "ʩ"], [67473, 1, "ɤ"], [67474, 1, "ɢ"], [67475, 1, "ɠ"], [67476, 1, "ʛ"], [67477, 1, "ħ"], [67478, 1, "ʜ"], [67479, 1, "ɧ"], [67480, 1, "ʄ"], [67481, 1, "ʪ"], [67482, 1, "ʫ"], [67483, 1, "ɬ"], [67484, 1, "\uD837\uDF04"], [67485, 1, "ꞎ"], [67486, 1, "ɮ"], [67487, 1, "\uD837\uDF05"], [67488, 1, "ʎ"], [67489, 1, "\uD837\uDF06"], [67490, 1, "ø"], [67491, 1, "ɶ"], [67492, 1, "ɷ"], [67493, 1, "q"], [67494, 1, "ɺ"], [67495, 1, "\uD837\uDF08"], [67496, 1, "ɽ"], [67497, 1, "ɾ"], [67498, 1, "ʀ"], [67499, 1, "ʨ"], [67500, 1, "ʦ"], [67501, 1, "ꭧ"], [67502, 1, "ʧ"], [67503, 1, "ʈ"], [67504, 1, "ⱱ"], [67505, 3], [67506, 1, "ʏ"], [67507, 1, "ʡ"], [67508, 1, "ʢ"], [67509, 1, "ʘ"], [67510, 1, "ǀ"], [67511, 1, "ǁ"], [67512, 1, "ǂ"], [67513, 1, "\uD837\uDF0A"], [67514, 1, "\uD837\uDF1E"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\uD803\uDCC0"], [68737, 1, "\uD803\uDCC1"], [68738, 1, "\uD803\uDCC2"], [68739, 1, "\uD803\uDCC3"], [68740, 1, "\uD803\uDCC4"], [68741, 1, "\uD803\uDCC5"], [68742, 1, "\uD803\uDCC6"], [68743, 1, "\uD803\uDCC7"], [68744, 1, "\uD803\uDCC8"], [68745, 1, "\uD803\uDCC9"], [68746, 1, "\uD803\uDCCA"], [68747, 1, "\uD803\uDCCB"], [68748, 1, "\uD803\uDCCC"], [68749, 1, "\uD803\uDCCD"], [68750, 1, "\uD803\uDCCE"], [68751, 1, "\uD803\uDCCF"], [68752, 1, "\uD803\uDCD0"], [68753, 1, "\uD803\uDCD1"], [68754, 1, "\uD803\uDCD2"], [68755, 1, "\uD803\uDCD3"], [68756, 1, "\uD803\uDCD4"], [68757, 1, "\uD803\uDCD5"], [68758, 1, "\uD803\uDCD6"], [68759, 1, "\uD803\uDCD7"], [68760, 1, "\uD803\uDCD8"], [68761, 1, "\uD803\uDCD9"], [68762, 1, "\uD803\uDCDA"], [68763, 1, "\uD803\uDCDB"], [68764, 1, "\uD803\uDCDC"], [68765, 1, "\uD803\uDCDD"], [68766, 1, "\uD803\uDCDE"], [68767, 1, "\uD803\uDCDF"], [68768, 1, "\uD803\uDCE0"], [68769, 1, "\uD803\uDCE1"], [68770, 1, "\uD803\uDCE2"], [68771, 1, "\uD803\uDCE3"], [68772, 1, "\uD803\uDCE4"], [68773, 1, "\uD803\uDCE5"], [68774, 1, "\uD803\uDCE6"], [68775, 1, "\uD803\uDCE7"], [68776, 1, "\uD803\uDCE8"], [68777, 1, "\uD803\uDCE9"], [68778, 1, "\uD803\uDCEA"], [68779, 1, "\uD803\uDCEB"], [68780, 1, "\uD803\uDCEC"], [68781, 1, "\uD803\uDCED"], [68782, 1, "\uD803\uDCEE"], [68783, 1, "\uD803\uDCEF"], [68784, 1, "\uD803\uDCF0"], [68785, 1, "\uD803\uDCF1"], [68786, 1, "\uD803\uDCF2"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 68927], 3], [[68928, 68943], 2], [68944, 1, "\uD803\uDD70"], [68945, 1, "\uD803\uDD71"], [68946, 1, "\uD803\uDD72"], [68947, 1, "\uD803\uDD73"], [68948, 1, "\uD803\uDD74"], [68949, 1, "\uD803\uDD75"], [68950, 1, "\uD803\uDD76"], [68951, 1, "\uD803\uDD77"], [68952, 1, "\uD803\uDD78"], [68953, 1, "\uD803\uDD79"], [68954, 1, "\uD803\uDD7A"], [68955, 1, "\uD803\uDD7B"], [68956, 1, "\uD803\uDD7C"], [68957, 1, "\uD803\uDD7D"], [68958, 1, "\uD803\uDD7E"], [68959, 1, "\uD803\uDD7F"], [68960, 1, "\uD803\uDD80"], [68961, 1, "\uD803\uDD81"], [68962, 1, "\uD803\uDD82"], [68963, 1, "\uD803\uDD83"], [68964, 1, "\uD803\uDD84"], [68965, 1, "\uD803\uDD85"], [[68966, 68968], 3], [[68969, 68973], 2], [68974, 2], [[68975, 68997], 2], [[68998, 69005], 3], [[69006, 69007], 2], [[69008, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69313], 3], [[69314, 69316], 2], [[69317, 69371], 3], [69372, 2], [[69373, 69375], 2], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70209], 2], [[70210, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70527], 3], [[70528, 70537], 2], [70538, 3], [70539, 2], [[70540, 70541], 3], [70542, 2], [70543, 3], [[70544, 70581], 2], [70582, 3], [[70583, 70592], 2], [70593, 3], [70594, 2], [[70595, 70596], 3], [70597, 2], [70598, 3], [[70599, 70602], 2], [70603, 3], [[70604, 70611], 2], [[70612, 70613], 2], [70614, 3], [[70615, 70616], 2], [[70617, 70624], 3], [[70625, 70626], 2], [[70627, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71375], 3], [[71376, 71395], 2], [[71396, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\uD806\uDCC0"], [71841, 1, "\uD806\uDCC1"], [71842, 1, "\uD806\uDCC2"], [71843, 1, "\uD806\uDCC3"], [71844, 1, "\uD806\uDCC4"], [71845, 1, "\uD806\uDCC5"], [71846, 1, "\uD806\uDCC6"], [71847, 1, "\uD806\uDCC7"], [71848, 1, "\uD806\uDCC8"], [71849, 1, "\uD806\uDCC9"], [71850, 1, "\uD806\uDCCA"], [71851, 1, "\uD806\uDCCB"], [71852, 1, "\uD806\uDCCC"], [71853, 1, "\uD806\uDCCD"], [71854, 1, "\uD806\uDCCE"], [71855, 1, "\uD806\uDCCF"], [71856, 1, "\uD806\uDCD0"], [71857, 1, "\uD806\uDCD1"], [71858, 1, "\uD806\uDCD2"], [71859, 1, "\uD806\uDCD3"], [71860, 1, "\uD806\uDCD4"], [71861, 1, "\uD806\uDCD5"], [71862, 1, "\uD806\uDCD6"], [71863, 1, "\uD806\uDCD7"], [71864, 1, "\uD806\uDCD8"], [71865, 1, "\uD806\uDCD9"], [71866, 1, "\uD806\uDCDA"], [71867, 1, "\uD806\uDCDB"], [71868, 1, "\uD806\uDCDC"], [71869, 1, "\uD806\uDCDD"], [71870, 1, "\uD806\uDCDE"], [71871, 1, "\uD806\uDCDF"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72447], 3], [[72448, 72457], 2], [[72458, 72639], 3], [[72640, 72672], 2], [72673, 2], [[72674, 72687], 3], [[72688, 72697], 2], [[72698, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73471], 3], [[73472, 73488], 2], [73489, 3], [[73490, 73530], 2], [[73531, 73533], 3], [[73534, 73538], 2], [[73539, 73551], 2], [[73552, 73561], 2], [73562, 2], [[73563, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 2], [[78896, 78904], 3], [[78905, 78911], 3], [[78912, 78933], 2], [[78934, 78943], 3], [[78944, 82938], 2], [[82939, 82943], 3], [[82944, 83526], 2], [[83527, 90367], 3], [[90368, 90425], 2], [[90426, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93503], 3], [[93504, 93548], 2], [[93549, 93551], 2], [[93552, 93561], 2], [[93562, 93759], 3], [93760, 1, "\uD81B\uDE60"], [93761, 1, "\uD81B\uDE61"], [93762, 1, "\uD81B\uDE62"], [93763, 1, "\uD81B\uDE63"], [93764, 1, "\uD81B\uDE64"], [93765, 1, "\uD81B\uDE65"], [93766, 1, "\uD81B\uDE66"], [93767, 1, "\uD81B\uDE67"], [93768, 1, "\uD81B\uDE68"], [93769, 1, "\uD81B\uDE69"], [93770, 1, "\uD81B\uDE6A"], [93771, 1, "\uD81B\uDE6B"], [93772, 1, "\uD81B\uDE6C"], [93773, 1, "\uD81B\uDE6D"], [93774, 1, "\uD81B\uDE6E"], [93775, 1, "\uD81B\uDE6F"], [93776, 1, "\uD81B\uDE70"], [93777, 1, "\uD81B\uDE71"], [93778, 1, "\uD81B\uDE72"], [93779, 1, "\uD81B\uDE73"], [93780, 1, "\uD81B\uDE74"], [93781, 1, "\uD81B\uDE75"], [93782, 1, "\uD81B\uDE76"], [93783, 1, "\uD81B\uDE77"], [93784, 1, "\uD81B\uDE78"], [93785, 1, "\uD81B\uDE79"], [93786, 1, "\uD81B\uDE7A"], [93787, 1, "\uD81B\uDE7B"], [93788, 1, "\uD81B\uDE7C"], [93789, 1, "\uD81B\uDE7D"], [93790, 1, "\uD81B\uDE7E"], [93791, 1, "\uD81B\uDE7F"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101630], 3], [101631, 2], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110897], 3], [110898, 2], [[110899, 110927], 3], [[110928, 110930], 2], [[110931, 110932], 3], [110933, 2], [[110934, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 117759], 3], [[117760, 117973], 2], [117974, 1, "a"], [117975, 1, "b"], [117976, 1, "c"], [117977, 1, "d"], [117978, 1, "e"], [117979, 1, "f"], [117980, 1, "g"], [117981, 1, "h"], [117982, 1, "i"], [117983, 1, "j"], [117984, 1, "k"], [117985, 1, "l"], [117986, 1, "m"], [117987, 1, "n"], [117988, 1, "o"], [117989, 1, "p"], [117990, 1, "q"], [117991, 1, "r"], [117992, 1, "s"], [117993, 1, "t"], [117994, 1, "u"], [117995, 1, "v"], [117996, 1, "w"], [117997, 1, "x"], [117998, 1, "y"], [117999, 1, "z"], [118000, 1, "0"], [118001, 1, "1"], [118002, 1, "2"], [118003, 1, "3"], [118004, 1, "4"], [118005, 1, "5"], [118006, 1, "6"], [118007, 1, "7"], [118008, 1, "8"], [118009, 1, "9"], [[118010, 118015], 3], [[118016, 118451], 2], [[118452, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\uD834\uDD57\uD834\uDD65"], [119135, 1, "\uD834\uDD58\uD834\uDD65"], [119136, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD6E"], [119137, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD6F"], [119138, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD70"], [119139, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD71"], [119140, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD72"], [[119141, 119154], 2], [[119155, 119162], 7], [[119163, 119226], 2], [119227, 1, "\uD834\uDDB9\uD834\uDD65"], [119228, 1, "\uD834\uDDBA\uD834\uDD65"], [119229, 1, "\uD834\uDDB9\uD834\uDD65\uD834\uDD6E"], [119230, 1, "\uD834\uDDBA\uD834\uDD65\uD834\uDD6E"], [119231, 1, "\uD834\uDDB9\uD834\uDD65\uD834\uDD6F"], [119232, 1, "\uD834\uDDBA\uD834\uDD65\uD834\uDD6F"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119487], 3], [[119488, 119507], 2], [[119508, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [120000, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "ı"], [120485, 1, "ȷ"], [[120486, 120487], 3], [120488, 1, "α"], [120489, 1, "β"], [120490, 1, "γ"], [120491, 1, "δ"], [120492, 1, "ε"], [120493, 1, "ζ"], [120494, 1, "η"], [120495, 1, "θ"], [120496, 1, "ι"], [120497, 1, "κ"], [120498, 1, "λ"], [120499, 1, "μ"], [120500, 1, "ν"], [120501, 1, "ξ"], [120502, 1, "ο"], [120503, 1, "π"], [120504, 1, "ρ"], [120505, 1, "θ"], [120506, 1, "σ"], [120507, 1, "τ"], [120508, 1, "υ"], [120509, 1, "φ"], [120510, 1, "χ"], [120511, 1, "ψ"], [120512, 1, "ω"], [120513, 1, "∇"], [120514, 1, "α"], [120515, 1, "β"], [120516, 1, "γ"], [120517, 1, "δ"], [120518, 1, "ε"], [120519, 1, "ζ"], [120520, 1, "η"], [120521, 1, "θ"], [120522, 1, "ι"], [120523, 1, "κ"], [120524, 1, "λ"], [120525, 1, "μ"], [120526, 1, "ν"], [120527, 1, "ξ"], [120528, 1, "ο"], [120529, 1, "π"], [120530, 1, "ρ"], [[120531, 120532], 1, "σ"], [120533, 1, "τ"], [120534, 1, "υ"], [120535, 1, "φ"], [120536, 1, "χ"], [120537, 1, "ψ"], [120538, 1, "ω"], [120539, 1, "∂"], [120540, 1, "ε"], [120541, 1, "θ"], [120542, 1, "κ"], [120543, 1, "φ"], [120544, 1, "ρ"], [120545, 1, "π"], [120546, 1, "α"], [120547, 1, "β"], [120548, 1, "γ"], [120549, 1, "δ"], [120550, 1, "ε"], [120551, 1, "ζ"], [120552, 1, "η"], [120553, 1, "θ"], [120554, 1, "ι"], [120555, 1, "κ"], [120556, 1, "λ"], [120557, 1, "μ"], [120558, 1, "ν"], [120559, 1, "ξ"], [120560, 1, "ο"], [120561, 1, "π"], [120562, 1, "ρ"], [120563, 1, "θ"], [120564, 1, "σ"], [120565, 1, "τ"], [120566, 1, "υ"], [120567, 1, "φ"], [120568, 1, "χ"], [120569, 1, "ψ"], [120570, 1, "ω"], [120571, 1, "∇"], [120572, 1, "α"], [120573, 1, "β"], [120574, 1, "γ"], [120575, 1, "δ"], [120576, 1, "ε"], [120577, 1, "ζ"], [120578, 1, "η"], [120579, 1, "θ"], [120580, 1, "ι"], [120581, 1, "κ"], [120582, 1, "λ"], [120583, 1, "μ"], [120584, 1, "ν"], [120585, 1, "ξ"], [120586, 1, "ο"], [120587, 1, "π"], [120588, 1, "ρ"], [[120589, 120590], 1, "σ"], [120591, 1, "τ"], [120592, 1, "υ"], [120593, 1, "φ"], [120594, 1, "χ"], [120595, 1, "ψ"], [120596, 1, "ω"], [120597, 1, "∂"], [120598, 1, "ε"], [120599, 1, "θ"], [120600, 1, "κ"], [120601, 1, "φ"], [120602, 1, "ρ"], [120603, 1, "π"], [120604, 1, "α"], [120605, 1, "β"], [120606, 1, "γ"], [120607, 1, "δ"], [120608, 1, "ε"], [120609, 1, "ζ"], [120610, 1, "η"], [120611, 1, "θ"], [120612, 1, "ι"], [120613, 1, "κ"], [120614, 1, "λ"], [120615, 1, "μ"], [120616, 1, "ν"], [120617, 1, "ξ"], [120618, 1, "ο"], [120619, 1, "π"], [120620, 1, "ρ"], [120621, 1, "θ"], [120622, 1, "σ"], [120623, 1, "τ"], [120624, 1, "υ"], [120625, 1, "φ"], [120626, 1, "χ"], [120627, 1, "ψ"], [120628, 1, "ω"], [120629, 1, "∇"], [120630, 1, "α"], [120631, 1, "β"], [120632, 1, "γ"], [120633, 1, "δ"], [120634, 1, "ε"], [120635, 1, "ζ"], [120636, 1, "η"], [120637, 1, "θ"], [120638, 1, "ι"], [120639, 1, "κ"], [120640, 1, "λ"], [120641, 1, "μ"], [120642, 1, "ν"], [120643, 1, "ξ"], [120644, 1, "ο"], [120645, 1, "π"], [120646, 1, "ρ"], [[120647, 120648], 1, "σ"], [120649, 1, "τ"], [120650, 1, "υ"], [120651, 1, "φ"], [120652, 1, "χ"], [120653, 1, "ψ"], [120654, 1, "ω"], [120655, 1, "∂"], [120656, 1, "ε"], [120657, 1, "θ"], [120658, 1, "κ"], [120659, 1, "φ"], [120660, 1, "ρ"], [120661, 1, "π"], [120662, 1, "α"], [120663, 1, "β"], [120664, 1, "γ"], [120665, 1, "δ"], [120666, 1, "ε"], [120667, 1, "ζ"], [120668, 1, "η"], [120669, 1, "θ"], [120670, 1, "ι"], [120671, 1, "κ"], [120672, 1, "λ"], [120673, 1, "μ"], [120674, 1, "ν"], [120675, 1, "ξ"], [120676, 1, "ο"], [120677, 1, "π"], [120678, 1, "ρ"], [120679, 1, "θ"], [120680, 1, "σ"], [120681, 1, "τ"], [120682, 1, "υ"], [120683, 1, "φ"], [120684, 1, "χ"], [120685, 1, "ψ"], [120686, 1, "ω"], [120687, 1, "∇"], [120688, 1, "α"], [120689, 1, "β"], [120690, 1, "γ"], [120691, 1, "δ"], [120692, 1, "ε"], [120693, 1, "ζ"], [120694, 1, "η"], [120695, 1, "θ"], [120696, 1, "ι"], [120697, 1, "κ"], [120698, 1, "λ"], [120699, 1, "μ"], [120700, 1, "ν"], [120701, 1, "ξ"], [120702, 1, "ο"], [120703, 1, "π"], [120704, 1, "ρ"], [[120705, 120706], 1, "σ"], [120707, 1, "τ"], [120708, 1, "υ"], [120709, 1, "φ"], [120710, 1, "χ"], [120711, 1, "ψ"], [120712, 1, "ω"], [120713, 1, "∂"], [120714, 1, "ε"], [120715, 1, "θ"], [120716, 1, "κ"], [120717, 1, "φ"], [120718, 1, "ρ"], [120719, 1, "π"], [120720, 1, "α"], [120721, 1, "β"], [120722, 1, "γ"], [120723, 1, "δ"], [120724, 1, "ε"], [120725, 1, "ζ"], [120726, 1, "η"], [120727, 1, "θ"], [120728, 1, "ι"], [120729, 1, "κ"], [120730, 1, "λ"], [120731, 1, "μ"], [120732, 1, "ν"], [120733, 1, "ξ"], [120734, 1, "ο"], [120735, 1, "π"], [120736, 1, "ρ"], [120737, 1, "θ"], [120738, 1, "σ"], [120739, 1, "τ"], [120740, 1, "υ"], [120741, 1, "φ"], [120742, 1, "χ"], [120743, 1, "ψ"], [120744, 1, "ω"], [120745, 1, "∇"], [120746, 1, "α"], [120747, 1, "β"], [120748, 1, "γ"], [120749, 1, "δ"], [120750, 1, "ε"], [120751, 1, "ζ"], [120752, 1, "η"], [120753, 1, "θ"], [120754, 1, "ι"], [120755, 1, "κ"], [120756, 1, "λ"], [120757, 1, "μ"], [120758, 1, "ν"], [120759, 1, "ξ"], [120760, 1, "ο"], [120761, 1, "π"], [120762, 1, "ρ"], [[120763, 120764], 1, "σ"], [120765, 1, "τ"], [120766, 1, "υ"], [120767, 1, "φ"], [120768, 1, "χ"], [120769, 1, "ψ"], [120770, 1, "ω"], [120771, 1, "∂"], [120772, 1, "ε"], [120773, 1, "θ"], [120774, 1, "κ"], [120775, 1, "φ"], [120776, 1, "ρ"], [120777, 1, "π"], [[120778, 120779], 1, "ϝ"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122660], 3], [[122661, 122666], 2], [[122667, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 122927], 3], [122928, 1, "а"], [122929, 1, "б"], [122930, 1, "в"], [122931, 1, "г"], [122932, 1, "д"], [122933, 1, "е"], [122934, 1, "ж"], [122935, 1, "з"], [122936, 1, "и"], [122937, 1, "к"], [122938, 1, "л"], [122939, 1, "м"], [122940, 1, "о"], [122941, 1, "п"], [122942, 1, "р"], [122943, 1, "с"], [122944, 1, "т"], [122945, 1, "у"], [122946, 1, "ф"], [122947, 1, "х"], [122948, 1, "ц"], [122949, 1, "ч"], [122950, 1, "ш"], [122951, 1, "ы"], [122952, 1, "э"], [122953, 1, "ю"], [122954, 1, "ꚉ"], [122955, 1, "ә"], [122956, 1, "і"], [122957, 1, "ј"], [122958, 1, "ө"], [122959, 1, "ү"], [122960, 1, "ӏ"], [122961, 1, "а"], [122962, 1, "б"], [122963, 1, "в"], [122964, 1, "г"], [122965, 1, "д"], [122966, 1, "е"], [122967, 1, "ж"], [122968, 1, "з"], [122969, 1, "и"], [122970, 1, "к"], [122971, 1, "л"], [122972, 1, "о"], [122973, 1, "п"], [122974, 1, "с"], [122975, 1, "у"], [122976, 1, "ф"], [122977, 1, "х"], [122978, 1, "ц"], [122979, 1, "ч"], [122980, 1, "ш"], [122981, 1, "ъ"], [122982, 1, "ы"], [122983, 1, "ґ"], [122984, 1, "і"], [122985, 1, "ѕ"], [122986, 1, "џ"], [122987, 1, "ҫ"], [122988, 1, "ꙑ"], [122989, 1, "ұ"], [[122990, 123022], 3], [123023, 2], [[123024, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124111], 3], [[124112, 124153], 2], [[124154, 124367], 3], [[124368, 124410], 2], [[124411, 124414], 3], [124415, 2], [[124416, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\uD83A\uDD22"], [125185, 1, "\uD83A\uDD23"], [125186, 1, "\uD83A\uDD24"], [125187, 1, "\uD83A\uDD25"], [125188, 1, "\uD83A\uDD26"], [125189, 1, "\uD83A\uDD27"], [125190, 1, "\uD83A\uDD28"], [125191, 1, "\uD83A\uDD29"], [125192, 1, "\uD83A\uDD2A"], [125193, 1, "\uD83A\uDD2B"], [125194, 1, "\uD83A\uDD2C"], [125195, 1, "\uD83A\uDD2D"], [125196, 1, "\uD83A\uDD2E"], [125197, 1, "\uD83A\uDD2F"], [125198, 1, "\uD83A\uDD30"], [125199, 1, "\uD83A\uDD31"], [125200, 1, "\uD83A\uDD32"], [125201, 1, "\uD83A\uDD33"], [125202, 1, "\uD83A\uDD34"], [125203, 1, "\uD83A\uDD35"], [125204, 1, "\uD83A\uDD36"], [125205, 1, "\uD83A\uDD37"], [125206, 1, "\uD83A\uDD38"], [125207, 1, "\uD83A\uDD39"], [125208, 1, "\uD83A\uDD3A"], [125209, 1, "\uD83A\uDD3B"], [125210, 1, "\uD83A\uDD3C"], [125211, 1, "\uD83A\uDD3D"], [125212, 1, "\uD83A\uDD3E"], [125213, 1, "\uD83A\uDD3F"], [125214, 1, "\uD83A\uDD40"], [125215, 1, "\uD83A\uDD41"], [125216, 1, "\uD83A\uDD42"], [125217, 1, "\uD83A\uDD43"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "ا"], [126465, 1, "ب"], [126466, 1, "ج"], [126467, 1, "د"], [126468, 3], [126469, 1, "و"], [126470, 1, "ز"], [126471, 1, "ح"], [126472, 1, "ط"], [126473, 1, "ي"], [126474, 1, "ك"], [126475, 1, "ل"], [126476, 1, "م"], [126477, 1, "ن"], [126478, 1, "س"], [126479, 1, "ع"], [126480, 1, "ف"], [126481, 1, "ص"], [126482, 1, "ق"], [126483, 1, "ر"], [126484, 1, "ش"], [126485, 1, "ت"], [126486, 1, "ث"], [126487, 1, "خ"], [126488, 1, "ذ"], [126489, 1, "ض"], [126490, 1, "ظ"], [126491, 1, "غ"], [126492, 1, "ٮ"], [126493, 1, "ں"], [126494, 1, "ڡ"], [126495, 1, "ٯ"], [126496, 3], [126497, 1, "ب"], [126498, 1, "ج"], [126499, 3], [126500, 1, "ه"], [[126501, 126502], 3], [126503, 1, "ح"], [126504, 3], [126505, 1, "ي"], [126506, 1, "ك"], [126507, 1, "ل"], [126508, 1, "م"], [126509, 1, "ن"], [126510, 1, "س"], [126511, 1, "ع"], [126512, 1, "ف"], [126513, 1, "ص"], [126514, 1, "ق"], [126515, 3], [126516, 1, "ش"], [126517, 1, "ت"], [126518, 1, "ث"], [126519, 1, "خ"], [126520, 3], [126521, 1, "ض"], [126522, 3], [126523, 1, "غ"], [[126524, 126529], 3], [126530, 1, "ج"], [[126531, 126534], 3], [126535, 1, "ح"], [126536, 3], [126537, 1, "ي"], [126538, 3], [126539, 1, "ل"], [126540, 3], [126541, 1, "ن"], [126542, 1, "س"], [126543, 1, "ع"], [126544, 3], [126545, 1, "ص"], [126546, 1, "ق"], [126547, 3], [126548, 1, "ش"], [[126549, 126550], 3], [126551, 1, "خ"], [126552, 3], [126553, 1, "ض"], [126554, 3], [126555, 1, "غ"], [126556, 3], [126557, 1, "ں"], [126558, 3], [126559, 1, "ٯ"], [126560, 3], [126561, 1, "ب"], [126562, 1, "ج"], [126563, 3], [126564, 1, "ه"], [[126565, 126566], 3], [126567, 1, "ح"], [126568, 1, "ط"], [126569, 1, "ي"], [126570, 1, "ك"], [126571, 3], [126572, 1, "م"], [126573, 1, "ن"], [126574, 1, "س"], [126575, 1, "ع"], [126576, 1, "ف"], [126577, 1, "ص"], [126578, 1, "ق"], [126579, 3], [126580, 1, "ش"], [126581, 1, "ت"], [126582, 1, "ث"], [126583, 1, "خ"], [126584, 3], [126585, 1, "ض"], [126586, 1, "ظ"], [126587, 1, "غ"], [126588, 1, "ٮ"], [126589, 3], [126590, 1, "ڡ"], [126591, 3], [126592, 1, "ا"], [126593, 1, "ب"], [126594, 1, "ج"], [126595, 1, "د"], [126596, 1, "ه"], [126597, 1, "و"], [126598, 1, "ز"], [126599, 1, "ح"], [126600, 1, "ط"], [126601, 1, "ي"], [126602, 3], [126603, 1, "ل"], [126604, 1, "م"], [126605, 1, "ن"], [126606, 1, "س"], [126607, 1, "ع"], [126608, 1, "ف"], [126609, 1, "ص"], [126610, 1, "ق"], [126611, 1, "ر"], [126612, 1, "ش"], [126613, 1, "ت"], [126614, 1, "ث"], [126615, 1, "خ"], [126616, 1, "ذ"], [126617, 1, "ض"], [126618, 1, "ظ"], [126619, 1, "غ"], [[126620, 126624], 3], [126625, 1, "ب"], [126626, 1, "ج"], [126627, 1, "د"], [126628, 3], [126629, 1, "و"], [126630, 1, "ز"], [126631, 1, "ح"], [126632, 1, "ط"], [126633, 1, "ي"], [126634, 3], [126635, 1, "ل"], [126636, 1, "م"], [126637, 1, "ن"], [126638, 1, "س"], [126639, 1, "ع"], [126640, 1, "ف"], [126641, 1, "ص"], [126642, 1, "ق"], [126643, 1, "ر"], [126644, 1, "ش"], [126645, 1, "ت"], [126646, 1, "ث"], [126647, 1, "خ"], [126648, 1, "ذ"], [126649, 1, "ض"], [126650, 1, "ظ"], [126651, 1, "غ"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 1, "0,"], [127234, 1, "1,"], [127235, 1, "2,"], [127236, 1, "3,"], [127237, 1, "4,"], [127238, 1, "5,"], [127239, 1, "6,"], [127240, 1, "7,"], [127241, 1, "8,"], [127242, 1, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 1, "(a)"], [127249, 1, "(b)"], [127250, 1, "(c)"], [127251, 1, "(d)"], [127252, 1, "(e)"], [127253, 1, "(f)"], [127254, 1, "(g)"], [127255, 1, "(h)"], [127256, 1, "(i)"], [127257, 1, "(j)"], [127258, 1, "(k)"], [127259, 1, "(l)"], [127260, 1, "(m)"], [127261, 1, "(n)"], [127262, 1, "(o)"], [127263, 1, "(p)"], [127264, 1, "(q)"], [127265, 1, "(r)"], [127266, 1, "(s)"], [127267, 1, "(t)"], [127268, 1, "(u)"], [127269, 1, "(v)"], [127270, 1, "(w)"], [127271, 1, "(x)"], [127272, 1, "(y)"], [127273, 1, "(z)"], [127274, 1, "〔s〕"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "ほか"], [127489, 1, "ココ"], [127490, 1, "サ"], [[127491, 127503], 3], [127504, 1, "手"], [127505, 1, "字"], [127506, 1, "双"], [127507, 1, "デ"], [127508, 1, "二"], [127509, 1, "多"], [127510, 1, "解"], [127511, 1, "天"], [127512, 1, "交"], [127513, 1, "映"], [127514, 1, "無"], [127515, 1, "料"], [127516, 1, "前"], [127517, 1, "後"], [127518, 1, "再"], [127519, 1, "新"], [127520, 1, "初"], [127521, 1, "終"], [127522, 1, "生"], [127523, 1, "販"], [127524, 1, "声"], [127525, 1, "吹"], [127526, 1, "演"], [127527, 1, "投"], [127528, 1, "捕"], [127529, 1, "一"], [127530, 1, "三"], [127531, 1, "遊"], [127532, 1, "左"], [127533, 1, "中"], [127534, 1, "右"], [127535, 1, "指"], [127536, 1, "走"], [127537, 1, "打"], [127538, 1, "禁"], [127539, 1, "空"], [127540, 1, "合"], [127541, 1, "満"], [127542, 1, "有"], [127543, 1, "月"], [127544, 1, "申"], [127545, 1, "割"], [127546, 1, "営"], [127547, 1, "配"], [[127548, 127551], 3], [127552, 1, "〔本〕"], [127553, 1, "〔三〕"], [127554, 1, "〔二〕"], [127555, 1, "〔安〕"], [127556, 1, "〔点〕"], [127557, 1, "〔打〕"], [127558, 1, "〔盗〕"], [127559, 1, "〔勝〕"], [127560, 1, "〔敗〕"], [[127561, 127567], 3], [127568, 1, "得"], [127569, 1, "可"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128000, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128731], 3], [128732, 2], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128886], 2], [[128887, 128890], 3], [[128891, 128895], 2], [[128896, 128980], 2], [[128981, 128984], 2], [128985, 2], [[128986, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129211], 2], [[129212, 129215], 3], [[129216, 129217], 2], [[129218, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 2], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129672], 2], [129673, 2], [[129674, 129678], 3], [129679, 2], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 2], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129725], 2], [129726, 2], [129727, 2], [[129728, 129730], 2], [[129731, 129733], 2], [129734, 2], [[129735, 129741], 3], [[129742, 129743], 2], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129755], 2], [129756, 2], [[129757, 129758], 3], [129759, 2], [[129760, 129767], 2], [129768, 2], [129769, 2], [[129770, 129775], 3], [[129776, 129782], 2], [[129783, 129784], 2], [[129785, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 2], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [177977, 2], [[177978, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 191471], 3], [[191472, 192093], 2], [[192094, 194559], 3], [194560, 1, "丽"], [194561, 1, "丸"], [194562, 1, "乁"], [194563, 1, "\uD840\uDD22"], [194564, 1, "你"], [194565, 1, "侮"], [194566, 1, "侻"], [194567, 1, "倂"], [194568, 1, "偺"], [194569, 1, "備"], [194570, 1, "僧"], [194571, 1, "像"], [194572, 1, "㒞"], [194573, 1, "\uD841\uDE3A"], [194574, 1, "免"], [194575, 1, "兔"], [194576, 1, "兤"], [194577, 1, "具"], [194578, 1, "\uD841\uDD1C"], [194579, 1, "㒹"], [194580, 1, "內"], [194581, 1, "再"], [194582, 1, "\uD841\uDD4B"], [194583, 1, "冗"], [194584, 1, "冤"], [194585, 1, "仌"], [194586, 1, "冬"], [194587, 1, "况"], [194588, 1, "\uD864\uDDDF"], [194589, 1, "凵"], [194590, 1, "刃"], [194591, 1, "㓟"], [194592, 1, "刻"], [194593, 1, "剆"], [194594, 1, "割"], [194595, 1, "剷"], [194596, 1, "㔕"], [194597, 1, "勇"], [194598, 1, "勉"], [194599, 1, "勤"], [194600, 1, "勺"], [194601, 1, "包"], [194602, 1, "匆"], [194603, 1, "北"], [194604, 1, "卉"], [194605, 1, "卑"], [194606, 1, "博"], [194607, 1, "即"], [194608, 1, "卽"], [[194609, 194611], 1, "卿"], [194612, 1, "\uD842\uDE2C"], [194613, 1, "灰"], [194614, 1, "及"], [194615, 1, "叟"], [194616, 1, "\uD842\uDF63"], [194617, 1, "叫"], [194618, 1, "叱"], [194619, 1, "吆"], [194620, 1, "咞"], [194621, 1, "吸"], [194622, 1, "呈"], [194623, 1, "周"], [194624, 1, "咢"], [194625, 1, "哶"], [194626, 1, "唐"], [194627, 1, "啓"], [194628, 1, "啣"], [[194629, 194630], 1, "善"], [194631, 1, "喙"], [194632, 1, "喫"], [194633, 1, "喳"], [194634, 1, "嗂"], [194635, 1, "圖"], [194636, 1, "嘆"], [194637, 1, "圗"], [194638, 1, "噑"], [194639, 1, "噴"], [194640, 1, "切"], [194641, 1, "壮"], [194642, 1, "城"], [194643, 1, "埴"], [194644, 1, "堍"], [194645, 1, "型"], [194646, 1, "堲"], [194647, 1, "報"], [194648, 1, "墬"], [194649, 1, "\uD845\uDCE4"], [194650, 1, "売"], [194651, 1, "壷"], [194652, 1, "夆"], [194653, 1, "多"], [194654, 1, "夢"], [194655, 1, "奢"], [194656, 1, "\uD845\uDEA8"], [194657, 1, "\uD845\uDEEA"], [194658, 1, "姬"], [194659, 1, "娛"], [194660, 1, "娧"], [194661, 1, "姘"], [194662, 1, "婦"], [194663, 1, "㛮"], [194664, 1, "㛼"], [194665, 1, "嬈"], [[194666, 194667], 1, "嬾"], [194668, 1, "\uD846\uDDC8"], [194669, 1, "寃"], [194670, 1, "寘"], [194671, 1, "寧"], [194672, 1, "寳"], [194673, 1, "\uD846\uDF18"], [194674, 1, "寿"], [194675, 1, "将"], [194676, 1, "当"], [194677, 1, "尢"], [194678, 1, "㞁"], [194679, 1, "屠"], [194680, 1, "屮"], [194681, 1, "峀"], [194682, 1, "岍"], [194683, 1, "\uD847\uDDE4"], [194684, 1, "嵃"], [194685, 1, "\uD847\uDDE6"], [194686, 1, "嵮"], [194687, 1, "嵫"], [194688, 1, "嵼"], [194689, 1, "巡"], [194690, 1, "巢"], [194691, 1, "㠯"], [194692, 1, "巽"], [194693, 1, "帨"], [194694, 1, "帽"], [194695, 1, "幩"], [194696, 1, "㡢"], [194697, 1, "\uD848\uDD83"], [194698, 1, "㡼"], [194699, 1, "庰"], [194700, 1, "庳"], [194701, 1, "庶"], [194702, 1, "廊"], [194703, 1, "\uD868\uDF92"], [194704, 1, "廾"], [[194705, 194706], 1, "\uD848\uDF31"], [194707, 1, "舁"], [[194708, 194709], 1, "弢"], [194710, 1, "㣇"], [194711, 1, "\uD84C\uDEB8"], [194712, 1, "\uD858\uDDDA"], [194713, 1, "形"], [194714, 1, "彫"], [194715, 1, "㣣"], [194716, 1, "徚"], [194717, 1, "忍"], [194718, 1, "志"], [194719, 1, "忹"], [194720, 1, "悁"], [194721, 1, "㤺"], [194722, 1, "㤜"], [194723, 1, "悔"], [194724, 1, "\uD849\uDED4"], [194725, 1, "惇"], [194726, 1, "慈"], [194727, 1, "慌"], [194728, 1, "慎"], [194729, 1, "慌"], [194730, 1, "慺"], [194731, 1, "憎"], [194732, 1, "憲"], [194733, 1, "憤"], [194734, 1, "憯"], [194735, 1, "懞"], [194736, 1, "懲"], [194737, 1, "懶"], [194738, 1, "成"], [194739, 1, "戛"], [194740, 1, "扝"], [194741, 1, "抱"], [194742, 1, "拔"], [194743, 1, "捐"], [194744, 1, "\uD84A\uDF0C"], [194745, 1, "挽"], [194746, 1, "拼"], [194747, 1, "捨"], [194748, 1, "掃"], [194749, 1, "揤"], [194750, 1, "\uD84A\uDFF1"], [194751, 1, "搢"], [194752, 1, "揅"], [194753, 1, "掩"], [194754, 1, "㨮"], [194755, 1, "摩"], [194756, 1, "摾"], [194757, 1, "撝"], [194758, 1, "摷"], [194759, 1, "㩬"], [194760, 1, "敏"], [194761, 1, "敬"], [194762, 1, "\uD84C\uDC0A"], [194763, 1, "旣"], [194764, 1, "書"], [194765, 1, "晉"], [194766, 1, "㬙"], [194767, 1, "暑"], [194768, 1, "㬈"], [194769, 1, "㫤"], [194770, 1, "冒"], [194771, 1, "冕"], [194772, 1, "最"], [194773, 1, "暜"], [194774, 1, "肭"], [194775, 1, "䏙"], [194776, 1, "朗"], [194777, 1, "望"], [194778, 1, "朡"], [194779, 1, "杞"], [194780, 1, "杓"], [194781, 1, "\uD84C\uDFC3"], [194782, 1, "㭉"], [194783, 1, "柺"], [194784, 1, "枅"], [194785, 1, "桒"], [194786, 1, "梅"], [194787, 1, "\uD84D\uDC6D"], [194788, 1, "梎"], [194789, 1, "栟"], [194790, 1, "椔"], [194791, 1, "㮝"], [194792, 1, "楂"], [194793, 1, "榣"], [194794, 1, "槪"], [194795, 1, "檨"], [194796, 1, "\uD84D\uDEA3"], [194797, 1, "櫛"], [194798, 1, "㰘"], [194799, 1, "次"], [194800, 1, "\uD84E\uDCA7"], [194801, 1, "歔"], [194802, 1, "㱎"], [194803, 1, "歲"], [194804, 1, "殟"], [194805, 1, "殺"], [194806, 1, "殻"], [194807, 1, "\uD84E\uDE8D"], [194808, 1, "\uD847\uDD0B"], [194809, 1, "\uD84E\uDEFA"], [194810, 1, "汎"], [194811, 1, "\uD84F\uDCBC"], [194812, 1, "沿"], [194813, 1, "泍"], [194814, 1, "汧"], [194815, 1, "洖"], [194816, 1, "派"], [194817, 1, "海"], [194818, 1, "流"], [194819, 1, "浩"], [194820, 1, "浸"], [194821, 1, "涅"], [194822, 1, "\uD84F\uDD1E"], [194823, 1, "洴"], [194824, 1, "港"], [194825, 1, "湮"], [194826, 1, "㴳"], [194827, 1, "滋"], [194828, 1, "滇"], [194829, 1, "\uD84F\uDED1"], [194830, 1, "淹"], [194831, 1, "潮"], [194832, 1, "\uD84F\uDF5E"], [194833, 1, "\uD84F\uDF8E"], [194834, 1, "濆"], [194835, 1, "瀹"], [194836, 1, "瀞"], [194837, 1, "瀛"], [194838, 1, "㶖"], [194839, 1, "灊"], [194840, 1, "災"], [194841, 1, "灷"], [194842, 1, "炭"], [194843, 1, "\uD841\uDD25"], [194844, 1, "煅"], [194845, 1, "\uD850\uDE63"], [194846, 1, "熜"], [194847, 1, "\uD850\uDFAB"], [194848, 1, "爨"], [194849, 1, "爵"], [194850, 1, "牐"], [194851, 1, "\uD851\uDE08"], [194852, 1, "犀"], [194853, 1, "犕"], [194854, 1, "\uD851\uDF35"], [194855, 1, "\uD852\uDC14"], [194856, 1, "獺"], [194857, 1, "王"], [194858, 1, "㺬"], [194859, 1, "玥"], [[194860, 194861], 1, "㺸"], [194862, 1, "瑇"], [194863, 1, "瑜"], [194864, 1, "瑱"], [194865, 1, "璅"], [194866, 1, "瓊"], [194867, 1, "㼛"], [194868, 1, "甤"], [194869, 1, "\uD853\uDC36"], [194870, 1, "甾"], [194871, 1, "\uD853\uDC92"], [194872, 1, "異"], [194873, 1, "\uD848\uDD9F"], [194874, 1, "瘐"], [194875, 1, "\uD853\uDFA1"], [194876, 1, "\uD853\uDFB8"], [194877, 1, "\uD854\uDC44"], [194878, 1, "㿼"], [194879, 1, "䀈"], [194880, 1, "直"], [194881, 1, "\uD854\uDCF3"], [194882, 1, "\uD854\uDCF2"], [194883, 1, "\uD854\uDD19"], [194884, 1, "\uD854\uDD33"], [194885, 1, "眞"], [[194886, 194887], 1, "真"], [194888, 1, "睊"], [194889, 1, "䀹"], [194890, 1, "瞋"], [194891, 1, "䁆"], [194892, 1, "䂖"], [194893, 1, "\uD855\uDC1D"], [194894, 1, "硎"], [194895, 1, "碌"], [194896, 1, "磌"], [194897, 1, "䃣"], [194898, 1, "\uD855\uDE26"], [194899, 1, "祖"], [194900, 1, "\uD855\uDE9A"], [194901, 1, "\uD855\uDEC5"], [194902, 1, "福"], [194903, 1, "秫"], [194904, 1, "䄯"], [194905, 1, "穀"], [194906, 1, "穊"], [194907, 1, "穏"], [194908, 1, "\uD856\uDD7C"], [[194909, 194910], 1, "\uD856\uDEA7"], [194911, 1, "竮"], [194912, 1, "䈂"], [194913, 1, "\uD856\uDFAB"], [194914, 1, "篆"], [194915, 1, "築"], [194916, 1, "䈧"], [194917, 1, "\uD857\uDC80"], [194918, 1, "糒"], [194919, 1, "䊠"], [194920, 1, "糨"], [194921, 1, "糣"], [194922, 1, "紀"], [194923, 1, "\uD857\uDF86"], [194924, 1, "絣"], [194925, 1, "䌁"], [194926, 1, "緇"], [194927, 1, "縂"], [194928, 1, "繅"], [194929, 1, "䌴"], [194930, 1, "\uD858\uDE28"], [194931, 1, "\uD858\uDE47"], [194932, 1, "䍙"], [194933, 1, "\uD858\uDED9"], [194934, 1, "罺"], [194935, 1, "\uD858\uDF3E"], [194936, 1, "羕"], [194937, 1, "翺"], [194938, 1, "者"], [194939, 1, "\uD859\uDCDA"], [194940, 1, "\uD859\uDD23"], [194941, 1, "聠"], [194942, 1, "\uD859\uDDA8"], [194943, 1, "聰"], [194944, 1, "\uD84C\uDF5F"], [194945, 1, "䏕"], [194946, 1, "育"], [194947, 1, "脃"], [194948, 1, "䐋"], [194949, 1, "脾"], [194950, 1, "媵"], [194951, 1, "\uD859\uDFA7"], [194952, 1, "\uD859\uDFB5"], [194953, 1, "\uD84C\uDF93"], [194954, 1, "\uD84C\uDF9C"], [194955, 1, "舁"], [194956, 1, "舄"], [194957, 1, "辞"], [194958, 1, "䑫"], [194959, 1, "芑"], [194960, 1, "芋"], [194961, 1, "芝"], [194962, 1, "劳"], [194963, 1, "花"], [194964, 1, "芳"], [194965, 1, "芽"], [194966, 1, "苦"], [194967, 1, "\uD85A\uDF3C"], [194968, 1, "若"], [194969, 1, "茝"], [194970, 1, "荣"], [194971, 1, "莭"], [194972, 1, "茣"], [194973, 1, "莽"], [194974, 1, "菧"], [194975, 1, "著"], [194976, 1, "荓"], [194977, 1, "菊"], [194978, 1, "菌"], [194979, 1, "菜"], [194980, 1, "\uD85B\uDC36"], [194981, 1, "\uD85B\uDD6B"], [194982, 1, "\uD85B\uDCD5"], [194983, 1, "䔫"], [194984, 1, "蓱"], [194985, 1, "蓳"], [194986, 1, "蔖"], [194987, 1, "\uD85C\uDFCA"], [194988, 1, "蕤"], [194989, 1, "\uD85B\uDF2C"], [194990, 1, "䕝"], [194991, 1, "䕡"], [194992, 1, "\uD85B\uDFB1"], [194993, 1, "\uD85C\uDCD2"], [194994, 1, "䕫"], [194995, 1, "虐"], [194996, 1, "虜"], [194997, 1, "虧"], [194998, 1, "虩"], [194999, 1, "蚩"], [195000, 1, "蚈"], [195001, 1, "蜎"], [195002, 1, "蛢"], [195003, 1, "蝹"], [195004, 1, "蜨"], [195005, 1, "蝫"], [195006, 1, "螆"], [195007, 1, "䗗"], [195008, 1, "蟡"], [195009, 1, "蠁"], [195010, 1, "䗹"], [195011, 1, "衠"], [195012, 1, "衣"], [195013, 1, "\uD85D\uDE67"], [195014, 1, "裗"], [195015, 1, "裞"], [195016, 1, "䘵"], [195017, 1, "裺"], [195018, 1, "㒻"], [195019, 1, "\uD85E\uDCAE"], [195020, 1, "\uD85E\uDD66"], [195021, 1, "䚾"], [195022, 1, "䛇"], [195023, 1, "誠"], [195024, 1, "諭"], [195025, 1, "變"], [195026, 1, "豕"], [195027, 1, "\uD85F\uDCA8"], [195028, 1, "貫"], [195029, 1, "賁"], [195030, 1, "贛"], [195031, 1, "起"], [195032, 1, "\uD85F\uDF2F"], [195033, 1, "\uD842\uDC04"], [195034, 1, "跋"], [195035, 1, "趼"], [195036, 1, "跰"], [195037, 1, "\uD842\uDCDE"], [195038, 1, "軔"], [195039, 1, "輸"], [195040, 1, "\uD861\uDDD2"], [195041, 1, "\uD861\uDDED"], [195042, 1, "邔"], [195043, 1, "郱"], [195044, 1, "鄑"], [195045, 1, "\uD861\uDF2E"], [195046, 1, "鄛"], [195047, 1, "鈸"], [195048, 1, "鋗"], [195049, 1, "鋘"], [195050, 1, "鉼"], [195051, 1, "鏹"], [195052, 1, "鐕"], [195053, 1, "\uD862\uDFFA"], [195054, 1, "開"], [195055, 1, "䦕"], [195056, 1, "閷"], [195057, 1, "\uD863\uDD77"], [195058, 1, "䧦"], [195059, 1, "雃"], [195060, 1, "嶲"], [195061, 1, "霣"], [195062, 1, "\uD864\uDD45"], [195063, 1, "\uD864\uDE1A"], [195064, 1, "䩮"], [195065, 1, "䩶"], [195066, 1, "韠"], [195067, 1, "\uD865\uDC0A"], [195068, 1, "䪲"], [195069, 1, "\uD865\uDC96"], [[195070, 195071], 1, "頋"], [195072, 1, "頩"], [195073, 1, "\uD865\uDDB6"], [195074, 1, "飢"], [195075, 1, "䬳"], [195076, 1, "餩"], [195077, 1, "馧"], [195078, 1, "駂"], [195079, 1, "駾"], [195080, 1, "䯎"], [195081, 1, "\uD866\uDF30"], [195082, 1, "鬒"], [195083, 1, "鱀"], [195084, 1, "鳽"], [195085, 1, "䳎"], [195086, 1, "䳭"], [195087, 1, "鵧"], [195088, 1, "\uD868\uDCCE"], [195089, 1, "䳸"], [195090, 1, "\uD868\uDD05"], [195091, 1, "\uD868\uDE0E"], [195092, 1, "\uD868\uDE91"], [195093, 1, "麻"], [195094, 1, "䵖"], [195095, 1, "黹"], [195096, 1, "黾"], [195097, 1, "鼅"], [195098, 1, "鼏"], [195099, 1, "鼖"], [195100, 1, "鼻"], [195101, 1, "\uD869\uDE00"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 201551], 3], [[201552, 205743], 2], [[205744, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918000, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
});

// node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS((exports, module) => {
  exports.STATUS_MAPPING = {
    mapped: 1,
    valid: 2,
    disallowed: 3,
    deviation: 6,
    ignored: 7
  };
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var punycode = require_punycode();
  var regexes = require_regexes();
  var mappingTable = require_mappingTable();
  var { STATUS_MAPPING } = require_statusMapping();
  function containsNonASCII(str) {
    return /[^\x00-\x7F]/u.test(str);
  }
  function findStatus(val) {
    let start = 0;
    let end = mappingTable.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const target = mappingTable[mid];
      const min = Array.isArray(target[0]) ? target[0][0] : target[0];
      const max2 = Array.isArray(target[0]) ? target[0][1] : target[0];
      if (min <= val && max2 >= val) {
        return target.slice(1);
      } else if (min > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  }
  function mapChars(domainName, { transitionalProcessing }) {
    let processed = "";
    for (const ch of domainName) {
      const [status2, mapping] = findStatus(ch.codePointAt(0));
      switch (status2) {
        case STATUS_MAPPING.disallowed:
          processed += ch;
          break;
        case STATUS_MAPPING.ignored:
          break;
        case STATUS_MAPPING.mapped:
          if (transitionalProcessing && ch === "ẞ") {
            processed += "ss";
          } else {
            processed += mapping;
          }
          break;
        case STATUS_MAPPING.deviation:
          if (transitionalProcessing) {
            processed += mapping;
          } else {
            processed += ch;
          }
          break;
        case STATUS_MAPPING.valid:
          processed += ch;
          break;
      }
    }
    return processed;
  }
  function validateLabel(label, {
    checkHyphens,
    checkBidi,
    checkJoiners,
    transitionalProcessing,
    useSTD3ASCIIRules,
    isBidi
  }) {
    if (label.length === 0) {
      return true;
    }
    if (label.normalize("NFC") !== label) {
      return false;
    }
    const codePoints = Array.from(label);
    if (checkHyphens) {
      if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
        return false;
      }
    }
    if (!checkHyphens) {
      if (label.startsWith("xn--")) {
        return false;
      }
    }
    if (label.includes(".")) {
      return false;
    }
    if (regexes.combiningMarks.test(codePoints[0])) {
      return false;
    }
    for (const ch of codePoints) {
      const codePoint = ch.codePointAt(0);
      const [status2] = findStatus(codePoint);
      if (transitionalProcessing) {
        if (status2 !== STATUS_MAPPING.valid) {
          return false;
        }
      } else if (status2 !== STATUS_MAPPING.valid && status2 !== STATUS_MAPPING.deviation) {
        return false;
      }
      if (useSTD3ASCIIRules && codePoint <= 127) {
        if (!/^(?:[a-z]|[0-9]|-)$/u.test(ch)) {
          return false;
        }
      }
    }
    if (checkJoiners) {
      let last = 0;
      for (const [i, ch] of codePoints.entries()) {
        if (ch === "‌" || ch === "‍") {
          if (i > 0) {
            if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
              continue;
            }
            if (ch === "‌") {
              const next = codePoints.indexOf("‌", i + 1);
              const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
              if (regexes.validZWNJ.test(test.join(""))) {
                last = i + 1;
                continue;
              }
            }
          }
          return false;
        }
      }
    }
    if (checkBidi && isBidi) {
      let rtl;
      if (regexes.bidiS1LTR.test(codePoints[0])) {
        rtl = false;
      } else if (regexes.bidiS1RTL.test(codePoints[0])) {
        rtl = true;
      } else {
        return false;
      }
      if (rtl) {
        if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
          return false;
        }
      } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
        return false;
      }
    }
    return true;
  }
  function isBidiDomain(labels) {
    const domain = labels.map((label) => {
      if (label.startsWith("xn--")) {
        try {
          return punycode.decode(label.substring(4));
        } catch {
          return "";
        }
      }
      return label;
    }).join(".");
    return regexes.bidiDomain.test(domain);
  }
  function processing(domainName, options) {
    let string = mapChars(domainName, options);
    string = string.normalize("NFC");
    const labels = string.split(".");
    const isBidi = isBidiDomain(labels);
    let error = false;
    for (const [i, origLabel] of labels.entries()) {
      let label = origLabel;
      let transitionalProcessingForThisLabel = options.transitionalProcessing;
      if (label.startsWith("xn--")) {
        if (containsNonASCII(label)) {
          error = true;
          continue;
        }
        try {
          label = punycode.decode(label.substring(4));
        } catch {
          if (!options.ignoreInvalidPunycode) {
            error = true;
            continue;
          }
        }
        labels[i] = label;
        if (label === "" || !containsNonASCII(label)) {
          error = true;
        }
        transitionalProcessingForThisLabel = false;
      }
      if (error) {
        continue;
      }
      const validation = validateLabel(label, {
        ...options,
        transitionalProcessing: transitionalProcessingForThisLabel,
        isBidi
      });
      if (!validation) {
        error = true;
      }
    }
    return {
      string: labels.join("."),
      error
    };
  }
  function toASCII(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    verifyDNSLength = false,
    transitionalProcessing = false,
    ignoreInvalidPunycode = false
  } = {}) {
    const result = processing(domainName, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules,
      transitionalProcessing,
      ignoreInvalidPunycode
    });
    let labels = result.string.split(".");
    labels = labels.map((l2) => {
      if (containsNonASCII(l2)) {
        try {
          return `xn--${punycode.encode(l2)}`;
        } catch {
          result.error = true;
        }
      }
      return l2;
    });
    if (verifyDNSLength) {
      const total = labels.join(".").length;
      if (total > 253 || total === 0) {
        result.error = true;
      }
      for (let i = 0;i < labels.length; ++i) {
        if (labels[i].length > 63 || labels[i].length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error) {
      return null;
    }
    return labels.join(".");
  }
  function toUnicode(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    transitionalProcessing = false,
    ignoreInvalidPunycode = false
  } = {}) {
    const result = processing(domainName, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules,
      transitionalProcessing,
      ignoreInvalidPunycode
    });
    return {
      domain: result.string,
      error: result.error
    };
  }
  module.exports = {
    toASCII,
    toUnicode
  };
});

// node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS((exports, module) => {
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  module.exports = {
    isASCIIDigit,
    isASCIIAlpha,
    isASCIIAlphanumeric,
    isASCIIHex
  };
});

// node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  var utf8Encoder = new TextEncoder;
  var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
  function utf8Encode(string) {
    return utf8Encoder.encode(string);
  }
  function utf8DecodeWithoutBOM(bytes) {
    return utf8Decoder.decode(bytes);
  }
  module.exports = {
    utf8Encode,
    utf8DecodeWithoutBOM
  };
});

// node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS((exports, module) => {
  var { isASCIIHex } = require_infra();
  var { utf8Encode } = require_encoding();
  function p(char) {
    return char.codePointAt(0);
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    return `%${hex}`;
  }
  function percentDecodeBytes(input) {
    const output = new Uint8Array(input.byteLength);
    let outputIndex = 0;
    for (let i = 0;i < input.byteLength; ++i) {
      const byte2 = input[i];
      if (byte2 !== 37) {
        output[outputIndex++] = byte2;
      } else if (byte2 === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
        output[outputIndex++] = byte2;
      } else {
        const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
        output[outputIndex++] = bytePoint;
        i += 2;
      }
    }
    return output.slice(0, outputIndex);
  }
  function percentDecodeString(input) {
    const bytes = utf8Encode(input);
    return percentDecodeBytes(bytes);
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  var extraFragmentPercentEncodeSet = new Set([p(" "), p('"'), p("<"), p(">"), p("`")]);
  function isFragmentPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
  }
  var extraQueryPercentEncodeSet = new Set([p(" "), p('"'), p("#"), p("<"), p(">")]);
  function isQueryPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
  }
  function isSpecialQueryPercentEncode(c) {
    return isQueryPercentEncode(c) || c === p("'");
  }
  var extraPathPercentEncodeSet = new Set([p("?"), p("`"), p("{"), p("}"), p("^")]);
  function isPathPercentEncode(c) {
    return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  var extraUserinfoPercentEncodeSet = new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("|")]);
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  var extraComponentPercentEncodeSet = new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
  function isComponentPercentEncode(c) {
    return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
  }
  var extraURLEncodedPercentEncodeSet = new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
  function isURLEncodedPercentEncode(c) {
    return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
  }
  function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
    const bytes = utf8Encode(codePoint);
    let output = "";
    for (const byte2 of bytes) {
      if (!percentEncodePredicate(byte2)) {
        output += String.fromCharCode(byte2);
      } else {
        output += percentEncode(byte2);
      }
    }
    return output;
  }
  function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
    return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
  }
  function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
    let output = "";
    for (const codePoint of input) {
      if (spaceAsPlus && codePoint === " ") {
        output += "+";
      } else {
        output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
      }
    }
    return output;
  }
  module.exports = {
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode,
    isURLEncodedPercentEncode,
    percentDecodeString,
    percentDecodeBytes,
    utf8PercentEncodeString,
    utf8PercentEncodeCodePoint
  };
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var tr46 = require_tr46();
  var infra = require_infra();
  var { utf8DecodeWithoutBOM } = require_encoding();
  var {
    percentDecodeString,
    utf8PercentEncodeCodePoint,
    utf8PercentEncodeString,
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode
  } = require_percent_encoding();
  function p(char) {
    return char.codePointAt(0);
  }
  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  function countSymbols(str) {
    return [...str].length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  }
  function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
  }
  function containsForbiddenDomainCodePoint(string) {
    return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function isNotSpecial(url) {
    return !isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function parseIPv4Number(input) {
    if (input === "") {
      return failure;
    }
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    let regex2 = /[^0-7]/u;
    if (R === 10) {
      regex2 = /[^0-9]/u;
    }
    if (R === 16) {
      regex2 = /[^0-9A-Fa-f]/u;
    }
    if (regex2.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  }
  function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return failure;
    }
    const numbers = [];
    for (const part of parts) {
      const n2 = parseIPv4Number(part);
      if (n2 === failure) {
        return failure;
      }
      numbers.push(n2);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n2 of numbers) {
      ipv4 += n2 * 256 ** (3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    let output = "";
    let n2 = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n2 % 256) + output;
      if (i !== 4) {
        output = `.${output}`;
      }
      n2 = Math.floor(n2 / 256);
    }
    return output;
  }
  function parseIPv6(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer2 = 0;
    input = Array.from(input, (c) => c.codePointAt(0));
    if (input[pointer2] === p(":")) {
      if (input[pointer2 + 1] !== p(":")) {
        return failure;
      }
      pointer2 += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer2 < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer2] === p(":")) {
        if (compress !== null) {
          return failure;
        }
        ++pointer2;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && infra.isASCIIHex(input[pointer2])) {
        value = value * 16 + parseInt(at(input, pointer2), 16);
        ++pointer2;
        ++length;
      }
      if (input[pointer2] === p(".")) {
        if (length === 0) {
          return failure;
        }
        pointer2 -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer2] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer2] === p(".") && numbersSeen < 4) {
              ++pointer2;
            } else {
              return failure;
            }
          }
          if (!infra.isASCIIDigit(input[pointer2])) {
            return failure;
          }
          while (infra.isASCIIDigit(input[pointer2])) {
            const number = parseInt(at(input, pointer2));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer2;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer2] === p(":")) {
        ++pointer2;
        if (input[pointer2] === undefined) {
          return failure;
        }
      } else if (input[pointer2] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    let output = "";
    const compress = findTheIPv6AddressCompressedPieceIndex(address);
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  }
  function parseHost(input, isOpaque = false) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (isOpaque) {
      return parseOpaqueHost(input);
    }
    const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === failure) {
      return failure;
    }
    if (endsInANumber(asciiDomain)) {
      return parseIPv4(asciiDomain);
    }
    return asciiDomain;
  }
  function endsInANumber(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length === 1) {
        return false;
      }
      parts.pop();
    }
    const last = parts[parts.length - 1];
    if (parseIPv4Number(last) !== failure) {
      return true;
    }
    if (/^[0-9]+$/u.test(last)) {
      return true;
    }
    return false;
  }
  function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePoint(input)) {
      return failure;
    }
    return utf8PercentEncodeString(input, isC0ControlPercentEncode);
  }
  function findTheIPv6AddressCompressedPieceIndex(address) {
    let longestIndex = null;
    let longestSize = 1;
    let foundIndex = null;
    let foundSize = 0;
    for (let pieceIndex = 0;pieceIndex < address.length; ++pieceIndex) {
      if (address[pieceIndex] !== 0) {
        if (foundSize > longestSize) {
          longestIndex = foundIndex;
          longestSize = foundSize;
        }
        foundIndex = null;
        foundSize = 0;
      } else {
        if (foundIndex === null) {
          foundIndex = pieceIndex;
        }
        ++foundSize;
      }
    }
    if (foundSize > longestSize) {
      return foundIndex;
    }
    return longestIndex;
  }
  function serializeHost(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return `[${serializeIPv6(host)}]`;
    }
    return host;
  }
  function domainToASCII(domain, beStrict = false) {
    const result = tr46.toASCII(domain, {
      checkHyphens: beStrict,
      checkBidi: true,
      checkJoiners: true,
      useSTD3ASCIIRules: beStrict,
      transitionalProcessing: false,
      verifyDNSLength: beStrict,
      ignoreInvalidPunycode: false
    });
    if (result === null) {
      return failure;
    }
    if (!beStrict) {
      if (result === "") {
        return failure;
      }
      if (containsForbiddenDomainCodePoint(result)) {
        return failure;
      }
    }
    return result;
  }
  function trimControlChars(string) {
    let start = 0;
    let end = string.length;
    for (;start < end; ++start) {
      if (string.charCodeAt(start) > 32) {
        break;
      }
    }
    for (;end > start; --end) {
      if (string.charCodeAt(end - 1) > 32) {
        break;
      }
    }
    return string.substring(start, end);
  }
  function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/ug, "");
  }
  function shortenPath(url) {
    const { path } = url;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.scheme === "file";
  }
  function hasAnOpaquePath(url) {
    return typeof url.path === "string";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/u.test(string);
  }
  function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(this.input, (c) => c.codePointAt(0));
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this[`parse ${this.state}`](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (infra.isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c === p(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = "";
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c === p("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === p("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (c === p("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c === p("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === p("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== p("/") && c !== p("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === p("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = `%40${this.buffer}`;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer2 = 0;pointer2 < len; ++pointer2) {
        const codePoint = this.buffer.codePointAt(pointer2);
        if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === p(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === p("[")) {
        this.arrFlag = true;
      } else if (c === p("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (infra.isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > 2 ** 16 - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([p("/"), p("\\"), p("?"), p("#")]);
  function startsWithWindowsDriveLetter(input, pointer2) {
    const length = input.length - pointer2;
    return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer2], input[pointer2 + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer2 + 2]));
  }
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c === p("/") || c === p("\\")) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === p("/") || c === p("\\")) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== p("/") && c !== p("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== p("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
      if (isSpecial(this.url) && c === p("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = `${this.buffer[0]}:`;
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
    if (c === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c === p(" ")) {
      const remaining = this.input[this.pointer + 1];
      if (remaining === p("?") || remaining === p("#")) {
        this.url.path += "%20";
      } else {
        this.url.path += " ";
      }
    } else {
      if (!isNaN(c) && c !== p("%")) {
        this.parseError = true;
      }
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c === p("#") || isNaN(c)) {
      const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
      this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c)) {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (!isNaN(c)) {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
    }
    return true;
  };
  function serializeURL(url, excludeFragment) {
    let output = `${url.scheme}:`;
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += `:${url.password}`;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += `:${url.port}`;
      }
    }
    if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
      output += "/.";
    }
    output += serializePath(url);
    if (url.query !== null) {
      output += `?${url.query}`;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += `#${url.fragment}`;
    }
    return output;
  }
  function serializeOrigin(tuple) {
    let result = `${tuple.scheme}://`;
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += `:${tuple.port}`;
    }
    return result;
  }
  function serializePath(url) {
    if (hasAnOpaquePath(url)) {
      return url.path;
    }
    let output = "";
    for (const segment of url.path) {
      output += `/${segment}`;
    }
    return output;
  }
  exports.serializeURL = serializeURL;
  exports.serializePath = serializePath;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob": {
        const pathURL = exports.parseURL(serializePath(url));
        if (pathURL === null) {
          return "null";
        }
        if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
          return "null";
        }
        return exports.serializeURLOrigin(pathURL);
      }
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "null";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return null;
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
  };
  exports.setThePassword = function(url, password) {
    url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = hasAnOpaquePath;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
  var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
  function p(char) {
    return char.codePointAt(0);
  }
  function parseUrlencoded(input) {
    const sequences = strictlySplitByteSequence(input, p("&"));
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0) {
        continue;
      }
      let name, value;
      const indexOfEqual = bytes.indexOf(p("="));
      if (indexOfEqual >= 0) {
        name = bytes.slice(0, indexOfEqual);
        value = bytes.slice(indexOfEqual + 1);
      } else {
        name = bytes;
        value = new Uint8Array(0);
      }
      name = replaceByteInByteSequence(name, 43, 32);
      value = replaceByteInByteSequence(value, 43, 32);
      const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
      const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
      output.push([nameString, valueString]);
    }
    return output;
  }
  function parseUrlencodedString(input) {
    return parseUrlencoded(utf8Encode(input));
  }
  function serializeUrlencoded(tuples) {
    let output = "";
    for (const [i, tuple] of tuples.entries()) {
      const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
      const value = utf8PercentEncodeString(tuple[1], isURLEncodedPercentEncode, true);
      if (i !== 0) {
        output += "&";
      }
      output += `${name}=${value}`;
    }
    return output;
  }
  function strictlySplitByteSequence(buf, cp) {
    const list = [];
    let last = 0;
    let i = buf.indexOf(cp);
    while (i >= 0) {
      list.push(buf.slice(last, i));
      last = i + 1;
      i = buf.indexOf(cp, last);
    }
    if (last !== buf.length) {
      list.push(buf.slice(last));
    }
    return list;
  }
  function replaceByteInByteSequence(buf, from, to) {
    let i = buf.indexOf(from);
    while (i >= 0) {
      buf[i] = to;
      i = buf.indexOf(from, i + 1);
    }
    return buf;
  }
  module.exports = {
    parseUrlencodedString,
    serializeUrlencoded
  };
});

// node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS((exports) => {
  var conversions = require_lib();
  var utils = require_utils2();
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (typeof value !== "function") {
      throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(...args) {
      const thisArg = utils.tryWrapperForImpl(this);
      let callResult;
      for (let i = 0;i < args.length; i++) {
        args[i] = utils.tryWrapperForImpl(args[i]);
      }
      callResult = Reflect.apply(value, thisArg, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    }
    invokeTheCallbackFunction.construct = (...args) => {
      for (let i = 0;i < args.length; i++) {
        args[i] = utils.tryWrapperForImpl(args[i]);
      }
      let callResult = Reflect.construct(value, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
  };
});

// node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS((exports) => {
  var urlencoded = require_urlencoded();
  exports.implementation = class URLSearchParamsImpl {
    constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
      let init = constructorArgs[0];
      this._list = [];
      this._url = null;
      if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
        init = init.slice(1);
      }
      if (Array.isArray(init)) {
        for (const pair of init) {
          if (pair.length !== 2) {
            throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not " + "contain exactly two elements.");
          }
          this._list.push([pair[0], pair[1]]);
        }
      } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
        for (const name of Object.keys(init)) {
          const value = init[name];
          this._list.push([name, value]);
        }
      } else {
        this._list = urlencoded.parseUrlencodedString(init);
      }
    }
    _updateSteps() {
      if (this._url !== null) {
        let serializedQuery = urlencoded.serializeUrlencoded(this._list);
        if (serializedQuery === "") {
          serializedQuery = null;
        }
        this._url._url.query = serializedQuery;
      }
    }
    get size() {
      return this._list.length;
    }
    append(name, value) {
      this._list.push([name, value]);
      this._updateSteps();
    }
    delete(name, value) {
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name && (value === undefined || this._list[i][1] === value)) {
          this._list.splice(i, 1);
        } else {
          i++;
        }
      }
      this._updateSteps();
    }
    get(name) {
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          return tuple[1];
        }
      }
      return null;
    }
    getAll(name) {
      const output = [];
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          output.push(tuple[1]);
        }
      }
      return output;
    }
    has(name, value) {
      for (const tuple of this._list) {
        if (tuple[0] === name && (value === undefined || tuple[1] === value)) {
          return true;
        }
      }
      return false;
    }
    set(name, value) {
      let found = false;
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name) {
          if (found) {
            this._list.splice(i, 1);
          } else {
            found = true;
            this._list[i][1] = value;
            i++;
          }
        } else {
          i++;
        }
      }
      if (!found) {
        this._list.push([name, value]);
      }
      this._updateSteps();
    }
    sort() {
      this._list.sort((a12, b) => {
        if (a12[0] < b[0]) {
          return -1;
        }
        if (a12[0] > b[0]) {
          return 1;
        }
        return 0;
      });
      this._updateSteps();
    }
    [Symbol.iterator]() {
      return this._list[Symbol.iterator]();
    }
    toString() {
      return urlencoded.serializeUrlencoded(this._list);
    }
  };
});

// node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var conversions = require_lib();
  var utils = require_utils2();
  var Function3 = require_Function();
  var newObjectInRealm = utils.newObjectInRealm;
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URLSearchParams";
  exports.is = (value) => {
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value) => {
    return utils.isObject(value) && value instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (exports.is(value)) {
      return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
  };
  exports.createDefaultIterator = (globalObject, target, kind) => {
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
    const iterator = Object.create(iteratorPrototype);
    Object.defineProperty(iterator, utils.iterInternalSymbol, {
      value: { target, kind, index: 0 },
      configurable: true
    });
    return iterator;
  };
  function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
    }
    return Object.create(proto);
  }
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URLSearchParams {
      constructor() {
        const args = [];
        {
          let curArg = arguments[0];
          if (curArg !== undefined) {
            if (utils.isObject(curArg)) {
              if (curArg[Symbol.iterator] !== undefined) {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1" + " sequence" + " is not an iterable object.");
                } else {
                  const V = [];
                  const tmp = curArg;
                  for (let nextItem of tmp) {
                    if (!utils.isObject(nextItem)) {
                      throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1" + " sequence" + "'s element" + " is not an iterable object.");
                    } else {
                      const V2 = [];
                      const tmp2 = nextItem;
                      for (let nextItem2 of tmp2) {
                        nextItem2 = conversions["USVString"](nextItem2, {
                          context: "Failed to construct 'URLSearchParams': parameter 1" + " sequence" + "'s element" + "'s element",
                          globals: globalObject
                        });
                        V2.push(nextItem2);
                      }
                      nextItem = V2;
                    }
                    V.push(nextItem);
                  }
                  curArg = V;
                }
              } else {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1" + " record" + " is not an object.");
                } else {
                  const result = Object.create(null);
                  for (const key of Reflect.ownKeys(curArg)) {
                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                    if (desc && desc.enumerable) {
                      let typedKey = key;
                      typedKey = conversions["USVString"](typedKey, {
                        context: "Failed to construct 'URLSearchParams': parameter 1" + " record" + "'s key",
                        globals: globalObject
                      });
                      let typedValue = curArg[key];
                      typedValue = conversions["USVString"](typedValue, {
                        context: "Failed to construct 'URLSearchParams': parameter 1" + " record" + "'s value",
                        globals: globalObject
                      });
                      result[typedKey] = typedValue;
                    }
                  }
                  curArg = result;
                }
              }
            } else {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URLSearchParams': parameter 1",
                globals: globalObject
              });
            }
          } else {
            curArg = "";
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      append(name, value) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'append' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
      }
      delete(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'delete' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
      }
      get(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return esValue[implSymbol].get(...args);
      }
      getAll(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'getAll' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
      }
      has(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return esValue[implSymbol].has(...args);
      }
      set(name, value) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
      }
      sort() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].sort());
      }
      toString() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol].toString();
      }
      keys() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key");
      }
      values() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'values' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "value");
      }
      entries() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'entries' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key+value");
      }
      forEach(callback) {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'forEach' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
        }
        callback = Function3.convert(globalObject, callback, {
          context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
        });
        const thisArg = arguments[1];
        let pairs = Array.from(this[implSymbol]);
        let i = 0;
        while (i < pairs.length) {
          const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
          callback.call(thisArg, value, key, this);
          pairs = Array.from(this[implSymbol]);
          i++;
        }
      }
      get size() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol]["size"];
      }
    }
    Object.defineProperties(URLSearchParams.prototype, {
      append: { enumerable: true },
      delete: { enumerable: true },
      get: { enumerable: true },
      getAll: { enumerable: true },
      has: { enumerable: true },
      set: { enumerable: true },
      sort: { enumerable: true },
      toString: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
      forEach: { enumerable: true },
      size: { enumerable: true },
      [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
      [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
    });
    ctorRegistry[interfaceName] = URLSearchParams;
    ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
      [Symbol.toStringTag]: {
        configurable: true,
        value: "URLSearchParams Iterator"
      }
    });
    utils.define(ctorRegistry["URLSearchParams Iterator"], {
      next() {
        const internal = this && this[utils.iterInternalSymbol];
        if (!internal) {
          throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
        }
        const { target, kind, index } = internal;
        const values = Array.from(target[implSymbol]);
        const len = values.length;
        if (index >= len) {
          return newObjectInRealm(globalObject, { value: undefined, done: true });
        }
        const pair = values[index];
        internal.index = index + 1;
        return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
      }
    });
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URLSearchParams
    });
  };
  var Impl = require_URLSearchParams_impl();
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  var urlencoded = require_urlencoded();
  var URLSearchParams = require_URLSearchParams();
  exports.implementation = class URLImpl {
    constructor(globalObject, [url, base]) {
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          throw new TypeError(`Invalid base URL: ${base}`);
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      const query = parsedURL.query !== null ? parsedURL.query : "";
      this._url = parsedURL;
      this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
      this._query._url = this;
    }
    static parse(globalObject, input, base) {
      try {
        return new URLImpl(globalObject, [input, base]);
      } catch {
        return null;
      }
    }
    static canParse(url, base) {
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          return false;
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        return false;
      }
      return true;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${v}`);
      }
      this._url = parsedURL;
      this._query._list.splice(0);
      const { query } = parsedURL;
      if (query !== null) {
        this._query._list = urlencoded.parseUrlencodedString(query);
      }
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return `${this._url.scheme}:`;
    }
    set protocol(v) {
      usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
    }
    set host(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      return usm.serializePath(this._url);
    }
    set pathname(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return `?${this._url.query}`;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        this._query._list = [];
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
      this._query._list = urlencoded.parseUrlencodedString(input);
    }
    get searchParams() {
      return this._query;
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return `#${this._url.fragment}`;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports) => {
  var conversions = require_lib();
  var utils = require_utils2();
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URL";
  exports.is = (value) => {
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value) => {
    return utils.isObject(value) && value instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (exports.is(value)) {
      return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
  };
  function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
    }
    return Object.create(proto);
  }
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URL2 {
      constructor(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to construct 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      toJSON() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol].toJSON();
      }
      get href() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      set href(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'href' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["href"] = V;
      }
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      get origin() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["origin"];
      }
      get protocol() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["protocol"];
      }
      set protocol(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'protocol' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["protocol"] = V;
      }
      get username() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["username"];
      }
      set username(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'username' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["username"] = V;
      }
      get password() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["password"];
      }
      set password(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'password' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["password"] = V;
      }
      get host() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["host"];
      }
      set host(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'host' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["host"] = V;
      }
      get hostname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hostname"];
      }
      set hostname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hostname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hostname"] = V;
      }
      get port() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["port"];
      }
      set port(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'port' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["port"] = V;
      }
      get pathname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["pathname"];
      }
      set pathname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'pathname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["pathname"] = V;
      }
      get search() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["search"];
      }
      set search(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'search' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["search"] = V;
      }
      get searchParams() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
        }
        return utils.getSameObject(this, "searchParams", () => {
          return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
        });
      }
      get hash() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hash"];
      }
      set hash(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hash' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hash"] = V;
      }
      static parse(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'parse' on 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'parse' on 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'parse' on 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(Impl.implementation.parse(globalObject, ...args));
      }
      static canParse(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'canParse' on 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return Impl.implementation.canParse(...args);
      }
    }
    Object.defineProperties(URL2.prototype, {
      toJSON: { enumerable: true },
      href: { enumerable: true },
      toString: { enumerable: true },
      origin: { enumerable: true },
      protocol: { enumerable: true },
      username: { enumerable: true },
      password: { enumerable: true },
      host: { enumerable: true },
      hostname: { enumerable: true },
      port: { enumerable: true },
      pathname: { enumerable: true },
      search: { enumerable: true },
      searchParams: { enumerable: true },
      hash: { enumerable: true },
      [Symbol.toStringTag]: { value: "URL", configurable: true }
    });
    Object.defineProperties(URL2, { parse: { enumerable: true }, canParse: { enumerable: true } });
    ctorRegistry[interfaceName] = URL2;
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URL2
    });
    if (globalNames.includes("Window")) {
      Object.defineProperty(globalObject, "webkitURL", {
        configurable: true,
        writable: true,
        value: URL2
      });
    }
  };
  var Impl = require_URL_impl();
});

// node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS((exports) => {
  var URL2 = require_URL();
  var URLSearchParams = require_URLSearchParams();
  exports.URL = URL2;
  exports.URLSearchParams = URLSearchParams;
});

// node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS((exports) => {
  var { URL: URL2, URLSearchParams } = require_webidl2js_wrapper();
  var urlStateMachine = require_url_state_machine();
  var percentEncoding = require_percent_encoding();
  var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
  URL2.install(sharedGlobalObject, ["Window"]);
  URLSearchParams.install(sharedGlobalObject, ["Window"]);
  exports.URL = sharedGlobalObject.URL;
  exports.URLSearchParams = sharedGlobalObject.URLSearchParams;
  exports.parseURL = urlStateMachine.parseURL;
  exports.basicURLParse = urlStateMachine.basicURLParse;
  exports.serializeURL = urlStateMachine.serializeURL;
  exports.serializePath = urlStateMachine.serializePath;
  exports.serializeHost = urlStateMachine.serializeHost;
  exports.serializeInteger = urlStateMachine.serializeInteger;
  exports.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
  exports.setTheUsername = urlStateMachine.setTheUsername;
  exports.setThePassword = urlStateMachine.setThePassword;
  exports.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
  exports.percentDecodeString = percentEncoding.percentDecodeString;
  exports.percentDecodeBytes = percentEncoding.percentDecodeBytes;
});

// node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m2, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redactConnectionString = exports.redactValidConnectionString = undefined;
  var index_1 = __importStar(require_lib2());
  function redactValidConnectionString(inputUrl, options) {
    var _a3, _b2;
    const url = inputUrl.clone();
    const replacementString = (_a3 = options === null || options === undefined ? undefined : options.replacementString) !== null && _a3 !== undefined ? _a3 : "_credentials_";
    const redactUsernames = (_b2 = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b2 !== undefined ? _b2 : true;
    if ((url.username || url.password) && redactUsernames) {
      url.username = replacementString;
      url.password = "";
    } else if (url.password) {
      url.password = replacementString;
    }
    if (url.searchParams.has("authMechanismProperties")) {
      const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get("authMechanismProperties"));
      if (props.get("AWS_SESSION_TOKEN")) {
        props.set("AWS_SESSION_TOKEN", replacementString);
        url.searchParams.set("authMechanismProperties", props.toString());
      }
    }
    if (url.searchParams.has("tlsCertificateKeyFilePassword")) {
      url.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
    }
    if (url.searchParams.has("proxyUsername") && redactUsernames) {
      url.searchParams.set("proxyUsername", replacementString);
    }
    if (url.searchParams.has("proxyPassword")) {
      url.searchParams.set("proxyPassword", replacementString);
    }
    return url;
  }
  exports.redactValidConnectionString = redactValidConnectionString;
  function redactConnectionString(uri2, options) {
    var _a3, _b2;
    const replacementString = (_a3 = options === null || options === undefined ? undefined : options.replacementString) !== null && _a3 !== undefined ? _a3 : "<credentials>";
    const redactUsernames = (_b2 = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b2 !== undefined ? _b2 : true;
    let parsed;
    try {
      parsed = new index_1.default(uri2);
    } catch (_c) {
    }
    if (parsed) {
      options = { ...options, replacementString: "___credentials___" };
      return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
    }
    const R = replacementString;
    const replacements = [
      (uri3) => uri3.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `$1${R}$3`),
      (uri3) => uri3.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `$1${R}`),
      (uri3) => uri3.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `$1${R}`),
      (uri3) => redactUsernames ? uri3.replace(/(proxyUsername=)([^&]+)/gi, `$1${R}`) : uri3,
      (uri3) => uri3.replace(/(proxyPassword=)([^&]+)/gi, `$1${R}`)
    ];
    for (const replacer of replacements) {
      uri2 = replacer(uri2);
    }
    return uri2;
  }
  exports.redactConnectionString = redactConnectionString;
});

// node_modules/mongodb-connection-string-url/lib/index.js
var require_lib2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = undefined;
  var whatwg_url_1 = require_whatwg_url();
  var redact_1 = require_redact();
  Object.defineProperty(exports, "redactConnectionString", { enumerable: true, get: function() {
    return redact_1.redactConnectionString;
  } });
  var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
  function connectionStringHasValidScheme(connectionString) {
    return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
  }
  var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;

  class CaseInsensitiveMap extends Map {
    delete(name) {
      return super.delete(this._normalizeKey(name));
    }
    get(name) {
      return super.get(this._normalizeKey(name));
    }
    has(name) {
      return super.has(this._normalizeKey(name));
    }
    set(name, value) {
      return super.set(this._normalizeKey(name), value);
    }
    _normalizeKey(name) {
      name = `${name}`;
      for (const key of this.keys()) {
        if (key.toLowerCase() === name.toLowerCase()) {
          name = key;
          break;
        }
      }
      return name;
    }
  }
  function caseInsenstiveURLSearchParams(Ctor) {
    return class CaseInsenstiveURLSearchParams extends Ctor {
      append(name, value) {
        return super.append(this._normalizeKey(name), value);
      }
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      getAll(name) {
        return super.getAll(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value) {
        return super.set(this._normalizeKey(name), value);
      }
      keys() {
        return super.keys();
      }
      values() {
        return super.values();
      }
      entries() {
        return super.entries();
      }
      [Symbol.iterator]() {
        return super[Symbol.iterator]();
      }
      _normalizeKey(name) {
        return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
      }
    };
  }

  class URLWithoutHost extends whatwg_url_1.URL {
  }

  class MongoParseError extends Error {
    get name() {
      return "MongoParseError";
    }
  }

  class ConnectionString extends URLWithoutHost {
    constructor(uri2, options = {}) {
      var _a3;
      const { looseValidation } = options;
      if (!looseValidation && !connectionStringHasValidScheme(uri2)) {
        throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
      }
      const match = uri2.match(HOSTS_REGEX);
      if (!match) {
        throw new MongoParseError(`Invalid connection string "${uri2}"`);
      }
      const { protocol, username, password, hosts, rest } = (_a3 = match.groups) !== null && _a3 !== undefined ? _a3 : {};
      if (!looseValidation) {
        if (!protocol || !hosts) {
          throw new MongoParseError(`Protocol and host list are required in "${uri2}"`);
        }
        try {
          decodeURIComponent(username !== null && username !== undefined ? username : "");
          decodeURIComponent(password !== null && password !== undefined ? password : "");
        } catch (err2) {
          throw new MongoParseError(err2.message);
        }
        const illegalCharacters = /[:/?#[\]@]/gi;
        if (username === null || username === undefined ? undefined : username.match(illegalCharacters)) {
          throw new MongoParseError(`Username contains unescaped characters ${username}`);
        }
        if (!username || !password) {
          const uriWithoutProtocol = uri2.replace(`${protocol}://`, "");
          if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
            throw new MongoParseError("URI contained empty userinfo section");
          }
        }
        if (password === null || password === undefined ? undefined : password.match(illegalCharacters)) {
          throw new MongoParseError("Password contains unescaped characters");
        }
      }
      let authString = "";
      if (typeof username === "string")
        authString += username;
      if (typeof password === "string")
        authString += `:${password}`;
      if (authString)
        authString += "@";
      try {
        super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
      } catch (err2) {
        if (looseValidation) {
          new ConnectionString(uri2, {
            ...options,
            looseValidation: false
          });
        }
        if (typeof err2.message === "string") {
          err2.message = err2.message.replace(DUMMY_HOSTNAME, hosts);
        }
        throw err2;
      }
      this._hosts = hosts.split(",");
      if (!looseValidation) {
        if (this.isSRV && this.hosts.length !== 1) {
          throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
        }
        if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
          throw new MongoParseError("mongodb+srv URI cannot have port number");
        }
      }
      if (!this.pathname) {
        this.pathname = "/";
      }
      Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
    }
    get host() {
      return DUMMY_HOSTNAME;
    }
    set host(_ignored) {
      throw new Error("No single host for connection string");
    }
    get hostname() {
      return DUMMY_HOSTNAME;
    }
    set hostname(_ignored) {
      throw new Error("No single host for connection string");
    }
    get port() {
      return "";
    }
    set port(_ignored) {
      throw new Error("No single host for connection string");
    }
    get href() {
      return this.toString();
    }
    set href(_ignored) {
      throw new Error("Cannot set href for connection strings");
    }
    get isSRV() {
      return this.protocol.includes("srv");
    }
    get hosts() {
      return this._hosts;
    }
    set hosts(list) {
      this._hosts = list;
    }
    toString() {
      return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
    }
    clone() {
      return new ConnectionString(this.toString(), {
        looseValidation: true
      });
    }
    redact(options) {
      return (0, redact_1.redactValidConnectionString)(this, options);
    }
    typedSearchParams() {
      const sametype = false;
      return this.searchParams;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash: hash2 } = this;
      return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash: hash2 };
    }
  }
  exports.ConnectionString = ConnectionString;

  class CommaAndColonSeparatedRecord extends CaseInsensitiveMap {
    constructor(from) {
      super();
      for (const entry of (from !== null && from !== undefined ? from : "").split(",")) {
        if (!entry)
          continue;
        const colonIndex = entry.indexOf(":");
        if (colonIndex === -1) {
          this.set(entry, "");
        } else {
          this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
        }
      }
    }
    toString() {
      return [...this].map((entry) => entry.join(":")).join(",");
    }
  }
  exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
  exports.default = ConnectionString;
});

// node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OpCompressedRequest = exports.OpMsgResponse = exports.OpMsgRequest = exports.DocumentSequence = exports.OpReply = exports.OpQueryRequest = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var compression_1 = require_compression();
  var constants_1 = require_constants2();
  var _requestId = 0;
  var OPTS_TAILABLE_CURSOR = 2;
  var OPTS_SECONDARY = 4;
  var OPTS_OPLOG_REPLAY = 8;
  var OPTS_NO_CURSOR_TIMEOUT = 16;
  var OPTS_AWAIT_DATA = 32;
  var OPTS_EXHAUST = 64;
  var OPTS_PARTIAL = 128;
  var CURSOR_NOT_FOUND = 1;
  var QUERY_FAILURE = 2;
  var SHARD_CONFIG_STALE = 4;
  var AWAIT_CAPABLE = 8;
  var encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;

  class OpQueryRequest {
    constructor(databaseName, query, options) {
      this.moreToCome = false;
      const ns = `${databaseName}.$cmd`;
      if (typeof databaseName !== "string") {
        throw new error_1.MongoRuntimeError("Database name must be a string for a query");
      }
      if (query == null)
        throw new error_1.MongoRuntimeError("A query document must be specified for query");
      if (ns.indexOf("\x00") !== -1) {
        throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
      }
      this.databaseName = databaseName;
      this.query = query;
      this.ns = ns;
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || undefined;
      this.requestId = options.requestId ?? OpQueryRequest.getRequestId();
      this.pre32Limit = options.pre32Limit;
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.batchSize = this.numberToReturn;
      this.tailable = false;
      this.secondaryOk = typeof options.secondaryOk === "boolean" ? options.secondaryOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    }
    incRequestId() {
      this.requestId = _requestId++;
    }
    nextRequestId() {
      return _requestId + 1;
    }
    static getRequestId() {
      return ++_requestId;
    }
    toBin() {
      const buffers = [];
      let projection = null;
      let flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.secondaryOk) {
        flags |= OPTS_SECONDARY;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (this.batchSize !== this.numberToReturn)
        this.numberToReturn = this.batchSize;
      const header = Buffer.alloc(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1 + 4 + 4);
      buffers.push(header);
      const query = BSON.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
        projection = BSON.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      const totalLength = header.length + query.length + (projection ? projection.length : 0);
      let index = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index + 3] = this.requestId >> 24 & 255;
      header[index + 2] = this.requestId >> 16 & 255;
      header[index + 1] = this.requestId >> 8 & 255;
      header[index] = this.requestId & 255;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 255;
      header[index + 2] = 0 >> 16 & 255;
      header[index + 1] = 0 >> 8 & 255;
      header[index] = 0 & 255;
      index = index + 4;
      header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
      header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
      header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
      header[index] = constants_1.OP_QUERY & 255;
      index = index + 4;
      header[index + 3] = flags >> 24 & 255;
      header[index + 2] = flags >> 16 & 255;
      header[index + 1] = flags >> 8 & 255;
      header[index] = flags & 255;
      index = index + 4;
      index = index + header.write(this.ns, index, "utf8") + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 255;
      header[index + 2] = this.numberToSkip >> 16 & 255;
      header[index + 1] = this.numberToSkip >> 8 & 255;
      header[index] = this.numberToSkip & 255;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 255;
      header[index + 2] = this.numberToReturn >> 16 & 255;
      header[index + 1] = this.numberToReturn >> 8 & 255;
      header[index] = this.numberToReturn & 255;
      index = index + 4;
      return buffers;
    }
  }
  exports.OpQueryRequest = OpQueryRequest;

  class OpReply {
    constructor(message, msgHeader, msgBody, opts) {
      this.index = 0;
      this.sections = [];
      this.moreToCome = false;
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
    }
    isParsed() {
      return this.parsed;
    }
    parse() {
      if (this.parsed)
        return this.sections[0];
      this.index = 20;
      this.responseFlags = this.data.readInt32LE(0);
      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
      this.startingFrom = this.data.readInt32LE(12);
      this.numberReturned = this.data.readInt32LE(16);
      if (this.numberReturned < 0 || this.numberReturned > 2 ** 32 - 1) {
        throw new RangeError(`OP_REPLY numberReturned is an invalid array length ${this.numberReturned}`);
      }
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      for (let i = 0;i < this.numberReturned; i++) {
        const bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        const section = this.data.subarray(this.index, this.index + bsonSize);
        this.sections.push(section);
        this.index = this.index + bsonSize;
      }
      this.parsed = true;
      return this.sections[0];
    }
  }
  exports.OpReply = OpReply;
  var OPTS_CHECKSUM_PRESENT = 1;
  var OPTS_MORE_TO_COME = 2;
  var OPTS_EXHAUST_ALLOWED = 1 << 16;

  class DocumentSequence {
    constructor(field, documents) {
      this.field = field;
      this.documents = [];
      this.chunks = [];
      this.serializedDocumentsLength = 0;
      const buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);
      buffer[0] = 1;
      encodeUTF8Into(buffer, `${this.field}\x00`, 5);
      this.chunks.push(buffer);
      this.header = buffer;
      if (documents) {
        for (const doc of documents) {
          this.push(doc, BSON.serialize(doc));
        }
      }
    }
    push(document2, buffer) {
      this.serializedDocumentsLength += buffer.length;
      this.documents.push(document2);
      this.chunks.push(buffer);
      this.header?.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);
      return this.serializedDocumentsLength + this.header.length;
    }
    toBin() {
      return Buffer.concat(this.chunks);
    }
  }
  exports.DocumentSequence = DocumentSequence;

  class OpMsgRequest {
    constructor(databaseName, command, options) {
      if (command == null)
        throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
      this.databaseName = databaseName;
      this.command = command;
      this.command.$db = databaseName;
      this.options = options ?? {};
      this.requestId = options.requestId ? options.requestId : OpMsgRequest.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checksumPresent = false;
      this.moreToCome = options.moreToCome ?? command.writeConcern?.w === 0;
      this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
    }
    toBin() {
      const buffers = [];
      let flags = 0;
      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }
      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }
      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }
      const header = Buffer.alloc(4 * 4 + 4);
      buffers.push(header);
      let totalLength = header.length;
      const command = this.command;
      totalLength += this.makeSections(buffers, command);
      header.writeInt32LE(totalLength, 0);
      header.writeInt32LE(this.requestId, 4);
      header.writeInt32LE(0, 8);
      header.writeInt32LE(constants_1.OP_MSG, 12);
      header.writeUInt32LE(flags, 16);
      return buffers;
    }
    makeSections(buffers, document2) {
      const sequencesBuffer = this.extractDocumentSequences(document2);
      const payloadTypeBuffer = Buffer.allocUnsafe(1);
      payloadTypeBuffer[0] = 0;
      const documentBuffer = this.serializeBson(document2);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      buffers.push(sequencesBuffer);
      return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
    }
    extractDocumentSequences(document2) {
      const chunks = [];
      for (const [key, value] of Object.entries(document2)) {
        if (value instanceof DocumentSequence) {
          chunks.push(value.toBin());
          delete document2[key];
        }
      }
      if (chunks.length > 0) {
        return Buffer.concat(chunks);
      }
      return Buffer.alloc(0);
    }
    serializeBson(document2) {
      return BSON.serialize(document2, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
    static getRequestId() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    }
  }
  exports.OpMsgRequest = OpMsgRequest;

  class OpMsgResponse {
    constructor(message, msgHeader, msgBody, opts) {
      this.index = 0;
      this.sections = [];
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
      this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
      this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
    }
    isParsed() {
      return this.parsed;
    }
    parse() {
      if (this.parsed)
        return this.sections[0];
      this.index = 4;
      while (this.index < this.data.length) {
        const payloadType = this.data.readUInt8(this.index++);
        if (payloadType === 0) {
          const bsonSize = this.data.readUInt32LE(this.index);
          const bin = this.data.subarray(this.index, this.index + bsonSize);
          this.sections.push(bin);
          this.index += bsonSize;
        } else if (payloadType === 1) {
          throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
        }
      }
      this.parsed = true;
      return this.sections[0];
    }
  }
  exports.OpMsgResponse = OpMsgResponse;
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;

  class OpCompressedRequest {
    constructor(command, options) {
      this.command = command;
      this.options = {
        zlibCompressionLevel: options.zlibCompressionLevel,
        agreedCompressor: options.agreedCompressor
      };
    }
    static canCompress(command) {
      const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !compression_1.uncompressibleCommands.has(commandName);
    }
    async toBin() {
      const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
      msgHeader.writeInt32LE(this.command.requestId, 4);
      msgHeader.writeInt32LE(0, 8);
      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
      compressionDetails.writeInt32LE(originalCommandOpCode, 0);
      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
      compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8);
      return [msgHeader, compressionDetails, compressedMessage];
    }
  }
  exports.OpCompressedRequest = OpCompressedRequest;
});

// node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uncompressibleCommands = exports.Compressor = undefined;
  exports.compress = compress;
  exports.decompress = decompress;
  exports.compressCommand = compressCommand;
  exports.decompressResponse = decompressResponse;
  var util_1 = __require("util");
  var zlib = __require("zlib");
  var constants_1 = require_constants();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var commands_1 = require_commands();
  var constants_2 = require_constants2();
  exports.Compressor = Object.freeze({
    none: 0,
    snappy: 1,
    zlib: 2,
    zstd: 3
  });
  exports.uncompressibleCommands = new Set([
    constants_1.LEGACY_HELLO_COMMAND,
    "saslStart",
    "saslContinue",
    "getnonce",
    "authenticate",
    "createUser",
    "updateUser",
    "copydbSaslStart",
    "copydbgetnonce",
    "copydb"
  ]);
  var ZSTD_COMPRESSION_LEVEL = 3;
  var zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));
  var zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));
  var zstd;
  var Snappy = null;
  function loadSnappy() {
    if (Snappy == null) {
      const snappyImport = (0, deps_1.getSnappy)();
      if ("kModuleError" in snappyImport) {
        throw snappyImport.kModuleError;
      }
      Snappy = snappyImport;
    }
    return Snappy;
  }
  async function compress(options, dataToBeCompressed) {
    const zlibOptions = {};
    switch (options.agreedCompressor) {
      case "snappy": {
        Snappy ??= loadSnappy();
        return await Snappy.compress(dataToBeCompressed);
      }
      case "zstd": {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
      }
      case "zlib": {
        if (options.zlibCompressionLevel) {
          zlibOptions.level = options.zlibCompressionLevel;
        }
        return await zlibDeflate(dataToBeCompressed, zlibOptions);
      }
      default: {
        throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);
      }
    }
  }
  async function decompress(compressorID, compressedData) {
    if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {
      throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
    }
    switch (compressorID) {
      case exports.Compressor.snappy: {
        Snappy ??= loadSnappy();
        return await Snappy.uncompress(compressedData, { asBuffer: true });
      }
      case exports.Compressor.zstd: {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return await zstd.decompress(compressedData);
      }
      case exports.Compressor.zlib: {
        return await zlibInflate(compressedData);
      }
      default: {
        return compressedData;
      }
    }
  }
  function loadZstd() {
    if (!zstd) {
      zstd = (0, deps_1.getZstdLibrary)();
    }
  }
  var MESSAGE_HEADER_SIZE = 16;
  async function compressCommand(command, description) {
    const finalCommand = description.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
      agreedCompressor: description.agreedCompressor ?? "none",
      zlibCompressionLevel: description.zlibCompressionLevel ?? 0
    });
    const data = await finalCommand.toBin();
    return Buffer.concat(data);
  }
  async function decompressResponse(message) {
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
      const ResponseType2 = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
      const messageBody2 = message.subarray(MESSAGE_HEADER_SIZE);
      return new ResponseType2(message, messageHeader, messageBody2);
    }
    const header = {
      ...messageHeader,
      fromCompressed: true,
      opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
      length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
    };
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
    const messageBody = await decompress(compressorID, compressedBuffer);
    if (messageBody.length !== header.length) {
      throw new error_1.MongoDecompressionError("Message body and message header must be the same length");
    }
    return new ResponseType(message, header, messageBody);
  }
});

// node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js
var require_crypto_callbacks = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmacSha256Hook = exports.hmacSha512Hook = exports.aes256CtrDecryptHook = exports.aes256CtrEncryptHook = exports.aes256CbcDecryptHook = exports.aes256CbcEncryptHook = undefined;
  exports.makeAES256Hook = makeAES256Hook;
  exports.randomHook = randomHook;
  exports.sha256Hook = sha256Hook;
  exports.makeHmacHook = makeHmacHook;
  exports.signRsaSha256Hook = signRsaSha256Hook;
  var crypto2 = __require("crypto");
  function makeAES256Hook(method, mode) {
    return function(key, iv, input, output) {
      let result;
      try {
        const cipher = crypto2[method](mode, key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
        const final = cipher.final();
        if (final.length > 0) {
          result = Buffer.concat([result, final]);
        }
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    };
  }
  function randomHook(buffer, count) {
    try {
      crypto2.randomFillSync(buffer, 0, count);
    } catch (e) {
      return e;
    }
    return count;
  }
  function sha256Hook(input, output) {
    let result;
    try {
      result = crypto2.createHash("sha256").update(input).digest();
    } catch (e) {
      return e;
    }
    result.copy(output);
    return result.length;
  }
  function makeHmacHook(algorithm) {
    return (key, input, output) => {
      let result;
      try {
        result = crypto2.createHmac(algorithm, key).update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    };
  }
  function signRsaSha256Hook(key, input, output) {
    let result;
    try {
      const signer = crypto2.createSign("sha256WithRSAEncryption");
      const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----
${key.toString("base64")}
-----END PRIVATE KEY-----
`);
      result = signer.update(input).end().sign(privateKey);
    } catch (e) {
      return e;
    }
    result.copy(output);
    return result.length;
  }
  exports.aes256CbcEncryptHook = makeAES256Hook("createCipheriv", "aes-256-cbc");
  exports.aes256CbcDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-cbc");
  exports.aes256CtrEncryptHook = makeAES256Hook("createCipheriv", "aes-256-ctr");
  exports.aes256CtrDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-ctr");
  exports.hmacSha512Hook = makeHmacHook("sha512");
  exports.hmacSha256Hook = makeHmacHook("sha256");
});

// node_modules/mongodb/lib/client-side-encryption/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptAzureKMSRequestError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = undefined;
  var error_1 = require_error();

  class MongoCryptError extends error_1.MongoError {
    constructor(message, options = {}) {
      super(message, options);
    }
    get name() {
      return "MongoCryptError";
    }
  }
  exports.MongoCryptError = MongoCryptError;

  class MongoCryptInvalidArgumentError extends MongoCryptError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCryptInvalidArgumentError";
    }
  }
  exports.MongoCryptInvalidArgumentError = MongoCryptInvalidArgumentError;

  class MongoCryptCreateDataKeyError extends MongoCryptError {
    constructor(encryptedFields, { cause }) {
      super(`Unable to complete creating data keys: ${cause.message}`, { cause });
      this.encryptedFields = encryptedFields;
    }
    get name() {
      return "MongoCryptCreateDataKeyError";
    }
  }
  exports.MongoCryptCreateDataKeyError = MongoCryptCreateDataKeyError;

  class MongoCryptCreateEncryptedCollectionError extends MongoCryptError {
    constructor(encryptedFields, { cause }) {
      super(`Unable to create collection: ${cause.message}`, { cause });
      this.encryptedFields = encryptedFields;
    }
    get name() {
      return "MongoCryptCreateEncryptedCollectionError";
    }
  }
  exports.MongoCryptCreateEncryptedCollectionError = MongoCryptCreateEncryptedCollectionError;

  class MongoCryptAzureKMSRequestError extends MongoCryptError {
    constructor(message, body) {
      super(message);
      this.body = body;
    }
    get name() {
      return "MongoCryptAzureKMSRequestError";
    }
  }
  exports.MongoCryptAzureKMSRequestError = MongoCryptAzureKMSRequestError;

  class MongoCryptKMSRequestNetworkTimeoutError extends MongoCryptError {
    get name() {
      return "MongoCryptKMSRequestNetworkTimeoutError";
    }
  }
  exports.MongoCryptKMSRequestNetworkTimeoutError = MongoCryptKMSRequestNetworkTimeoutError;
});

// node_modules/mongodb/lib/cmap/auth/aws_temporary_credentials.js
var require_aws_temporary_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LegacyAWSTemporaryCredentialProvider = exports.AWSSDKCredentialProvider = exports.AWSTemporaryCredentialProvider = undefined;
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var AWS_RELATIVE_URI = "http://169.254.170.2";
  var AWS_EC2_URI = "http://169.254.169.254";
  var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";

  class AWSTemporaryCredentialProvider {
    static get awsSDK() {
      AWSTemporaryCredentialProvider._awsSDK ??= (0, deps_1.getAwsCredentialProvider)();
      return AWSTemporaryCredentialProvider._awsSDK;
    }
    static get isAWSSDKInstalled() {
      return !("kModuleError" in AWSTemporaryCredentialProvider.awsSDK);
    }
  }
  exports.AWSTemporaryCredentialProvider = AWSTemporaryCredentialProvider;

  class AWSSDKCredentialProvider extends AWSTemporaryCredentialProvider {
    constructor(credentialsProvider) {
      super();
      if (credentialsProvider) {
        this._provider = credentialsProvider;
      }
    }
    get provider() {
      if ("kModuleError" in AWSTemporaryCredentialProvider.awsSDK) {
        throw AWSTemporaryCredentialProvider.awsSDK.kModuleError;
      }
      if (this._provider) {
        return this._provider;
      }
      let { AWS_STS_REGIONAL_ENDPOINTS = "", AWS_REGION = "" } = process.env;
      AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();
      AWS_REGION = AWS_REGION.toLowerCase();
      const awsRegionSettingsExist = AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;
      const LEGACY_REGIONS = new Set([
        "ap-northeast-1",
        "ap-south-1",
        "ap-southeast-1",
        "ap-southeast-2",
        "aws-global",
        "ca-central-1",
        "eu-central-1",
        "eu-north-1",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-west-1",
        "us-west-2"
      ]);
      const useRegionalSts = AWS_STS_REGIONAL_ENDPOINTS === "regional" || AWS_STS_REGIONAL_ENDPOINTS === "legacy" && !LEGACY_REGIONS.has(AWS_REGION);
      this._provider = awsRegionSettingsExist && useRegionalSts ? AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain({
        clientConfig: { region: AWS_REGION }
      }) : AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain();
      return this._provider;
    }
    async getCredentials() {
      try {
        const creds = await this.provider();
        return {
          AccessKeyId: creds.accessKeyId,
          SecretAccessKey: creds.secretAccessKey,
          Token: creds.sessionToken,
          Expiration: creds.expiration
        };
      } catch (error) {
        throw new error_1.MongoAWSError(error.message, { cause: error });
      }
    }
  }
  exports.AWSSDKCredentialProvider = AWSSDKCredentialProvider;

  class LegacyAWSTemporaryCredentialProvider extends AWSTemporaryCredentialProvider {
    async getCredentials() {
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        return await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`);
      }
      const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
        method: "PUT",
        json: false,
        headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 }
      });
      const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
        json: false,
        headers: { "X-aws-ec2-metadata-token": token }
      });
      const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
        headers: { "X-aws-ec2-metadata-token": token }
      });
      return creds;
    }
  }
  exports.LegacyAWSTemporaryCredentialProvider = LegacyAWSTemporaryCredentialProvider;
});

// node_modules/mongodb/lib/client-side-encryption/providers/aws.js
var require_aws = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadAWSCredentials = loadAWSCredentials;
  var aws_temporary_credentials_1 = require_aws_temporary_credentials();
  async function loadAWSCredentials(kmsProviders, provider) {
    const credentialProvider = new aws_temporary_credentials_1.AWSSDKCredentialProvider(provider);
    const { SecretAccessKey = "", AccessKeyId = "", Token } = await credentialProvider.getCredentials();
    const aws = {
      secretAccessKey: SecretAccessKey,
      accessKeyId: AccessKeyId
    };
    Token != null && (aws.sessionToken = Token);
    return { ...kmsProviders, aws };
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/azure.js
var require_azure = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tokenCache = exports.AzureCredentialCache = exports.AZURE_BASE_URL = undefined;
  exports.addAzureParams = addAzureParams;
  exports.prepareRequest = prepareRequest;
  exports.fetchAzureKMSToken = fetchAzureKMSToken;
  exports.loadAzureCredentials = loadAzureCredentials;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var errors_1 = require_errors();
  var MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;
  exports.AZURE_BASE_URL = "http://169.254.169.254/metadata/identity/oauth2/token?";

  class AzureCredentialCache {
    constructor() {
      this.cachedToken = null;
    }
    async getToken() {
      if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {
        this.cachedToken = await this._getToken();
      }
      return { accessToken: this.cachedToken.accessToken };
    }
    needsRefresh(token) {
      const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();
      return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;
    }
    resetCache() {
      this.cachedToken = null;
    }
    _getToken() {
      return fetchAzureKMSToken();
    }
  }
  exports.AzureCredentialCache = AzureCredentialCache;
  exports.tokenCache = new AzureCredentialCache;
  async function parseResponse(response) {
    const { status: status2, body: rawBody } = response;
    const body = (() => {
      try {
        return JSON.parse(rawBody);
      } catch {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed JSON body in GET request.");
      }
    })();
    if (status2 !== 200) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Unable to complete request.", body);
    }
    if (!body.access_token) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `access_token`.");
    }
    if (!body.expires_in) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `expires_in`.");
    }
    const expiresInMS = Number(body.expires_in) * 1000;
    if (Number.isNaN(expiresInMS)) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - unable to parse int from `expires_in` field.");
    }
    return {
      accessToken: body.access_token,
      expiresOnTimestamp: Date.now() + expiresInMS
    };
  }
  function addAzureParams(url, resource, username) {
    url.searchParams.append("api-version", "2018-02-01");
    url.searchParams.append("resource", resource);
    if (username) {
      url.searchParams.append("client_id", username);
    }
    return url;
  }
  function prepareRequest(options) {
    const url = new URL(options.url?.toString() ?? exports.AZURE_BASE_URL);
    addAzureParams(url, "https://vault.azure.net");
    const headers = { ...options.headers, "Content-Type": "application/json", Metadata: true };
    return { headers, url };
  }
  async function fetchAzureKMSToken(options = {}) {
    const { headers, url } = prepareRequest(options);
    try {
      const response = await (0, utils_1.get)(url, { headers });
      return await parseResponse(response);
    } catch (error) {
      if (error instanceof error_1.MongoNetworkTimeoutError) {
        throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);
      }
      throw error;
    }
  }
  async function loadAzureCredentials(kmsProviders) {
    const azure = await exports.tokenCache.getToken();
    return { ...kmsProviders, azure };
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/gcp.js
var require_gcp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadGCPCredentials = loadGCPCredentials;
  var deps_1 = require_deps();
  async function loadGCPCredentials(kmsProviders) {
    const gcpMetadata = (0, deps_1.getGcpMetadata)();
    if ("kModuleError" in gcpMetadata) {
      return kmsProviders;
    }
    const { access_token: accessToken } = await gcpMetadata.instance({
      property: "service-accounts/default/token"
    });
    return { ...kmsProviders, gcp: { accessToken } };
  }
});

// node_modules/mongodb/lib/client-side-encryption/providers/index.js
var require_providers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmptyCredentials = isEmptyCredentials;
  exports.refreshKMSCredentials = refreshKMSCredentials;
  var aws_1 = require_aws();
  var azure_1 = require_azure();
  var gcp_1 = require_gcp();
  function isEmptyCredentials(providerName, kmsProviders) {
    const provider = kmsProviders[providerName];
    if (provider == null) {
      return false;
    }
    return typeof provider === "object" && Object.keys(provider).length === 0;
  }
  async function refreshKMSCredentials(kmsProviders, credentialProviders) {
    let finalKMSProviders = kmsProviders;
    if (isEmptyCredentials("aws", kmsProviders)) {
      finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders, credentialProviders?.aws);
    }
    if (isEmptyCredentials("gcp", kmsProviders)) {
      finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);
    }
    if (isEmptyCredentials("azure", kmsProviders)) {
      finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);
    }
    return finalKMSProviders;
  }
});

// node_modules/mongodb/lib/client-side-encryption/state_machine.js
var require_state_machine = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StateMachine = undefined;
  var fs = __require("fs/promises");
  var net = __require("net");
  var tls = __require("tls");
  var bson_1 = require_bson2();
  var abstract_cursor_1 = require_abstract_cursor();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var client_encryption_1 = require_client_encryption();
  var errors_1 = require_errors();
  var socks = null;
  function loadSocks() {
    if (socks == null) {
      const socksImport = (0, deps_1.getSocks)();
      if ("kModuleError" in socksImport) {
        throw socksImport.kModuleError;
      }
      socks = socksImport;
    }
    return socks;
  }
  var MONGOCRYPT_CTX_ERROR = 0;
  var MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
  var MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
  var MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
  var MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
  var MONGOCRYPT_CTX_NEED_KMS = 4;
  var MONGOCRYPT_CTX_READY = 5;
  var MONGOCRYPT_CTX_DONE = 6;
  var HTTPS_PORT = 443;
  var stateToString = new Map([
    [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
    [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
    [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
    [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
    [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, "MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS"],
    [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
    [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
    [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
  ]);
  var INSECURE_TLS_OPTIONS = [
    "tlsInsecure",
    "tlsAllowInvalidCertificates",
    "tlsAllowInvalidHostnames"
  ];
  function debug2(msg) {
    if (process.env.MONGODB_CRYPT_DEBUG) {
      console.error(msg);
    }
  }
  var EMPTY_V;

  class StateMachine {
    constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {
      this.options = options;
      this.bsonOptions = bsonOptions;
    }
    async execute(executor, context, options) {
      const keyVaultNamespace = executor._keyVaultNamespace;
      const keyVaultClient = executor._keyVaultClient;
      const metaDataClient = executor._metaDataClient;
      const mongocryptdClient = executor._mongocryptdClient;
      const mongocryptdManager = executor._mongocryptdManager;
      let result = null;
      const getStatus = () => context.status;
      const getState = () => context.state;
      while (getState() !== MONGOCRYPT_CTX_DONE && getState() !== MONGOCRYPT_CTX_ERROR) {
        options.signal?.throwIfAborted();
        debug2(`[context#${context.id}] ${stateToString.get(getState()) || getState()}`);
        switch (getState()) {
          case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
            const filter = (0, bson_1.deserialize)(context.nextMongoOperation());
            if (!metaDataClient) {
              throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined");
            }
            const collInfoCursor = this.fetchCollectionInfo(metaDataClient, context.ns, filter, options);
            for await (const collInfo of collInfoCursor) {
              context.addMongoOperationResponse((0, bson_1.serialize)(collInfo));
              if (getState() === MONGOCRYPT_CTX_ERROR)
                break;
            }
            if (getState() === MONGOCRYPT_CTX_ERROR)
              break;
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
            const command = context.nextMongoOperation();
            if (getState() === MONGOCRYPT_CTX_ERROR)
              break;
            if (!mongocryptdClient) {
              throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined");
            }
            const markedCommand = mongocryptdManager ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command, options)) : await this.markCommand(mongocryptdClient, context.ns, command, options);
            context.addMongoOperationResponse(markedCommand);
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
            const filter = context.nextMongoOperation();
            const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, options);
            if (keys.length === 0) {
              result = EMPTY_V ??= (0, bson_1.serialize)({ v: [] });
            }
            for (const key of keys) {
              context.addMongoOperationResponse((0, bson_1.serialize)(key));
            }
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
            const kmsProviders = await executor.askForKMSCredentials();
            context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));
            break;
          }
          case MONGOCRYPT_CTX_NEED_KMS: {
            await Promise.all(this.requests(context, options));
            context.finishKMSRequests();
            break;
          }
          case MONGOCRYPT_CTX_READY: {
            const finalizedContext = context.finalize();
            if (getState() === MONGOCRYPT_CTX_ERROR) {
              const message = getStatus().message || "Finalization error";
              throw new errors_1.MongoCryptError(message);
            }
            result = finalizedContext;
            break;
          }
          default:
            throw new errors_1.MongoCryptError(`Unknown state: ${getState()}`);
        }
      }
      if (getState() === MONGOCRYPT_CTX_ERROR || result == null) {
        const message = getStatus().message;
        if (!message) {
          debug2(`unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`);
        }
        throw new errors_1.MongoCryptError(message ?? "unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.");
      }
      return result;
    }
    async kmsRequest(request, options) {
      const parsedUrl = request.endpoint.split(":");
      const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
      const socketOptions = {
        host: parsedUrl[0],
        servername: parsedUrl[0],
        port,
        ...(0, client_encryption_1.autoSelectSocketOptions)(this.options.socketOptions || {})
      };
      const message = request.message;
      const buffer = new utils_1.BufferPool;
      let netSocket;
      let socket;
      function destroySockets() {
        for (const sock of [socket, netSocket]) {
          if (sock) {
            sock.destroy();
          }
        }
      }
      function onerror(cause) {
        return new errors_1.MongoCryptError("KMS request failed", { cause });
      }
      function onclose() {
        return new errors_1.MongoCryptError("KMS request closed");
      }
      const tlsOptions = this.options.tlsOptions;
      if (tlsOptions) {
        const kmsProvider = request.kmsProvider;
        const providerTlsOptions = tlsOptions[kmsProvider];
        if (providerTlsOptions) {
          const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);
          if (error) {
            throw error;
          }
          try {
            await this.setTlsOptions(providerTlsOptions, socketOptions);
          } catch (err2) {
            throw onerror(err2);
          }
        }
      }
      let abortListener;
      try {
        if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {
          netSocket = new net.Socket;
          const { promise: willConnect, reject: rejectOnNetSocketError, resolve: resolveOnNetSocketConnect } = (0, utils_1.promiseWithResolvers)();
          netSocket.once("error", (err2) => rejectOnNetSocketError(onerror(err2))).once("close", () => rejectOnNetSocketError(onclose())).once("connect", () => resolveOnNetSocketConnect());
          const netSocketOptions = {
            ...socketOptions,
            host: this.options.proxyOptions.proxyHost,
            port: this.options.proxyOptions.proxyPort || 1080
          };
          netSocket.connect(netSocketOptions);
          await willConnect;
          try {
            socks ??= loadSocks();
            socketOptions.socket = (await socks.SocksClient.createConnection({
              existing_socket: netSocket,
              command: "connect",
              destination: { host: socketOptions.host, port: socketOptions.port },
              proxy: {
                host: "iLoveJavaScript",
                port: 0,
                type: 5,
                userId: this.options.proxyOptions.proxyUsername,
                password: this.options.proxyOptions.proxyPassword
              }
            })).socket;
          } catch (err2) {
            throw onerror(err2);
          }
        }
        socket = tls.connect(socketOptions, () => {
          socket.write(message);
        });
        const { promise: willResolveKmsRequest, reject: rejectOnTlsSocketError, resolve } = (0, utils_1.promiseWithResolvers)();
        abortListener = (0, utils_1.addAbortListener)(options?.signal, function() {
          destroySockets();
          rejectOnTlsSocketError(this.reason);
        });
        socket.once("error", (err2) => rejectOnTlsSocketError(onerror(err2))).once("close", () => rejectOnTlsSocketError(onclose())).on("data", (data) => {
          buffer.append(data);
          while (request.bytesNeeded > 0 && buffer.length) {
            const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
            request.addResponse(buffer.read(bytesNeeded));
          }
          if (request.bytesNeeded <= 0) {
            resolve();
          }
        });
        await (options?.timeoutContext?.csotEnabled() ? Promise.all([
          willResolveKmsRequest,
          timeout_1.Timeout.expires(options.timeoutContext?.remainingTimeMS)
        ]) : willResolveKmsRequest);
      } catch (error) {
        if (error instanceof timeout_1.TimeoutError)
          throw new error_1.MongoOperationTimeoutError("KMS request timed out");
        throw error;
      } finally {
        destroySockets();
        abortListener?.[utils_1.kDispose]();
      }
    }
    *requests(context, options) {
      for (let request = context.nextKMSRequest();request != null; request = context.nextKMSRequest()) {
        yield this.kmsRequest(request, options);
      }
    }
    validateTlsOptions(kmsProvider, tlsOptions) {
      const tlsOptionNames = Object.keys(tlsOptions);
      for (const option of INSECURE_TLS_OPTIONS) {
        if (tlsOptionNames.includes(option)) {
          return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
        }
      }
    }
    async setTlsOptions(tlsOptions, options) {
      if (tlsOptions.tlsCertificateKeyFile) {
        const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);
        options.cert = options.key = cert;
      }
      if (tlsOptions.tlsCAFile) {
        options.ca = await fs.readFile(tlsOptions.tlsCAFile);
      }
      if (tlsOptions.tlsCertificateKeyFilePassword) {
        options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
      }
    }
    fetchCollectionInfo(client, ns, filter, options) {
      const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
      const cursor = client.db(db).listCollections(filter, {
        promoteLongs: false,
        promoteValues: false,
        timeoutContext: options?.timeoutContext && new abstract_cursor_1.CursorTimeoutContext(options?.timeoutContext, Symbol()),
        signal: options?.signal,
        nameOnly: false
      });
      return cursor;
    }
    async markCommand(client, ns, command, options) {
      const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
      const bsonOptions = { promoteLongs: false, promoteValues: false };
      const rawCommand = (0, bson_1.deserialize)(command, bsonOptions);
      const commandOptions = {
        timeoutMS: undefined,
        signal: undefined
      };
      if (options?.timeoutContext?.csotEnabled()) {
        commandOptions.timeoutMS = options.timeoutContext.remainingTimeMS;
      }
      if (options?.signal) {
        commandOptions.signal = options.signal;
      }
      const response = await client.db(db).command(rawCommand, {
        ...bsonOptions,
        ...commandOptions
      });
      return (0, bson_1.serialize)(response, this.bsonOptions);
    }
    fetchKeys(client, keyVaultNamespace, filter, options) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);
      const commandOptions = {
        timeoutContext: undefined,
        signal: undefined
      };
      if (options?.timeoutContext != null) {
        commandOptions.timeoutContext = new abstract_cursor_1.CursorTimeoutContext(options.timeoutContext, Symbol());
      }
      if (options?.signal != null) {
        commandOptions.signal = options.signal;
      }
      return client.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find((0, bson_1.deserialize)(filter), commandOptions).toArray();
    }
  }
  exports.StateMachine = StateMachine;
});

// node_modules/mongodb/lib/client-side-encryption/client_encryption.js
var require_client_encryption = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientEncryption = undefined;
  exports.autoSelectSocketOptions = autoSelectSocketOptions;
  var bson_1 = require_bson2();
  var deps_1 = require_deps();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var cryptoCallbacks = require_crypto_callbacks();
  var errors_1 = require_errors();
  var index_1 = require_providers2();
  var state_machine_1 = require_state_machine();

  class ClientEncryption {
    static getMongoCrypt() {
      const encryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in encryption) {
        throw encryption.kModuleError;
      }
      return encryption.MongoCrypt;
    }
    constructor(client, options) {
      this._client = client;
      this._proxyOptions = options.proxyOptions ?? {};
      this._tlsOptions = options.tlsOptions ?? {};
      this._kmsProviders = options.kmsProviders || {};
      const { timeoutMS } = (0, utils_1.resolveTimeoutOptions)(client, options);
      this._timeoutMS = timeoutMS;
      this._credentialProviders = options.credentialProviders;
      if (options.credentialProviders?.aws && !(0, index_1.isEmptyCredentials)("aws", this._kmsProviders)) {
        throw new errors_1.MongoCryptInvalidArgumentError("Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching");
      }
      if (options.keyVaultNamespace == null) {
        throw new errors_1.MongoCryptInvalidArgumentError("Missing required option `keyVaultNamespace`");
      }
      const mongoCryptOptions = {
        ...options,
        cryptoCallbacks,
        kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders
      };
      this._keyVaultNamespace = options.keyVaultNamespace;
      this._keyVaultClient = options.keyVaultClient || client;
      const MongoCrypt = ClientEncryption.getMongoCrypt();
      this._mongoCrypt = new MongoCrypt(mongoCryptOptions);
    }
    async createDataKey(provider, options = {}) {
      if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {
        throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);
      }
      let keyAltNames = undefined;
      if (options.keyAltNames && options.keyAltNames.length > 0) {
        keyAltNames = options.keyAltNames.map((keyAltName, i) => {
          if (typeof keyAltName !== "string") {
            throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
          }
          return (0, bson_1.serialize)({ keyAltName });
        });
      }
      let keyMaterial = undefined;
      if (options.keyMaterial) {
        keyMaterial = (0, bson_1.serialize)({ keyMaterial: options.keyMaterial });
      }
      const dataKeyBson = (0, bson_1.serialize)({
        provider,
        ...options.masterKey
      });
      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {
        keyAltNames,
        keyMaterial
      });
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const timeoutContext = options?.timeoutContext ?? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
      const dataKey = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const { insertedId } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {
        writeConcern: { w: "majority" },
        timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : undefined
      });
      return insertedId;
    }
    async rewrapManyDataKey(filter, options) {
      let keyEncryptionKeyBson = undefined;
      if (options) {
        const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);
        keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);
      }
      const filterBson = (0, bson_1.serialize)(filter);
      const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const timeoutContext = timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
      const { v: dataKeys } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      if (dataKeys.length === 0) {
        return {};
      }
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const replacements = dataKeys.map((key) => ({
        updateOne: {
          filter: { _id: key._id },
          update: {
            $set: {
              masterKey: key.masterKey,
              keyMaterial: key.keyMaterial
            },
            $currentDate: {
              updateDate: true
            }
          }
        }
      }));
      const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {
        writeConcern: { w: "majority" },
        timeoutMS: timeoutContext.csotEnabled() ? timeoutContext?.remainingTimeMS : undefined
      });
      return { bulkWriteResult: result };
    }
    async deleteKey(_id) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return await this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({ _id }, { writeConcern: { w: "majority" }, timeoutMS: this._timeoutMS });
    }
    getKeys() {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return this._keyVaultClient.db(dbName).collection(collectionName).find({}, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
    }
    async getKey(_id) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ _id }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
    }
    async getKeyByAltName(keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ keyAltNames: keyAltName }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
    }
    async addKeyAltName(_id, keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, { $addToSet: { keyAltNames: keyAltName } }, { writeConcern: { w: "majority" }, returnDocument: "before", timeoutMS: this._timeoutMS });
      return value;
    }
    async removeKeyAltName(_id, keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const pipeline2 = [
        {
          $set: {
            keyAltNames: {
              $cond: [
                {
                  $eq: ["$keyAltNames", [keyAltName]]
                },
                "$$REMOVE",
                {
                  $filter: {
                    input: "$keyAltNames",
                    cond: {
                      $ne: ["$$this", keyAltName]
                    }
                  }
                }
              ]
            }
          }
        }
      ];
      const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, pipeline2, {
        writeConcern: { w: "majority" },
        returnDocument: "before",
        timeoutMS: this._timeoutMS
      });
      return value;
    }
    async createEncryptedCollection(db, name, options) {
      const { provider, masterKey, createCollectionOptions: { encryptedFields: { ...encryptedFields }, ...createCollectionOptions } } = options;
      const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : undefined;
      if (Array.isArray(encryptedFields.fields)) {
        const createDataKeyPromises = encryptedFields.fields.map(async (field) => field == null || typeof field !== "object" || field.keyId != null ? field : {
          ...field,
          keyId: await this.createDataKey(provider, {
            masterKey,
            timeoutContext: timeoutContext?.csotEnabled() ? timeoutContext?.clone() : undefined
          })
        });
        const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);
        encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === "fulfilled" ? resolution.value : encryptedFields.fields[index]);
        const rejection = createDataKeyResolutions.find((result) => result.status === "rejected");
        if (rejection != null) {
          throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });
        }
      }
      try {
        const collection = await db.createCollection(name, {
          ...createCollectionOptions,
          encryptedFields,
          timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : undefined
        });
        return { collection, encryptedFields };
      } catch (cause) {
        throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });
      }
    }
    async encrypt(value, options) {
      return await this._encrypt(value, false, options);
    }
    async encryptExpression(expression, options) {
      return await this._encrypt(expression, true, options);
    }
    async decrypt(value) {
      const valueBuffer = (0, bson_1.serialize)({ v: value });
      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : undefined;
      const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      return v;
    }
    async askForKMSCredentials() {
      return await (0, index_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);
    }
    static get libmongocryptVersion() {
      return ClientEncryption.getMongoCrypt().libmongocryptVersion;
    }
    async _encrypt(value, expressionMode, options) {
      const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;
      const contextOptions = {
        expressionMode,
        algorithm
      };
      if (keyId) {
        contextOptions.keyId = keyId.buffer;
      }
      if (keyAltName) {
        if (keyId) {
          throw new errors_1.MongoCryptInvalidArgumentError(`"options" cannot contain both "keyId" and "keyAltName"`);
        }
        if (typeof keyAltName !== "string") {
          throw new errors_1.MongoCryptInvalidArgumentError(`"options.keyAltName" must be of type string, but was of type ${typeof keyAltName}`);
        }
        contextOptions.keyAltName = (0, bson_1.serialize)({ keyAltName });
      }
      if (typeof contentionFactor === "number" || typeof contentionFactor === "bigint") {
        contextOptions.contentionFactor = contentionFactor;
      }
      if (typeof queryType === "string") {
        contextOptions.queryType = queryType;
      }
      if (typeof rangeOptions === "object") {
        contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);
      }
      const valueBuffer = (0, bson_1.serialize)({ v: value });
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
      const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : undefined;
      const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      return v;
    }
  }
  exports.ClientEncryption = ClientEncryption;
  function autoSelectSocketOptions(baseOptions) {
    const options = { autoSelectFamily: true };
    if ("autoSelectFamily" in baseOptions) {
      options.autoSelectFamily = baseOptions.autoSelectFamily;
    }
    if ("autoSelectFamilyAttemptTimeout" in baseOptions) {
      options.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;
    }
    return options;
  }
});

// node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js
var require_mongocryptd_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongocryptdManager = undefined;
  var error_1 = require_error();

  class MongocryptdManager {
    constructor(extraOptions = {}) {
      this.spawnPath = "";
      this.spawnArgs = [];
      this.uri = typeof extraOptions.mongocryptdURI === "string" && extraOptions.mongocryptdURI.length > 0 ? extraOptions.mongocryptdURI : MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
      this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
      if (Object.hasOwn(extraOptions, "mongocryptdSpawnPath") && extraOptions.mongocryptdSpawnPath) {
        this.spawnPath = extraOptions.mongocryptdSpawnPath;
      }
      if (Object.hasOwn(extraOptions, "mongocryptdSpawnArgs") && Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
        this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
      }
      if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
        this.spawnArgs.push("--idleShutdownTimeoutSecs", "60");
      }
    }
    async spawn() {
      const cmdName = this.spawnPath || "mongocryptd";
      const { spawn } = __require("child_process");
      this._child = spawn(cmdName, this.spawnArgs, {
        stdio: "ignore",
        detached: true
      });
      this._child.on("error", () => {
      });
      this._child.unref();
    }
    async withRespawn(fn) {
      try {
        const result2 = await fn();
        return result2;
      } catch (err2) {
        const shouldSpawn = err2 instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;
        if (!shouldSpawn) {
          throw err2;
        }
      }
      await this.spawn();
      const result = await fn();
      return result;
    }
  }
  exports.MongocryptdManager = MongocryptdManager;
  MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = "mongodb://localhost:27020";
});

// node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js
var require_auto_encrypter = __commonJS((exports) => {
  var _a3;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = undefined;
  var net = __require("net");
  var bson_1 = require_bson2();
  var constants_1 = require_constants();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var utils_1 = require_utils();
  var client_encryption_1 = require_client_encryption();
  var cryptoCallbacks = require_crypto_callbacks();
  var errors_1 = require_errors();
  var mongocryptd_manager_1 = require_mongocryptd_manager();
  var providers_1 = require_providers2();
  var state_machine_1 = require_state_machine();
  exports.AutoEncryptionLoggerLevel = Object.freeze({
    FatalError: 0,
    Error: 1,
    Warning: 2,
    Info: 3,
    Trace: 4
  });

  class AutoEncrypter {
    static getMongoCrypt() {
      const encryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in encryption) {
        throw encryption.kModuleError;
      }
      return encryption.MongoCrypt;
    }
    constructor(client, options) {
      this[_a3] = false;
      this._client = client;
      this._bypassEncryption = options.bypassAutoEncryption === true;
      this._keyVaultNamespace = options.keyVaultNamespace || "admin.datakeys";
      this._keyVaultClient = options.keyVaultClient || client;
      this._metaDataClient = options.metadataClient || client;
      this._proxyOptions = options.proxyOptions || {};
      this._tlsOptions = options.tlsOptions || {};
      this._kmsProviders = options.kmsProviders || {};
      this._credentialProviders = options.credentialProviders;
      if (options.credentialProviders?.aws && !(0, providers_1.isEmptyCredentials)("aws", this._kmsProviders)) {
        throw new errors_1.MongoCryptInvalidArgumentError("Can only provide a custom AWS credential provider when the state machine is configured for automatic AWS credential fetching");
      }
      const mongoCryptOptions = {
        enableMultipleCollinfo: true,
        cryptoCallbacks
      };
      if (options.schemaMap) {
        mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);
      }
      if (options.encryptedFieldsMap) {
        mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);
      }
      mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;
      if (options.options?.logger) {
        mongoCryptOptions.logger = options.options.logger;
      }
      if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {
        mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;
      }
      if (options.bypassQueryAnalysis) {
        mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;
      }
      if (options.keyExpirationMS != null) {
        mongoCryptOptions.keyExpirationMS = options.keyExpirationMS;
      }
      this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;
      if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {
        mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;
      } else if (!this._bypassMongocryptdAndCryptShared) {
        mongoCryptOptions.cryptSharedLibSearchPaths = ["$SYSTEM"];
      }
      const MongoCrypt = AutoEncrypter.getMongoCrypt();
      this._mongocrypt = new MongoCrypt(mongoCryptOptions);
      this._contextCounter = 0;
      if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {
        throw new errors_1.MongoCryptInvalidArgumentError("`cryptSharedLibRequired` set but no crypt_shared library loaded");
      }
      if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
        this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);
        const clientOptions = {
          serverSelectionTimeoutMS: 1e4
        };
        if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== "string") && !net.getDefaultAutoSelectFamily) {
          clientOptions.family = 4;
        }
        if (net.getDefaultAutoSelectFamily) {
          Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.s?.options ?? {}));
        }
        this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
      }
    }
    async init() {
      if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
        return;
      }
      if (!this._mongocryptdManager) {
        throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.");
      }
      if (!this._mongocryptdClient) {
        throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.");
      }
      if (!this._mongocryptdManager.bypassSpawn) {
        await this._mongocryptdManager.spawn();
      }
      try {
        const client = await this._mongocryptdClient.connect();
        return client;
      } catch (error) {
        throw new error_1.MongoRuntimeError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn", { cause: error });
      }
    }
    async close() {
      await this._mongocryptdClient?.close();
    }
    async encrypt(ns, cmd, options = {}) {
      options.signal?.throwIfAborted();
      if (this._bypassEncryption) {
        return cmd;
      }
      const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);
      const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
      context.id = this._contextCounter++;
      context.ns = ns;
      context.document = cmd;
      const stateMachine = new state_machine_1.StateMachine({
        promoteValues: false,
        promoteLongs: false,
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
      });
      return (0, bson_1.deserialize)(await stateMachine.execute(this, context, options), {
        promoteValues: false,
        promoteLongs: false
      });
    }
    async decrypt(response, options = {}) {
      options.signal?.throwIfAborted();
      const context = this._mongocrypt.makeDecryptionContext(response);
      context.id = this._contextCounter++;
      const stateMachine = new state_machine_1.StateMachine({
        ...options,
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
      });
      return await stateMachine.execute(this, context, options);
    }
    async askForKMSCredentials() {
      return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders, this._credentialProviders);
    }
    get cryptSharedLibVersionInfo() {
      return this._mongocrypt.cryptSharedLibVersionInfo;
    }
    static get libmongocryptVersion() {
      return AutoEncrypter.getMongoCrypt().libmongocryptVersion;
    }
  }
  exports.AutoEncrypter = AutoEncrypter;
  _a3 = constants_1.kDecorateResult;
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Encrypter = undefined;
  var auto_encrypter_1 = require_auto_encrypter();
  var constants_1 = require_constants();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();

  class Encrypter {
    constructor(client, uri2, options) {
      if (typeof options.autoEncryption !== "object") {
        throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
      }
      this.internalClient = null;
      this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
      this.needsConnecting = false;
      if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = client;
      } else if (options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri2, options);
      }
      if (this.bypassAutoEncryption) {
        options.autoEncryption.metadataClient = undefined;
      } else if (options.maxPoolSize === 0) {
        options.autoEncryption.metadataClient = client;
      } else {
        options.autoEncryption.metadataClient = this.getInternalClient(client, uri2, options);
      }
      if (options.proxyHost) {
        options.autoEncryption.proxyOptions = {
          proxyHost: options.proxyHost,
          proxyPort: options.proxyPort,
          proxyUsername: options.proxyUsername,
          proxyPassword: options.proxyPassword
        };
      }
      this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options.autoEncryption);
    }
    getInternalClient(client, uri2, options) {
      let internalClient = this.internalClient;
      if (internalClient == null) {
        const clonedOptions = {};
        for (const key of [
          ...Object.getOwnPropertyNames(options),
          ...Object.getOwnPropertySymbols(options)
        ]) {
          if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
            continue;
          Reflect.set(clonedOptions, key, Reflect.get(options, key));
        }
        clonedOptions.minPoolSize = 0;
        internalClient = new mongo_client_1.MongoClient(uri2, clonedOptions);
        this.internalClient = internalClient;
        for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
          for (const listener of client.listeners(eventName)) {
            internalClient.on(eventName, listener);
          }
        }
        client.on("newListener", (eventName, listener) => {
          internalClient?.on(eventName, listener);
        });
        this.needsConnecting = true;
      }
      return internalClient;
    }
    async connectInternalClient() {
      const internalClient = this.internalClient;
      if (this.needsConnecting && internalClient != null) {
        this.needsConnecting = false;
        await internalClient.connect();
      }
    }
    async close(client) {
      let error;
      try {
        await this.autoEncrypter.close();
      } catch (autoEncrypterError) {
        error = autoEncrypterError;
      }
      const internalClient = this.internalClient;
      if (internalClient != null && client !== internalClient) {
        return await internalClient.close();
      }
      if (error != null) {
        throw error;
      }
    }
    static checkForMongoCrypt() {
      const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in mongodbClientEncryption) {
        throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. " + "Please add `mongodb-client-encryption` as a dependency of your project", {
          cause: mongodbClientEncryption["kModuleError"],
          dependencyName: "mongodb-client-encryption"
        });
      }
    }
  }
  exports.Encrypter = Encrypter;
});

// node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolMetrics = undefined;

  class ConnectionPoolMetrics {
    constructor() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
    markPinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections += 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections += 1;
      } else {
        this.otherConnections += 1;
      }
    }
    markUnpinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections -= 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections -= 1;
      } else {
        this.otherConnections -= 1;
      }
    }
    info(maxPoolSize) {
      return "Timed out while checking out a connection from connection pool: " + `maxPoolSize: ${maxPoolSize}, ` + `connections in use by cursors: ${this.cursorConnections}, ` + `connections in use by transactions: ${this.txnConnections}, ` + `connections in use by other operations: ${this.otherConnections}`;
    }
    reset() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
  }
  exports.ConnectionPoolMetrics = ConnectionPoolMetrics;
  ConnectionPoolMetrics.TXN = "txn";
  ConnectionPoolMetrics.CURSOR = "cursor";
  ConnectionPoolMetrics.OTHER = "other";
});

// node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerDescription = undefined;
  exports.parseServerType = parseServerType;
  exports.compareTopologyVersion = compareTopologyVersion;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var common_1 = require_common2();
  var WRITABLE_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.Standalone,
    common_1.ServerType.Mongos,
    common_1.ServerType.LoadBalancer
  ]);
  var DATA_BEARING_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.RSSecondary,
    common_1.ServerType.Mongos,
    common_1.ServerType.Standalone,
    common_1.ServerType.LoadBalancer
  ]);

  class ServerDescription {
    constructor(address, hello, options = {}) {
      if (address == null || address === "") {
        throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
      }
      this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
      this.type = parseServerType(hello, options);
      this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
      this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
      this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
      this.tags = hello?.tags ?? {};
      this.minWireVersion = hello?.minWireVersion ?? 0;
      this.maxWireVersion = hello?.maxWireVersion ?? 0;
      this.roundTripTime = options?.roundTripTime ?? -1;
      this.minRoundTripTime = options?.minRoundTripTime ?? 0;
      this.lastUpdateTime = (0, utils_1.now)();
      this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
      this.error = options.error ?? null;
      this.error?.stack;
      this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
      this.setName = hello?.setName ?? null;
      this.setVersion = hello?.setVersion ?? null;
      this.electionId = hello?.electionId ?? null;
      this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
      this.maxMessageSizeBytes = hello?.maxMessageSizeBytes ?? null;
      this.maxWriteBatchSize = hello?.maxWriteBatchSize ?? null;
      this.maxBsonObjectSize = hello?.maxBsonObjectSize ?? null;
      this.primary = hello?.primary ?? null;
      this.me = hello?.me?.toLowerCase() ?? null;
      this.$clusterTime = hello?.$clusterTime ?? null;
      this.iscryptd = Boolean(hello?.iscryptd);
    }
    get hostAddress() {
      return utils_1.HostAddress.fromString(this.address);
    }
    get allHosts() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    get isReadable() {
      return this.type === common_1.ServerType.RSSecondary || this.isWritable;
    }
    get isDataBearing() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    get isWritable() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
    get host() {
      const chopLength = `:${this.port}`.length;
      return this.address.slice(0, -chopLength);
    }
    get port() {
      const port = this.address.split(":").pop();
      return port ? Number.parseInt(port, 10) : 27017;
    }
    equals(other) {
      const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion || compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
      const electionIdsEqual = this.electionId != null && other?.electionId != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === other?.electionId;
      return other != null && other.iscryptd === this.iscryptd && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  }
  exports.ServerDescription = ServerDescription;
  function parseServerType(hello, options) {
    if (options?.loadBalanced) {
      return common_1.ServerType.LoadBalancer;
    }
    if (!hello || !hello.ok) {
      return common_1.ServerType.Unknown;
    }
    if (hello.isreplicaset) {
      return common_1.ServerType.RSGhost;
    }
    if (hello.msg && hello.msg === "isdbgrid") {
      return common_1.ServerType.Mongos;
    }
    if (hello.setName) {
      if (hello.hidden) {
        return common_1.ServerType.RSOther;
      } else if (hello.isWritablePrimary) {
        return common_1.ServerType.RSPrimary;
      } else if (hello.secondary) {
        return common_1.ServerType.RSSecondary;
      } else if (hello.arbiterOnly) {
        return common_1.ServerType.RSArbiter;
      } else {
        return common_1.ServerType.RSOther;
      }
    }
    return common_1.ServerType.Standalone;
  }
  function tagsStrictEqual(tags, tags2) {
    const tagsKeys = Object.keys(tags);
    const tags2Keys = Object.keys(tags2);
    return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
  }
  function compareTopologyVersion(currentTv, newTv) {
    if (currentTv == null || newTv == null) {
      return -1;
    }
    if (!currentTv.processId.equals(newTv.processId)) {
      return -1;
    }
    const currentCounter = typeof currentTv.counter === "bigint" ? bson_1.Long.fromBigInt(currentTv.counter) : bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
    const newCounter = typeof newTv.counter === "bigint" ? bson_1.Long.fromBigInt(newTv.counter) : bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
    return currentCounter.compare(newCounter);
  }
});

// node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TopologyDescription = undefined;
  var bson_1 = require_bson2();
  var WIRE_CONSTANTS = require_constants2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var common_1 = require_common2();
  var server_description_1 = require_server_description();
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
  var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
  var NON_PRIMARY_RS_MEMBERS = new Set([
    common_1.ServerType.RSSecondary,
    common_1.ServerType.RSArbiter,
    common_1.ServerType.RSOther
  ]);

  class TopologyDescription {
    constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
      options = options ?? {};
      this.type = topologyType ?? common_1.TopologyType.Unknown;
      this.servers = serverDescriptions ?? new Map;
      this.stale = false;
      this.compatible = true;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;
      this.localThresholdMS = options.localThresholdMS ?? 15;
      this.setName = setName ?? null;
      this.maxElectionId = maxElectionId ?? null;
      this.maxSetVersion = maxSetVersion ?? null;
      this.commonWireVersion = commonWireVersion ?? 0;
      for (const serverDescription of this.servers.values()) {
        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
          continue;
        }
        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        }
        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
          break;
        }
      }
      this.logicalSessionTimeoutMinutes = null;
      for (const [, server] of this.servers) {
        if (server.isReadable) {
          if (server.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = null;
            break;
          }
          if (this.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
            continue;
          }
          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
        }
      }
    }
    updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
      const incomingHostnames = ev.hostnames();
      const currentHostnames = new Set(this.servers.keys());
      const hostnamesToAdd = new Set(incomingHostnames);
      const hostnamesToRemove = new Set;
      for (const hostname of currentHostnames) {
        hostnamesToAdd.delete(hostname);
        if (!incomingHostnames.has(hostname)) {
          hostnamesToRemove.add(hostname);
        }
      }
      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
        return this;
      }
      const serverDescriptions = new Map(this.servers);
      for (const removedHost of hostnamesToRemove) {
        serverDescriptions.delete(removedHost);
      }
      if (hostnamesToAdd.size > 0) {
        if (srvMaxHosts === 0) {
          for (const hostToAdd of hostnamesToAdd) {
            serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
          }
        } else if (serverDescriptions.size < srvMaxHosts) {
          const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
          for (const selectedHostToAdd of selectedHosts) {
            serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
          }
        }
      }
      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    update(serverDescription) {
      const address = serverDescription.address;
      let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
      const serverType = serverDescription.type;
      const serverDescriptions = new Map(this.servers);
      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }
      if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
        if (topologyType === common_1.TopologyType.Single) {
          serverDescription = new server_description_1.ServerDescription(address);
        } else {
          serverDescriptions.delete(address);
        }
      }
      serverDescriptions.set(address, serverDescription);
      if (topologyType === common_1.TopologyType.Single) {
        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      if (topologyType === common_1.TopologyType.Unknown) {
        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions.delete(address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }
      if (topologyType === common_1.TopologyType.Sharded) {
        if (!MONGOS_OR_UNKNOWN.has(serverType)) {
          serverDescriptions.delete(address);
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
        }
        if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
          topologyType = result[0];
          setName = result[1];
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }
      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    get error() {
      const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }
      return null;
    }
    get hasKnownServers() {
      return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
    }
    get hasDataBearingServers() {
      return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
    }
    hasServer(address) {
      return this.servers.has(address);
    }
    toJSON() {
      return bson_1.EJSON.serialize(this);
    }
  }
  exports.TopologyDescription = TopologyDescription;
  function topologyTypeForServerType(serverType) {
    switch (serverType) {
      case common_1.ServerType.Standalone:
        return common_1.TopologyType.Single;
      case common_1.ServerType.Mongos:
        return common_1.TopologyType.Sharded;
      case common_1.ServerType.RSPrimary:
        return common_1.TopologyType.ReplicaSetWithPrimary;
      case common_1.ServerType.RSOther:
      case common_1.ServerType.RSSecondary:
        return common_1.TopologyType.ReplicaSetNoPrimary;
      default:
        return common_1.TopologyType.Unknown;
    }
  }
  function updateRsFromPrimary(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
    const setVersionElectionIdMismatch = (serverDescription2, maxSetVersion2, maxElectionId2) => {
      return `primary marked stale due to electionId/setVersion mismatch:` + ` server setVersion: ${serverDescription2.setVersion},` + ` server electionId: ${serverDescription2.electionId},` + ` topology setVersion: ${maxSetVersion2},` + ` topology electionId: ${maxElectionId2}`;
    };
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    if (serverDescription.maxWireVersion >= 17) {
      const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
      const maxElectionIdIsEqual = electionIdComparison === 0;
      const maxElectionIdIsLess = electionIdComparison === -1;
      const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
      if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
        maxElectionId = serverDescription.electionId;
        maxSetVersion = serverDescription.setVersion;
      } else {
        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, undefined, {
          error: new error_1.MongoStalePrimaryError(setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId))
        }));
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
    } else {
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, undefined, {
              error: new error_1.MongoStalePrimaryError(setVersionElectionIdMismatch(serverDescription, maxSetVersion, maxElectionId))
            }));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
    }
    for (const [address, server] of serverDescriptions) {
      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address, undefined, {
          error: new error_1.MongoStalePrimaryError("primary marked stale due to discovery of newer primary")
        }));
        break;
      }
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    const currentAddresses = Array.from(serverDescriptions.keys());
    const responseAddresses = serverDescription.allHosts;
    currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
      serverDescriptions.delete(address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }
  function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
    if (setName == null) {
      throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
    }
    if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
  }
  function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
    setName = setName ?? serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [topologyType, setName];
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return [topologyType, setName];
  }
  function checkHasPrimary(serverDescriptions) {
    for (const serverDescription of serverDescriptions.values()) {
      if (serverDescription.type === common_1.ServerType.RSPrimary) {
        return common_1.TopologyType.ReplicaSetWithPrimary;
      }
    }
    return common_1.TopologyType.ReplicaSetNoPrimary;
  }
});

// node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getReadPreference = getReadPreference;
  exports.isSharded = isSharded;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common2();
  var topology_description_1 = require_topology_description();
  function getReadPreference(options) {
    let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;
    if (typeof readPreference === "string") {
      readPreference = read_preference_1.ReadPreference.fromString(readPreference);
    }
    if (!(readPreference instanceof read_preference_1.ReadPreference)) {
      throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
    }
    return readPreference;
  }
  function isSharded(topologyOrServer) {
    if (topologyOrServer == null) {
      return false;
    }
    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
      return true;
    }
    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
      const servers = Array.from(topologyOrServer.description.servers.values());
      return servers.some((server) => server.type === common_1.ServerType.Mongos);
    }
    return false;
  }
});

// node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transaction = exports.TxnState = undefined;
  exports.isTransactionCommand = isTransactionCommand;
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var write_concern_1 = require_write_concern();
  exports.TxnState = Object.freeze({
    NO_TRANSACTION: "NO_TRANSACTION",
    STARTING_TRANSACTION: "STARTING_TRANSACTION",
    TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
    TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
    TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
    TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
  });
  var stateMachine = {
    [exports.TxnState.NO_TRANSACTION]: [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
    [exports.TxnState.STARTING_TRANSACTION]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_IN_PROGRESS]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_COMMITTED]: [
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.STARTING_TRANSACTION,
      exports.TxnState.NO_TRANSACTION
    ],
    [exports.TxnState.TRANSACTION_ABORTED]: [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
    [exports.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.NO_TRANSACTION
    ]
  };
  var ACTIVE_STATES = new Set([
    exports.TxnState.STARTING_TRANSACTION,
    exports.TxnState.TRANSACTION_IN_PROGRESS
  ]);
  var COMMITTED_STATES = new Set([
    exports.TxnState.TRANSACTION_COMMITTED,
    exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
    exports.TxnState.TRANSACTION_ABORTED
  ]);

  class Transaction {
    constructor(options) {
      options = options ?? {};
      this.state = exports.TxnState.NO_TRANSACTION;
      this.options = {};
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        if (writeConcern.w === 0) {
          throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
        }
        this.options.writeConcern = writeConcern;
      }
      if (options.readConcern) {
        this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      }
      if (options.readPreference) {
        this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
      }
      if (options.maxCommitTimeMS) {
        this.options.maxTimeMS = options.maxCommitTimeMS;
      }
      this._pinnedServer = undefined;
      this._recoveryToken = undefined;
    }
    get server() {
      return this._pinnedServer;
    }
    get recoveryToken() {
      return this._recoveryToken;
    }
    get isPinned() {
      return !!this.server;
    }
    get isStarting() {
      return this.state === exports.TxnState.STARTING_TRANSACTION;
    }
    get isActive() {
      return ACTIVE_STATES.has(this.state);
    }
    get isCommitted() {
      return COMMITTED_STATES.has(this.state);
    }
    transition(nextState) {
      const nextStates = stateMachine[this.state];
      if (nextStates && nextStates.includes(nextState)) {
        this.state = nextState;
        if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
          this.unpinServer();
        }
        return;
      }
      throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
    }
    pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    unpinServer() {
      this._pinnedServer = undefined;
    }
  }
  exports.Transaction = Transaction;
  function isTransactionCommand(command) {
    return !!(command.commitTransaction || command.abortTransaction);
  }
});

// node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerSessionPool = exports.ServerSession = exports.ClientSession = undefined;
  exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
  exports.applySession = applySession;
  exports.updateSessionFromResponse = updateSessionFromResponse;
  var bson_1 = require_bson2();
  var metrics_1 = require_metrics();
  var shared_1 = require_shared();
  var constants_1 = require_constants();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var resource_management_1 = require_resource_management();
  var common_1 = require_common2();
  var timeout_1 = require_timeout();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var minWireVersionForShardedTransactions = 8;

  class ClientSession extends mongo_types_1.TypedEventEmitter {
    constructor(client, sessionPool, options, clientOptions) {
      super();
      this.timeoutContext = null;
      this.on("error", utils_1.noop);
      if (client == null) {
        throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
      }
      if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
        throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
      }
      options = options ?? {};
      this.snapshotEnabled = options.snapshot === true;
      if (options.causalConsistency === true && this.snapshotEnabled) {
        throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
      }
      this.client = client;
      this.sessionPool = sessionPool;
      this.hasEnded = false;
      this.clientOptions = clientOptions;
      this.timeoutMS = options.defaultTimeoutMS ?? client.s.options?.timeoutMS;
      this.explicit = !!options.explicit;
      this._serverSession = this.explicit ? this.sessionPool.acquire() : null;
      this.txnNumberIncrement = 0;
      const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
      this.supports = {
        causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue
      };
      this.clusterTime = options.initialClusterTime;
      this.operationTime = undefined;
      this.owner = options.owner;
      this.defaultTransactionOptions = { ...options.defaultTransactionOptions };
      this.transaction = new transactions_1.Transaction;
    }
    get id() {
      return this.serverSession?.id;
    }
    get serverSession() {
      let serverSession = this._serverSession;
      if (serverSession == null) {
        if (this.explicit) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
        }
        if (this.hasEnded) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
        }
        serverSession = this.sessionPool.acquire();
        this._serverSession = serverSession;
      }
      return serverSession;
    }
    get loadBalanced() {
      return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
    }
    pin(conn) {
      if (this.pinnedConnection) {
        throw TypeError("Cannot pin multiple connections to the same session");
      }
      this.pinnedConnection = conn;
      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    unpin(options) {
      if (this.loadBalanced) {
        return maybeClearPinnedConnection(this, options);
      }
      this.transaction.unpinServer();
    }
    get isPinned() {
      return this.loadBalanced ? !!this.pinnedConnection : this.transaction.isPinned;
    }
    async endSession(options) {
      try {
        if (this.inTransaction()) {
          await this.abortTransaction({ ...options, throwTimeout: true });
        }
      } catch (error) {
        if (error.name === "MongoOperationTimeoutError")
          throw error;
        (0, utils_1.squashError)(error);
      } finally {
        if (!this.hasEnded) {
          const serverSession = this.serverSession;
          if (serverSession != null) {
            this.sessionPool.release(serverSession);
            this._serverSession = new ServerSession(serverSession);
          }
          this.hasEnded = true;
          this.emit("ended", this);
        }
        maybeClearPinnedConnection(this, { force: true, ...options });
      }
    }
    async asyncDispose() {
      await this.endSession({ force: true });
    }
    advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }
      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    advanceClusterTime(clusterTime) {
      if (!clusterTime || typeof clusterTime !== "object") {
        throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
      }
      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
        throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
      }
      if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== "Binary" || typeof clusterTime.signature.keyId !== "bigint" && typeof clusterTime.signature.keyId !== "number" && clusterTime.signature.keyId?._bsontype !== "Long") {
        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
      }
      (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }
      if (this.id == null || session.id == null) {
        return false;
      }
      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
    }
    incrementTransactionNumber() {
      this.txnNumberIncrement += 1;
    }
    inTransaction() {
      return this.transaction.isActive;
    }
    startTransaction(options) {
      if (this.snapshotEnabled) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
      }
      if (this.inTransaction()) {
        throw new error_1.MongoTransactionError("Transaction already in progress");
      }
      if (this.isPinned && this.transaction.isCommitted) {
        this.unpin();
      }
      const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
      }
      this.commitAttempted = false;
      this.incrementTransactionNumber();
      this.transaction = new transactions_1.Transaction({
        readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,
        writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,
        readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,
        maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
      });
      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
    async commitTransaction(options) {
      if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
        throw new error_1.MongoTransactionError("No transaction started");
      }
      if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
        return;
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
        throw new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction");
      }
      const command = { commitTransaction: 1 };
      const timeoutMS = typeof options?.timeoutMS === "number" ? options.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
      const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
      if (wc != null) {
        if (timeoutMS == null && this.timeoutContext == null) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
        } else {
          const wcKeys = Object.keys(wc);
          if (wcKeys.length > 2 || !wcKeys.includes("wtimeoutMS") && !wcKeys.includes("wTimeoutMS"))
            write_concern_1.WriteConcern.apply(command, { ...wc, wtimeoutMS: undefined });
        }
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.commitAttempted) {
        if (timeoutMS == null && this.timeoutContext == null) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
        } else {
          write_concern_1.WriteConcern.apply(command, { w: "majority", ...wc, wtimeoutMS: undefined });
        }
      }
      if (typeof this.transaction.options.maxTimeMS === "number") {
        command.maxTimeMS = this.transaction.options.maxTimeMS;
      }
      if (this.transaction.recoveryToken) {
        command.recoveryToken = this.transaction.recoveryToken;
      }
      const operation = new run_command_1.RunAdminCommandOperation(command, {
        session: this,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      });
      const timeoutContext = this.timeoutContext ?? (typeof timeoutMS === "number" ? timeout_1.TimeoutContext.create({
        serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
        socketTimeoutMS: this.clientOptions.socketTimeoutMS,
        timeoutMS
      }) : null);
      try {
        await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
        this.commitAttempted = undefined;
        return;
      } catch (firstCommitError) {
        this.commitAttempted = true;
        if (firstCommitError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstCommitError)) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
          this.unpin({ force: true });
          try {
            await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunAdminCommandOperation(command, {
              session: this,
              readPreference: read_preference_1.ReadPreference.primary,
              bypassPinningCheck: true
            }), timeoutContext);
            return;
          } catch (retryCommitError) {
            if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {
              retryCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
            }
            if (shouldUnpinAfterCommitError(retryCommitError)) {
              this.unpin({ error: retryCommitError });
            }
            throw retryCommitError;
          }
        }
        if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {
          firstCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
        }
        if (shouldUnpinAfterCommitError(firstCommitError)) {
          this.unpin({ error: firstCommitError });
        }
        throw firstCommitError;
      } finally {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
      }
    }
    async abortTransaction(options) {
      if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
        throw new error_1.MongoTransactionError("No transaction started");
      }
      if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        return;
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
        throw new error_1.MongoTransactionError("Cannot call abortTransaction twice");
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        throw new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction");
      }
      const command = { abortTransaction: 1 };
      const timeoutMS = typeof options?.timeoutMS === "number" ? options.timeoutMS : this.timeoutContext?.csotEnabled() ? this.timeoutContext.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
      const timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
        timeoutMS,
        serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
        socketTimeoutMS: this.clientOptions.socketTimeoutMS
      }) : null;
      const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
      if (wc != null && timeoutMS == null) {
        write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
      }
      if (this.transaction.recoveryToken) {
        command.recoveryToken = this.transaction.recoveryToken;
      }
      const operation = new run_command_1.RunAdminCommandOperation(command, {
        session: this,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      });
      try {
        await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
        this.unpin();
        return;
      } catch (firstAbortError) {
        this.unpin();
        if (firstAbortError.name === "MongoRuntimeError")
          throw firstAbortError;
        if (options?.throwTimeout && firstAbortError.name === "MongoOperationTimeoutError") {
          throw firstAbortError;
        }
        if (firstAbortError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAbortError)) {
          try {
            await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
            return;
          } catch (secondAbortError) {
            if (secondAbortError.name === "MongoRuntimeError")
              throw secondAbortError;
            if (options?.throwTimeout && secondAbortError.name === "MongoOperationTimeoutError") {
              throw secondAbortError;
            }
          }
        }
      } finally {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        if (this.loadBalanced) {
          maybeClearPinnedConnection(this, { force: false });
        }
      }
    }
    toBSON() {
      throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
    }
    async withTransaction(fn, options) {
      const MAX_TIMEOUT = 120000;
      const timeoutMS = options?.timeoutMS ?? this.timeoutMS ?? null;
      this.timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
        timeoutMS,
        serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
        socketTimeoutMS: this.clientOptions.socketTimeoutMS
      }) : null;
      const startTime = this.timeoutContext?.csotEnabled() ? this.timeoutContext.start : (0, utils_1.now)();
      let committed = false;
      let result;
      try {
        while (!committed) {
          this.startTransaction(options);
          try {
            const promise = fn(this);
            if (!(0, utils_1.isPromiseLike)(promise)) {
              throw new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise");
            }
            result = await promise;
            if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
              return result;
            }
          } catch (fnError) {
            if (!(fnError instanceof error_1.MongoError) || fnError instanceof error_1.MongoInvalidArgumentError) {
              await this.abortTransaction();
              throw fnError;
            }
            if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS) {
              await this.abortTransaction();
            }
            if (fnError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
              continue;
            }
            throw fnError;
          }
          while (!committed) {
            try {
              await this.commitTransaction();
              committed = true;
            } catch (commitError) {
              if (!isMaxTimeMSExpiredError(commitError) && commitError.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                continue;
              }
              if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                break;
              }
              throw commitError;
            }
          }
        }
        return result;
      } finally {
        this.timeoutContext = null;
      }
    }
  }
  exports.ClientSession = ClientSession;
  (0, resource_management_1.configureResourceManagement)(ClientSession.prototype);
  var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    "CannotSatisfyWriteConcern",
    "UnknownReplWriteConcern",
    "UnsatisfiableWriteConcern"
  ]);
  function shouldUnpinAfterCommitError(commitError) {
    if (commitError instanceof error_1.MongoError) {
      if ((0, error_1.isRetryableWriteError)(commitError) || commitError instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(commitError)) {
        if (isUnknownTransactionCommitResult(commitError)) {
          return true;
        }
      } else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return true;
      }
    }
    return false;
  }
  function shouldAddUnknownTransactionCommitResultLabel(commitError) {
    let ok = (0, error_1.isRetryableWriteError)(commitError);
    ok ||= commitError instanceof error_1.MongoWriteConcernError;
    ok ||= isMaxTimeMSExpiredError(commitError);
    ok &&= isUnknownTransactionCommitResult(commitError);
    return ok;
  }
  function isUnknownTransactionCommitResult(err2) {
    const isNonDeterministicWriteConcernError = err2 instanceof error_1.MongoServerError && err2.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err2.codeName);
    return isMaxTimeMSExpiredError(err2) || !isNonDeterministicWriteConcernError && err2.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err2.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
  }
  function maybeClearPinnedConnection(session, options) {
    const conn = session.pinnedConnection;
    const error = options?.error;
    if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
      return;
    }
    const topology = session.client.topology;
    if (conn && topology != null) {
      const servers = Array.from(topology.s.servers.values());
      const loadBalancer = servers[0];
      if (options?.error == null || options?.force) {
        loadBalancer.pool.checkIn(conn);
        session.pinnedConnection = undefined;
        conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
        if (options?.forceClear) {
          loadBalancer.pool.clear({ serviceId: conn.serviceId });
        }
      }
    }
  }
  function isMaxTimeMSExpiredError(err2) {
    if (err2 == null || !(err2 instanceof error_1.MongoServerError)) {
      return false;
    }
    return err2.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err2.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
  }

  class ServerSession {
    constructor(cloned) {
      if (cloned != null) {
        const idBytes = Buffer.allocUnsafe(16);
        idBytes.set(cloned.id.id.buffer);
        this.id = { id: new bson_1.Binary(idBytes, cloned.id.id.sub_type) };
        this.lastUse = cloned.lastUse;
        this.txnNumber = cloned.txnNumber;
        this.isDirty = cloned.isDirty;
        return;
      }
      this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
      this.lastUse = (0, utils_1.now)();
      this.txnNumber = 0;
      this.isDirty = false;
    }
    hasTimedOut(sessionTimeoutMinutes) {
      const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
  }
  exports.ServerSession = ServerSession;

  class ServerSessionPool {
    constructor(client) {
      if (client == null) {
        throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
      }
      this.client = client;
      this.sessions = new utils_1.List;
    }
    acquire() {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      let session = null;
      while (this.sessions.length > 0) {
        const potentialSession = this.sessions.shift();
        if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
          session = potentialSession;
          break;
        }
      }
      if (session == null) {
        session = new ServerSession;
      }
      return session;
    }
    release(session) {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
        this.sessions.unshift(session);
      }
      if (!sessionTimeoutMinutes) {
        return;
      }
      this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        }
        this.sessions.unshift(session);
      }
    }
  }
  exports.ServerSessionPool = ServerSessionPool;
  function applySession(session, command, options) {
    if (session.hasEnded) {
      return new error_1.MongoExpiredSessionError;
    }
    const serverSession = session.serverSession;
    if (serverSession == null) {
      return new error_1.MongoRuntimeError("Unable to acquire server session");
    }
    if (options.writeConcern?.w === 0) {
      if (session && session.explicit) {
        return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
      }
      return;
    }
    serverSession.lastUse = (0, utils_1.now)();
    command.lsid = serverSession.id;
    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
    const isRetryableWrite = !!options.willRetryWrite;
    if (isRetryableWrite || inTxnOrTxnCommand) {
      serverSession.txnNumber += session.txnNumberIncrement;
      session.txnNumberIncrement = 0;
      command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTxnOrTxnCommand) {
      if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
      }
      if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      } else if (session.snapshotEnabled) {
        command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
        if (session.snapshotTime != null) {
          Object.assign(command.readConcern, { atClusterTime: session.snapshotTime });
        }
      }
      return;
    }
    command.autocommit = false;
    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
      command.startTransaction = true;
      const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
      if (readConcern) {
        command.readConcern = readConcern;
      }
      if (session.supports.causalConsistency && session.operationTime) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      }
    }
    return;
  }
  function updateSessionFromResponse(session, document2) {
    if (document2.$clusterTime) {
      (0, common_1._advanceClusterTime)(session, document2.$clusterTime);
    }
    if (document2.operationTime && session && session.supports.causalConsistency) {
      session.advanceOperationTime(document2.operationTime);
    }
    if (document2.recoveryToken && session && session.inTransaction()) {
      session.transaction._recoveryToken = document2.recoveryToken;
    }
    if (session?.snapshotEnabled && session.snapshotTime == null) {
      const atClusterTime = document2.atClusterTime;
      if (atClusterTime) {
        session.snapshotTime = atClusterTime;
      }
    }
  }
});

// node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = undefined;
  var constants_1 = require_constants();
  var utils_1 = require_utils();
  var commands_1 = require_commands();

  class CommandStartedEvent {
    constructor(connection, command, serverConnectionId) {
      this.name = constants_1.COMMAND_STARTED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      if (exports.SENSITIVE_COMMANDS.has(commandName)) {
        this.commandObj = {};
        this.commandObj[commandName] = true;
      }
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.databaseName = command.databaseName;
      this.commandName = commandName;
      this.command = maybeRedact(commandName, cmd, cmd);
      this.serverConnectionId = serverConnectionId;
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandStartedEvent = CommandStartedEvent;

  class CommandSucceededEvent {
    constructor(connection, command, reply, started, serverConnectionId) {
      this.name = constants_1.COMMAND_SUCCEEDED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.reply = maybeRedact(commandName, cmd, extractReply(reply));
      this.serverConnectionId = serverConnectionId;
      this.databaseName = command.databaseName;
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandSucceededEvent = CommandSucceededEvent;

  class CommandFailedEvent {
    constructor(connection, command, error, started, serverConnectionId) {
      this.name = constants_1.COMMAND_FAILED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.failure = maybeRedact(commandName, cmd, error);
      this.serverConnectionId = serverConnectionId;
      this.databaseName = command.databaseName;
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandFailedEvent = CommandFailedEvent;
  exports.SENSITIVE_COMMANDS = new Set([
    "authenticate",
    "saslStart",
    "saslContinue",
    "getnonce",
    "createUser",
    "updateUser",
    "copydbgetnonce",
    "copydbsaslstart",
    "copydb"
  ]);
  var HELLO_COMMANDS = new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
  var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
  var collectionName = (command) => command.ns.split(".")[1];
  var maybeRedact = (commandName, commandDoc, result) => exports.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
  var LEGACY_FIND_QUERY_MAP = {
    $query: "filter",
    $orderby: "sort",
    $hint: "hint",
    $comment: "comment",
    $maxScan: "maxScan",
    $max: "max",
    $min: "min",
    $returnKey: "returnKey",
    $showDiskLoc: "showRecordId",
    $maxTimeMS: "maxTimeMS",
    $snapshot: "snapshot"
  };
  var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: "skip",
    numberToReturn: "batchSize",
    returnFieldSelector: "projection"
  };
  function extractCommand(command) {
    if (command instanceof commands_1.OpMsgRequest) {
      const cmd = { ...command.command };
      if (cmd.ops instanceof commands_1.DocumentSequence) {
        cmd.ops = cmd.ops.documents;
      }
      if (cmd.nsInfo instanceof commands_1.DocumentSequence) {
        cmd.nsInfo = cmd.nsInfo.documents;
      }
      return cmd;
    }
    if (command.query?.$query) {
      let result;
      if (command.ns === "admin.$cmd") {
        result = Object.assign({}, command.query.$query);
      } else {
        result = { find: collectionName(command) };
        Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
          if (command.query[key] != null) {
            result[LEGACY_FIND_QUERY_MAP[key]] = { ...command.query[key] };
          }
        });
      }
      Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
        const legacyKey = key;
        if (command[legacyKey] != null) {
          result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = command[legacyKey];
        }
      });
      return result;
    }
    let clonedQuery = {};
    const clonedCommand = { ...command };
    if (command.query) {
      clonedQuery = { ...command.query };
      clonedCommand.query = clonedQuery;
    }
    return command.query ? clonedQuery : clonedCommand;
  }
  function extractReply(reply) {
    if (!reply) {
      return reply;
    }
    return reply.result ? reply.result : reply;
  }
  function extractConnectionDetails(connection) {
    let connectionId;
    if ("id" in connection) {
      connectionId = connection.id;
    }
    return {
      address: connection.address,
      serviceId: connection.serviceId,
      connectionId
    };
  }
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamDescription = undefined;
  var bson_1 = require_bson2();
  var common_1 = require_common2();
  var server_description_1 = require_server_description();
  var RESPONSE_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "logicalSessionTimeoutMinutes"
  ];

  class StreamDescription {
    constructor(address, options) {
      this.hello = null;
      this.address = address;
      this.type = common_1.ServerType.Unknown;
      this.minWireVersion = undefined;
      this.maxWireVersion = undefined;
      this.maxBsonObjectSize = 16777216;
      this.maxMessageSizeBytes = 48000000;
      this.maxWriteBatchSize = 1e5;
      this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;
      this.loadBalanced = !!options?.loadBalanced;
      this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
      this.serverConnectionId = null;
    }
    receiveResponse(response) {
      if (response == null) {
        return;
      }
      this.hello = response;
      this.type = (0, server_description_1.parseServerType)(response);
      if ("connectionId" in response) {
        this.serverConnectionId = this.parseServerConnectionID(response.connectionId);
      } else {
        this.serverConnectionId = null;
      }
      for (const field of RESPONSE_FIELDS) {
        if (response[field] != null) {
          this[field] = response[field];
        }
        if ("__nodejs_mock_server__" in response) {
          this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
        }
      }
      if (response.compression) {
        this.compressor = this.compressors.filter((c) => response.compression?.includes(c))[0];
      }
    }
    parseServerConnectionID(serverConnectionId) {
      return bson_1.Long.isLong(serverConnectionId) ? serverConnectionId.toBigInt() : BigInt(serverConnectionId);
    }
  }
  exports.StreamDescription = StreamDescription;
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_data.js
var require_on_data = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onData = onData;
  var utils_1 = require_utils();
  function onData(emitter, { timeoutContext, signal }) {
    signal?.throwIfAborted();
    const unconsumedEvents = new utils_1.List;
    const unconsumedPromises = new utils_1.List;
    let error = null;
    let finished = false;
    const iterator = {
      next() {
        const value = unconsumedEvents.shift();
        if (value != null) {
          return Promise.resolve({ value, done: false });
        }
        if (error != null) {
          const p = Promise.reject(error);
          error = null;
          return p;
        }
        if (finished)
          return closeHandler();
        const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
        unconsumedPromises.push({ resolve, reject });
        return promise;
      },
      return() {
        return closeHandler();
      },
      throw(err2) {
        errorHandler(err2);
        return Promise.resolve({ value: undefined, done: true });
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      async[Symbol.asyncDispose]() {
        await closeHandler();
      }
    };
    emitter.on("data", eventHandler);
    emitter.on("error", errorHandler);
    const abortListener = (0, utils_1.addAbortListener)(signal, function() {
      errorHandler(this.reason);
    });
    const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;
    timeoutForSocketRead?.throwIfExpired();
    timeoutForSocketRead?.then(undefined, errorHandler);
    return iterator;
    function eventHandler(value) {
      const promise = unconsumedPromises.shift();
      if (promise != null)
        promise.resolve({ value, done: false });
      else
        unconsumedEvents.push(value);
    }
    function errorHandler(err2) {
      const promise = unconsumedPromises.shift();
      if (promise != null)
        promise.reject(err2);
      else
        error = err2;
      closeHandler();
    }
    function closeHandler() {
      emitter.off("data", eventHandler);
      emitter.off("error", errorHandler);
      abortListener?.[utils_1.kDispose]();
      finished = true;
      timeoutForSocketRead?.clear();
      const doneResult = { value: undefined, done: finished };
      for (const promise of unconsumedPromises) {
        promise.resolve(doneResult);
      }
      return Promise.resolve(doneResult);
    }
  }
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CryptoConnection = exports.SizedMessageTransform = exports.Connection = undefined;
  exports.hasSessionSupport = hasSessionSupport;
  var stream_1 = __require("stream");
  var timers_1 = __require("timers");
  var bson_1 = require_bson2();
  var constants_1 = require_constants();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common2();
  var sessions_1 = require_sessions();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var command_monitoring_events_1 = require_command_monitoring_events();
  var commands_1 = require_commands();
  var stream_description_1 = require_stream_description();
  var compression_1 = require_compression();
  var on_data_1 = require_on_data();
  var responses_1 = require_responses();
  var shared_1 = require_shared();
  function hasSessionSupport(conn) {
    const description = conn.description;
    return description.logicalSessionTimeoutMinutes != null;
  }
  function streamIdentifier(stream, options) {
    if (options.proxyHost) {
      return options.hostAddress.toString();
    }
    const { remoteAddress, remotePort } = stream;
    if (typeof remoteAddress === "string" && typeof remotePort === "number") {
      return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
    }
    return (0, utils_1.uuidV4)().toString("hex");
  }

  class Connection extends mongo_types_1.TypedEventEmitter {
    constructor(stream, options) {
      super();
      this.lastHelloMS = -1;
      this.helloOk = false;
      this.delayedTimeoutId = null;
      this.closed = false;
      this.clusterTime = null;
      this.error = null;
      this.dataEvents = null;
      this.on("error", utils_1.noop);
      this.socket = stream;
      this.id = options.id;
      this.address = streamIdentifier(stream, options);
      this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
      this.monitorCommands = options.monitorCommands;
      this.serverApi = options.serverApi;
      this.mongoLogger = options.mongoLogger;
      this.established = false;
      this.description = new stream_description_1.StreamDescription(this.address, options);
      this.generation = options.generation;
      this.lastUseTime = (0, utils_1.now)();
      this.messageStream = this.socket.on("error", this.onSocketError.bind(this)).pipe(new SizedMessageTransform({ connection: this })).on("error", this.onTransformError.bind(this));
      this.socket.on("close", this.onClose.bind(this));
      this.socket.on("timeout", this.onTimeout.bind(this));
      this.messageStream.pause();
    }
    get hello() {
      return this.description.hello;
    }
    set hello(response) {
      this.description.receiveResponse(response);
      Object.freeze(this.description);
    }
    get serviceId() {
      return this.hello?.serviceId;
    }
    get loadBalanced() {
      return this.description.loadBalanced;
    }
    get idleTime() {
      return (0, utils_1.calculateDurationInMs)(this.lastUseTime);
    }
    get hasSessionSupport() {
      return this.description.logicalSessionTimeoutMinutes != null;
    }
    get supportsOpMsg() {
      return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;
    }
    get shouldEmitAndLogCommand() {
      return (this.monitorCommands || this.established && !this.authContext?.reauthenticating && this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG)) ?? false;
    }
    markAvailable() {
      this.lastUseTime = (0, utils_1.now)();
    }
    onSocketError(cause) {
      this.onError(new error_1.MongoNetworkError(cause.message, { cause }));
    }
    onTransformError(error) {
      this.onError(error);
    }
    onError(error) {
      this.cleanup(error);
    }
    onClose() {
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(new error_1.MongoNetworkError(message));
    }
    onTimeout() {
      this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {
        const message = `connection ${this.id} to ${this.address} timed out`;
        const beforeHandshake = this.hello == null;
        this.cleanup(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
      }, 1).unref();
    }
    destroy() {
      if (this.closed) {
        return;
      }
      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(new error_1.MongoNetworkError(message));
    }
    cleanup(error) {
      if (this.closed) {
        return;
      }
      this.socket.destroy();
      this.error = error;
      this.dataEvents?.throw(error).then(undefined, utils_1.squashError);
      this.closed = true;
      this.emit(Connection.CLOSE);
    }
    prepareCommand(db, command, options) {
      let cmd = { ...command };
      const readPreference = (0, shared_1.getReadPreference)(options);
      const session = options?.session;
      let clusterTime = this.clusterTime;
      if (this.serverApi) {
        const { version, strict, deprecationErrors } = this.serverApi;
        cmd.apiVersion = version;
        if (strict != null)
          cmd.apiStrict = strict;
        if (deprecationErrors != null)
          cmd.apiDeprecationErrors = deprecationErrors;
      }
      if (this.hasSessionSupport && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }
        const sessionError = (0, sessions_1.applySession)(session, cmd, options);
        if (sessionError)
          throw sessionError;
      } else if (session?.explicit) {
        throw new error_1.MongoCompatibilityError("Current topology does not support sessions");
      }
      if (clusterTime) {
        cmd.$clusterTime = clusterTime;
      }
      if (this.description.type !== common_1.ServerType.Standalone) {
        if (!(0, shared_1.isSharded)(this) && !this.description.loadBalanced && this.supportsOpMsg && options.directConnection === true && readPreference?.mode === "primary") {
          cmd.$readPreference = read_preference_1.ReadPreference.primaryPreferred.toJSON();
        } else if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference?.mode !== "primary") {
          cmd = {
            $query: cmd,
            $readPreference: readPreference.toJSON()
          };
        } else if (readPreference?.mode !== "primary") {
          cmd.$readPreference = readPreference.toJSON();
        }
      }
      const commandOptions = {
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        secondaryOk: readPreference.secondaryOk(),
        ...options
      };
      options.timeoutContext?.addMaxTimeMSToCommand(cmd, options);
      const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(db, cmd, commandOptions) : new commands_1.OpQueryRequest(db, cmd, commandOptions);
      return message;
    }
    async* sendWire(message, options, responseType) {
      this.throwIfAborted();
      const timeout = options.socketTimeoutMS ?? options?.timeoutContext?.getSocketTimeoutMS() ?? this.socketTimeoutMS;
      this.socket.setTimeout(timeout);
      try {
        await this.writeCommand(message, {
          agreedCompressor: this.description.compressor ?? "none",
          zlibCompressionLevel: this.description.zlibCompressionLevel,
          timeoutContext: options.timeoutContext,
          signal: options.signal
        });
        if (options.noResponse || message.moreToCome) {
          yield responses_1.MongoDBResponse.empty;
          return;
        }
        this.throwIfAborted();
        if (options.timeoutContext?.csotEnabled() && options.timeoutContext.minRoundTripTime != null && options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {
          throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
        }
        for await (const response of this.readMany(options)) {
          this.socket.setTimeout(0);
          const bson = response.parse();
          const document2 = (responseType ?? responses_1.MongoDBResponse).make(bson);
          yield document2;
          this.throwIfAborted();
          this.socket.setTimeout(timeout);
        }
      } finally {
        this.socket.setTimeout(0);
      }
    }
    async* sendCommand(ns, command, options, responseType) {
      options?.signal?.throwIfAborted();
      const message = this.prepareCommand(ns.db, command, options);
      let started = 0;
      if (this.shouldEmitAndLogCommand) {
        started = (0, utils_1.now)();
        this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));
      }
      const bsonOptions = options.documentsReturnedIn == null || !options.raw ? options : {
        ...options,
        raw: false,
        fieldsAsRaw: { [options.documentsReturnedIn]: true }
      };
      let document2 = undefined;
      let object = undefined;
      try {
        this.throwIfAborted();
        for await (document2 of this.sendWire(message, options, responseType)) {
          object = undefined;
          if (options.session != null) {
            (0, sessions_1.updateSessionFromResponse)(options.session, document2);
          }
          if (document2.$clusterTime) {
            this.clusterTime = document2.$clusterTime;
            this.emit(Connection.CLUSTER_TIME_RECEIVED, document2.$clusterTime);
          }
          if (document2.ok === 0) {
            if (options.timeoutContext?.csotEnabled() && document2.isMaxTimeExpiredError) {
              throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                cause: new error_1.MongoServerError(object ??= document2.toObject(bsonOptions))
              });
            }
            throw new error_1.MongoServerError(object ??= document2.toObject(bsonOptions));
          }
          if (this.shouldEmitAndLogCommand) {
            this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse ? undefined : message.moreToCome ? { ok: 1 } : object ??= document2.toObject(bsonOptions), started, this.description.serverConnectionId));
          }
          if (responseType == null) {
            yield object ??= document2.toObject(bsonOptions);
          } else {
            yield document2;
          }
          this.throwIfAborted();
        }
      } catch (error) {
        if (this.shouldEmitAndLogCommand) {
          this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error, started, this.description.serverConnectionId));
        }
        throw error;
      }
    }
    async command(ns, command, options = {}, responseType) {
      this.throwIfAborted();
      options.signal?.throwIfAborted();
      for await (const document2 of this.sendCommand(ns, command, options, responseType)) {
        if (options.timeoutContext?.csotEnabled()) {
          if (responses_1.MongoDBResponse.is(document2)) {
            if (document2.isMaxTimeExpiredError) {
              throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                cause: new error_1.MongoServerError(document2.toObject())
              });
            }
          } else {
            if (Array.isArray(document2?.writeErrors) && document2.writeErrors.some((error) => error?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) || document2?.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) {
              throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                cause: new error_1.MongoServerError(document2)
              });
            }
          }
        }
        return document2;
      }
      throw new error_1.MongoUnexpectedServerResponseError("Unable to get response from server");
    }
    exhaustCommand(ns, command, options, replyListener) {
      const exhaustLoop = async () => {
        this.throwIfAborted();
        for await (const reply of this.sendCommand(ns, command, options)) {
          replyListener(undefined, reply);
          this.throwIfAborted();
        }
        throw new error_1.MongoUnexpectedServerResponseError("Server ended moreToCome unexpectedly");
      };
      exhaustLoop().then(undefined, replyListener);
    }
    throwIfAborted() {
      if (this.error)
        throw this.error;
    }
    async writeCommand(command, options) {
      const finalCommand = options.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
        agreedCompressor: options.agreedCompressor ?? "none",
        zlibCompressionLevel: options.zlibCompressionLevel ?? 0
      });
      const buffer = Buffer.concat(await finalCommand.toBin());
      if (options.timeoutContext?.csotEnabled()) {
        if (options.timeoutContext.minRoundTripTime != null && options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {
          throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
        }
      }
      if (this.socket.write(buffer))
        return;
      const drainEvent = (0, utils_1.once)(this.socket, "drain", options);
      const timeout = options?.timeoutContext?.timeoutForSocketWrite;
      const drained = timeout ? Promise.race([drainEvent, timeout]) : drainEvent;
      try {
        return await drained;
      } catch (writeError) {
        if (timeout_1.TimeoutError.is(writeError)) {
          const timeoutError = new error_1.MongoOperationTimeoutError("Timed out at socket write");
          this.onError(timeoutError);
          throw timeoutError;
        } else if (writeError === options.signal?.reason) {
          this.onError(writeError);
        }
        throw writeError;
      } finally {
        timeout?.clear();
      }
    }
    async* readMany(options) {
      try {
        this.dataEvents = (0, on_data_1.onData)(this.messageStream, options);
        this.messageStream.resume();
        for await (const message of this.dataEvents) {
          const response = await (0, compression_1.decompressResponse)(message);
          yield response;
          if (!response.moreToCome) {
            return;
          }
        }
      } catch (readError) {
        if (timeout_1.TimeoutError.is(readError)) {
          const timeoutError = new error_1.MongoOperationTimeoutError(`Timed out during socket read (${readError.duration}ms)`);
          this.dataEvents = null;
          this.onError(timeoutError);
          throw timeoutError;
        } else if (readError === options.signal?.reason) {
          this.onError(readError);
        }
        throw readError;
      } finally {
        this.dataEvents = null;
        this.messageStream.pause();
      }
    }
  }
  exports.Connection = Connection;
  Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
  Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
  Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
  Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
  Connection.CLOSE = constants_1.CLOSE;
  Connection.PINNED = constants_1.PINNED;
  Connection.UNPINNED = constants_1.UNPINNED;

  class SizedMessageTransform extends stream_1.Transform {
    constructor({ connection }) {
      super({ writableObjectMode: false, readableObjectMode: true });
      this.bufferPool = new utils_1.BufferPool;
      this.connection = connection;
    }
    _transform(chunk, encoding, callback) {
      if (this.connection.delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);
        this.connection.delayedTimeoutId = null;
      }
      this.bufferPool.append(chunk);
      while (this.bufferPool.length) {
        const sizeOfMessage = this.bufferPool.getInt32();
        if (sizeOfMessage == null) {
          break;
        }
        if (sizeOfMessage < 0) {
          return callback(new error_1.MongoParseError(`Message size cannot be negative: ${sizeOfMessage}`));
        }
        if (sizeOfMessage > this.bufferPool.length) {
          break;
        }
        const message = this.bufferPool.read(sizeOfMessage);
        if (!this.push(message)) {
          return callback(new error_1.MongoRuntimeError(`SizedMessageTransform does not support backpressure`));
        }
      }
      callback();
    }
  }
  exports.SizedMessageTransform = SizedMessageTransform;

  class CryptoConnection extends Connection {
    constructor(stream, options) {
      super(stream, options);
      this.autoEncrypter = options.autoEncrypter;
    }
    async command(ns, cmd, options, responseType) {
      const { autoEncrypter } = this;
      if (!autoEncrypter) {
        throw new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption", {
          dependencyName: "n/a"
        });
      }
      const serverWireVersion = (0, utils_1.maxWireVersion)(this);
      if (serverWireVersion === 0) {
        return await super.command(ns, cmd, options, responseType);
      }
      if (serverWireVersion < 8) {
        throw new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2");
      }
      const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
      const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
      const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);
      if (sort != null && (cmd.find || cmd.findAndModify)) {
        encrypted.sort = sort;
      }
      if (indexKeys != null && cmd.createIndexes) {
        for (const [offset, index] of indexKeys.entries()) {
          encrypted.indexes[offset].key = index;
        }
      }
      const encryptedResponse = await super.command(ns, encrypted, options, responseType ?? responses_1.MongoDBResponse);
      const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options);
      const decryptedResponse = responseType?.make(result) ?? (0, bson_1.deserialize)(result, options);
      if (autoEncrypter[constants_1.kDecorateResult]) {
        if (responseType == null) {
          (0, utils_1.decorateDecryptionResult)(decryptedResponse, encryptedResponse.toObject(), true);
        } else if (decryptedResponse instanceof responses_1.CursorResponse) {
          decryptedResponse.encryptedResponse = encryptedResponse;
        }
      }
      return decryptedResponse;
    }
  }
  exports.CryptoConnection = CryptoConnection;
});

// node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = undefined;
  exports.connect = connect;
  exports.makeConnection = makeConnection;
  exports.performInitialHandshake = performInitialHandshake;
  exports.prepareHandshakeDocument = prepareHandshakeDocument;
  exports.makeSocket = makeSocket;
  var net = __require("net");
  var tls = __require("tls");
  var constants_1 = require_constants();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var providers_1 = require_providers();
  var connection_1 = require_connection();
  var constants_2 = require_constants2();
  async function connect(options) {
    let connection = null;
    try {
      const socket = await makeSocket(options);
      connection = makeConnection(options, socket);
      await performInitialHandshake(connection, options);
      return connection;
    } catch (error) {
      connection?.destroy();
      throw error;
    }
  }
  function makeConnection(options, socket) {
    let ConnectionType = options.connectionType ?? connection_1.Connection;
    if (options.autoEncrypter) {
      ConnectionType = connection_1.CryptoConnection;
    }
    return new ConnectionType(socket, options);
  }
  function checkSupportedServer(hello, options) {
    const maxWireVersion = Number(hello.maxWireVersion);
    const minWireVersion = Number(hello.minWireVersion);
    const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
    const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
      if (serverVersionLowEnough) {
        return null;
      }
      const message2 = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message2);
    }
    const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
    return new error_1.MongoCompatibilityError(message);
  }
  async function performInitialHandshake(conn, options) {
    const credentials = options.credentials;
    if (credentials) {
      if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties)) {
        throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
      }
    }
    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
    conn.authContext = authContext;
    const handshakeDoc = await prepareHandshakeDocument(authContext);
    const handshakeOptions = { ...options, raw: false };
    if (typeof options.connectTimeoutMS === "number") {
      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
    }
    const start = new Date().getTime();
    const response = await executeHandshake(handshakeDoc, handshakeOptions);
    if (!("isWritablePrimary" in response)) {
      response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
    }
    if (response.helloOk) {
      conn.helloOk = true;
    }
    const supportedServerErr = checkSupportedServer(response, options);
    if (supportedServerErr) {
      throw supportedServerErr;
    }
    if (options.loadBalanced) {
      if (!response.serviceId) {
        throw new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, " + "but the server does not support this mode.");
      }
    }
    conn.hello = response;
    conn.lastHelloMS = new Date().getTime() - start;
    if (!response.arbiterOnly && credentials) {
      authContext.response = response;
      const resolvedCredentials = credentials.resolveAuthMechanism(response);
      const provider = options.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
      }
      try {
        await provider.auth(authContext);
      } catch (error) {
        if (error instanceof error_1.MongoError) {
          error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
          if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion, conn.description.type)) {
            error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        throw error;
      }
    }
    conn.established = true;
    async function executeHandshake(handshakeDoc2, handshakeOptions2) {
      try {
        const handshakeResponse = await conn.command((0, utils_1.ns)("admin.$cmd"), handshakeDoc2, handshakeOptions2);
        return handshakeResponse;
      } catch (error) {
        if (error instanceof error_1.MongoError) {
          error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
        }
        throw error;
      }
    }
  }
  async function prepareHandshakeDocument(authContext) {
    const options = authContext.options;
    const compressors = options.compressors ? options.compressors : [];
    const { serverApi } = authContext.connection;
    const clientMetadata = await options.extendedMetadata;
    const handshakeDoc = {
      [serverApi?.version || options.loadBalanced === true ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
      helloOk: true,
      client: clientMetadata,
      compression: compressors
    };
    if (options.loadBalanced === true) {
      handshakeDoc.loadBalanced = true;
    }
    const credentials = authContext.credentials;
    if (credentials) {
      if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
        handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
        const provider2 = authContext.options.authProviders.getOrCreateProvider(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, credentials.mechanismProperties);
        if (!provider2) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
        }
        return await provider2.prepare(handshakeDoc, authContext);
      }
      const provider = authContext.options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
      }
      return await provider.prepare(handshakeDoc, authContext);
    }
    return handshakeDoc;
  }
  exports.LEGAL_TLS_SOCKET_OPTIONS = [
    "allowPartialTrustChain",
    "ALPNProtocols",
    "ca",
    "cert",
    "checkServerIdentity",
    "ciphers",
    "crl",
    "ecdhCurve",
    "key",
    "minDHSize",
    "passphrase",
    "pfx",
    "rejectUnauthorized",
    "secureContext",
    "secureProtocol",
    "servername",
    "session"
  ];
  exports.LEGAL_TCP_SOCKET_OPTIONS = [
    "autoSelectFamily",
    "autoSelectFamilyAttemptTimeout",
    "keepAliveInitialDelay",
    "family",
    "hints",
    "localAddress",
    "localPort",
    "lookup"
  ];
  function parseConnectOptions(options) {
    const hostAddress = options.hostAddress;
    if (!hostAddress)
      throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
    const result = {};
    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    result.keepAliveInitialDelay ??= 120000;
    result.keepAlive = true;
    result.noDelay = options.noDelay ?? true;
    if (typeof hostAddress.socketPath === "string") {
      result.path = hostAddress.socketPath;
      return result;
    } else if (typeof hostAddress.host === "string") {
      result.host = hostAddress.host;
      result.port = hostAddress.port;
      return result;
    } else {
      throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
    }
  }
  function parseSslOptions(options) {
    const result = parseConnectOptions(options);
    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (options.existingSocket) {
      result.socket = options.existingSocket;
    }
    if (result.servername == null && result.host && !net.isIP(result.host)) {
      result.servername = result.host;
    }
    return result;
  }
  async function makeSocket(options) {
    const useTLS = options.tls ?? false;
    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;
    const existingSocket = options.existingSocket;
    let socket;
    if (options.proxyHost != null) {
      return await makeSocks5Connection({
        ...options,
        connectTimeoutMS
      });
    }
    if (useTLS) {
      const tlsSocket = tls.connect(parseSslOptions(options));
      if (typeof tlsSocket.disableRenegotiation === "function") {
        tlsSocket.disableRenegotiation();
      }
      socket = tlsSocket;
    } else if (existingSocket) {
      socket = existingSocket;
    } else {
      socket = net.createConnection(parseConnectOptions(options));
    }
    socket.setTimeout(connectTimeoutMS);
    let cancellationHandler = null;
    const { promise: connectedSocket, resolve, reject } = (0, utils_1.promiseWithResolvers)();
    if (existingSocket) {
      resolve(socket);
    } else {
      const start = performance.now();
      const connectEvent = useTLS ? "secureConnect" : "connect";
      socket.once(connectEvent, () => resolve(socket)).once("error", (cause) => reject(new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause }))).once("timeout", () => {
        reject(new error_1.MongoNetworkTimeoutError(`Socket '${connectEvent}' timed out after ${performance.now() - start | 0}ms (connectTimeoutMS: ${connectTimeoutMS})`));
      }).once("close", () => reject(new error_1.MongoNetworkError(`Socket closed after ${performance.now() - start | 0} during connection establishment`)));
      if (options.cancellationToken != null) {
        cancellationHandler = () => reject(new error_1.MongoNetworkError(`Socket connection establishment was cancelled after ${performance.now() - start | 0}`));
        options.cancellationToken.once("cancel", cancellationHandler);
      }
    }
    try {
      socket = await connectedSocket;
      return socket;
    } catch (error) {
      socket.destroy();
      throw error;
    } finally {
      socket.setTimeout(0);
      if (cancellationHandler != null) {
        options.cancellationToken?.removeListener("cancel", cancellationHandler);
      }
    }
  }
  var socks = null;
  function loadSocks() {
    if (socks == null) {
      const socksImport = (0, deps_1.getSocks)();
      if ("kModuleError" in socksImport) {
        throw socksImport.kModuleError;
      }
      socks = socksImport;
    }
    return socks;
  }
  async function makeSocks5Connection(options) {
    const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? "", options.proxyPort ?? 1080);
    const rawSocket = await makeSocket({
      ...options,
      hostAddress,
      tls: false,
      proxyHost: undefined
    });
    const destination = parseConnectOptions(options);
    if (typeof destination.host !== "string" || typeof destination.port !== "number") {
      throw new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts");
    }
    socks ??= loadSocks();
    let existingSocket;
    try {
      const connection = await socks.SocksClient.createConnection({
        existing_socket: rawSocket,
        timeout: options.connectTimeoutMS,
        command: "connect",
        destination: {
          host: destination.host,
          port: destination.port
        },
        proxy: {
          host: "iLoveJavaScript",
          port: 0,
          type: 5,
          userId: options.proxyUsername || undefined,
          password: options.proxyPassword || undefined
        }
      });
      existingSocket = connection.socket;
    } catch (cause) {
      throw new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause });
    }
    return await makeSocket({ ...options, existingSocket, proxyHost: undefined });
  }
});

// node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = undefined;
  var constants_1 = require_constants();

  class ServerDescriptionChangedEvent {
    constructor(topologyId, address, previousDescription, newDescription) {
      this.name = constants_1.SERVER_DESCRIPTION_CHANGED;
      this.topologyId = topologyId;
      this.address = address;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;

  class ServerOpeningEvent {
    constructor(topologyId, address) {
      this.name = constants_1.SERVER_OPENING;
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerOpeningEvent = ServerOpeningEvent;

  class ServerClosedEvent {
    constructor(topologyId, address) {
      this.name = constants_1.SERVER_CLOSED;
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerClosedEvent = ServerClosedEvent;

  class TopologyDescriptionChangedEvent {
    constructor(topologyId, previousDescription, newDescription) {
      this.name = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
      this.topologyId = topologyId;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;

  class TopologyOpeningEvent {
    constructor(topologyId) {
      this.name = constants_1.TOPOLOGY_OPENING;
      this.topologyId = topologyId;
    }
  }
  exports.TopologyOpeningEvent = TopologyOpeningEvent;

  class TopologyClosedEvent {
    constructor(topologyId) {
      this.name = constants_1.TOPOLOGY_CLOSED;
      this.topologyId = topologyId;
    }
  }
  exports.TopologyClosedEvent = TopologyClosedEvent;

  class ServerHeartbeatStartedEvent {
    constructor(connectionId, awaited) {
      this.name = constants_1.SERVER_HEARTBEAT_STARTED;
      this.connectionId = connectionId;
      this.awaited = awaited;
    }
  }
  exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;

  class ServerHeartbeatSucceededEvent {
    constructor(connectionId, duration, reply, awaited) {
      this.name = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
      this.connectionId = connectionId;
      this.duration = duration;
      this.reply = reply ?? {};
      this.awaited = awaited;
    }
  }
  exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;

  class ServerHeartbeatFailedEvent {
    constructor(connectionId, duration, failure, awaited) {
      this.name = constants_1.SERVER_HEARTBEAT_FAILED;
      this.connectionId = connectionId;
      this.duration = duration;
      this.failure = failure;
      this.awaited = awaited;
    }
  }
  exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
});

// node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = undefined;
  var constants_1 = require_constants();
  var utils_1 = require_utils();

  class ConnectionPoolMonitoringEvent {
    constructor(pool) {
      this.time = new Date;
      this.address = pool.address;
    }
  }
  exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;

  class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CREATED;
      const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } = pool.options;
      this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };
    }
  }
  exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;

  class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_READY;
    }
  }
  exports.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;

  class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLOSED;
    }
  }
  exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;

  class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CREATED;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCreatedEvent = ConnectionCreatedEvent;

  class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, connectionCreatedEventTime) {
      super(pool);
      this.name = constants_1.CONNECTION_READY;
      this.durationMS = (0, utils_1.now)() - connectionCreatedEventTime;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionReadyEvent = ConnectionReadyEvent;

  class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, reason, error) {
      super(pool);
      this.name = constants_1.CONNECTION_CLOSED;
      this.connectionId = connection.id;
      this.reason = reason;
      this.serviceId = connection.serviceId;
      this.error = error ?? null;
    }
  }
  exports.ConnectionClosedEvent = ConnectionClosedEvent;

  class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
    }
  }
  exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;

  class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, reason, checkoutTime, error) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
      this.durationMS = (0, utils_1.now)() - checkoutTime;
      this.reason = reason;
      this.error = error;
    }
  }
  exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;

  class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, checkoutTime) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_OUT;
      this.durationMS = (0, utils_1.now)() - checkoutTime;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;

  class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_IN;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;

  class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, options = {}) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLEARED;
      this.serviceId = options.serviceId;
      this.interruptInUseConnections = options.interruptInUseConnections;
    }
  }
  exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueueTimeoutError = exports.PoolClearedOnNetworkError = exports.PoolClearedError = exports.PoolClosedError = undefined;
  var error_1 = require_error();

  class PoolClosedError extends error_1.MongoDriverError {
    constructor(pool) {
      super("Attempted to check out a connection from closed connection pool");
      this.address = pool.address;
    }
    get name() {
      return "MongoPoolClosedError";
    }
  }
  exports.PoolClosedError = PoolClosedError;

  class PoolClearedError extends error_1.MongoNetworkError {
    constructor(pool, message) {
      const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
      super(errorMessage, pool.serverError ? { cause: pool.serverError } : undefined);
      this.address = pool.address;
      this.addErrorLabel(error_1.MongoErrorLabel.PoolRequstedRetry);
    }
    get name() {
      return "MongoPoolClearedError";
    }
  }
  exports.PoolClearedError = PoolClearedError;

  class PoolClearedOnNetworkError extends PoolClearedError {
    constructor(pool) {
      super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
    }
    get name() {
      return "PoolClearedOnNetworkError";
    }
  }
  exports.PoolClearedOnNetworkError = PoolClearedOnNetworkError;

  class WaitQueueTimeoutError extends error_1.MongoDriverError {
    constructor(message, address) {
      super(message);
      this.address = address;
    }
    get name() {
      return "MongoWaitQueueTimeoutError";
    }
  }
  exports.WaitQueueTimeoutError = WaitQueueTimeoutError;
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPool = exports.PoolState = undefined;
  var timers_1 = __require("timers");
  var constants_1 = require_constants();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var connect_1 = require_connect();
  var connection_1 = require_connection();
  var connection_pool_events_1 = require_connection_pool_events();
  var errors_1 = require_errors2();
  var metrics_1 = require_metrics();
  exports.PoolState = Object.freeze({
    paused: "paused",
    ready: "ready",
    closed: "closed"
  });

  class ConnectionPool extends mongo_types_1.TypedEventEmitter {
    constructor(server, options) {
      super();
      this.on("error", utils_1.noop);
      this.options = Object.freeze({
        connectionType: connection_1.Connection,
        ...options,
        maxPoolSize: options.maxPoolSize ?? 100,
        minPoolSize: options.minPoolSize ?? 0,
        maxConnecting: options.maxConnecting ?? 2,
        maxIdleTimeMS: options.maxIdleTimeMS ?? 0,
        waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,
        minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,
        autoEncrypter: options.autoEncrypter
      });
      if (this.options.minPoolSize > this.options.maxPoolSize) {
        throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
      }
      this.poolState = exports.PoolState.paused;
      this.server = server;
      this.connections = new utils_1.List;
      this.pending = 0;
      this.checkedOut = new Set;
      this.minPoolSizeTimer = undefined;
      this.generation = 0;
      this.serviceGenerations = new Map;
      this.connectionCounter = (0, utils_1.makeCounter)(1);
      this.cancellationToken = new mongo_types_1.CancellationToken;
      this.cancellationToken.setMaxListeners(Infinity);
      this.waitQueue = new utils_1.List;
      this.metrics = new metrics_1.ConnectionPoolMetrics;
      this.processingWaitQueue = false;
      this.mongoLogger = this.server.topology.client?.mongoLogger;
      this.component = "connection";
      process.nextTick(() => {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
      });
    }
    get address() {
      return this.options.hostAddress.toString();
    }
    get closed() {
      return this.poolState === exports.PoolState.closed;
    }
    get totalConnectionCount() {
      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
    }
    get availableConnectionCount() {
      return this.connections.length;
    }
    get pendingConnectionCount() {
      return this.pending;
    }
    get currentCheckedOutCount() {
      return this.checkedOut.size;
    }
    get waitQueueSize() {
      return this.waitQueue.length;
    }
    get loadBalanced() {
      return this.options.loadBalanced;
    }
    get serverError() {
      return this.server.description.error;
    }
    get checkedOutConnections() {
      return this.checkedOut;
    }
    waitQueueErrorMetrics() {
      return this.metrics.info(this.options.maxPoolSize);
    }
    ready() {
      if (this.poolState !== exports.PoolState.paused) {
        return;
      }
      this.poolState = exports.PoolState.ready;
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
      (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
      this.ensureMinPoolSize();
    }
    async checkOut(options) {
      const checkoutTime = (0, utils_1.now)();
      this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
      const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
      const timeout = options.timeoutContext.connectionCheckoutTimeout;
      const waitQueueMember = {
        resolve,
        reject,
        cancelled: false,
        checkoutTime
      };
      const abortListener = (0, utils_1.addAbortListener)(options.signal, function() {
        waitQueueMember.cancelled = true;
        reject(this.reason);
      });
      this.waitQueue.push(waitQueueMember);
      process.nextTick(() => this.processWaitQueue());
      try {
        timeout?.throwIfExpired();
        return await (timeout ? Promise.race([promise, timeout]) : promise);
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          timeout?.clear();
          waitQueueMember.cancelled = true;
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout", waitQueueMember.checkoutTime));
          const timeoutError = new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address);
          if (options.timeoutContext.csotEnabled()) {
            throw new error_1.MongoOperationTimeoutError("Timed out during connection checkout", {
              cause: timeoutError
            });
          }
          throw timeoutError;
        }
        throw error;
      } finally {
        abortListener?.[utils_1.kDispose]();
        timeout?.clear();
      }
    }
    checkIn(connection) {
      if (!this.checkedOut.has(connection)) {
        return;
      }
      const poolClosed = this.closed;
      const stale = this.connectionIsStale(connection);
      const willDestroy = !!(poolClosed || stale || connection.closed);
      if (!willDestroy) {
        connection.markAvailable();
        this.connections.unshift(connection);
      }
      this.checkedOut.delete(connection);
      this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
      if (willDestroy) {
        const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
        this.destroyConnection(connection, reason);
      }
      process.nextTick(() => this.processWaitQueue());
    }
    clear(options = {}) {
      if (this.closed) {
        return;
      }
      if (this.loadBalanced) {
        const { serviceId } = options;
        if (!serviceId) {
          throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
        }
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        if (generation == null) {
          throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
        } else {
          this.serviceGenerations.set(sid, generation + 1);
        }
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
        return;
      }
      const interruptInUseConnections = options.interruptInUseConnections ?? false;
      const oldGeneration = this.generation;
      this.generation += 1;
      const alreadyPaused = this.poolState === exports.PoolState.paused;
      this.poolState = exports.PoolState.paused;
      this.clearMinPoolSizeTimer();
      if (!alreadyPaused) {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
          interruptInUseConnections
        }));
      }
      if (interruptInUseConnections) {
        process.nextTick(() => this.interruptInUseConnections(oldGeneration));
      }
      this.processWaitQueue();
    }
    interruptInUseConnections(minGeneration) {
      for (const connection of this.checkedOut) {
        if (connection.generation <= minGeneration) {
          connection.onError(new errors_1.PoolClearedOnNetworkError(this));
        }
      }
    }
    closeCheckedOutConnections() {
      for (const conn of this.checkedOut) {
        conn.onError(new error_1.MongoClientClosedError);
      }
    }
    close() {
      if (this.closed) {
        return;
      }
      this.cancellationToken.emit("cancel");
      if (typeof this.connectionCounter.return === "function") {
        this.connectionCounter.return(undefined);
      }
      this.poolState = exports.PoolState.closed;
      this.clearMinPoolSizeTimer();
      this.processWaitQueue();
      for (const conn of this.connections) {
        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
        conn.destroy();
      }
      this.connections.clear();
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
    }
    async reauthenticate(connection) {
      const authContext = connection.authContext;
      if (!authContext) {
        throw new error_1.MongoRuntimeError("No auth context found on connection.");
      }
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("Connection is missing credentials when asked to reauthenticate");
      }
      const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);
      const provider = this.server.topology.client.s.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
      if (!provider) {
        throw new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`);
      }
      await provider.reauth(authContext);
      return;
    }
    clearMinPoolSizeTimer() {
      const minPoolSizeTimer = this.minPoolSizeTimer;
      if (minPoolSizeTimer) {
        (0, timers_1.clearTimeout)(minPoolSizeTimer);
      }
    }
    destroyConnection(connection, reason) {
      this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
      connection.destroy();
    }
    connectionIsStale(connection) {
      const serviceId = connection.serviceId;
      if (this.loadBalanced && serviceId) {
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        return connection.generation !== generation;
      }
      return connection.generation !== this.generation;
    }
    connectionIsIdle(connection) {
      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
    }
    destroyConnectionIfPerished(connection) {
      const isStale = this.connectionIsStale(connection);
      const isIdle = this.connectionIsIdle(connection);
      if (!isStale && !isIdle && !connection.closed) {
        return false;
      }
      const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
      this.destroyConnection(connection, reason);
      return true;
    }
    createConnection(callback) {
      const connectOptions = {
        ...this.options,
        id: this.connectionCounter.next().value,
        generation: this.generation,
        cancellationToken: this.cancellationToken,
        mongoLogger: this.mongoLogger,
        authProviders: this.server.topology.client.s.authProviders,
        extendedMetadata: this.server.topology.client.options.extendedMetadata
      };
      this.pending++;
      const connectionCreatedTime = (0, utils_1.now)();
      this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
      (0, connect_1.connect)(connectOptions).then((connection) => {
        if (this.poolState !== exports.PoolState.ready) {
          this.pending--;
          connection.destroy();
          callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
          return;
        }
        for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
          connection.on(event, (e) => this.emit(event, e));
        }
        if (this.loadBalanced) {
          connection.on(connection_1.Connection.PINNED, (pinType) => this.metrics.markPinned(pinType));
          connection.on(connection_1.Connection.UNPINNED, (pinType) => this.metrics.markUnpinned(pinType));
          const serviceId = connection.serviceId;
          if (serviceId) {
            let generation;
            const sid = serviceId.toHexString();
            if (generation = this.serviceGenerations.get(sid)) {
              connection.generation = generation;
            } else {
              this.serviceGenerations.set(sid, 0);
              connection.generation = 0;
            }
          }
        }
        connection.markAvailable();
        this.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection, connectionCreatedTime));
        this.pending--;
        callback(undefined, connection);
      }, (error) => {
        this.pending--;
        this.server.handleError(error);
        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: undefined }, "error", error));
        if (error instanceof error_1.MongoNetworkError || error instanceof error_1.MongoServerError) {
          error.connectionGeneration = connectOptions.generation;
        }
        callback(error ?? new error_1.MongoRuntimeError("Connection creation failed without error"));
      });
    }
    ensureMinPoolSize() {
      const minPoolSize = this.options.minPoolSize;
      if (this.poolState !== exports.PoolState.ready) {
        return;
      }
      this.connections.prune((connection) => this.destroyConnectionIfPerished(connection));
      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
        this.createConnection((err2, connection) => {
          if (!err2 && connection) {
            this.connections.push(connection);
            process.nextTick(() => this.processWaitQueue());
          }
          if (this.poolState === exports.PoolState.ready) {
            (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
            this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
          }
        });
      } else {
        (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
        this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
      }
    }
    processWaitQueue() {
      if (this.processingWaitQueue) {
        return;
      }
      this.processingWaitQueue = true;
      while (this.waitQueueSize) {
        const waitQueueMember = this.waitQueue.first();
        if (!waitQueueMember) {
          this.waitQueue.shift();
          continue;
        }
        if (waitQueueMember.cancelled) {
          this.waitQueue.shift();
          continue;
        }
        if (this.poolState !== exports.PoolState.ready) {
          const reason = this.closed ? "poolClosed" : "connectionError";
          const error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error));
          this.waitQueue.shift();
          waitQueueMember.reject(error);
          continue;
        }
        if (!this.availableConnectionCount) {
          break;
        }
        const connection = this.connections.shift();
        if (!connection) {
          break;
        }
        if (!this.destroyConnectionIfPerished(connection)) {
          this.checkedOut.add(connection);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
          this.waitQueue.shift();
          waitQueueMember.resolve(connection);
        }
      }
      const { maxPoolSize, maxConnecting } = this.options;
      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
        const waitQueueMember = this.waitQueue.shift();
        if (!waitQueueMember || waitQueueMember.cancelled) {
          continue;
        }
        this.createConnection((err2, connection) => {
          if (waitQueueMember.cancelled) {
            if (!err2 && connection) {
              this.connections.push(connection);
            }
          } else {
            if (err2) {
              this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError", waitQueueMember.checkoutTime, err2));
              waitQueueMember.reject(err2);
            } else if (connection) {
              this.checkedOut.add(connection);
              this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
              waitQueueMember.resolve(connection);
            }
          }
          process.nextTick(() => this.processWaitQueue());
        });
      }
      this.processingWaitQueue = false;
    }
  }
  exports.ConnectionPool = ConnectionPool;
  ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
  ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
  ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
  ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
  ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
  ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
  ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
  ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
  ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
  ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
  ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
});

// node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = undefined;
  var connection_1 = require_connection();
  var connection_pool_1 = require_connection_pool();
  var errors_1 = require_errors2();
  var constants_1 = require_constants();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var common_1 = require_common2();
  var monitor_1 = require_monitor();
  var server_description_1 = require_server_description();
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });

  class Server extends mongo_types_1.TypedEventEmitter {
    constructor(topology, description, options) {
      super();
      this.on("error", utils_1.noop);
      this.serverApi = options.serverApi;
      const poolOptions = { hostAddress: description.hostAddress, ...options };
      this.topology = topology;
      this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
      this.s = {
        description,
        options,
        state: common_1.STATE_CLOSED,
        operationCount: 0
      };
      for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
        this.pool.on(event, (e) => this.emit(event, e));
      }
      this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
        this.clusterTime = clusterTime;
      });
      if (this.loadBalanced) {
        this.monitor = null;
        return;
      }
      this.monitor = new monitor_1.Monitor(this, this.s.options);
      for (const event of constants_1.HEARTBEAT_EVENTS) {
        this.monitor.on(event, (e) => this.emit(event, e));
      }
      this.monitor.on("resetServer", (error) => markServerUnknown(this, error));
      this.monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
        this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
          roundTripTime: this.monitor?.roundTripTime,
          minRoundTripTime: this.monitor?.minRoundTripTime
        }));
        if (this.s.state === common_1.STATE_CONNECTING) {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(Server.CONNECT, this);
        }
      });
    }
    get clusterTime() {
      return this.topology.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.topology.clusterTime = clusterTime;
    }
    get description() {
      return this.s.description;
    }
    get name() {
      return this.s.description.address;
    }
    get autoEncrypter() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }
      return;
    }
    get loadBalanced() {
      return this.topology.description.type === common_1.TopologyType.LoadBalanced;
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      if (!this.loadBalanced) {
        this.monitor?.connect();
      } else {
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Server.CONNECT, this);
      }
    }
    closeCheckedOutConnections() {
      return this.pool.closeCheckedOutConnections();
    }
    close() {
      if (this.s.state === common_1.STATE_CLOSED) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      if (!this.loadBalanced) {
        this.monitor?.close();
      }
      this.pool.close();
      stateTransition(this, common_1.STATE_CLOSED);
      this.emit("closed");
    }
    requestCheck() {
      if (!this.loadBalanced) {
        this.monitor?.requestCheck();
      }
    }
    async command(ns, cmd, { ...options }, responseType) {
      if (ns.db == null || typeof ns === "string") {
        throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
      }
      if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
        throw new error_1.MongoServerClosedError;
      }
      options.directConnection = this.topology.s.options.directConnection;
      if (options.omitReadPreference) {
        delete options.readPreference;
      }
      if (this.description.iscryptd) {
        options.omitMaxTimeMS = true;
      }
      const session = options.session;
      let conn = session?.pinnedConnection;
      this.incrementOperationCount();
      if (conn == null) {
        try {
          conn = await this.pool.checkOut(options);
          if (this.loadBalanced && isPinnableCommand(cmd, session)) {
            session?.pin(conn);
          }
        } catch (checkoutError) {
          this.decrementOperationCount();
          if (!(checkoutError instanceof errors_1.PoolClearedError))
            this.handleError(checkoutError);
          throw checkoutError;
        }
      }
      let reauthPromise = null;
      try {
        try {
          const res = await conn.command(ns, cmd, options, responseType);
          (0, write_concern_1.throwIfWriteConcernError)(res);
          return res;
        } catch (commandError) {
          throw this.decorateCommandError(conn, cmd, options, commandError);
        }
      } catch (operationError) {
        if (operationError instanceof error_1.MongoError && operationError.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
          reauthPromise = this.pool.reauthenticate(conn);
          reauthPromise.then(undefined, (error) => {
            reauthPromise = null;
            (0, utils_1.squashError)(error);
          });
          await (0, utils_1.abortable)(reauthPromise, options);
          reauthPromise = null;
          try {
            const res = await conn.command(ns, cmd, options, responseType);
            (0, write_concern_1.throwIfWriteConcernError)(res);
            return res;
          } catch (commandError) {
            throw this.decorateCommandError(conn, cmd, options, commandError);
          }
        } else {
          throw operationError;
        }
      } finally {
        this.decrementOperationCount();
        if (session?.pinnedConnection !== conn) {
          if (reauthPromise != null) {
            const checkBackIn = () => {
              this.pool.checkIn(conn);
            };
            reauthPromise.then(checkBackIn, checkBackIn);
          } else {
            this.pool.checkIn(conn);
          }
        }
      }
    }
    handleError(error, connection) {
      if (!(error instanceof error_1.MongoError)) {
        return;
      }
      const isStaleError = error.connectionGeneration && error.connectionGeneration < this.pool.generation;
      if (isStaleError) {
        return;
      }
      const isNetworkNonTimeoutError = error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError);
      const isNetworkTimeoutBeforeHandshakeError = error instanceof error_1.MongoNetworkError && error.beforeHandshake;
      const isAuthHandshakeError = error.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
      if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
        if (!this.loadBalanced) {
          error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
          markServerUnknown(this, error);
        } else if (connection) {
          this.pool.clear({ serviceId: connection.serviceId });
        }
      } else {
        if ((0, error_1.isSDAMUnrecoverableError)(error)) {
          if (shouldHandleStateChangeError(this, error)) {
            const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error);
            if (this.loadBalanced && connection && shouldClearPool) {
              this.pool.clear({ serviceId: connection.serviceId });
            }
            if (!this.loadBalanced) {
              if (shouldClearPool) {
                error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
              }
              markServerUnknown(this, error);
              process.nextTick(() => this.requestCheck());
            }
          }
        }
      }
    }
    decorateCommandError(connection, cmd, options, error) {
      if (typeof error !== "object" || error == null || !("name" in error)) {
        throw new error_1.MongoRuntimeError("An unexpected error type: " + typeof error);
      }
      if (error.name === "AbortError" && "cause" in error && error.cause instanceof error_1.MongoError) {
        error = error.cause;
      }
      if (!(error instanceof error_1.MongoError)) {
        return error;
      }
      if (connectionIsStale(this.pool, connection)) {
        return error;
      }
      const session = options?.session;
      if (error instanceof error_1.MongoNetworkError) {
        if (session && !session.hasEnded && session.serverSession) {
          session.serverSession.isDirty = true;
        }
        if (inActiveTransaction(session, cmd) && !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
        }
        if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(this) && !inActiveTransaction(session, cmd)) {
          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      } else {
        if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(this), this.description.type) && !inActiveTransaction(session, cmd)) {
          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      }
      if (session && session.isPinned && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        session.unpin({ force: true });
      }
      this.handleError(error, connection);
      return error;
    }
    decrementOperationCount() {
      return this.s.operationCount -= 1;
    }
    incrementOperationCount() {
      return this.s.operationCount += 1;
    }
  }
  exports.Server = Server;
  Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
  Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
  Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
  Server.CONNECT = constants_1.CONNECT;
  Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
  Server.CLOSED = constants_1.CLOSED;
  Server.ENDED = constants_1.ENDED;
  function markServerUnknown(server, error) {
    if (server.loadBalanced) {
      return;
    }
    if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
      server.monitor?.reset();
    }
    server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, { error }));
  }
  function isPinnableCommand(cmd, session) {
    if (session) {
      return session.inTransaction() || session.transaction.isCommitted && "commitTransaction" in cmd || "aggregate" in cmd || "find" in cmd || "getMore" in cmd || "listCollections" in cmd || "listIndexes" in cmd || "bulkWrite" in cmd;
    }
    return false;
  }
  function connectionIsStale(pool, connection) {
    if (connection.serviceId) {
      return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
    }
    return connection.generation !== pool.generation;
  }
  function shouldHandleStateChangeError(server, err2) {
    const etv = err2.topologyVersion;
    const stv = server.description.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
  }
  function inActiveTransaction(session, cmd) {
    return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
  }
  function isRetryableWritesEnabled(topology) {
    return topology.s.options.retryWrites !== false;
  }
});

// node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = undefined;
  var timers_1 = __require("timers");
  var bson_1 = require_bson2();
  var connect_1 = require_connect();
  var client_metadata_1 = require_client_metadata();
  var constants_1 = require_constants();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var common_1 = require_common2();
  var events_1 = require_events();
  var server_1 = require_server();
  var STATE_IDLE = "idle";
  var STATE_MONITORING = "monitoring";
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
  });
  var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
  function isInCloseState(monitor) {
    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
  }
  exports.ServerMonitoringMode = Object.freeze({
    auto: "auto",
    poll: "poll",
    stream: "stream"
  });

  class Monitor extends mongo_types_1.TypedEventEmitter {
    constructor(server, options) {
      super();
      this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;
      this.on("error", utils_1.noop);
      this.server = server;
      this.connection = null;
      this.cancellationToken = new mongo_types_1.CancellationToken;
      this.cancellationToken.setMaxListeners(Infinity);
      this.monitorId = undefined;
      this.s = {
        state: common_1.STATE_CLOSED
      };
      this.address = server.description.address;
      this.options = Object.freeze({
        connectTimeoutMS: options.connectTimeoutMS ?? 1e4,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 1e4,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,
        serverMonitoringMode: options.serverMonitoringMode
      });
      this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;
      this.mongoLogger = this.server.topology.client?.mongoLogger;
      this.rttSampler = new RTTSampler(10);
      const cancellationToken = this.cancellationToken;
      const connectOptions = {
        id: "<monitor>",
        generation: server.pool.generation,
        cancellationToken,
        hostAddress: server.description.hostAddress,
        ...options,
        raw: false,
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: true
      };
      delete connectOptions.credentials;
      if (connectOptions.autoEncrypter) {
        delete connectOptions.autoEncrypter;
      }
      this.connectOptions = Object.freeze(connectOptions);
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this.monitorId = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS,
        immediate: true
      });
    }
    requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }
      this.monitorId?.wake();
    }
    reset() {
      const topologyVersion = this.server.description.topologyVersion;
      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      stateTransition(this, STATE_IDLE);
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this.monitorId = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS
      });
    }
    close() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      this.emit("close");
      stateTransition(this, common_1.STATE_CLOSED);
    }
    get roundTripTime() {
      return this.rttSampler.average();
    }
    get minRoundTripTime() {
      return this.rttSampler.min();
    }
    get latestRtt() {
      return this.rttSampler.last;
    }
    addRttSample(rtt) {
      this.rttSampler.addSample(rtt);
    }
    clearRttSamples() {
      this.rttSampler.clear();
    }
  }
  exports.Monitor = Monitor;
  function resetMonitorState(monitor) {
    monitor.monitorId?.stop();
    monitor.monitorId = undefined;
    monitor.rttPinger?.close();
    monitor.rttPinger = undefined;
    monitor.cancellationToken.emit("cancel");
    monitor.connection?.destroy();
    monitor.connection = null;
    monitor.clearRttSamples();
  }
  function useStreamingProtocol(monitor, topologyVersion) {
    if (topologyVersion == null)
      return false;
    const serverMonitoringMode = monitor.options.serverMonitoringMode;
    if (serverMonitoringMode === exports.ServerMonitoringMode.poll)
      return false;
    if (serverMonitoringMode === exports.ServerMonitoringMode.stream)
      return true;
    if (monitor.isRunningInFaasEnv)
      return false;
    return true;
  }
  function checkServer(monitor, callback) {
    let start;
    let awaited;
    const topologyVersion = monitor.server.description.topologyVersion;
    const isAwaitable = useStreamingProtocol(monitor, topologyVersion);
    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
    function onHeartbeatFailed(err2) {
      monitor.connection?.destroy();
      monitor.connection = null;
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err2, awaited));
      const error = !(err2 instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err2), { cause: err2 }) : err2;
      error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
      if (error instanceof error_1.MongoNetworkTimeoutError) {
        error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
      }
      monitor.emit("resetServer", error);
      callback(err2);
    }
    function onHeartbeatSucceeded(hello) {
      if (!("isWritablePrimary" in hello)) {
        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
      }
      const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.latestRtt ?? (0, utils_1.calculateDurationInMs)(start) : (0, utils_1.calculateDurationInMs)(start);
      monitor.addRttSample(duration);
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
      if (isAwaitable) {
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
        start = (0, utils_1.now)();
      } else {
        monitor.rttPinger?.close();
        monitor.rttPinger = undefined;
        callback(undefined, hello);
      }
    }
    const { connection } = monitor;
    if (connection && !connection.closed) {
      const { serverApi, helloOk } = connection;
      const connectTimeoutMS = monitor.options.connectTimeoutMS;
      const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
      const cmd = {
        [serverApi?.version || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
        ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
      };
      const options = isAwaitable ? {
        socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
        exhaustAllowed: true
      } : { socketTimeoutMS: connectTimeoutMS };
      if (isAwaitable && monitor.rttPinger == null) {
        monitor.rttPinger = new RTTPinger(monitor);
      }
      start = (0, utils_1.now)();
      if (isAwaitable) {
        awaited = true;
        return connection.exhaustCommand((0, utils_1.ns)("admin.$cmd"), cmd, options, (error, hello) => {
          if (error)
            return onHeartbeatFailed(error);
          return onHeartbeatSucceeded(hello);
        });
      }
      awaited = false;
      connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options).then(onHeartbeatSucceeded, onHeartbeatFailed);
      return;
    }
    (async () => {
      const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);
      const connection2 = (0, connect_1.makeConnection)(monitor.connectOptions, socket);
      start = (0, utils_1.now)();
      try {
        await (0, connect_1.performInitialHandshake)(connection2, monitor.connectOptions);
        return connection2;
      } catch (error) {
        connection2.destroy();
        throw error;
      }
    })().then((connection2) => {
      if (isInCloseState(monitor)) {
        connection2.destroy();
        return;
      }
      const duration = (0, utils_1.calculateDurationInMs)(start);
      monitor.addRttSample(duration);
      monitor.connection = connection2;
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, connection2.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection2.hello, useStreamingProtocol(monitor, connection2.hello?.topologyVersion)));
      callback(undefined, connection2.hello);
    }, (error) => {
      monitor.connection = null;
      awaited = false;
      onHeartbeatFailed(error);
    });
  }
  function monitorServer(monitor) {
    return (callback) => {
      if (monitor.s.state === STATE_MONITORING) {
        process.nextTick(callback);
        return;
      }
      stateTransition(monitor, STATE_MONITORING);
      function done() {
        if (!isInCloseState(monitor)) {
          stateTransition(monitor, STATE_IDLE);
        }
        callback();
      }
      checkServer(monitor, (err2, hello) => {
        if (err2) {
          if (monitor.server.description.type === common_1.ServerType.Unknown) {
            return done();
          }
        }
        if (useStreamingProtocol(monitor, hello?.topologyVersion)) {
          (0, timers_1.setTimeout)(() => {
            if (!isInCloseState(monitor)) {
              monitor.monitorId?.wake();
            }
          }, 0);
        }
        done();
      });
    };
  }
  function makeTopologyVersion(tv) {
    return {
      processId: tv.processId,
      counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
    };
  }

  class RTTPinger {
    constructor(monitor) {
      this.connection = undefined;
      this.cancellationToken = monitor.cancellationToken;
      this.closed = false;
      this.monitor = monitor;
      this.latestRtt = monitor.latestRtt ?? undefined;
      const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;
      this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);
    }
    get roundTripTime() {
      return this.monitor.roundTripTime;
    }
    get minRoundTripTime() {
      return this.monitor.minRoundTripTime;
    }
    close() {
      this.closed = true;
      (0, timers_1.clearTimeout)(this.monitorId);
      this.connection?.destroy();
      this.connection = undefined;
    }
    measureAndReschedule(start, conn) {
      if (this.closed) {
        conn?.destroy();
        return;
      }
      if (this.connection == null) {
        this.connection = conn;
      }
      this.latestRtt = (0, utils_1.calculateDurationInMs)(start);
      this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);
    }
    measureRoundTripTime() {
      const start = (0, utils_1.now)();
      if (this.closed) {
        return;
      }
      const connection = this.connection;
      if (connection == null) {
        (0, connect_1.connect)(this.monitor.connectOptions).then((connection2) => {
          this.measureAndReschedule(start, connection2);
        }, () => {
          this.connection = undefined;
        });
        return;
      }
      const commandName = connection.serverApi?.version || connection.helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND;
      connection.command((0, utils_1.ns)("admin.$cmd"), { [commandName]: 1 }, undefined).then(() => this.measureAndReschedule(start), () => {
        this.connection?.destroy();
        this.connection = undefined;
        return;
      });
    }
  }
  exports.RTTPinger = RTTPinger;

  class MonitorInterval {
    constructor(fn, options = {}) {
      this.isExpeditedCallToFnScheduled = false;
      this.stopped = false;
      this.isExecutionInProgress = false;
      this.hasExecutedOnce = false;
      this._executeAndReschedule = () => {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.isExpeditedCallToFnScheduled = false;
        this.isExecutionInProgress = true;
        this.fn(() => {
          this.lastExecutionEnded = (0, utils_1.now)();
          this.isExecutionInProgress = false;
          this._reschedule(this.heartbeatFrequencyMS);
        });
      };
      this.fn = fn;
      this.lastExecutionEnded = -Infinity;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;
      this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;
      if (options.immediate) {
        this._executeAndReschedule();
      } else {
        this._reschedule(undefined);
      }
    }
    wake() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      if (timeSinceLastCall < 0) {
        return this._executeAndReschedule();
      }
      if (this.isExecutionInProgress) {
        return;
      }
      if (this.isExpeditedCallToFnScheduled) {
        return;
      }
      if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
        this.isExpeditedCallToFnScheduled = true;
        this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
        return;
      }
      this._executeAndReschedule();
    }
    stop() {
      this.stopped = true;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
        this.timerId = undefined;
      }
      this.lastExecutionEnded = -Infinity;
      this.isExpeditedCallToFnScheduled = false;
    }
    toString() {
      return JSON.stringify(this);
    }
    toJSON() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      return {
        timerId: this.timerId != null ? "set" : "cleared",
        lastCallTime: this.lastExecutionEnded,
        isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
        stopped: this.stopped,
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
        currentTime,
        timeSinceLastCall
      };
    }
    _reschedule(ms) {
      if (this.stopped)
        return;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
      }
      this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
    }
  }
  exports.MonitorInterval = MonitorInterval;

  class RTTSampler {
    constructor(windowSize = 10) {
      this.rttSamples = new Float64Array(windowSize);
      this.length = 0;
      this.writeIndex = 0;
    }
    addSample(sample) {
      this.rttSamples[this.writeIndex++] = sample;
      if (this.length < this.rttSamples.length) {
        this.length++;
      }
      this.writeIndex %= this.rttSamples.length;
    }
    min() {
      if (this.length < 2)
        return 0;
      let min = this.rttSamples[0];
      for (let i = 1;i < this.length; i++) {
        if (this.rttSamples[i] < min)
          min = this.rttSamples[i];
      }
      return min;
    }
    average() {
      if (this.length === 0)
        return 0;
      let sum = 0;
      for (let i = 0;i < this.length; i++) {
        sum += this.rttSamples[i];
      }
      return sum / this.length;
    }
    get last() {
      if (this.length === 0)
        return null;
      return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];
    }
    clear() {
      this.length = 0;
      this.writeIndex = 0;
    }
  }
  exports.RTTSampler = RTTSampler;
});

// node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_OPTIONS = exports.OPTIONS = undefined;
  exports.resolveSRVRecord = resolveSRVRecord;
  exports.parseOptions = parseOptions;
  var dns = __require("dns");
  var mongodb_connection_string_url_1 = require_lib2();
  var url_1 = __require("url");
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var client_metadata_1 = require_client_metadata();
  var compression_1 = require_compression();
  var encrypter_1 = require_encrypter();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_logger_1 = require_mongo_logger();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var monitor_1 = require_monitor();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
  var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
  var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
  var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
  function retryDNSTimeoutFor(api) {
    return async function dnsReqRetryTimeout(lookupAddress) {
      try {
        return await dns.promises[api](lookupAddress);
      } catch (firstDNSError) {
        if (firstDNSError.code === dns.TIMEOUT) {
          return await dns.promises[api](lookupAddress);
        } else {
          throw firstDNSError;
        }
      }
    };
  }
  var resolveSrv = retryDNSTimeoutFor("resolveSrv");
  var resolveTxt = retryDNSTimeoutFor("resolveTxt");
  async function resolveSRVRecord(options) {
    if (typeof options.srvHost !== "string") {
      throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
    }
    const lookupAddress = options.srvHost;
    const txtResolutionPromise = resolveTxt(lookupAddress);
    txtResolutionPromise.then(undefined, utils_1.squashError);
    const hostname = `_${options.srvServiceName}._tcp.${lookupAddress}`;
    const addresses = await resolveSrv(hostname);
    if (addresses.length === 0) {
      throw new error_1.MongoAPIError("No addresses found at host");
    }
    for (const { name } of addresses) {
      (0, utils_1.checkParentDomainMatch)(name, lookupAddress);
    }
    const hostAddresses = addresses.map((r2) => utils_1.HostAddress.fromString(`${r2.name}:${r2.port ?? 27017}`));
    validateLoadBalancedOptions(hostAddresses, options, true);
    let record;
    try {
      record = await txtResolutionPromise;
    } catch (error) {
      if (error.code !== "ENODATA" && error.code !== "ENOTFOUND") {
        throw error;
      }
      return hostAddresses;
    }
    if (record.length > 1) {
      throw new error_1.MongoParseError("Multiple text records not allowed");
    }
    const txtRecordOptions = new url_1.URLSearchParams(record[0].join(""));
    const txtRecordOptionKeys = [...txtRecordOptions.keys()];
    if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
      throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
    }
    if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
      throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
    }
    const source = txtRecordOptions.get("authSource") ?? undefined;
    const replicaSet = txtRecordOptions.get("replicaSet") ?? undefined;
    const loadBalanced = txtRecordOptions.get("loadBalanced") ?? undefined;
    if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
      options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
    }
    if (!options.userSpecifiedReplicaSet && replicaSet) {
      options.replicaSet = replicaSet;
    }
    if (loadBalanced === "true") {
      options.loadBalanced = true;
    }
    if (options.replicaSet && options.srvMaxHosts > 0) {
      throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
    }
    validateLoadBalancedOptions(hostAddresses, options, true);
    return hostAddresses;
  }
  function checkTLSOptions(allOptions) {
    if (!allOptions)
      return;
    const check2 = (a12, b) => {
      if (allOptions.has(a12) && allOptions.has(b)) {
        throw new error_1.MongoAPIError(`The '${a12}' option cannot be used with the '${b}' option`);
      }
    };
    check2("tlsInsecure", "tlsAllowInvalidCertificates");
    check2("tlsInsecure", "tlsAllowInvalidHostnames");
  }
  function getBoolean(name, value) {
    if (typeof value === "boolean")
      return value;
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new error_1.MongoParseError(`${name} must be either "true" or "false"`);
    }
  }
  function getIntFromOptions(name, value) {
    const parsedInt = (0, utils_1.parseInteger)(value);
    if (parsedInt != null) {
      return parsedInt;
    }
    throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
  }
  function getUIntFromOptions(name, value) {
    const parsedValue = getIntFromOptions(name, value);
    if (parsedValue < 0) {
      throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
    }
    return parsedValue;
  }
  function* entriesFromString(value) {
    if (value === "") {
      return;
    }
    const keyValuePairs = value.split(",");
    for (const keyValue of keyValuePairs) {
      const [key, value2] = keyValue.split(/:(.*)/);
      if (value2 == null) {
        throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
      }
      yield [key, value2];
    }
  }

  class CaseInsensitiveMap extends Map {
    constructor(entries = []) {
      super(entries.map(([k, v]) => [k.toLowerCase(), v]));
    }
    has(k) {
      return super.has(k.toLowerCase());
    }
    get(k) {
      return super.get(k.toLowerCase());
    }
    set(k, v) {
      return super.set(k.toLowerCase(), v);
    }
    delete(k) {
      return super.delete(k.toLowerCase());
    }
  }
  function parseOptions(uri2, mongoClient = undefined, options = {}) {
    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
      options = mongoClient;
      mongoClient = undefined;
    }
    if (options.useBigInt64 && typeof options.promoteLongs === "boolean" && !options.promoteLongs) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    if (options.useBigInt64 && typeof options.promoteValues === "boolean" && !options.promoteValues) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    const url = new mongodb_connection_string_url_1.default(uri2);
    const { hosts, isSRV } = url;
    const mongoOptions = Object.create(null);
    mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
    const urlOptions = new CaseInsensitiveMap;
    if (url.pathname !== "/" && url.pathname !== "") {
      const dbName = decodeURIComponent(url.pathname[0] === "/" ? url.pathname.slice(1) : url.pathname);
      if (dbName) {
        urlOptions.set("dbName", [dbName]);
      }
    }
    if (url.username !== "") {
      const auth = {
        username: decodeURIComponent(url.username)
      };
      if (typeof url.password === "string") {
        auth.password = decodeURIComponent(url.password);
      }
      urlOptions.set("auth", [auth]);
    }
    for (const key of url.searchParams.keys()) {
      const values = url.searchParams.getAll(key);
      const isReadPreferenceTags = /readPreferenceTags/i.test(key);
      if (!isReadPreferenceTags && values.length > 1) {
        throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
      }
      if (!isReadPreferenceTags && values.includes("")) {
        throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
      }
      if (!urlOptions.has(key)) {
        urlOptions.set(key, values);
      }
    }
    const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null));
    if (urlOptions.has("serverApi")) {
      throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
    }
    const uriMechanismProperties = urlOptions.get("authMechanismProperties");
    if (uriMechanismProperties) {
      for (const property of uriMechanismProperties) {
        if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
          throw new error_1.MongoParseError("Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.");
        }
      }
    }
    if (objectOptions.has("loadBalanced")) {
      throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
    }
    const allProvidedOptions = new CaseInsensitiveMap;
    const allProvidedKeys = new Set([...urlOptions.keys(), ...objectOptions.keys()]);
    for (const key of allProvidedKeys) {
      const values = [];
      const objectOptionValue = objectOptions.get(key);
      if (objectOptionValue != null) {
        values.push(objectOptionValue);
      }
      const urlValues = urlOptions.get(key) ?? [];
      values.push(...urlValues);
      allProvidedOptions.set(key, values);
    }
    if (allProvidedOptions.has("tls") || allProvidedOptions.has("ssl")) {
      const tlsAndSslOpts = (allProvidedOptions.get("tls") || []).concat(allProvidedOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
      if (new Set(tlsAndSslOpts).size !== 1) {
        throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
      }
    }
    checkTLSOptions(allProvidedOptions);
    const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map((s) => s.toLowerCase()));
    if (unsupportedOptions.size !== 0) {
      const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
      const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
      throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
    }
    for (const [key, descriptor] of Object.entries(exports.OPTIONS)) {
      const values = allProvidedOptions.get(key);
      if (!values || values.length === 0) {
        if (exports.DEFAULT_OPTIONS.has(key)) {
          setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
        }
      } else {
        const { deprecated } = descriptor;
        if (deprecated) {
          const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
          (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
        }
        setOption(mongoOptions, key, descriptor, values);
      }
    }
    if (mongoOptions.credentials) {
      const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
      const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
      const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
      const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
      if ((isGssapi || isX509) && allProvidedOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
        throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '$external'`);
      }
      if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has("authSource")) {
        mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
          source: mongoOptions.dbName
        });
      }
      if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
        throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
      }
      mongoOptions.credentials.validate();
      if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
        delete mongoOptions.credentials;
      }
    }
    if (!mongoOptions.dbName) {
      mongoOptions.dbName = "test";
    }
    validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
    if (mongoClient && mongoOptions.autoEncryption) {
      encrypter_1.Encrypter.checkForMongoCrypt();
      mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri2, options);
      mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
    }
    mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
    mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
    if (isSRV) {
      mongoOptions.srvHost = hosts[0];
      if (mongoOptions.directConnection) {
        throw new error_1.MongoAPIError("SRV URI does not support directConnection");
      }
      if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
      }
      const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
      const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
      if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
        mongoOptions.tls = true;
      }
    } else {
      const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
      if (userSpecifiedSrvOptions) {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
      }
    }
    if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
      throw new error_1.MongoParseError("directConnection option requires exactly one host");
    }
    if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
      throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
    }
    if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
      throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
    }
    const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => urlOptions.get(key) ?? []);
    if (proxyOptions.some((options2) => options2.length > 1)) {
      throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
    }
    mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions({
      MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
      MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
      MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
      MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
      MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT,
      MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
      MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
      MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH
    }, {
      mongodbLogPath: mongoOptions.mongodbLogPath,
      mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
      mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
    });
    mongoOptions.additionalDriverInfo = [];
    mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
    mongoOptions.extendedMetadata = (0, client_metadata_1.addContainerMetadata)(mongoOptions.metadata).then(undefined, utils_1.squashError);
    return mongoOptions;
  }
  function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
    if (mongoOptions.loadBalanced) {
      if (hosts.length > 1) {
        throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
      }
      if (mongoOptions.replicaSet) {
        throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
      }
      if (mongoOptions.directConnection) {
        throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
      }
      if (isSrv && mongoOptions.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
      }
    }
    return;
  }
  function setOption(mongoOptions, key, descriptor, values) {
    const { target, type, transform: transform2 } = descriptor;
    const name = target ?? key;
    switch (type) {
      case "boolean":
        mongoOptions[name] = getBoolean(name, values[0]);
        break;
      case "int":
        mongoOptions[name] = getIntFromOptions(name, values[0]);
        break;
      case "uint":
        mongoOptions[name] = getUIntFromOptions(name, values[0]);
        break;
      case "string":
        if (values[0] == null) {
          break;
        }
        mongoOptions[name] = String(values[0]);
        break;
      case "record":
        if (!(0, utils_1.isRecord)(values[0])) {
          throw new error_1.MongoParseError(`${name} must be an object`);
        }
        mongoOptions[name] = values[0];
        break;
      case "any":
        mongoOptions[name] = values[0];
        break;
      default: {
        if (!transform2) {
          throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
        }
        const transformValue = transform2({ name, options: mongoOptions, values });
        mongoOptions[name] = transformValue;
        break;
      }
    }
  }
  exports.OPTIONS = {
    appName: {
      type: "string"
    },
    auth: {
      target: "credentials",
      transform({ name, options, values: [value] }) {
        if (!(0, utils_1.isRecord)(value, ["username", "password"])) {
          throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          username: value.username,
          password: value.password
        });
      }
    },
    authMechanism: {
      target: "credentials",
      transform({ options, values: [value] }) {
        const mechanisms = Object.values(providers_1.AuthMechanism);
        const [mechanism] = mechanisms.filter((m2) => m2.match(RegExp(String.raw`\b${value}\b`, "i")));
        if (!mechanism) {
          throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
        }
        let source = options.credentials?.source;
        if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
          source = "$external";
        }
        let password = options.credentials?.password;
        if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
          password = undefined;
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanism,
          source,
          password
        });
      }
    },
    authMechanismProperties: {
      target: "credentials",
      transform({ options, values }) {
        let mechanismProperties = Object.create(null);
        for (const optionValue of values) {
          if (typeof optionValue === "string") {
            for (const [key, value] of entriesFromString(optionValue)) {
              try {
                mechanismProperties[key] = getBoolean(key, value);
              } catch {
                mechanismProperties[key] = value;
              }
            }
          } else {
            if (!(0, utils_1.isRecord)(optionValue)) {
              throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
            }
            mechanismProperties = { ...optionValue };
          }
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanismProperties
        });
      }
    },
    authSource: {
      target: "credentials",
      transform({ options, values: [value] }) {
        const source = String(value);
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
      }
    },
    autoEncryption: {
      type: "record"
    },
    autoSelectFamily: {
      type: "boolean",
      default: true
    },
    autoSelectFamilyAttemptTimeout: {
      type: "uint"
    },
    bsonRegExp: {
      type: "boolean"
    },
    serverApi: {
      target: "serverApi",
      transform({ values: [version] }) {
        const serverApiToValidate = typeof version === "string" ? { version } : version;
        const versionToValidate = serverApiToValidate && serverApiToValidate.version;
        if (!versionToValidate) {
          throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        if (!Object.values(mongo_client_1.ServerApiVersion).some((v) => v === versionToValidate)) {
          throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        return serverApiToValidate;
      }
    },
    checkKeys: {
      type: "boolean"
    },
    compressors: {
      default: "none",
      target: "compressors",
      transform({ values }) {
        const compressionList = new Set;
        for (const compVal of values) {
          const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
          if (!Array.isArray(compValArray)) {
            throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
          }
          for (const c of compValArray) {
            if (Object.keys(compression_1.Compressor).includes(String(c))) {
              compressionList.add(String(c));
            } else {
              throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
            }
          }
        }
        return [...compressionList];
      }
    },
    connectTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    dbName: {
      type: "string"
    },
    directConnection: {
      default: false,
      type: "boolean"
    },
    driverInfo: {
      default: {},
      type: "record"
    },
    enableUtf8Validation: { type: "boolean", default: true },
    family: {
      transform({ name, values: [value] }) {
        const transformValue = getIntFromOptions(name, value);
        if (transformValue === 4 || transformValue === 6) {
          return transformValue;
        }
        throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
      }
    },
    fieldsAsRaw: {
      type: "record"
    },
    forceServerObjectId: {
      default: false,
      type: "boolean"
    },
    fsync: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            fsync: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
        return wc;
      }
    },
    heartbeatFrequencyMS: {
      default: 1e4,
      type: "uint"
    },
    ignoreUndefined: {
      type: "boolean"
    },
    j: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
        return wc;
      }
    },
    journal: {
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
        return wc;
      }
    },
    loadBalanced: {
      default: false,
      type: "boolean"
    },
    localThresholdMS: {
      default: 15,
      type: "uint"
    },
    maxConnecting: {
      default: 2,
      transform({ name, values: [value] }) {
        const maxConnecting = getUIntFromOptions(name, value);
        if (maxConnecting === 0) {
          throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
        }
        return maxConnecting;
      }
    },
    maxIdleTimeMS: {
      default: 0,
      type: "uint"
    },
    maxPoolSize: {
      default: 100,
      type: "uint"
    },
    maxStalenessSeconds: {
      target: "readPreference",
      transform({ name, options, values: [value] }) {
        const maxStalenessSeconds = getUIntFromOptions(name, value);
        if (options.readPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, maxStalenessSeconds }
          });
        } else {
          return new read_preference_1.ReadPreference("secondary", undefined, { maxStalenessSeconds });
        }
      }
    },
    minInternalBufferSize: {
      type: "uint"
    },
    minPoolSize: {
      default: 0,
      type: "uint"
    },
    minHeartbeatFrequencyMS: {
      default: 500,
      type: "uint"
    },
    monitorCommands: {
      default: false,
      type: "boolean"
    },
    name: {
      target: "driverInfo",
      transform({ values: [value], options }) {
        return { ...options.driverInfo, name: String(value) };
      }
    },
    noDelay: {
      default: true,
      type: "boolean"
    },
    pkFactory: {
      default: utils_1.DEFAULT_PK_FACTORY,
      transform({ values: [value] }) {
        if ((0, utils_1.isRecord)(value, ["createPk"]) && typeof value.createPk === "function") {
          return value;
        }
        throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
      }
    },
    promoteBuffers: {
      type: "boolean"
    },
    promoteLongs: {
      type: "boolean"
    },
    promoteValues: {
      type: "boolean"
    },
    useBigInt64: {
      type: "boolean"
    },
    proxyHost: {
      type: "string"
    },
    proxyPassword: {
      type: "string"
    },
    proxyPort: {
      type: "uint"
    },
    proxyUsername: {
      type: "string"
    },
    raw: {
      default: false,
      type: "boolean"
    },
    readConcern: {
      transform({ values: [value], options }) {
        if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ["level"])) {
          return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value });
        }
        throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
      }
    },
    readConcernLevel: {
      target: "readConcern",
      transform({ values: [level], options }) {
        return read_concern_1.ReadConcern.fromOptions({
          ...options.readConcern,
          level
        });
      }
    },
    readPreference: {
      default: read_preference_1.ReadPreference.primary,
      transform({ values: [value], options }) {
        if (value instanceof read_preference_1.ReadPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value },
            ...value
          });
        }
        if ((0, utils_1.isRecord)(value, ["mode"])) {
          const rp = read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value },
            ...value
          });
          if (rp)
            return rp;
          else
            throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
        }
        if (typeof value === "string") {
          const rpOpts = {
            hedge: options.readPreference?.hedge,
            maxStalenessSeconds: options.readPreference?.maxStalenessSeconds
          };
          return new read_preference_1.ReadPreference(value, options.readPreference?.tags, rpOpts);
        }
        throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
      }
    },
    readPreferenceTags: {
      target: "readPreference",
      transform({ values, options }) {
        const tags = Array.isArray(values[0]) ? values[0] : values;
        const readPreferenceTags = [];
        for (const tag of tags) {
          const readPreferenceTag = Object.create(null);
          if (typeof tag === "string") {
            for (const [k, v] of entriesFromString(tag)) {
              readPreferenceTag[k] = v;
            }
          }
          if ((0, utils_1.isRecord)(tag)) {
            for (const [k, v] of Object.entries(tag)) {
              readPreferenceTag[k] = v;
            }
          }
          readPreferenceTags.push(readPreferenceTag);
        }
        return read_preference_1.ReadPreference.fromOptions({
          readPreference: options.readPreference,
          readPreferenceTags
        });
      }
    },
    replicaSet: {
      type: "string"
    },
    retryReads: {
      default: true,
      type: "boolean"
    },
    retryWrites: {
      default: true,
      type: "boolean"
    },
    serializeFunctions: {
      type: "boolean"
    },
    serverMonitoringMode: {
      default: "auto",
      transform({ values: [value] }) {
        if (!Object.values(monitor_1.ServerMonitoringMode).includes(value)) {
          throw new error_1.MongoParseError("serverMonitoringMode must be one of `auto`, `poll`, or `stream`");
        }
        return value;
      }
    },
    serverSelectionTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    servername: {
      type: "string"
    },
    socketTimeoutMS: {
      default: 0,
      type: "uint"
    },
    srvMaxHosts: {
      type: "uint",
      default: 0
    },
    srvServiceName: {
      type: "string",
      default: "mongodb"
    },
    ssl: {
      target: "tls",
      type: "boolean"
    },
    timeoutMS: {
      type: "uint"
    },
    tls: {
      type: "boolean"
    },
    tlsAllowInvalidCertificates: {
      target: "rejectUnauthorized",
      transform({ name, values: [value] }) {
        return !getBoolean(name, value);
      }
    },
    tlsAllowInvalidHostnames: {
      target: "checkServerIdentity",
      transform({ name, values: [value] }) {
        return getBoolean(name, value) ? () => {
          return;
        } : undefined;
      }
    },
    tlsCAFile: {
      type: "string"
    },
    tlsCRLFile: {
      type: "string"
    },
    tlsCertificateKeyFile: {
      type: "string"
    },
    tlsCertificateKeyFilePassword: {
      target: "passphrase",
      type: "any"
    },
    tlsInsecure: {
      transform({ name, options, values: [value] }) {
        const tlsInsecure = getBoolean(name, value);
        if (tlsInsecure) {
          options.checkServerIdentity = () => {
            return;
          };
          options.rejectUnauthorized = false;
        } else {
          options.checkServerIdentity = options.tlsAllowInvalidHostnames ? () => {
            return;
          } : undefined;
          options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
        }
        return tlsInsecure;
      }
    },
    w: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value } });
      }
    },
    waitQueueTimeoutMS: {
      default: 0,
      type: "uint"
    },
    writeConcern: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              ...value
            }
          });
        } else if (value === "majority" || typeof value === "number") {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              w: value
            }
          });
        }
        throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
      }
    },
    wtimeout: {
      deprecated: "Please use wtimeoutMS instead",
      target: "writeConcern",
      transform({ values: [value], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeout: getUIntFromOptions("wtimeout", value)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    wtimeoutMS: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeoutMS: getUIntFromOptions("wtimeoutMS", value)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    zlibCompressionLevel: {
      default: 0,
      type: "int"
    },
    mongodbLogPath: {
      transform({ values: [value] }) {
        if (!(typeof value === "string" && ["stderr", "stdout"].includes(value) || value && typeof value === "object" && ("write" in value) && typeof value.write === "function")) {
          throw new error_1.MongoAPIError(`Option 'mongodbLogPath' must be of type 'stderr' | 'stdout' | MongoDBLogWritable`);
        }
        return value;
      }
    },
    mongodbLogComponentSeverities: {
      transform({ values: [value] }) {
        if (typeof value !== "object" || !value) {
          throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' must be a non-null object`);
        }
        for (const [k, v] of Object.entries(value)) {
          if (typeof v !== "string" || typeof k !== "string") {
            throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' object cannot include a non-string key or value`);
          }
          if (!Object.values(mongo_logger_1.MongoLoggableComponent).some((val) => val === k) && k !== "default") {
            throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' contains invalid key: ${k}`);
          }
          if (!Object.values(mongo_logger_1.SeverityLevel).some((val) => val === v)) {
            throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' does not support ${v} as a value for ${k}`);
          }
        }
        return value;
      }
    },
    mongodbLogMaxDocumentLength: { type: "uint" },
    connectionType: { type: "any" },
    srvPoller: { type: "any" },
    allowPartialTrustChain: { type: "any" },
    minDHSize: { type: "any" },
    pskCallback: { type: "any" },
    secureContext: { type: "any" },
    enableTrace: { type: "any" },
    requestCert: { type: "any" },
    rejectUnauthorized: { type: "any" },
    checkServerIdentity: { type: "any" },
    keepAliveInitialDelay: { type: "any" },
    ALPNProtocols: { type: "any" },
    SNICallback: { type: "any" },
    session: { type: "any" },
    requestOCSP: { type: "any" },
    localAddress: { type: "any" },
    localPort: { type: "any" },
    hints: { type: "any" },
    lookup: { type: "any" },
    ca: { type: "any" },
    cert: { type: "any" },
    ciphers: { type: "any" },
    crl: { type: "any" },
    ecdhCurve: { type: "any" },
    key: { type: "any" },
    passphrase: { type: "any" },
    pfx: { type: "any" },
    secureProtocol: { type: "any" },
    index: { type: "any" },
    useNewUrlParser: {
      type: "boolean",
      deprecated: "useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
    },
    useUnifiedTopology: {
      type: "boolean",
      deprecated: "useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
    },
    __skipPingOnConnect: { type: "boolean" }
  };
  exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d]) => [k, d.default]));
});

// node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBAWS = undefined;
  var BSON = require_bson2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var aws_temporary_credentials_1 = require_aws_temporary_credentials();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var ASCII_N = 110;
  var bsonOptions = {
    useBigInt64: false,
    promoteLongs: true,
    promoteValues: true,
    promoteBuffers: false,
    bsonRegExp: false
  };

  class MongoDBAWS extends auth_provider_1.AuthProvider {
    constructor(credentialProvider) {
      super();
      this.credentialProvider = credentialProvider;
      this.credentialFetcher = aws_temporary_credentials_1.AWSTemporaryCredentialProvider.isAWSSDKInstalled ? new aws_temporary_credentials_1.AWSSDKCredentialProvider(credentialProvider) : new aws_temporary_credentials_1.LegacyAWSTemporaryCredentialProvider;
    }
    async auth(authContext) {
      const { connection } = authContext;
      if (!authContext.credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if ("kModuleError" in deps_1.aws4) {
        throw deps_1.aws4["kModuleError"];
      }
      const { sign } = deps_1.aws4;
      if ((0, utils_1.maxWireVersion)(connection) < 9) {
        throw new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later");
      }
      if (!authContext.credentials.username) {
        authContext.credentials = await makeTempCredentials(authContext.credentials, this.credentialFetcher);
      }
      const { credentials } = authContext;
      const accessKeyId = credentials.username;
      const secretAccessKey = credentials.password;
      const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : undefined;
      const db = credentials.source;
      const nonce = await (0, utils_1.randomBytes)(32);
      const saslStart = {
        saslStart: 1,
        mechanism: "MONGODB-AWS",
        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
      };
      const saslStartResponse = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, undefined);
      const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
      const host = serverResponse.h;
      const serverNonce = serverResponse.s.buffer;
      if (serverNonce.length !== 64) {
        throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
      }
      if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
        throw new error_1.MongoRuntimeError("Server nonce does not begin with client nonce");
      }
      if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
      }
      const body = "Action=GetCallerIdentity&Version=2011-06-15";
      const options = sign({
        method: "POST",
        host,
        region: deriveRegion(serverResponse.h),
        service: "sts",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Content-Length": body.length,
          "X-MongoDB-Server-Nonce": utils_1.ByteUtils.toBase64(serverNonce),
          "X-MongoDB-GS2-CB-Flag": "n"
        },
        path: "/",
        body
      }, awsCredentials);
      const payload = {
        a: options.headers.Authorization,
        d: options.headers["X-Amz-Date"]
      };
      if (sessionToken) {
        payload.t = sessionToken;
      }
      const saslContinue = {
        saslContinue: 1,
        conversationId: saslStartResponse.conversationId,
        payload: BSON.serialize(payload, bsonOptions)
      };
      await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, undefined);
    }
  }
  exports.MongoDBAWS = MongoDBAWS;
  async function makeTempCredentials(credentials, awsCredentialFetcher) {
    function makeMongoCredentialsFromAWSTemp(creds) {
      if (!creds.AccessKeyId || !creds.SecretAccessKey) {
        throw new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials");
      }
      return new mongo_credentials_1.MongoCredentials({
        username: creds.AccessKeyId,
        password: creds.SecretAccessKey,
        source: credentials.source,
        mechanism: providers_1.AuthMechanism.MONGODB_AWS,
        mechanismProperties: {
          AWS_SESSION_TOKEN: creds.Token
        }
      });
    }
    const temporaryCredentials = await awsCredentialFetcher.getCredentials();
    return makeMongoCredentialsFromAWSTemp(temporaryCredentials);
  }
  function deriveRegion(host) {
    const parts = host.split(".");
    if (parts.length === 1 || parts[1] === "amazonaws") {
      return "us-east-1";
    }
    return parts[1];
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/command_builders.js
var require_command_builders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finishCommandDocument = finishCommandDocument;
  exports.startCommandDocument = startCommandDocument;
  var bson_1 = require_bson2();
  var providers_1 = require_providers();
  function finishCommandDocument(token, conversationId) {
    if (conversationId != null) {
      return {
        saslContinue: 1,
        conversationId,
        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
      };
    }
    return {
      saslStart: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
    };
  }
  function startCommandDocument(credentials) {
    const payload = {};
    if (credentials.username) {
      payload.n = credentials.username;
    }
    return {
      saslStart: 1,
      autoAuthorize: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
    };
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js
var require_callback_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallbackWorkflow = exports.AUTOMATED_TIMEOUT_MS = exports.HUMAN_TIMEOUT_MS = undefined;
  var promises_1 = __require("timers/promises");
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_builders_1 = require_command_builders();
  exports.HUMAN_TIMEOUT_MS = 300000;
  exports.AUTOMATED_TIMEOUT_MS = 60000;
  var RESULT_PROPERTIES = ["accessToken", "expiresInSeconds", "refreshToken"];
  var CALLBACK_RESULT_ERROR = "User provided OIDC callbacks must return a valid object with an accessToken.";
  var THROTTLE_MS = 100;

  class CallbackWorkflow {
    constructor(cache, callback) {
      this.cache = cache;
      this.callback = this.withLock(callback);
      this.lastExecutionTime = Date.now() - THROTTLE_MS;
    }
    async speculativeAuth(connection, credentials) {
      if (this.cache.hasAccessToken) {
        const accessToken = this.cache.getAccessToken();
        connection.accessToken = accessToken;
        const document2 = (0, command_builders_1.finishCommandDocument)(accessToken);
        document2.db = credentials.source;
        return { speculativeAuthenticate: document2 };
      }
      return {};
    }
    async reauthenticate(connection, credentials) {
      if (this.cache.hasAccessToken) {
        if (connection.accessToken === this.cache.getAccessToken()) {
          this.cache.removeAccessToken();
          delete connection.accessToken;
        } else {
          connection.accessToken = this.cache.getAccessToken();
        }
      }
      await this.execute(connection, credentials);
    }
    async startAuthentication(connection, credentials, response) {
      let result;
      if (response?.speculativeAuthenticate) {
        result = response.speculativeAuthenticate;
      } else {
        result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), undefined);
      }
      return result;
    }
    async finishAuthentication(connection, credentials, token, conversationId) {
      await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), undefined);
    }
    async executeAndValidateCallback(params) {
      const result = await this.callback(params);
      if (isCallbackResultInvalid(result)) {
        throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
      }
      return result;
    }
    withLock(callback) {
      let lock = Promise.resolve();
      return async (params) => {
        await lock;
        lock = lock.catch(() => null).then(async () => {
          const difference = Date.now() - this.lastExecutionTime;
          if (difference <= THROTTLE_MS) {
            await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });
          }
          this.lastExecutionTime = Date.now();
          return await callback(params);
        });
        return await lock;
      };
    }
  }
  exports.CallbackWorkflow = CallbackWorkflow;
  function isCallbackResultInvalid(tokenResult) {
    if (tokenResult == null || typeof tokenResult !== "object")
      return true;
    if (!("accessToken" in tokenResult))
      return true;
    return !Object.getOwnPropertyNames(tokenResult).every((prop) => RESULT_PROPERTIES.includes(prop));
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/automated_callback_workflow.js
var require_automated_callback_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutomatedCallbackWorkflow = undefined;
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var callback_workflow_1 = require_callback_workflow();

  class AutomatedCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {
    constructor(cache, callback) {
      super(cache, callback);
    }
    async execute(connection, credentials) {
      if (this.cache.hasAccessToken) {
        const token = this.cache.getAccessToken();
        if (!connection.accessToken) {
          connection.accessToken = token;
        }
        try {
          return await this.finishAuthentication(connection, credentials, token);
        } catch (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
            this.cache.removeAccessToken();
            return await this.execute(connection, credentials);
          } else {
            throw error;
          }
        }
      }
      const response = await this.fetchAccessToken(credentials);
      this.cache.put(response);
      connection.accessToken = response.accessToken;
      await this.finishAuthentication(connection, credentials, response.accessToken);
    }
    async fetchAccessToken(credentials) {
      const controller = new AbortController;
      const params = {
        timeoutContext: controller.signal,
        version: mongodb_oidc_1.OIDC_VERSION
      };
      if (credentials.username) {
        params.username = credentials.username;
      }
      if (credentials.mechanismProperties.TOKEN_RESOURCE) {
        params.tokenAudience = credentials.mechanismProperties.TOKEN_RESOURCE;
      }
      const timeout = timeout_1.Timeout.expires(callback_workflow_1.AUTOMATED_TIMEOUT_MS);
      try {
        return await Promise.race([this.executeAndValidateCallback(params), timeout]);
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          controller.abort();
          throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.AUTOMATED_TIMEOUT_MS}ms.`);
        }
        throw error;
      } finally {
        timeout.clear();
      }
    }
  }
  exports.AutomatedCallbackWorkflow = AutomatedCallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_machine_workflow.js
var require_azure_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callback = undefined;
  var azure_1 = require_azure();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var AZURE_HEADERS = Object.freeze({ Metadata: "true", Accept: "application/json" });
  var ENDPOINT_RESULT_ERROR = "Azure endpoint did not return a value with only access_token and expires_in properties";
  var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.";
  var callback = async (params) => {
    const tokenAudience = params.tokenAudience;
    const username = params.username;
    if (!tokenAudience) {
      throw new error_1.MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);
    }
    const response = await getAzureTokenData(tokenAudience, username);
    if (!isEndpointResultValid(response)) {
      throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
    }
    return response;
  };
  exports.callback = callback;
  async function getAzureTokenData(tokenAudience, username) {
    const url = new URL(azure_1.AZURE_BASE_URL);
    (0, azure_1.addAzureParams)(url, tokenAudience, username);
    const response = await (0, utils_1.get)(url, {
      headers: AZURE_HEADERS
    });
    if (response.status !== 200) {
      throw new error_1.MongoAzureError(`Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`);
    }
    const result = JSON.parse(response.body);
    return {
      accessToken: result.access_token,
      expiresInSeconds: Number(result.expires_in)
    };
  }
  function isEndpointResultValid(token) {
    if (token == null || typeof token !== "object")
      return false;
    return "accessToken" in token && typeof token.accessToken === "string" && "expiresInSeconds" in token && typeof token.expiresInSeconds === "number";
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/gcp_machine_workflow.js
var require_gcp_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callback = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var GCP_BASE_URL = "http://metadata/computeMetadata/v1/instance/service-accounts/default/identity";
  var GCP_HEADERS = Object.freeze({ "Metadata-Flavor": "Google" });
  var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.";
  var callback = async (params) => {
    const tokenAudience = params.tokenAudience;
    if (!tokenAudience) {
      throw new error_1.MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);
    }
    return await getGcpTokenData(tokenAudience);
  };
  exports.callback = callback;
  async function getGcpTokenData(tokenAudience) {
    const url = new URL(GCP_BASE_URL);
    url.searchParams.append("audience", tokenAudience);
    const response = await (0, utils_1.get)(url, {
      headers: GCP_HEADERS
    });
    if (response.status !== 200) {
      throw new error_1.MongoGCPError(`Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`);
    }
    return { accessToken: response.body };
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/k8s_machine_workflow.js
var require_k8s_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callback = undefined;
  var promises_1 = __require("fs/promises");
  var FALLBACK_FILENAME = "/var/run/secrets/kubernetes.io/serviceaccount/token";
  var AZURE_FILENAME = "AZURE_FEDERATED_TOKEN_FILE";
  var AWS_FILENAME = "AWS_WEB_IDENTITY_TOKEN_FILE";
  var callback = async () => {
    let filename;
    if (process.env[AZURE_FILENAME]) {
      filename = process.env[AZURE_FILENAME];
    } else if (process.env[AWS_FILENAME]) {
      filename = process.env[AWS_FILENAME];
    } else {
      filename = FALLBACK_FILENAME;
    }
    const token = await (0, promises_1.readFile)(filename, "utf8");
    return { accessToken: token };
  };
  exports.callback = callback;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_cache.js
var require_token_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenCache = undefined;
  var error_1 = require_error();

  class MongoOIDCError extends error_1.MongoDriverError {
  }

  class TokenCache {
    get hasAccessToken() {
      return !!this.accessToken;
    }
    get hasRefreshToken() {
      return !!this.refreshToken;
    }
    get hasIdpInfo() {
      return !!this.idpInfo;
    }
    getAccessToken() {
      if (!this.accessToken) {
        throw new MongoOIDCError("Attempted to get an access token when none exists.");
      }
      return this.accessToken;
    }
    getRefreshToken() {
      if (!this.refreshToken) {
        throw new MongoOIDCError("Attempted to get a refresh token when none exists.");
      }
      return this.refreshToken;
    }
    getIdpInfo() {
      if (!this.idpInfo) {
        throw new MongoOIDCError("Attempted to get IDP information when none exists.");
      }
      return this.idpInfo;
    }
    put(response, idpInfo) {
      this.accessToken = response.accessToken;
      this.refreshToken = response.refreshToken;
      this.expiresInSeconds = response.expiresInSeconds;
      if (idpInfo) {
        this.idpInfo = idpInfo;
      }
    }
    removeAccessToken() {
      this.accessToken = undefined;
    }
    removeRefreshToken() {
      this.refreshToken = undefined;
    }
  }
  exports.TokenCache = TokenCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_machine_workflow.js
var require_token_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callback = undefined;
  var fs = __require("fs");
  var error_1 = require_error();
  var TOKEN_MISSING_ERROR = "OIDC_TOKEN_FILE must be set in the environment.";
  var callback = async () => {
    const tokenFile = process.env.OIDC_TOKEN_FILE;
    if (!tokenFile) {
      throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
    }
    const token = await fs.promises.readFile(tokenFile, "utf8");
    return { accessToken: token };
  };
  exports.callback = callback;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js
var require_mongodb_oidc = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = exports.OIDC_VERSION = undefined;
  var error_1 = require_error();
  var auth_provider_1 = require_auth_provider();
  var automated_callback_workflow_1 = require_automated_callback_workflow();
  var azure_machine_workflow_1 = require_azure_machine_workflow();
  var gcp_machine_workflow_1 = require_gcp_machine_workflow();
  var k8s_machine_workflow_1 = require_k8s_machine_workflow();
  var token_cache_1 = require_token_cache();
  var token_machine_workflow_1 = require_token_machine_workflow();
  var MISSING_CREDENTIALS_ERROR = "AuthContext must provide credentials.";
  exports.OIDC_VERSION = 1;
  exports.OIDC_WORKFLOWS = new Map;
  exports.OIDC_WORKFLOWS.set("test", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache, token_machine_workflow_1.callback));
  exports.OIDC_WORKFLOWS.set("azure", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache, azure_machine_workflow_1.callback));
  exports.OIDC_WORKFLOWS.set("gcp", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache, gcp_machine_workflow_1.callback));
  exports.OIDC_WORKFLOWS.set("k8s", () => new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache, k8s_machine_workflow_1.callback));

  class MongoDBOIDC extends auth_provider_1.AuthProvider {
    constructor(workflow) {
      super();
      if (!workflow) {
        throw new error_1.MongoInvalidArgumentError("No workflow provided to the OIDC auth provider.");
      }
      this.workflow = workflow;
    }
    async auth(authContext) {
      const { connection, reauthenticating, response } = authContext;
      if (response?.speculativeAuthenticate?.done && !reauthenticating) {
        return;
      }
      const credentials = getCredentials(authContext);
      if (reauthenticating) {
        await this.workflow.reauthenticate(connection, credentials);
      } else {
        await this.workflow.execute(connection, credentials, response);
      }
    }
    async prepare(handshakeDoc, authContext) {
      const { connection } = authContext;
      const credentials = getCredentials(authContext);
      const result = await this.workflow.speculativeAuth(connection, credentials);
      return { ...handshakeDoc, ...result };
    }
  }
  exports.MongoDBOIDC = MongoDBOIDC;
  function getCredentials(authContext) {
    const { credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
    }
    return credentials;
  }
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js
var require_human_callback_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HumanCallbackWorkflow = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var callback_workflow_1 = require_callback_workflow();

  class HumanCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {
    constructor(cache, callback) {
      super(cache, callback);
    }
    async execute(connection, credentials) {
      if (this.cache.hasAccessToken) {
        const token = this.cache.getAccessToken();
        connection.accessToken = token;
        try {
          return await this.finishAuthentication(connection, credentials, token);
        } catch (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
            this.cache.removeAccessToken();
            delete connection.accessToken;
            return await this.execute(connection, credentials);
          } else {
            throw error;
          }
        }
      }
      if (this.cache.hasRefreshToken) {
        const refreshToken = this.cache.getRefreshToken();
        const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);
        this.cache.put(result);
        connection.accessToken = result.accessToken;
        try {
          return await this.finishAuthentication(connection, credentials, result.accessToken);
        } catch (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
            this.cache.removeRefreshToken();
            delete connection.accessToken;
            return await this.execute(connection, credentials);
          } else {
            throw error;
          }
        }
      }
      const startResponse = await this.startAuthentication(connection, credentials);
      const conversationId = startResponse.conversationId;
      const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);
      const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);
      this.cache.put(callbackResponse, idpInfo);
      connection.accessToken = callbackResponse.accessToken;
      return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);
    }
    async fetchAccessToken(idpInfo, credentials, refreshToken) {
      const controller = new AbortController;
      const params = {
        timeoutContext: controller.signal,
        version: mongodb_oidc_1.OIDC_VERSION,
        idpInfo
      };
      if (credentials.username) {
        params.username = credentials.username;
      }
      if (refreshToken) {
        params.refreshToken = refreshToken;
      }
      const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);
      try {
        return await Promise.race([this.executeAndValidateCallback(params), timeout]);
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          controller.abort();
          throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);
        }
        throw error;
      } finally {
        timeout.clear();
      }
    }
  }
  exports.HumanCallbackWorkflow = HumanCallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Plain = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class Plain extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const { username, password } = credentials;
      const payload = new bson_1.Binary(Buffer.from(`\x00${username}\x00${password}`));
      const command = {
        saslStart: 1,
        mechanism: "PLAIN",
        payload,
        autoAuthorize: 1
      };
      await connection.command((0, utils_1.ns)("$external.$cmd"), command, undefined);
    }
  }
  exports.Plain = Plain;
});

// node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var getCodePoint = (character) => character.codePointAt(0);
  var first = (x) => x[0];
  var last = (x) => x[x.length - 1];
  function toCodePoints(input) {
    const codepoints = [];
    const size = input.length;
    for (let i = 0;i < size; i += 1) {
      const before = input.charCodeAt(i);
      if (before >= 55296 && before <= 56319 && size > i + 1) {
        const next = input.charCodeAt(i + 1);
        if (next >= 56320 && next <= 57343) {
          codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
          i += 1;
          continue;
        }
      }
      codepoints.push(before);
    }
    return codepoints;
  }
  function saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l }, input, opts = {}) {
    const mapping2space = non_ASCII_space_characters;
    const mapping2nothing = commonly_mapped_to_nothing;
    if (typeof input !== "string") {
      throw new TypeError("Expected string.");
    }
    if (input.length === 0) {
      return "";
    }
    const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
    const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
    const normalized_map = toCodePoints(normalized_input);
    const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
    if (hasProhibited) {
      throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
    }
    if (opts.allowUnassigned !== true) {
      const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
      if (hasUnassigned) {
        throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
      }
    }
    const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
    const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
    if (hasBidiRAL && hasBidiL) {
      throw new Error("String must not contain RandALCat and LCat at the same time," + " see https://tools.ietf.org/html/rfc3454#section-6");
    }
    const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
    const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
      throw new Error("Bidirectional RandALCat character must be the first and the last" + " character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
    }
    return normalized_input;
  }
  saslprep.saslprep = saslprep;
  saslprep.default = saslprep;
  module.exports = saslprep;
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS((exports, module) => {
  module.exports = Pager;
  function Pager(pageSize, opts) {
    if (!(this instanceof Pager))
      return new Pager(pageSize, opts);
    this.length = 0;
    this.updates = [];
    this.path = new Uint16Array(4);
    this.pages = new Array(32768);
    this.maxPages = this.pages.length;
    this.level = 0;
    this.pageSize = pageSize || 1024;
    this.deduplicate = opts ? opts.deduplicate : null;
    this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
  }
  Pager.prototype.updated = function(page) {
    while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
      page.deduplicate++;
      if (page.deduplicate === this.deduplicate.length) {
        page.deduplicate = 0;
        if (page.buffer.equals && page.buffer.equals(this.deduplicate))
          page.buffer = this.deduplicate;
        break;
      }
    }
    if (page.updated || !this.updates)
      return;
    page.updated = true;
    this.updates.push(page);
  };
  Pager.prototype.lastUpdate = function() {
    if (!this.updates || !this.updates.length)
      return null;
    var page = this.updates.pop();
    page.updated = false;
    return page;
  };
  Pager.prototype._array = function(i, noAllocate) {
    if (i >= this.maxPages) {
      if (noAllocate)
        return;
      grow(this, i);
    }
    factor(i, this.path);
    var arr = this.pages;
    for (var j = this.level;j > 0; j--) {
      var p = this.path[j];
      var next = arr[p];
      if (!next) {
        if (noAllocate)
          return;
        next = arr[p] = new Array(32768);
      }
      arr = next;
    }
    return arr;
  };
  Pager.prototype.get = function(i, noAllocate) {
    var arr = this._array(i, noAllocate);
    var first = this.path[0];
    var page = arr && arr[first];
    if (!page && !noAllocate) {
      page = arr[first] = new Page(i, alloc(this.pageSize));
      if (i >= this.length)
        this.length = i + 1;
    }
    if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
      page.buffer = copy(page.buffer);
      page.deduplicate = 0;
    }
    return page;
  };
  Pager.prototype.set = function(i, buf) {
    var arr = this._array(i, false);
    var first = this.path[0];
    if (i >= this.length)
      this.length = i + 1;
    if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
      arr[first] = undefined;
      return;
    }
    if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
      buf = this.deduplicate;
    }
    var page = arr[first];
    var b = truncate(buf, this.pageSize);
    if (page)
      page.buffer = b;
    else
      arr[first] = new Page(i, b);
  };
  Pager.prototype.toBuffer = function() {
    var list = new Array(this.length);
    var empty = alloc(this.pageSize);
    var ptr = 0;
    while (ptr < list.length) {
      var arr = this._array(ptr, true);
      for (var i = 0;i < 32768 && ptr < list.length; i++) {
        list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
      }
    }
    return Buffer.concat(list);
  };
  function grow(pager, index) {
    while (pager.maxPages < index) {
      var old = pager.pages;
      pager.pages = new Array(32768);
      pager.pages[0] = old;
      pager.level++;
      pager.maxPages *= 32768;
    }
  }
  function truncate(buf, len) {
    if (buf.length === len)
      return buf;
    if (buf.length > len)
      return buf.slice(0, len);
    var cpy = alloc(len);
    buf.copy(cpy);
    return cpy;
  }
  function alloc(size) {
    if (Buffer.alloc)
      return Buffer.alloc(size);
    var buf = new Buffer(size);
    buf.fill(0);
    return buf;
  }
  function copy(buf) {
    var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
    buf.copy(cpy);
    return cpy;
  }
  function Page(i, buf) {
    this.offset = i * buf.length;
    this.buffer = buf;
    this.updated = false;
    this.deduplicate = 0;
  }
  function factor(n2, out) {
    n2 = (n2 - (out[0] = n2 & 32767)) / 32768;
    n2 = (n2 - (out[1] = n2 & 32767)) / 32768;
    out[3] = (n2 - (out[2] = n2 & 32767)) / 32768 & 32767;
  }
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS((exports, module) => {
  var pager = require_memory_pager();
  module.exports = Bitfield;
  function Bitfield(opts) {
    if (!(this instanceof Bitfield))
      return new Bitfield(opts);
    if (!opts)
      opts = {};
    if (Buffer.isBuffer(opts))
      opts = { buffer: opts };
    this.pageOffset = opts.pageOffset || 0;
    this.pageSize = opts.pageSize || 1024;
    this.pages = opts.pages || pager(this.pageSize);
    this.byteLength = this.pages.length * this.pageSize;
    this.length = 8 * this.byteLength;
    if (!powerOfTwo(this.pageSize))
      throw new Error("The page size should be a power of two");
    this._trackUpdates = !!opts.trackUpdates;
    this._pageMask = this.pageSize - 1;
    if (opts.buffer) {
      for (var i = 0;i < opts.buffer.length; i += this.pageSize) {
        this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
      }
      this.byteLength = opts.buffer.length;
      this.length = 8 * this.byteLength;
    }
  }
  Bitfield.prototype.get = function(i) {
    var o = i & 7;
    var j = (i - o) / 8;
    return !!(this.getByte(j) & 128 >> o);
  };
  Bitfield.prototype.getByte = function(i) {
    var o = i & this._pageMask;
    var j = (i - o) / this.pageSize;
    var page = this.pages.get(j, true);
    return page ? page.buffer[o + this.pageOffset] : 0;
  };
  Bitfield.prototype.set = function(i, v) {
    var o = i & 7;
    var j = (i - o) / 8;
    var b = this.getByte(j);
    return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
  };
  Bitfield.prototype.toBuffer = function() {
    var all = alloc(this.pages.length * this.pageSize);
    for (var i = 0;i < this.pages.length; i++) {
      var next = this.pages.get(i, true);
      var allOffset = i * this.pageSize;
      if (next)
        next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
    }
    return all;
  };
  Bitfield.prototype.setByte = function(i, b) {
    var o = i & this._pageMask;
    var j = (i - o) / this.pageSize;
    var page = this.pages.get(j, false);
    o += this.pageOffset;
    if (page.buffer[o] === b)
      return false;
    page.buffer[o] = b;
    if (i >= this.byteLength) {
      this.byteLength = i + 1;
      this.length = this.byteLength * 8;
    }
    if (this._trackUpdates)
      this.pages.updated(page);
    return true;
  };
  function alloc(n2) {
    if (Buffer.alloc)
      return Buffer.alloc(n2);
    var b = new Buffer(n2);
    b.fill(0);
    return b;
  }
  function powerOfTwo(x) {
    return !(x & x - 1);
  }
});

// node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMemoryCodePoints = createMemoryCodePoints;
  var sparse_bitfield_1 = __importDefault(require_sparse_bitfield());
  function createMemoryCodePoints(data) {
    let offset = 0;
    function read() {
      const size = data.readUInt32BE(offset);
      offset += 4;
      const codepoints = data.slice(offset, offset + size);
      offset += size;
      return (0, sparse_bitfield_1.default)({ buffer: codepoints });
    }
    const unassigned_code_points = read();
    const commonly_mapped_to_nothing = read();
    const non_ASCII_space_characters = read();
    const prohibited_characters = read();
    const bidirectional_r_al = read();
    const bidirectional_l = read();
    return {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
});

// node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var zlib_1 = __require("zlib");
  exports.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcaRkA4LemO9Mhxm0FITnE9Cwr4jHgwgZ22B6YywqCJ0HQg5CL4sGTuOjCtGSF4CkHEW856MlTQHD3EJnWkU0Owh5VxE3LHlYQdNxd2U6mU59UV/d09fw4M2EySSXPAzNdP1/9fX/99bzVNZEN4jisRDulVFnQmLxm1aXF9Id/2/xMxNJ4XZlg576yuYlGt9gupV6xoFf8jhu9YvulVrFlp5XSx+lfvYhORGPXvqIRWSxERKtIm8bKFd10WNfKDS5Fo9jJWrq2+M2IlW+8uHgl/+BsROfPF4v5L7148Ur68Sha6dqZpYiVVy8tvLCWXo80Sf/lS89dGX2wHGvpzoXVn75/YWH5wmqe8uika82ViJXTy83Ve2k5Urozm38wm4/ls6t5uT6yfsTSJ7J3T0VKt8c5ExEXI8aFkH729c3eT+7EC6ca8cVULZUiYacX0R5PNWNxlh9L1y90q5kyzrpyy+9WcvOV6URntqw7La9sNVstXyczWVaWYbaaTYqzOHpr7pyiNT3/YzKuT63Z/FqKZlFTiuXtFM2vVOtIq7jiyKJbWZaOWD0euz0yoV2Z7kY0xq2x0YhfzVpmM5px9nTEH7JZ0ot5u39p0ma75Z472/s/H+2yr2inYyuq7fMvJivH2rM72N/Z3lyL31F2b1ya1P0zn816k2KP6JU9UzseucdQH5YqVeH/lFajSN2udg+TLJ9rksNxlvV2lki19rXKI43TPLejFu4ov7k3nMbhyhfY3Xb37f8BAGCf0eMTOH5szf154KmnNgKcnLb+Fzi2AfXktbN7fJelwTAiO/W5uQ2KINXRYu+znqo/WTAdLadURHmy3qciazd3bra4T3w16/f7t7Ms9U5gfJu10955sx1r3vmhBAAAAAAAgId20J1iZbDowNvIjuH427Gr5l/eiC+8OplZON8sVjx/qr9y+Pj+YRItT+NqAM+kkZs3AAAAAID6yfx1FwCAI97/dCh1/ub6SA0AAAAAAAAAgNoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hutp5SiQpYAAAAAAAAAQO2MIpZiT804flnAE2fhwjOeAZXr76kOAAAAAAAA8FjNf4N/l0NE3U/vuVQskLpSd4/Yh2xu9xTu0tFeeNYsLI2f/VMdNxTzj6Je9E/+6pp6Nn3awW3A54goe4Bss6v+PGsjQGMAAAAAAOBp5XEgwH6e7J7rwEQHRb/XvAMAAAAAAAA8yzoDeQDwVGjIAgAAAAAAAACoPfF/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqL/GSkSkClkCAAAAAAAAALXTSAAAAAAAAABA3Y1kAQAAAAAAAADUX8RSXZ9dsHC9+M8Fg2Ex/em1lAZpEBGttcrVjZqLEa+k0XpKw9mG4zWx4ukPUMhkAQAAAAAAABzBqbSe3//rXOS9HxGdo4TqR2XkutCdBu+LaPZw/lBbO7cbHnh2C7N7AIo4evEznllqLqWUp/LnYOtpM2bnOH66wI1+9GO4sOuISwv/TOlumu56FDv3NZhc4mR9v7zYIrafr40j/Cccvj9Xns3t3mu99E7qxUv3bqS0/ouNH/08++RGemfQ+nsx/5uNXsQPGulynPvv3ZTW37zd+1ovrqaYpP/122X6Xpx779Z3zr/3YOPKW1lkaRDf31pPaf3j/msRsVGkL+d/f+/m4sJsPm1cfSsr16e8m9Ldj/KsnyIuR3nXw83Is3EhxLd/2V773ks3m/cj/THKUummdP9qKhIOImuOU0Xjwb3y+oqt735rpTetVbF9n8R4x9crRfO77TKqVOZpDclv5bfK18lMnk+q0K18UpxF/RrGXE0Zxtqx3tWSj+vxbL4XaasfKb0dRbtLW73JsfPGg177H+OmGKlfvS1msllt7JEJm9XOJqXR+Fkfo1H66uy5H1v3Xx5+uJmGLw9jro2u7Loj4PnuR6+f+e3d261+eazNhzrL7X83MohoHpS4PddV8ki1it61//pw1g7z6p1U/26Nm2llST57B5rUvuG0XqSU/rPd7jYrqWcbd+beJQ77BgPMDwn37/8BAGCf0eMTOH4cPlufv9VGgJOzqf8Fjm1APXkd7B7f5dF57GPMaWy/MTvjvNvtXj6h8W2+GXvnzXaseeeHEgAAAAAAAB7aQXeKlcGiadBoEOeLb2dtpGOL2MyOtf391a3P/zD96c3JzIP3t4oV797vrh8+vn+YRL5bBuj/AQAAAABqJvfHXQAAHkX82zfXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeAgkAAAAAAAAAqLuRLAAAAAAAAACA2hv9D1iu/VAYaAYA", "base64"));
});

// node_modules/@mongodb-js/saslprep/dist/node.js
var require_node2 = __commonJS((exports, module) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var index_1 = __importDefault(require_dist2());
  var memory_code_points_1 = require_memory_code_points();
  var code_points_data_1 = __importDefault(require_code_points_data());
  var codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
  function saslprep(input, opts) {
    return (0, index_1.default)(codePoints, input, opts);
  }
  saslprep.saslprep = saslprep;
  saslprep.default = saslprep;
  module.exports = saslprep;
});

// node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScramSHA256 = exports.ScramSHA1 = undefined;
  var saslprep_1 = require_node2();
  var crypto2 = __require("crypto");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var providers_1 = require_providers();

  class ScramSHA extends auth_provider_1.AuthProvider {
    constructor(cryptoMethod) {
      super();
      this.cryptoMethod = cryptoMethod || "sha1";
    }
    async prepare(handshakeDoc, authContext) {
      const cryptoMethod = this.cryptoMethod;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const nonce = await (0, utils_1.randomBytes)(24);
      authContext.nonce = nonce;
      const request = {
        ...handshakeDoc,
        speculativeAuthenticate: {
          ...makeFirstMessage(cryptoMethod, credentials, nonce),
          db: credentials.source
        }
      };
      return request;
    }
    async auth(authContext) {
      const { reauthenticating, response } = authContext;
      if (response?.speculativeAuthenticate && !reauthenticating) {
        return await continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
      }
      return await executeScram(this.cryptoMethod, authContext);
    }
  }
  function cleanUsername(username) {
    return username.replace("=", "=3D").replace(",", "=2C");
  }
  function clientFirstMessageBare(username, nonce) {
    return Buffer.concat([
      Buffer.from("n=", "utf8"),
      Buffer.from(username, "utf8"),
      Buffer.from(",r=", "utf8"),
      Buffer.from(nonce.toString("base64"), "utf8")
    ]);
  }
  function makeFirstMessage(cryptoMethod, credentials, nonce) {
    const username = cleanUsername(credentials.username);
    const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
    return {
      saslStart: 1,
      mechanism,
      payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
      autoAuthorize: 1,
      options: { skipEmptyExchange: true }
    };
  }
  async function executeScram(cryptoMethod, authContext) {
    const { connection, credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
    const response = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStartCmd, undefined);
    await continueScramConversation(cryptoMethod, response, authContext);
  }
  async function continueScramConversation(cryptoMethod, response, authContext) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const username = cleanUsername(credentials.username);
    const password = credentials.password;
    const processedPassword = cryptoMethod === "sha256" ? (0, saslprep_1.saslprep)(password) : passwordDigest(username, password);
    const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
    const dict = parsePayload(payload);
    const iterations = parseInt(dict.i, 10);
    if (iterations && iterations < 4096) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
    }
    const salt = dict.s;
    const rnonce = dict.r;
    if (rnonce.startsWith("nonce")) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
    }
    const withoutProof = `c=biws,r=${rnonce}`;
    const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
    const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
    const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
    const storedKey = H(cryptoMethod, clientKey);
    const authMessage = [
      clientFirstMessageBare(username, nonce),
      payload.toString("utf8"),
      withoutProof
    ].join(",");
    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
    const clientProof = `p=${xor(clientKey, clientSignature)}`;
    const clientFinal = [withoutProof, clientProof].join(",");
    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
    const saslContinueCmd = {
      saslContinue: 1,
      conversationId: response.conversationId,
      payload: new bson_1.Binary(Buffer.from(clientFinal))
    };
    const r2 = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinueCmd, undefined);
    const parsedResponse = parsePayload(r2.payload);
    if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
      throw new error_1.MongoRuntimeError("Server returned an invalid signature");
    }
    if (r2.done !== false) {
      return;
    }
    const retrySaslContinueCmd = {
      saslContinue: 1,
      conversationId: r2.conversationId,
      payload: Buffer.alloc(0)
    };
    await connection.command((0, utils_1.ns)(`${db}.$cmd`), retrySaslContinueCmd, undefined);
  }
  function parsePayload(payload) {
    const payloadStr = payload.toString("utf8");
    const dict = {};
    const parts = payloadStr.split(",");
    for (let i = 0;i < parts.length; i++) {
      const valueParts = (parts[i].match(/^([^=]*)=(.*)$/) ?? []).slice(1);
      dict[valueParts[0]] = valueParts[1];
    }
    return dict;
  }
  function passwordDigest(username, password) {
    if (typeof username !== "string") {
      throw new error_1.MongoInvalidArgumentError("Username must be a string");
    }
    if (typeof password !== "string") {
      throw new error_1.MongoInvalidArgumentError("Password must be a string");
    }
    if (password.length === 0) {
      throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
    }
    let md5;
    try {
      md5 = crypto2.createHash("md5");
    } catch (err2) {
      if (crypto2.getFips()) {
        throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
      }
      throw err2;
    }
    md5.update(`${username}:mongo:${password}`, "utf8");
    return md5.digest("hex");
  }
  function xor(a12, b) {
    if (!Buffer.isBuffer(a12)) {
      a12 = Buffer.from(a12);
    }
    if (!Buffer.isBuffer(b)) {
      b = Buffer.from(b);
    }
    const length = Math.max(a12.length, b.length);
    const res = [];
    for (let i = 0;i < length; i += 1) {
      res.push(a12[i] ^ b[i]);
    }
    return Buffer.from(res).toString("base64");
  }
  function H(method, text) {
    return crypto2.createHash(method).update(text).digest();
  }
  function HMAC(method, key, text) {
    return crypto2.createHmac(method, key).update(text).digest();
  }
  var _hiCache = {};
  var _hiCacheCount = 0;
  function _hiCachePurge() {
    _hiCache = {};
    _hiCacheCount = 0;
  }
  var hiLengthMap = {
    sha256: 32,
    sha1: 20
  };
  function HI(data, salt, iterations, cryptoMethod) {
    const key = [data, salt.toString("base64"), iterations].join("_");
    if (_hiCache[key] != null) {
      return _hiCache[key];
    }
    const saltedData = crypto2.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
    if (_hiCacheCount >= 200) {
      _hiCachePurge();
    }
    _hiCache[key] = saltedData;
    _hiCacheCount += 1;
    return saltedData;
  }
  function compareDigest(lhs, rhs) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    if (typeof crypto2.timingSafeEqual === "function") {
      return crypto2.timingSafeEqual(lhs, rhs);
    }
    let result = 0;
    for (let i = 0;i < lhs.length; i++) {
      result |= lhs[i] ^ rhs[i];
    }
    return result === 0;
  }

  class ScramSHA1 extends ScramSHA {
    constructor() {
      super("sha1");
    }
  }
  exports.ScramSHA1 = ScramSHA1;

  class ScramSHA256 extends ScramSHA {
    constructor() {
      super("sha256");
    }
  }
  exports.ScramSHA256 = ScramSHA256;
});

// node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X509 = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class X509 extends auth_provider_1.AuthProvider {
    async prepare(handshakeDoc, authContext) {
      const { credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
    }
    async auth(authContext) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const response = authContext.response;
      if (response?.speculativeAuthenticate) {
        return;
      }
      await connection.command((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), undefined);
    }
  }
  exports.X509 = X509;
  function x509AuthenticateCommand(credentials) {
    const command = { authenticate: 1, mechanism: "MONGODB-X509" };
    if (credentials.username) {
      command.user = credentials.username;
    }
    return command;
  }
});

// node_modules/mongodb/lib/mongo_client_auth_providers.js
var require_mongo_client_auth_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoClientAuthProviders = undefined;
  var gssapi_1 = require_gssapi();
  var mongodb_aws_1 = require_mongodb_aws();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var automated_callback_workflow_1 = require_automated_callback_workflow();
  var human_callback_workflow_1 = require_human_callback_workflow();
  var token_cache_1 = require_token_cache();
  var plain_1 = require_plain();
  var providers_1 = require_providers();
  var scram_1 = require_scram();
  var x509_1 = require_x509();
  var error_1 = require_error();
  var AUTH_PROVIDERS = new Map([
    [
      providers_1.AuthMechanism.MONGODB_AWS,
      ({ AWS_CREDENTIAL_PROVIDER }) => new mongodb_aws_1.MongoDBAWS(AWS_CREDENTIAL_PROVIDER)
    ],
    [
      providers_1.AuthMechanism.MONGODB_CR,
      () => {
        throw new error_1.MongoInvalidArgumentError("MONGODB-CR is no longer a supported auth mechanism in MongoDB 4.0+");
      }
    ],
    [providers_1.AuthMechanism.MONGODB_GSSAPI, () => new gssapi_1.GSSAPI],
    [providers_1.AuthMechanism.MONGODB_OIDC, (properties) => new mongodb_oidc_1.MongoDBOIDC(getWorkflow(properties))],
    [providers_1.AuthMechanism.MONGODB_PLAIN, () => new plain_1.Plain],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, () => new scram_1.ScramSHA1],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, () => new scram_1.ScramSHA256],
    [providers_1.AuthMechanism.MONGODB_X509, () => new x509_1.X509]
  ]);

  class MongoClientAuthProviders {
    constructor() {
      this.existingProviders = new Map;
    }
    getOrCreateProvider(name, authMechanismProperties) {
      const authProvider = this.existingProviders.get(name);
      if (authProvider) {
        return authProvider;
      }
      const providerFunction = AUTH_PROVIDERS.get(name);
      if (!providerFunction) {
        throw new error_1.MongoInvalidArgumentError(`authMechanism ${name} not supported`);
      }
      const provider = providerFunction(authMechanismProperties);
      this.existingProviders.set(name, provider);
      return provider;
    }
  }
  exports.MongoClientAuthProviders = MongoClientAuthProviders;
  function getWorkflow(authMechanismProperties) {
    if (authMechanismProperties.OIDC_HUMAN_CALLBACK) {
      return new human_callback_workflow_1.HumanCallbackWorkflow(new token_cache_1.TokenCache, authMechanismProperties.OIDC_HUMAN_CALLBACK);
    } else if (authMechanismProperties.OIDC_CALLBACK) {
      return new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache, authMechanismProperties.OIDC_CALLBACK);
    } else {
      const environment = authMechanismProperties.ENVIRONMENT;
      const workflow = mongodb_oidc_1.OIDC_WORKFLOWS.get(environment)?.();
      if (!workflow) {
        throw new error_1.MongoInvalidArgumentError(`Could not load workflow for environment ${authMechanismProperties.ENVIRONMENT}`);
      }
      return workflow;
    }
  }
});

// node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketReadStream = undefined;
  var stream_1 = __require("stream");
  var abstract_cursor_1 = require_abstract_cursor();
  var error_1 = require_error();
  var timeout_1 = require_timeout();

  class GridFSBucketReadStream extends stream_1.Readable {
    constructor(chunks, files, readPreference, filter, options) {
      super({ emitClose: true });
      this.s = {
        bytesToTrim: 0,
        bytesToSkip: 0,
        bytesRead: 0,
        chunks,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        options: {
          start: 0,
          end: 0,
          ...options
        },
        readPreference,
        timeoutContext: options?.timeoutMS != null ? new timeout_1.CSOTTimeoutContext({ timeoutMS: options.timeoutMS, serverSelectionTimeoutMS: 0 }) : undefined
      };
    }
    _read() {
      if (this.destroyed)
        return;
      waitForFile(this, () => doRead(this));
    }
    start(start = 0) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    }
    end(end = 0) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    }
    async abort() {
      this.push(null);
      this.destroy();
      const remainingTimeMS = this.s.timeoutContext?.getRemainingTimeMSOrThrow();
      await this.s.cursor?.close({ timeoutMS: remainingTimeMS });
    }
  }
  exports.GridFSBucketReadStream = GridFSBucketReadStream;
  GridFSBucketReadStream.FILE = "file";
  function throwIfInitialized(stream) {
    if (stream.s.init) {
      throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
    }
  }
  function doRead(stream) {
    if (stream.destroyed)
      return;
    if (!stream.s.cursor)
      return;
    if (!stream.s.file)
      return;
    const handleReadResult = (doc) => {
      if (stream.destroyed)
        return;
      if (!doc) {
        stream.push(null);
        stream.s.cursor?.close().then(undefined, (error) => stream.destroy(error));
        return;
      }
      if (!stream.s.file)
        return;
      const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
      const expectedN = stream.s.expected++;
      const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
      if (doc.n > expectedN) {
        return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      if (doc.n < expectedN) {
        return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
      if (buf.byteLength !== expectedLength) {
        if (bytesRemaining <= 0) {
          return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
        }
        return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
      }
      stream.s.bytesRead += buf.byteLength;
      if (buf.byteLength === 0) {
        return stream.push(null);
      }
      let sliceStart = null;
      let sliceEnd = null;
      if (stream.s.bytesToSkip != null) {
        sliceStart = stream.s.bytesToSkip;
        stream.s.bytesToSkip = 0;
      }
      const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
      const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
      if (atEndOfStream && stream.s.bytesToTrim != null) {
        sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
      } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
        sliceEnd = bytesLeftToRead;
      }
      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
      }
      stream.push(buf);
      return;
    };
    stream.s.cursor.next().then(handleReadResult, (error) => {
      if (stream.destroyed)
        return;
      stream.destroy(error);
    });
  }
  function init(stream) {
    const findOneOptions = {};
    if (stream.s.readPreference) {
      findOneOptions.readPreference = stream.s.readPreference;
    }
    if (stream.s.options && stream.s.options.sort) {
      findOneOptions.sort = stream.s.options.sort;
    }
    if (stream.s.options && stream.s.options.skip) {
      findOneOptions.skip = stream.s.options.skip;
    }
    const handleReadResult = (doc) => {
      if (stream.destroyed)
        return;
      if (!doc) {
        const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
        const errmsg = `FileNotFound: file ${identifier} was not found`;
        const err2 = new error_1.MongoRuntimeError(errmsg);
        err2.code = "ENOENT";
        return stream.destroy(err2);
      }
      if (doc.length <= 0) {
        stream.push(null);
        return;
      }
      if (stream.destroyed) {
        stream.destroy();
        return;
      }
      try {
        stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
      } catch (error) {
        return stream.destroy(error);
      }
      const filter = { files_id: doc._id };
      if (stream.s.options && stream.s.options.start != null) {
        const skip = Math.floor(stream.s.options.start / doc.chunkSize);
        if (skip > 0) {
          filter["n"] = { $gte: skip };
        }
      }
      let remainingTimeMS2;
      try {
        remainingTimeMS2 = stream.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream.s.timeoutContext?.timeoutMS}ms`);
      } catch (error) {
        return stream.destroy(error);
      }
      stream.s.cursor = stream.s.chunks.find(filter, {
        timeoutMode: stream.s.options.timeoutMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : undefined,
        timeoutMS: remainingTimeMS2
      }).sort({ n: 1 });
      if (stream.s.readPreference) {
        stream.s.cursor.withReadPreference(stream.s.readPreference);
      }
      stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      stream.s.file = doc;
      try {
        stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
      } catch (error) {
        return stream.destroy(error);
      }
      stream.emit(GridFSBucketReadStream.FILE, doc);
      return;
    };
    let remainingTimeMS;
    try {
      remainingTimeMS = stream.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream.s.timeoutContext?.timeoutMS}ms`);
    } catch (error) {
      if (!stream.destroyed)
        stream.destroy(error);
      return;
    }
    findOneOptions.timeoutMS = remainingTimeMS;
    stream.s.files.findOne(stream.s.filter, findOneOptions).then(handleReadResult, (error) => {
      if (stream.destroyed)
        return;
      stream.destroy(error);
    });
  }
  function waitForFile(stream, callback) {
    if (stream.s.file) {
      return callback();
    }
    if (!stream.s.init) {
      init(stream);
      stream.s.init = true;
    }
    stream.once("file", () => {
      callback();
    });
  }
  function handleStartOption(stream, doc, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
      }
      if (options.end != null && options.end < options.start) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
      }
      stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream.s.expected = Math.floor(options.start / doc.chunkSize);
      return options.start - stream.s.bytesRead;
    }
    throw new error_1.MongoInvalidArgumentError("Start option must be defined");
  }
  function handleEndOption(stream, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start == null || options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
      }
      const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
      stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
    throw new error_1.MongoInvalidArgumentError("End option must be defined");
  }
});

// node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketWriteStream = undefined;
  var stream_1 = __require("stream");
  var bson_1 = require_bson2();
  var abstract_cursor_1 = require_abstract_cursor();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();

  class GridFSBucketWriteStream extends stream_1.Writable {
    constructor(bucket, filename, options) {
      super();
      this.gridFSFile = null;
      options = options ?? {};
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options;
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
      this.done = false;
      this.id = options.id ? options.id : new bson_1.ObjectId;
      this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
      this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false
      };
      if (options.timeoutMS != null)
        this.timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS: options.timeoutMS,
          serverSelectionTimeoutMS: (0, utils_1.resolveTimeoutOptions)(this.bucket.s.db.client, {}).serverSelectionTimeoutMS
        });
    }
    _construct(callback) {
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        checkIndexes(this).then(() => {
          this.bucket.s.checkedIndexes = true;
          this.bucket.emit("index");
          callback();
        }, (error) => {
          if (error instanceof error_1.MongoOperationTimeoutError) {
            return handleError(this, error, callback);
          }
          (0, utils_1.squashError)(error);
          callback();
        });
      } else {
        return process.nextTick(callback);
      }
    }
    _write(chunk, encoding, callback) {
      doWrite(this, chunk, encoding, callback);
    }
    _final(callback) {
      if (this.state.streamEnd) {
        return process.nextTick(callback);
      }
      this.state.streamEnd = true;
      writeRemnant(this, callback);
    }
    async abort() {
      if (this.state.streamEnd) {
        throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
      }
      if (this.state.aborted) {
        throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
      }
      this.state.aborted = true;
      const remainingTimeMS = this.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${this.timeoutContext?.timeoutMS}ms`);
      await this.chunks.deleteMany({ files_id: this.id }, { timeoutMS: remainingTimeMS });
    }
  }
  exports.GridFSBucketWriteStream = GridFSBucketWriteStream;
  function handleError(stream, error, callback) {
    if (stream.state.errored) {
      process.nextTick(callback);
      return;
    }
    stream.state.errored = true;
    process.nextTick(callback, error);
  }
  function createChunkDoc(filesId, n2, data) {
    return {
      _id: new bson_1.ObjectId,
      files_id: filesId,
      n: n2,
      data
    };
  }
  async function checkChunksIndex(stream) {
    const index = { files_id: 1, n: 1 };
    let remainingTimeMS;
    remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
    let indexes;
    try {
      indexes = await stream.chunks.listIndexes({
        timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : undefined,
        timeoutMS: remainingTimeMS
      }).toArray();
    } catch (error) {
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error;
      }
    }
    const hasChunksIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
        return true;
      }
      return false;
    });
    if (!hasChunksIndex) {
      remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      await stream.chunks.createIndex(index, {
        ...stream.writeConcern,
        background: true,
        unique: true,
        timeoutMS: remainingTimeMS
      });
    }
  }
  function checkDone(stream, callback) {
    if (stream.done) {
      return process.nextTick(callback);
    }
    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
      stream.done = true;
      const gridFSFile = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
      if (isAborted2(stream, callback)) {
        return;
      }
      const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
      if (remainingTimeMS != null && remainingTimeMS <= 0) {
        return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
      }
      stream.files.insertOne(gridFSFile, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
        stream.gridFSFile = gridFSFile;
        callback();
      }, (error) => {
        return handleError(stream, error, callback);
      });
      return;
    }
    process.nextTick(callback);
  }
  async function checkIndexes(stream) {
    let remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
    const doc = await stream.files.findOne({}, {
      projection: { _id: 1 },
      timeoutMS: remainingTimeMS
    });
    if (doc != null) {
      return;
    }
    const index = { filename: 1, uploadDate: 1 };
    let indexes;
    remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
    const listIndexesOptions = {
      timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : undefined,
      timeoutMS: remainingTimeMS
    };
    try {
      indexes = await stream.files.listIndexes(listIndexesOptions).toArray();
    } catch (error) {
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error;
      }
    }
    const hasFileIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
        return true;
      }
      return false;
    });
    if (!hasFileIndex) {
      remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      await stream.files.createIndex(index, { background: false, timeoutMS: remainingTimeMS });
    }
    await checkChunksIndex(stream);
  }
  function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
    const ret = {
      _id,
      length,
      chunkSize,
      uploadDate: new Date,
      filename
    };
    if (contentType) {
      ret.contentType = contentType;
    }
    if (aliases) {
      ret.aliases = aliases;
    }
    if (metadata) {
      ret.metadata = metadata;
    }
    return ret;
  }
  function doWrite(stream, chunk, encoding, callback) {
    if (isAborted2(stream, callback)) {
      return;
    }
    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
    stream.length += inputBuf.length;
    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
      inputBuf.copy(stream.bufToStore, stream.pos);
      stream.pos += inputBuf.length;
      process.nextTick(callback);
      return;
    }
    let inputBufRemaining = inputBuf.length;
    let spaceRemaining = stream.chunkSizeBytes - stream.pos;
    let numToCopy = Math.min(spaceRemaining, inputBuf.length);
    let outstandingRequests = 0;
    while (inputBufRemaining > 0) {
      const inputBufPos = inputBuf.length - inputBufRemaining;
      inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
      stream.pos += numToCopy;
      spaceRemaining -= numToCopy;
      let doc;
      if (spaceRemaining === 0) {
        doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
        const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
        if (remainingTimeMS != null && remainingTimeMS <= 0) {
          return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
        }
        ++stream.state.outstandingRequests;
        ++outstandingRequests;
        if (isAborted2(stream, callback)) {
          return;
        }
        stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
          --stream.state.outstandingRequests;
          --outstandingRequests;
          if (!outstandingRequests) {
            checkDone(stream, callback);
          }
        }, (error) => {
          return handleError(stream, error, callback);
        });
        spaceRemaining = stream.chunkSizeBytes;
        stream.pos = 0;
        ++stream.n;
      }
      inputBufRemaining -= numToCopy;
      numToCopy = Math.min(spaceRemaining, inputBufRemaining);
    }
  }
  function writeRemnant(stream, callback) {
    if (stream.pos === 0) {
      return checkDone(stream, callback);
    }
    const remnant = Buffer.alloc(stream.pos);
    stream.bufToStore.copy(remnant, 0, 0, stream.pos);
    const doc = createChunkDoc(stream.id, stream.n, remnant);
    if (isAborted2(stream, callback)) {
      return;
    }
    const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
    if (remainingTimeMS != null && remainingTimeMS <= 0) {
      return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
    }
    ++stream.state.outstandingRequests;
    stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
      --stream.state.outstandingRequests;
      checkDone(stream, callback);
    }, (error) => {
      return handleError(stream, error, callback);
    });
  }
  function isAborted2(stream, callback) {
    if (stream.state.aborted) {
      process.nextTick(callback, new error_1.MongoAPIError("Stream has been aborted"));
      return true;
    }
    return false;
  }
});

// node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucket = undefined;
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var download_1 = require_download();
  var upload_1 = require_upload();
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: "fs",
    chunkSizeBytes: 255 * 1024
  };

  class GridFSBucket extends mongo_types_1.TypedEventEmitter {
    constructor(db, options) {
      super();
      this.on("error", utils_1.noop);
      this.setMaxListeners(0);
      const privateOptions = (0, utils_1.resolveOptions)(db, {
        ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
        ...options,
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      });
      this.s = {
        db,
        options: privateOptions,
        _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
        _filesCollection: db.collection(privateOptions.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false
      };
    }
    openUploadStream(filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, {
        timeoutMS: this.s.options.timeoutMS,
        ...options
      });
    }
    openUploadStreamWithId(id, filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, {
        timeoutMS: this.s.options.timeoutMS,
        ...options,
        id
      });
    }
    openDownloadStream(id, options) {
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, { timeoutMS: this.s.options.timeoutMS, ...options });
    }
    async delete(id, options) {
      const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);
      let timeoutContext = undefined;
      if (timeoutMS) {
        timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS,
          serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
        });
      }
      const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id }, { timeoutMS: timeoutContext?.remainingTimeMS });
      const remainingTimeMS = timeoutContext?.remainingTimeMS;
      if (remainingTimeMS != null && remainingTimeMS <= 0)
        throw new error_1.MongoOperationTimeoutError(`Timed out after ${timeoutMS}ms`);
      await this.s._chunksCollection.deleteMany({ files_id: id }, { timeoutMS: remainingTimeMS });
      if (deletedCount === 0) {
        throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
      }
    }
    find(filter = {}, options = {}) {
      return this.s._filesCollection.find(filter, options);
    }
    openDownloadStreamByName(filename, options) {
      let sort = { uploadDate: -1 };
      let skip = undefined;
      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { timeoutMS: this.s.options.timeoutMS, ...options, sort, skip });
    }
    async rename(id, filename, options) {
      const filter = { _id: id };
      const update = { $set: { filename } };
      const { matchedCount } = await this.s._filesCollection.updateOne(filter, update, options);
      if (matchedCount === 0) {
        throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
      }
    }
    async drop(options) {
      const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);
      let timeoutContext = undefined;
      if (timeoutMS) {
        timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS,
          serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
        });
      }
      if (timeoutContext) {
        await this.s._filesCollection.drop({ timeoutMS: timeoutContext.remainingTimeMS });
        const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(`Timed out after ${timeoutMS}ms`);
        await this.s._chunksCollection.drop({ timeoutMS: remainingTimeMS });
      } else {
        await this.s._filesCollection.drop();
        await this.s._chunksCollection.drop();
      }
    }
  }
  exports.GridFSBucket = GridFSBucket;
  GridFSBucket.INDEX = "index";
});

// node_modules/mongodb/lib/sdam/server_selection_events.js
var require_server_selection_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionEvent = undefined;
  var utils_1 = require_utils();
  var constants_1 = require_constants();

  class ServerSelectionEvent {
    constructor(selector, topologyDescription, operation) {
      this.selector = selector;
      this.operation = operation;
      this.topologyDescription = topologyDescription;
    }
  }
  exports.ServerSelectionEvent = ServerSelectionEvent;

  class ServerSelectionStartedEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.SERVER_SELECTION_STARTED;
      this.message = "Server selection started";
    }
  }
  exports.ServerSelectionStartedEvent = ServerSelectionStartedEvent;

  class ServerSelectionFailedEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, error, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.SERVER_SELECTION_FAILED;
      this.message = "Server selection failed";
      this.failure = error;
    }
  }
  exports.ServerSelectionFailedEvent = ServerSelectionFailedEvent;

  class ServerSelectionSucceededEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, address, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.SERVER_SELECTION_SUCCEEDED;
      this.message = "Server selection succeeded";
      const { host, port } = utils_1.HostAddress.fromString(address).toHostPort();
      this.serverHost = host;
      this.serverPort = port;
    }
  }
  exports.ServerSelectionSucceededEvent = ServerSelectionSucceededEvent;

  class WaitingForSuitableServerEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, remainingTimeMS, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.WAITING_FOR_SUITABLE_SERVER;
      this.message = "Waiting for suitable server to become available";
      this.remainingTimeMS = remainingTimeMS;
    }
  }
  exports.WaitingForSuitableServerEvent = WaitingForSuitableServerEvent;
});

// node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SrvPoller = exports.SrvPollingEvent = undefined;
  var dns = __require("dns");
  var timers_1 = __require("timers");
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();

  class SrvPollingEvent {
    constructor(srvRecords) {
      this.srvRecords = srvRecords;
    }
    hostnames() {
      return new Set(this.srvRecords.map((r2) => utils_1.HostAddress.fromSrvRecord(r2).toString()));
    }
  }
  exports.SrvPollingEvent = SrvPollingEvent;

  class SrvPoller extends mongo_types_1.TypedEventEmitter {
    constructor(options) {
      super();
      this.on("error", utils_1.noop);
      if (!options || !options.srvHost) {
        throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
      }
      this.srvHost = options.srvHost;
      this.srvMaxHosts = options.srvMaxHosts ?? 0;
      this.srvServiceName = options.srvServiceName ?? "mongodb";
      this.rescanSrvIntervalMS = 60000;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1e4;
      this.haMode = false;
      this.generation = 0;
      this._timeout = undefined;
    }
    get srvAddress() {
      return `_${this.srvServiceName}._tcp.${this.srvHost}`;
    }
    get intervalMS() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
    stop() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
        this.generation += 1;
        this._timeout = undefined;
      }
    }
    schedule() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
      }
      this._timeout = (0, timers_1.setTimeout)(() => {
        this._poll().then(undefined, utils_1.squashError);
      }, this.intervalMS);
    }
    success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
    failure() {
      this.haMode = true;
      this.schedule();
    }
    async _poll() {
      const generation = this.generation;
      let srvRecords;
      try {
        srvRecords = await dns.promises.resolveSrv(this.srvAddress);
      } catch {
        this.failure();
        return;
      }
      if (generation !== this.generation) {
        return;
      }
      const finalAddresses = [];
      for (const record of srvRecords) {
        try {
          (0, utils_1.checkParentDomainMatch)(record.name, this.srvHost);
          finalAddresses.push(record);
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
      }
      if (!finalAddresses.length) {
        this.failure();
        return;
      }
      this.success(finalAddresses);
    }
  }
  exports.SrvPoller = SrvPoller;
  SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
});

// node_modules/mongodb/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoOperationTimeoutError = exports.MongoOIDCError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoGCPError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoClientClosedError = exports.MongoClientBulkWriteExecutionError = exports.MongoClientBulkWriteError = exports.MongoClientBulkWriteCursorError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.ClientEncryption = exports.MongoBulkWriteError = exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = undefined;
  exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.SeverityLevel = exports.MongoLoggableComponent = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.AutoEncryptionLoggerLevel = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.ExplainableCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = exports.AbstractCursor = exports.configureExplicitResourceManagement = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoStalePrimaryError = exports.MongoServerSelectionError = exports.MongoServerError = undefined;
  exports.MongoClientAuthProviders = exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptAzureKMSRequestError = exports.SrvPollingEvent = exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = undefined;
  var admin_1 = require_admin();
  Object.defineProperty(exports, "Admin", { enumerable: true, get: function() {
    return admin_1.Admin;
  } });
  var ordered_1 = require_ordered();
  Object.defineProperty(exports, "OrderedBulkOperation", { enumerable: true, get: function() {
    return ordered_1.OrderedBulkOperation;
  } });
  var unordered_1 = require_unordered();
  Object.defineProperty(exports, "UnorderedBulkOperation", { enumerable: true, get: function() {
    return unordered_1.UnorderedBulkOperation;
  } });
  var change_stream_1 = require_change_stream();
  Object.defineProperty(exports, "ChangeStream", { enumerable: true, get: function() {
    return change_stream_1.ChangeStream;
  } });
  var collection_1 = require_collection();
  Object.defineProperty(exports, "Collection", { enumerable: true, get: function() {
    return collection_1.Collection;
  } });
  var abstract_cursor_1 = require_abstract_cursor();
  Object.defineProperty(exports, "AbstractCursor", { enumerable: true, get: function() {
    return abstract_cursor_1.AbstractCursor;
  } });
  var aggregation_cursor_1 = require_aggregation_cursor();
  Object.defineProperty(exports, "AggregationCursor", { enumerable: true, get: function() {
    return aggregation_cursor_1.AggregationCursor;
  } });
  var find_cursor_1 = require_find_cursor();
  Object.defineProperty(exports, "FindCursor", { enumerable: true, get: function() {
    return find_cursor_1.FindCursor;
  } });
  var list_collections_cursor_1 = require_list_collections_cursor();
  Object.defineProperty(exports, "ListCollectionsCursor", { enumerable: true, get: function() {
    return list_collections_cursor_1.ListCollectionsCursor;
  } });
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  Object.defineProperty(exports, "ListIndexesCursor", { enumerable: true, get: function() {
    return list_indexes_cursor_1.ListIndexesCursor;
  } });
  var db_1 = require_db();
  Object.defineProperty(exports, "Db", { enumerable: true, get: function() {
    return db_1.Db;
  } });
  var explain_1 = require_explain();
  Object.defineProperty(exports, "ExplainableCursor", { enumerable: true, get: function() {
    return explain_1.ExplainableCursor;
  } });
  var gridfs_1 = require_gridfs();
  Object.defineProperty(exports, "GridFSBucket", { enumerable: true, get: function() {
    return gridfs_1.GridFSBucket;
  } });
  var download_1 = require_download();
  Object.defineProperty(exports, "GridFSBucketReadStream", { enumerable: true, get: function() {
    return download_1.GridFSBucketReadStream;
  } });
  var upload_1 = require_upload();
  Object.defineProperty(exports, "GridFSBucketWriteStream", { enumerable: true, get: function() {
    return upload_1.GridFSBucketWriteStream;
  } });
  var mongo_client_1 = require_mongo_client();
  Object.defineProperty(exports, "MongoClient", { enumerable: true, get: function() {
    return mongo_client_1.MongoClient;
  } });
  var mongo_types_1 = require_mongo_types();
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return mongo_types_1.CancellationToken;
  } });
  var sessions_1 = require_sessions();
  Object.defineProperty(exports, "ClientSession", { enumerable: true, get: function() {
    return sessions_1.ClientSession;
  } });
  var bson_1 = require_bson2();
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_1.BSON;
  } });
  var bson_2 = require_bson2();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_2.Binary;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_2.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_2.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_2.BSONType;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_2.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_2.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_2.Decimal128;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_2.Double;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_2.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_2.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_2.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_2.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_2.ObjectId;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_2.Timestamp;
  } });
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return bson_2.UUID;
  } });
  var common_1 = require_common3();
  Object.defineProperty(exports, "MongoBulkWriteError", { enumerable: true, get: function() {
    return common_1.MongoBulkWriteError;
  } });
  var client_encryption_1 = require_client_encryption();
  Object.defineProperty(exports, "ClientEncryption", { enumerable: true, get: function() {
    return client_encryption_1.ClientEncryption;
  } });
  var change_stream_cursor_1 = require_change_stream_cursor();
  Object.defineProperty(exports, "ChangeStreamCursor", { enumerable: true, get: function() {
    return change_stream_cursor_1.ChangeStreamCursor;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "MongoAPIError", { enumerable: true, get: function() {
    return error_1.MongoAPIError;
  } });
  Object.defineProperty(exports, "MongoAWSError", { enumerable: true, get: function() {
    return error_1.MongoAWSError;
  } });
  Object.defineProperty(exports, "MongoAzureError", { enumerable: true, get: function() {
    return error_1.MongoAzureError;
  } });
  Object.defineProperty(exports, "MongoBatchReExecutionError", { enumerable: true, get: function() {
    return error_1.MongoBatchReExecutionError;
  } });
  Object.defineProperty(exports, "MongoChangeStreamError", { enumerable: true, get: function() {
    return error_1.MongoChangeStreamError;
  } });
  Object.defineProperty(exports, "MongoClientBulkWriteCursorError", { enumerable: true, get: function() {
    return error_1.MongoClientBulkWriteCursorError;
  } });
  Object.defineProperty(exports, "MongoClientBulkWriteError", { enumerable: true, get: function() {
    return error_1.MongoClientBulkWriteError;
  } });
  Object.defineProperty(exports, "MongoClientBulkWriteExecutionError", { enumerable: true, get: function() {
    return error_1.MongoClientBulkWriteExecutionError;
  } });
  Object.defineProperty(exports, "MongoClientClosedError", { enumerable: true, get: function() {
    return error_1.MongoClientClosedError;
  } });
  Object.defineProperty(exports, "MongoCompatibilityError", { enumerable: true, get: function() {
    return error_1.MongoCompatibilityError;
  } });
  Object.defineProperty(exports, "MongoCursorExhaustedError", { enumerable: true, get: function() {
    return error_1.MongoCursorExhaustedError;
  } });
  Object.defineProperty(exports, "MongoCursorInUseError", { enumerable: true, get: function() {
    return error_1.MongoCursorInUseError;
  } });
  Object.defineProperty(exports, "MongoDecompressionError", { enumerable: true, get: function() {
    return error_1.MongoDecompressionError;
  } });
  Object.defineProperty(exports, "MongoDriverError", { enumerable: true, get: function() {
    return error_1.MongoDriverError;
  } });
  Object.defineProperty(exports, "MongoError", { enumerable: true, get: function() {
    return error_1.MongoError;
  } });
  Object.defineProperty(exports, "MongoExpiredSessionError", { enumerable: true, get: function() {
    return error_1.MongoExpiredSessionError;
  } });
  Object.defineProperty(exports, "MongoGCPError", { enumerable: true, get: function() {
    return error_1.MongoGCPError;
  } });
  Object.defineProperty(exports, "MongoGridFSChunkError", { enumerable: true, get: function() {
    return error_1.MongoGridFSChunkError;
  } });
  Object.defineProperty(exports, "MongoGridFSStreamError", { enumerable: true, get: function() {
    return error_1.MongoGridFSStreamError;
  } });
  Object.defineProperty(exports, "MongoInvalidArgumentError", { enumerable: true, get: function() {
    return error_1.MongoInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoKerberosError", { enumerable: true, get: function() {
    return error_1.MongoKerberosError;
  } });
  Object.defineProperty(exports, "MongoMissingCredentialsError", { enumerable: true, get: function() {
    return error_1.MongoMissingCredentialsError;
  } });
  Object.defineProperty(exports, "MongoMissingDependencyError", { enumerable: true, get: function() {
    return error_1.MongoMissingDependencyError;
  } });
  Object.defineProperty(exports, "MongoNetworkError", { enumerable: true, get: function() {
    return error_1.MongoNetworkError;
  } });
  Object.defineProperty(exports, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
    return error_1.MongoNetworkTimeoutError;
  } });
  Object.defineProperty(exports, "MongoNotConnectedError", { enumerable: true, get: function() {
    return error_1.MongoNotConnectedError;
  } });
  Object.defineProperty(exports, "MongoOIDCError", { enumerable: true, get: function() {
    return error_1.MongoOIDCError;
  } });
  Object.defineProperty(exports, "MongoOperationTimeoutError", { enumerable: true, get: function() {
    return error_1.MongoOperationTimeoutError;
  } });
  Object.defineProperty(exports, "MongoParseError", { enumerable: true, get: function() {
    return error_1.MongoParseError;
  } });
  Object.defineProperty(exports, "MongoRuntimeError", { enumerable: true, get: function() {
    return error_1.MongoRuntimeError;
  } });
  Object.defineProperty(exports, "MongoServerClosedError", { enumerable: true, get: function() {
    return error_1.MongoServerClosedError;
  } });
  Object.defineProperty(exports, "MongoServerError", { enumerable: true, get: function() {
    return error_1.MongoServerError;
  } });
  Object.defineProperty(exports, "MongoServerSelectionError", { enumerable: true, get: function() {
    return error_1.MongoServerSelectionError;
  } });
  Object.defineProperty(exports, "MongoStalePrimaryError", { enumerable: true, get: function() {
    return error_1.MongoStalePrimaryError;
  } });
  Object.defineProperty(exports, "MongoSystemError", { enumerable: true, get: function() {
    return error_1.MongoSystemError;
  } });
  Object.defineProperty(exports, "MongoTailableCursorError", { enumerable: true, get: function() {
    return error_1.MongoTailableCursorError;
  } });
  Object.defineProperty(exports, "MongoTopologyClosedError", { enumerable: true, get: function() {
    return error_1.MongoTopologyClosedError;
  } });
  Object.defineProperty(exports, "MongoTransactionError", { enumerable: true, get: function() {
    return error_1.MongoTransactionError;
  } });
  Object.defineProperty(exports, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
    return error_1.MongoUnexpectedServerResponseError;
  } });
  Object.defineProperty(exports, "MongoWriteConcernError", { enumerable: true, get: function() {
    return error_1.MongoWriteConcernError;
  } });
  var resource_management_1 = require_resource_management();
  Object.defineProperty(exports, "configureExplicitResourceManagement", { enumerable: true, get: function() {
    return resource_management_1.configureExplicitResourceManagement;
  } });
  var common_2 = require_common3();
  Object.defineProperty(exports, "BatchType", { enumerable: true, get: function() {
    return common_2.BatchType;
  } });
  var auto_encrypter_1 = require_auto_encrypter();
  Object.defineProperty(exports, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
    return auto_encrypter_1.AutoEncryptionLoggerLevel;
  } });
  var gssapi_1 = require_gssapi();
  Object.defineProperty(exports, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
    return gssapi_1.GSSAPICanonicalizationValue;
  } });
  var providers_1 = require_providers();
  Object.defineProperty(exports, "AuthMechanism", { enumerable: true, get: function() {
    return providers_1.AuthMechanism;
  } });
  var compression_1 = require_compression();
  Object.defineProperty(exports, "Compressor", { enumerable: true, get: function() {
    return compression_1.Compressor;
  } });
  var abstract_cursor_2 = require_abstract_cursor();
  Object.defineProperty(exports, "CURSOR_FLAGS", { enumerable: true, get: function() {
    return abstract_cursor_2.CURSOR_FLAGS;
  } });
  Object.defineProperty(exports, "CursorTimeoutMode", { enumerable: true, get: function() {
    return abstract_cursor_2.CursorTimeoutMode;
  } });
  var error_2 = require_error();
  Object.defineProperty(exports, "MongoErrorLabel", { enumerable: true, get: function() {
    return error_2.MongoErrorLabel;
  } });
  var explain_2 = require_explain();
  Object.defineProperty(exports, "ExplainVerbosity", { enumerable: true, get: function() {
    return explain_2.ExplainVerbosity;
  } });
  var mongo_client_2 = require_mongo_client();
  Object.defineProperty(exports, "ServerApiVersion", { enumerable: true, get: function() {
    return mongo_client_2.ServerApiVersion;
  } });
  var mongo_logger_1 = require_mongo_logger();
  Object.defineProperty(exports, "MongoLoggableComponent", { enumerable: true, get: function() {
    return mongo_logger_1.MongoLoggableComponent;
  } });
  Object.defineProperty(exports, "SeverityLevel", { enumerable: true, get: function() {
    return mongo_logger_1.SeverityLevel;
  } });
  var find_and_modify_1 = require_find_and_modify();
  Object.defineProperty(exports, "ReturnDocument", { enumerable: true, get: function() {
    return find_and_modify_1.ReturnDocument;
  } });
  var set_profiling_level_1 = require_set_profiling_level();
  Object.defineProperty(exports, "ProfilingLevel", { enumerable: true, get: function() {
    return set_profiling_level_1.ProfilingLevel;
  } });
  var read_concern_1 = require_read_concern();
  Object.defineProperty(exports, "ReadConcernLevel", { enumerable: true, get: function() {
    return read_concern_1.ReadConcernLevel;
  } });
  var read_preference_1 = require_read_preference();
  Object.defineProperty(exports, "ReadPreferenceMode", { enumerable: true, get: function() {
    return read_preference_1.ReadPreferenceMode;
  } });
  var common_3 = require_common2();
  Object.defineProperty(exports, "ServerType", { enumerable: true, get: function() {
    return common_3.ServerType;
  } });
  Object.defineProperty(exports, "TopologyType", { enumerable: true, get: function() {
    return common_3.TopologyType;
  } });
  var read_concern_2 = require_read_concern();
  Object.defineProperty(exports, "ReadConcern", { enumerable: true, get: function() {
    return read_concern_2.ReadConcern;
  } });
  var read_preference_2 = require_read_preference();
  Object.defineProperty(exports, "ReadPreference", { enumerable: true, get: function() {
    return read_preference_2.ReadPreference;
  } });
  var write_concern_1 = require_write_concern();
  Object.defineProperty(exports, "WriteConcern", { enumerable: true, get: function() {
    return write_concern_1.WriteConcern;
  } });
  var command_monitoring_events_1 = require_command_monitoring_events();
  Object.defineProperty(exports, "CommandFailedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandFailedEvent;
  } });
  Object.defineProperty(exports, "CommandStartedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandStartedEvent;
  } });
  Object.defineProperty(exports, "CommandSucceededEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandSucceededEvent;
  } });
  var connection_pool_events_1 = require_connection_pool_events();
  Object.defineProperty(exports, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedInEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedOutEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutFailedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutStartedEvent;
  } });
  Object.defineProperty(exports, "ConnectionClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClearedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolMonitoringEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolReadyEvent;
  } });
  Object.defineProperty(exports, "ConnectionReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionReadyEvent;
  } });
  var events_1 = require_events();
  Object.defineProperty(exports, "ServerClosedEvent", { enumerable: true, get: function() {
    return events_1.ServerClosedEvent;
  } });
  Object.defineProperty(exports, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.ServerDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatFailedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatStartedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatSucceededEvent;
  } });
  Object.defineProperty(exports, "ServerOpeningEvent", { enumerable: true, get: function() {
    return events_1.ServerOpeningEvent;
  } });
  Object.defineProperty(exports, "TopologyClosedEvent", { enumerable: true, get: function() {
    return events_1.TopologyClosedEvent;
  } });
  Object.defineProperty(exports, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.TopologyDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "TopologyOpeningEvent", { enumerable: true, get: function() {
    return events_1.TopologyOpeningEvent;
  } });
  var server_selection_events_1 = require_server_selection_events();
  Object.defineProperty(exports, "ServerSelectionEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionEvent;
  } });
  Object.defineProperty(exports, "ServerSelectionFailedEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionFailedEvent;
  } });
  Object.defineProperty(exports, "ServerSelectionStartedEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionStartedEvent;
  } });
  Object.defineProperty(exports, "ServerSelectionSucceededEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionSucceededEvent;
  } });
  Object.defineProperty(exports, "WaitingForSuitableServerEvent", { enumerable: true, get: function() {
    return server_selection_events_1.WaitingForSuitableServerEvent;
  } });
  var srv_polling_1 = require_srv_polling();
  Object.defineProperty(exports, "SrvPollingEvent", { enumerable: true, get: function() {
    return srv_polling_1.SrvPollingEvent;
  } });
  var errors_1 = require_errors();
  Object.defineProperty(exports, "MongoCryptAzureKMSRequestError", { enumerable: true, get: function() {
    return errors_1.MongoCryptAzureKMSRequestError;
  } });
  Object.defineProperty(exports, "MongoCryptCreateDataKeyError", { enumerable: true, get: function() {
    return errors_1.MongoCryptCreateDataKeyError;
  } });
  Object.defineProperty(exports, "MongoCryptCreateEncryptedCollectionError", { enumerable: true, get: function() {
    return errors_1.MongoCryptCreateEncryptedCollectionError;
  } });
  Object.defineProperty(exports, "MongoCryptError", { enumerable: true, get: function() {
    return errors_1.MongoCryptError;
  } });
  Object.defineProperty(exports, "MongoCryptInvalidArgumentError", { enumerable: true, get: function() {
    return errors_1.MongoCryptInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoCryptKMSRequestNetworkTimeoutError", { enumerable: true, get: function() {
    return errors_1.MongoCryptKMSRequestNetworkTimeoutError;
  } });
  var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
  Object.defineProperty(exports, "MongoClientAuthProviders", { enumerable: true, get: function() {
    return mongo_client_auth_providers_1.MongoClientAuthProviders;
  } });
});

// node_modules/mongodb/lib/beta.js
var require_beta = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_lib3(), exports);
  function __exportStar(mod) {
    for (const key of Object.keys(mod)) {
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return mod[key];
        }
      });
    }
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/client_bulk_write.js
var require_client_bulk_write = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteOperation = undefined;
  var beta_1 = require_beta();
  var responses_1 = require_responses();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ClientBulkWriteOperation extends command_1.CommandOperation {
    get commandName() {
      return "bulkWrite";
    }
    constructor(commandBuilder, options) {
      super(undefined, options);
      this.commandBuilder = commandBuilder;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    resetBatch() {
      return this.commandBuilder.resetBatch();
    }
    get canRetryWrite() {
      return this.commandBuilder.isBatchRetryable;
    }
    async execute(server, session, timeoutContext) {
      let command;
      if (server.description.type === beta_1.ServerType.LoadBalancer) {
        if (session) {
          let connection;
          if (!session.pinnedConnection) {
            connection = await server.pool.checkOut({ timeoutContext });
            session.pin(connection);
          } else {
            connection = session.pinnedConnection;
          }
          command = this.commandBuilder.buildBatch(connection.hello?.maxMessageSizeBytes, connection.hello?.maxWriteBatchSize, connection.hello?.maxBsonObjectSize);
        } else {
          throw new beta_1.MongoClientBulkWriteExecutionError("Session provided to the client bulk write operation must be present.");
        }
      } else {
        if (!server.description.maxWriteBatchSize || !server.description.maxMessageSizeBytes || !server.description.maxBsonObjectSize) {
          throw new beta_1.MongoClientBulkWriteExecutionError("In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.");
        }
        command = this.commandBuilder.buildBatch(server.description.maxMessageSizeBytes, server.description.maxWriteBatchSize, server.description.maxBsonObjectSize);
      }
      if (!this.canRetryWrite) {
        this.options.willRetryWrite = false;
      }
      return await super.executeCommand(server, session, command, timeoutContext, responses_1.ClientBulkWriteCursorResponse);
    }
  }
  exports.ClientBulkWriteOperation = ClientBulkWriteOperation;
  (0, operation_1.defineAspects)(ClientBulkWriteOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.SKIP_COLLATION,
    operation_1.Aspect.CURSOR_CREATING,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.COMMAND_BATCHING
  ]);
});

// node_modules/mongodb/lib/cursor/client_bulk_write_cursor.js
var require_client_bulk_write_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteCursor = undefined;
  var client_bulk_write_1 = require_client_bulk_write();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class ClientBulkWriteCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, commandBuilder, options = {}) {
      super(client, new utils_1.MongoDBNamespace("admin", "$cmd"), options);
      this.commandBuilder = commandBuilder;
      this.clientBulkWriteOptions = options;
    }
    get response() {
      if (this.cursorResponse)
        return this.cursorResponse;
      return null;
    }
    get operations() {
      return this.commandBuilder.lastOperations;
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this.clientBulkWriteOptions);
      delete clonedOptions.session;
      return new ClientBulkWriteCursor(this.client, this.commandBuilder, {
        ...clonedOptions
      });
    }
    async _initialize(session) {
      const clientBulkWriteOperation = new client_bulk_write_1.ClientBulkWriteOperation(this.commandBuilder, {
        ...this.clientBulkWriteOptions,
        ...this.cursorOptions,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, clientBulkWriteOperation, this.timeoutContext);
      this.cursorResponse = response;
      return { server: clientBulkWriteOperation.server, session, response };
    }
  }
  exports.ClientBulkWriteCursor = ClientBulkWriteCursor;
});

// node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js
var require_command_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = undefined;
  exports.buildOperation = buildOperation;
  var bson_1 = require_bson2();
  var commands_1 = require_commands();
  var error_1 = require_error();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var MESSAGE_OVERHEAD_BYTES = 1000;

  class ClientBulkWriteCommandBuilder {
    constructor(models, options, pkFactory) {
      this.models = models;
      this.options = options;
      this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;
      this.currentModelIndex = 0;
      this.previousModelIndex = 0;
      this.lastOperations = [];
      this.isBatchRetryable = true;
    }
    get errorsOnly() {
      if ("verboseResults" in this.options) {
        return !this.options.verboseResults;
      }
      return true;
    }
    hasNextBatch() {
      return this.currentModelIndex < this.models.length;
    }
    resetBatch() {
      this.currentModelIndex = this.previousModelIndex;
      return true;
    }
    buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {
      this.isBatchRetryable = true;
      let commandLength = 0;
      let currentNamespaceIndex = 0;
      const command = this.baseCommand();
      const namespaces = new Map;
      this.previousModelIndex = this.currentModelIndex;
      while (this.currentModelIndex < this.models.length) {
        const model = this.models[this.currentModelIndex];
        const ns = model.namespace;
        const nsIndex = namespaces.get(ns);
        if (model.name === "deleteMany" || model.name === "updateMany") {
          this.isBatchRetryable = false;
        }
        if (nsIndex != null) {
          const operation = buildOperation(model, nsIndex, this.pkFactory, this.options);
          let operationBuffer;
          try {
            operationBuffer = bson_1.BSON.serialize(operation);
          } catch (cause) {
            throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });
          }
          validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
          if (commandLength + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
            commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);
            this.currentModelIndex++;
          } else {
            break;
          }
        } else {
          namespaces.set(ns, currentNamespaceIndex);
          const nsInfo = { ns };
          const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory, this.options);
          let nsInfoBuffer;
          let operationBuffer;
          try {
            nsInfoBuffer = bson_1.BSON.serialize(nsInfo);
            operationBuffer = bson_1.BSON.serialize(operation);
          } catch (cause) {
            throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });
          }
          validateBufferSize("nsInfo", nsInfoBuffer, maxBsonObjectSize);
          validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
          if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
            commandLength = MESSAGE_OVERHEAD_BYTES + command.nsInfo.push(nsInfo, nsInfoBuffer) + command.ops.push(operation, operationBuffer);
            currentNamespaceIndex++;
            this.currentModelIndex++;
          } else {
            break;
          }
        }
      }
      this.lastOperations = command.ops.documents;
      return command;
    }
    baseCommand() {
      const command = {
        bulkWrite: 1,
        errorsOnly: this.errorsOnly,
        ordered: this.options.ordered ?? true,
        ops: new commands_1.DocumentSequence("ops"),
        nsInfo: new commands_1.DocumentSequence("nsInfo")
      };
      if (this.options.bypassDocumentValidation != null) {
        command.bypassDocumentValidation = this.options.bypassDocumentValidation;
      }
      if (this.options.let) {
        command.let = this.options.let;
      }
      if (this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return command;
    }
  }
  exports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
  function validateBufferSize(name, buffer, maxBsonObjectSize) {
    if (buffer.length > maxBsonObjectSize) {
      throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);
    }
  }
  var buildInsertOneOperation = (model, index, pkFactory) => {
    const document2 = {
      insert: index,
      document: model.document
    };
    document2.document._id = model.document._id ?? pkFactory.createPk();
    return document2;
  };
  exports.buildInsertOneOperation = buildInsertOneOperation;
  var buildDeleteOneOperation = (model, index) => {
    return createDeleteOperation(model, index, false);
  };
  exports.buildDeleteOneOperation = buildDeleteOneOperation;
  var buildDeleteManyOperation = (model, index) => {
    return createDeleteOperation(model, index, true);
  };
  exports.buildDeleteManyOperation = buildDeleteManyOperation;
  function createDeleteOperation(model, index, multi) {
    const document2 = {
      delete: index,
      multi,
      filter: model.filter
    };
    if (model.hint) {
      document2.hint = model.hint;
    }
    if (model.collation) {
      document2.collation = model.collation;
    }
    return document2;
  }
  var buildUpdateOneOperation = (model, index, options) => {
    return createUpdateOperation(model, index, false, options);
  };
  exports.buildUpdateOneOperation = buildUpdateOneOperation;
  var buildUpdateManyOperation = (model, index, options) => {
    return createUpdateOperation(model, index, true, options);
  };
  exports.buildUpdateManyOperation = buildUpdateManyOperation;
  function validateUpdate(update, options) {
    if (!(0, utils_1.hasAtomicOperators)(update, options)) {
      throw new error_1.MongoAPIError("Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.");
    }
  }
  function createUpdateOperation(model, index, multi, options) {
    validateUpdate(model.update, options);
    const document2 = {
      update: index,
      multi,
      filter: model.filter,
      updateMods: model.update
    };
    if (model.hint) {
      document2.hint = model.hint;
    }
    if (model.upsert) {
      document2.upsert = model.upsert;
    }
    if (model.arrayFilters) {
      document2.arrayFilters = model.arrayFilters;
    }
    if (model.collation) {
      document2.collation = model.collation;
    }
    if (!multi && "sort" in model && model.sort != null) {
      document2.sort = (0, sort_1.formatSort)(model.sort);
    }
    return document2;
  }
  var buildReplaceOneOperation = (model, index) => {
    if ((0, utils_1.hasAtomicOperators)(model.replacement)) {
      throw new error_1.MongoAPIError("Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.");
    }
    const document2 = {
      update: index,
      multi: false,
      filter: model.filter,
      updateMods: model.replacement
    };
    if (model.hint) {
      document2.hint = model.hint;
    }
    if (model.upsert) {
      document2.upsert = model.upsert;
    }
    if (model.collation) {
      document2.collation = model.collation;
    }
    if (model.sort != null) {
      document2.sort = (0, sort_1.formatSort)(model.sort);
    }
    return document2;
  };
  exports.buildReplaceOneOperation = buildReplaceOneOperation;
  function buildOperation(model, index, pkFactory, options) {
    switch (model.name) {
      case "insertOne":
        return (0, exports.buildInsertOneOperation)(model, index, pkFactory);
      case "deleteOne":
        return (0, exports.buildDeleteOneOperation)(model, index);
      case "deleteMany":
        return (0, exports.buildDeleteManyOperation)(model, index);
      case "updateOne":
        return (0, exports.buildUpdateOneOperation)(model, index, options);
      case "updateMany":
        return (0, exports.buildUpdateManyOperation)(model, index, options);
      case "replaceOne":
        return (0, exports.buildReplaceOneOperation)(model, index);
    }
  }
});

// node_modules/mongodb/lib/operations/client_bulk_write/results_merger.js
var require_results_merger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteResultsMerger = undefined;
  var __1 = require_lib3();
  var error_1 = require_error();
  var UNACKNOWLEDGED = {
    acknowledged: false,
    insertedCount: 0,
    upsertedCount: 0,
    matchedCount: 0,
    modifiedCount: 0,
    deletedCount: 0,
    insertResults: undefined,
    updateResults: undefined,
    deleteResults: undefined
  };

  class ClientBulkWriteResultsMerger {
    static unacknowledged() {
      return UNACKNOWLEDGED;
    }
    constructor(options) {
      this.options = options;
      this.currentBatchOffset = 0;
      this.writeConcernErrors = [];
      this.writeErrors = new Map;
      this.result = {
        acknowledged: true,
        insertedCount: 0,
        upsertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        insertResults: undefined,
        updateResults: undefined,
        deleteResults: undefined
      };
      if (options.verboseResults) {
        this.result.insertResults = new Map;
        this.result.updateResults = new Map;
        this.result.deleteResults = new Map;
      }
    }
    get bulkWriteResult() {
      return {
        acknowledged: this.result.acknowledged,
        insertedCount: this.result.insertedCount,
        upsertedCount: this.result.upsertedCount,
        matchedCount: this.result.matchedCount,
        modifiedCount: this.result.modifiedCount,
        deletedCount: this.result.deletedCount,
        insertResults: this.result.insertResults,
        updateResults: this.result.updateResults,
        deleteResults: this.result.deleteResults
      };
    }
    async merge(cursor) {
      let writeConcernErrorResult;
      try {
        for await (const document2 of cursor) {
          if (document2.ok === 1) {
            if (this.options.verboseResults) {
              this.processDocument(cursor, document2);
            }
          } else {
            if (this.options.ordered) {
              const error = new error_1.MongoClientBulkWriteError({
                message: "Mongo client ordered bulk write encountered a write error."
              });
              error.writeErrors.set(document2.idx + this.currentBatchOffset, {
                code: document2.code,
                message: document2.errmsg
              });
              error.partialResult = this.result;
              throw error;
            } else {
              this.writeErrors.set(document2.idx + this.currentBatchOffset, {
                code: document2.code,
                message: document2.errmsg
              });
            }
          }
        }
      } catch (error) {
        if (error instanceof __1.MongoWriteConcernError) {
          const result = error.result;
          writeConcernErrorResult = {
            insertedCount: result.nInserted,
            upsertedCount: result.nUpserted,
            matchedCount: result.nMatched,
            modifiedCount: result.nModified,
            deletedCount: result.nDeleted,
            writeConcernError: result.writeConcernError
          };
          if (this.options.verboseResults && result.cursor.firstBatch) {
            for (const document2 of result.cursor.firstBatch) {
              if (document2.ok === 1) {
                this.processDocument(cursor, document2);
              }
            }
          }
        } else {
          throw error;
        }
      } finally {
        if (cursor.response) {
          const response = cursor.response;
          this.incrementCounts(response);
        }
        this.currentBatchOffset += cursor.operations.length;
      }
      if (writeConcernErrorResult) {
        const writeConcernError = writeConcernErrorResult.writeConcernError;
        this.incrementCounts(writeConcernErrorResult);
        this.writeConcernErrors.push({
          code: writeConcernError.code,
          message: writeConcernError.errmsg
        });
      }
      return this.result;
    }
    processDocument(cursor, document2) {
      const operation = cursor.operations[document2.idx];
      if ("insert" in operation) {
        this.result.insertResults?.set(document2.idx + this.currentBatchOffset, {
          insertedId: operation.document._id
        });
      }
      if ("update" in operation) {
        const result = {
          matchedCount: document2.n,
          modifiedCount: document2.nModified ?? 0,
          didUpsert: document2.upserted != null
        };
        if (document2.upserted) {
          result.upsertedId = document2.upserted._id;
        }
        this.result.updateResults?.set(document2.idx + this.currentBatchOffset, result);
      }
      if ("delete" in operation) {
        this.result.deleteResults?.set(document2.idx + this.currentBatchOffset, {
          deletedCount: document2.n
        });
      }
    }
    incrementCounts(document2) {
      this.result.insertedCount += document2.insertedCount;
      this.result.upsertedCount += document2.upsertedCount;
      this.result.matchedCount += document2.matchedCount;
      this.result.modifiedCount += document2.modifiedCount;
      this.result.deletedCount += document2.deletedCount;
    }
  }
  exports.ClientBulkWriteResultsMerger = ClientBulkWriteResultsMerger;
});

// node_modules/mongodb/lib/operations/client_bulk_write/executor.js
var require_executor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteExecutor = undefined;
  var abstract_cursor_1 = require_abstract_cursor();
  var client_bulk_write_cursor_1 = require_client_bulk_write_cursor();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var execute_operation_1 = require_execute_operation();
  var client_bulk_write_1 = require_client_bulk_write();
  var command_builder_1 = require_command_builder();
  var results_merger_1 = require_results_merger();

  class ClientBulkWriteExecutor {
    constructor(client, operations, options) {
      if (operations.length === 0) {
        throw new error_1.MongoClientBulkWriteExecutionError("No client bulk write models were provided.");
      }
      this.client = client;
      this.operations = operations;
      this.options = {
        ordered: true,
        bypassDocumentValidation: false,
        verboseResults: false,
        ...options
      };
      if (!this.options.writeConcern) {
        this.options.writeConcern = write_concern_1.WriteConcern.fromOptions(this.client.s.options);
      }
      if (this.options.writeConcern?.w === 0) {
        if (this.options.verboseResults) {
          throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and verbose results");
        }
        if (this.options.ordered) {
          throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and ordered writes");
        }
      }
    }
    async execute() {
      const pkFactory = this.client.s.options.pkFactory;
      const commandBuilder = new command_builder_1.ClientBulkWriteCommandBuilder(this.operations, this.options, pkFactory);
      const resolvedOptions = (0, utils_1.resolveTimeoutOptions)(this.client, this.options);
      const context = timeout_1.TimeoutContext.create(resolvedOptions);
      if (this.options.writeConcern?.w === 0) {
        while (commandBuilder.hasNextBatch()) {
          const operation = new client_bulk_write_1.ClientBulkWriteOperation(commandBuilder, this.options);
          await (0, execute_operation_1.executeOperation)(this.client, operation, context);
        }
        return results_merger_1.ClientBulkWriteResultsMerger.unacknowledged();
      } else {
        const resultsMerger = new results_merger_1.ClientBulkWriteResultsMerger(this.options);
        while (commandBuilder.hasNextBatch()) {
          const cursorContext = new abstract_cursor_1.CursorTimeoutContext(context, Symbol());
          const options = {
            ...this.options,
            timeoutContext: cursorContext,
            ...resolvedOptions.timeoutMS != null && { timeoutMode: abstract_cursor_1.CursorTimeoutMode.LIFETIME }
          };
          const cursor = new client_bulk_write_cursor_1.ClientBulkWriteCursor(this.client, commandBuilder, options);
          try {
            await resultsMerger.merge(cursor);
          } catch (error) {
            if (error instanceof error_1.MongoServerError && !(error instanceof error_1.MongoClientBulkWriteError)) {
              const bulkWriteError = new error_1.MongoClientBulkWriteError({
                message: "Mongo client bulk write encountered an error during execution"
              });
              bulkWriteError.cause = error;
              bulkWriteError.partialResult = resultsMerger.bulkWriteResult;
              throw bulkWriteError;
            } else {
              throw error;
            }
          }
        }
        if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {
          const error = new error_1.MongoClientBulkWriteError({
            message: "Mongo client bulk write encountered errors during execution."
          });
          error.writeConcernErrors = resultsMerger.writeConcernErrors;
          error.writeErrors = resultsMerger.writeErrors;
          error.partialResult = resultsMerger.bulkWriteResult;
          throw error;
        }
        return resultsMerger.bulkWriteResult;
      }
    }
  }
  exports.ClientBulkWriteExecutor = ClientBulkWriteExecutor;
});

// node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCapabilities = exports.Topology = undefined;
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  var common_1 = require_common2();
  var events_1 = require_events();
  var server_1 = require_server();
  var server_description_1 = require_server_description();
  var server_selection_1 = require_server_selection();
  var server_selection_events_1 = require_server_selection_events();
  var srv_polling_1 = require_srv_polling();
  var topology_description_1 = require_topology_description();
  var globalTopologyCounter = 0;
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });

  class Topology extends mongo_types_1.TypedEventEmitter {
    constructor(client, seeds, options) {
      super();
      this.on("error", utils_1.noop);
      this.client = client;
      options = options ?? {
        hosts: [utils_1.HostAddress.fromString("localhost:27017")],
        ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())
      };
      if (typeof seeds === "string") {
        seeds = [utils_1.HostAddress.fromString(seeds)];
      } else if (!Array.isArray(seeds)) {
        seeds = [seeds];
      }
      const seedlist = [];
      for (const seed of seeds) {
        if (typeof seed === "string") {
          seedlist.push(utils_1.HostAddress.fromString(seed));
        } else if (seed instanceof utils_1.HostAddress) {
          seedlist.push(seed);
        } else {
          throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
        }
      }
      const topologyType = topologyTypeFromOptions(options);
      const topologyId = globalTopologyCounter++;
      const selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
      const serverDescriptions = new Map;
      for (const hostAddress of selectedHosts) {
        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
      }
      this.waitQueue = new utils_1.List;
      this.s = {
        id: topologyId,
        options,
        seedlist,
        state: common_1.STATE_CLOSED,
        description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
        serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
        servers: new Map,
        credentials: options?.credentials,
        clusterTime: undefined,
        detectShardedTopology: (ev) => this.detectShardedTopology(ev),
        detectSrvRecords: (ev) => this.detectSrvRecords(ev)
      };
      this.mongoLogger = client.mongoLogger;
      this.component = "topology";
      if (options.srvHost && !options.loadBalanced) {
        this.s.srvPoller = options.srvPoller ?? new srv_polling_1.SrvPoller({
          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
          srvHost: options.srvHost,
          srvMaxHosts: options.srvMaxHosts,
          srvServiceName: options.srvServiceName
        });
        this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
      }
      this.connectionLock = undefined;
    }
    detectShardedTopology(event) {
      const previousType = event.previousDescription.type;
      const newType = event.newDescription.type;
      const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
      const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
      const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
      if (transitionToSharded && !listeningToSrvPolling) {
        this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        this.s.srvPoller?.start();
      }
    }
    detectSrvRecords(ev) {
      const previousTopologyDescription = this.s.description;
      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
      if (this.s.description === previousTopologyDescription) {
        return;
      }
      updateServers(this);
      this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    get description() {
      return this.s.description;
    }
    get loadBalanced() {
      return this.s.options.loadBalanced;
    }
    get serverApi() {
      return this.s.options.serverApi;
    }
    get capabilities() {
      return new ServerCapabilities(this.lastHello());
    }
    async connect(options) {
      this.connectionLock ??= this._connect(options);
      try {
        await this.connectionLock;
        return this;
      } finally {
        this.connectionLock = undefined;
      }
    }
    async _connect(options) {
      options = options ?? {};
      if (this.s.state === common_1.STATE_CONNECTED) {
        return this;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      this.emitAndLog(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
      this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), this.s.description));
      const serverDescriptions = Array.from(this.s.description.servers.values());
      this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
        serverDescription.address,
        createAndConnectServer(this, serverDescription)
      ]));
      if (this.s.options.loadBalanced) {
        for (const description of serverDescriptions) {
          const newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
            loadBalanced: this.s.options.loadBalanced
          });
          this.serverUpdateHandler(newDescription);
        }
      }
      const serverSelectionTimeoutMS = this.client.s.options.serverSelectionTimeoutMS;
      const readPreference = options.readPreference ?? read_preference_1.ReadPreference.primary;
      const timeoutContext = timeout_1.TimeoutContext.create({
        timeoutMS: undefined,
        serverSelectionTimeoutMS,
        waitQueueTimeoutMS: this.client.s.options.waitQueueTimeoutMS
      });
      const selectServerOptions = {
        operationName: "ping",
        ...options,
        timeoutContext
      };
      try {
        const server = await this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), selectServerOptions);
        const skipPingOnConnect = this.s.options.__skipPingOnConnect === true;
        if (!skipPingOnConnect && this.s.credentials) {
          await server.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, { timeoutContext });
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(Topology.OPEN, this);
          this.emit(Topology.CONNECT, this);
          return this;
        }
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Topology.OPEN, this);
        this.emit(Topology.CONNECT, this);
        return this;
      } catch (error) {
        this.close();
        throw error;
      }
    }
    closeCheckedOutConnections() {
      for (const server of this.s.servers.values()) {
        return server.closeCheckedOutConnections();
      }
    }
    close() {
      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
        return;
      }
      for (const server of this.s.servers.values()) {
        closeServer(server, this);
      }
      this.s.servers.clear();
      stateTransition(this, common_1.STATE_CLOSING);
      drainWaitQueue(this.waitQueue, new error_1.MongoTopologyClosedError);
      if (this.s.srvPoller) {
        this.s.srvPoller.stop();
        this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
      }
      this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
      stateTransition(this, common_1.STATE_CLOSED);
      this.emitAndLog(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
    }
    async selectServer(selector, options) {
      let serverSelector;
      if (typeof selector !== "function") {
        if (typeof selector === "string") {
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
        } else {
          let readPreference;
          if (selector instanceof read_preference_1.ReadPreference) {
            readPreference = selector;
          } else {
            read_preference_1.ReadPreference.translate(options);
            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
          }
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
        }
      } else {
        serverSelector = selector;
      }
      options = { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS, ...options };
      if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
        this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionStartedEvent(selector, this.description, options.operationName));
      }
      let timeout;
      if (options.timeoutContext)
        timeout = options.timeoutContext.serverSelectionTimeout;
      else {
        timeout = timeout_1.Timeout.expires(options.serverSelectionTimeoutMS ?? 0);
      }
      const isSharded = this.description.type === common_1.TopologyType.Sharded;
      const session = options.session;
      const transaction = session && session.transaction;
      if (isSharded && transaction && transaction.server) {
        if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(selector, this.description, transaction.server.pool.address, options.operationName));
        }
        if (options.timeoutContext?.clearServerSelectionTimeout)
          timeout?.clear();
        return transaction.server;
      }
      const { promise: serverPromise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
      const waitQueueMember = {
        serverSelector,
        topologyDescription: this.description,
        mongoLogger: this.client.mongoLogger,
        transaction,
        resolve,
        reject,
        cancelled: false,
        startTime: (0, utils_1.now)(),
        operationName: options.operationName,
        waitingLogged: false,
        previousServer: options.previousServer
      };
      const abortListener = (0, utils_1.addAbortListener)(options.signal, function() {
        waitQueueMember.cancelled = true;
        reject(this.reason);
      });
      this.waitQueue.push(waitQueueMember);
      processWaitQueue(this);
      try {
        timeout?.throwIfExpired();
        const server = await (timeout ? Promise.race([serverPromise, timeout]) : serverPromise);
        if (options.timeoutContext?.csotEnabled() && server.description.minRoundTripTime !== 0) {
          options.timeoutContext.minRoundTripTime = server.description.minRoundTripTime;
        }
        return server;
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          waitQueueMember.cancelled = true;
          const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${timeout?.duration} ms`, this.description);
          if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(selector, this.description, timeoutError, options.operationName));
          }
          if (options.timeoutContext?.csotEnabled()) {
            throw new error_1.MongoOperationTimeoutError("Timed out during server selection", {
              cause: timeoutError
            });
          }
          throw timeoutError;
        }
        throw error;
      } finally {
        abortListener?.[utils_1.kDispose]();
        if (options.timeoutContext?.clearServerSelectionTimeout)
          timeout?.clear();
      }
    }
    serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      }
      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      }
      const previousTopologyDescription = this.s.description;
      const previousServerDescription = this.s.description.servers.get(serverDescription.address);
      if (!previousServerDescription) {
        return;
      }
      const clusterTime = serverDescription.$clusterTime;
      if (clusterTime) {
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
      this.s.description = this.s.description.update(serverDescription);
      if (this.s.description.compatibilityError) {
        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
        return;
      }
      if (!equalDescriptions) {
        const newDescription = this.s.description.servers.get(serverDescription.address);
        if (newDescription) {
          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
        }
      }
      updateServers(this, serverDescription);
      if (this.waitQueue.length > 0) {
        processWaitQueue(this);
      }
      if (!equalDescriptions) {
        this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
    auth(credentials, callback) {
      if (typeof credentials === "function")
        callback = credentials, credentials = undefined;
      if (typeof callback === "function")
        callback(undefined, true);
    }
    get clientMetadata() {
      return this.s.options.metadata;
    }
    isConnected() {
      return this.s.state === common_1.STATE_CONNECTED;
    }
    isDestroyed() {
      return this.s.state === common_1.STATE_CLOSED;
    }
    lastHello() {
      const serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0)
        return {};
      const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
      const result = sd || { maxWireVersion: this.description.commonWireVersion };
      return result;
    }
    get commonWireVersion() {
      return this.description.commonWireVersion;
    }
    get logicalSessionTimeoutMinutes() {
      return this.description.logicalSessionTimeoutMinutes;
    }
    get clusterTime() {
      return this.s.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  }
  exports.Topology = Topology;
  Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
  Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
  Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
  Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
  Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
  Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
  Topology.ERROR = constants_1.ERROR;
  Topology.OPEN = constants_1.OPEN;
  Topology.CONNECT = constants_1.CONNECT;
  Topology.CLOSE = constants_1.CLOSE;
  Topology.TIMEOUT = constants_1.TIMEOUT;
  function closeServer(server, topology) {
    for (const event of constants_1.LOCAL_SERVER_EVENTS) {
      server.removeAllListeners(event);
    }
    server.close();
    topology.emitAndLog(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
      server.removeAllListeners(event);
    }
  }
  function topologyTypeFromOptions(options) {
    if (options?.directConnection) {
      return common_1.TopologyType.Single;
    }
    if (options?.replicaSet) {
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
    if (options?.loadBalanced) {
      return common_1.TopologyType.LoadBalanced;
    }
    return common_1.TopologyType.Unknown;
  }
  function createAndConnectServer(topology, serverDescription) {
    topology.emitAndLog(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new server_1.Server(topology, serverDescription, topology.s.options);
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
      server.on(event, (e) => topology.emit(event, e));
    }
    server.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
    server.connect();
    return server;
  }
  function updateServers(topology, incomingServerDescription) {
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
      const server = topology.s.servers.get(incomingServerDescription.address);
      if (server) {
        server.s.description = incomingServerDescription;
        if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
          const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
          server.pool.clear({ interruptInUseConnections });
        } else if (incomingServerDescription.error == null) {
          const newTopologyType = topology.s.description.type;
          const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
          if (shouldMarkPoolReady) {
            server.pool.ready();
          }
        }
      }
    }
    for (const serverDescription of topology.description.servers.values()) {
      if (!topology.s.servers.has(serverDescription.address)) {
        const server = createAndConnectServer(topology, serverDescription);
        topology.s.servers.set(serverDescription.address, server);
      }
    }
    for (const entry of topology.s.servers) {
      const serverAddress = entry[0];
      if (topology.description.hasServer(serverAddress)) {
        continue;
      }
      if (!topology.s.servers.has(serverAddress)) {
        continue;
      }
      const server = topology.s.servers.get(serverAddress);
      topology.s.servers.delete(serverAddress);
      if (server) {
        closeServer(server, topology);
      }
    }
  }
  function drainWaitQueue(queue, drainError) {
    while (queue.length) {
      const waitQueueMember = queue.shift();
      if (!waitQueueMember) {
        continue;
      }
      if (!waitQueueMember.cancelled) {
        if (waitQueueMember.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          waitQueueMember.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, drainError, waitQueueMember.operationName));
        }
        waitQueueMember.reject(drainError);
      }
    }
  }
  function processWaitQueue(topology) {
    if (topology.s.state === common_1.STATE_CLOSED) {
      drainWaitQueue(topology.waitQueue, new error_1.MongoTopologyClosedError);
      return;
    }
    const isSharded = topology.description.type === common_1.TopologyType.Sharded;
    const serverDescriptions = Array.from(topology.description.servers.values());
    const membersToProcess = topology.waitQueue.length;
    for (let i = 0;i < membersToProcess; ++i) {
      const waitQueueMember = topology.waitQueue.shift();
      if (!waitQueueMember) {
        continue;
      }
      if (waitQueueMember.cancelled) {
        continue;
      }
      let selectedDescriptions;
      try {
        const serverSelector = waitQueueMember.serverSelector;
        const previousServer = waitQueueMember.previousServer;
        selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions, previousServer ? [previousServer] : []) : serverDescriptions;
      } catch (selectorError) {
        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, selectorError, waitQueueMember.operationName));
        }
        waitQueueMember.reject(selectorError);
        continue;
      }
      let selectedServer;
      if (selectedDescriptions.length === 0) {
        if (!waitQueueMember.waitingLogged) {
          if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.INFORMATIONAL)) {
            topology.client.mongoLogger?.info(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.WaitingForSuitableServerEvent(waitQueueMember.serverSelector, topology.description, topology.s.serverSelectionTimeoutMS !== 0 ? topology.s.serverSelectionTimeoutMS - ((0, utils_1.now)() - waitQueueMember.startTime) : -1, waitQueueMember.operationName));
          }
          waitQueueMember.waitingLogged = true;
        }
        topology.waitQueue.push(waitQueueMember);
        continue;
      } else if (selectedDescriptions.length === 1) {
        selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
      } else {
        const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
        const server1 = topology.s.servers.get(descriptions[0].address);
        const server2 = topology.s.servers.get(descriptions[1].address);
        selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
      }
      if (!selectedServer) {
        const serverSelectionError = new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description);
        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, serverSelectionError, waitQueueMember.operationName));
        }
        waitQueueMember.reject(serverSelectionError);
        return;
      }
      const transaction = waitQueueMember.transaction;
      if (isSharded && transaction && transaction.isActive && selectedServer) {
        transaction.pinServer(selectedServer);
      }
      if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
        topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, selectedServer.pool.address, waitQueueMember.operationName));
      }
      waitQueueMember.resolve(selectedServer);
    }
    if (topology.waitQueue.length > 0) {
      for (const [, server] of topology.s.servers) {
        process.nextTick(function scheduleServerCheck() {
          return server.requestCheck();
        });
      }
    }
  }
  function isStaleServerDescription(topologyDescription, incomingServerDescription) {
    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    const currentTopologyVersion = currentServerDescription?.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
  }

  class ServerCapabilities {
    constructor(hello) {
      this.minWireVersion = hello.minWireVersion || 0;
      this.maxWireVersion = hello.maxWireVersion || 0;
    }
    get hasAggregationCursor() {
      return this.maxWireVersion >= 1;
    }
    get hasWriteCommands() {
      return this.maxWireVersion >= 2;
    }
    get hasTextSearch() {
      return this.minWireVersion >= 0;
    }
    get hasAuthCommands() {
      return this.maxWireVersion >= 1;
    }
    get hasListCollectionsCommand() {
      return this.maxWireVersion >= 3;
    }
    get hasListIndexesCommand() {
      return this.maxWireVersion >= 3;
    }
    get supportsSnapshotReads() {
      return this.maxWireVersion >= 13;
    }
    get commandsTakeWriteConcern() {
      return this.maxWireVersion >= 5;
    }
    get commandsTakeCollation() {
      return this.maxWireVersion >= 5;
    }
  }
  exports.ServerCapabilities = ServerCapabilities;
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoClient = exports.ServerApiVersion = undefined;
  var fs_1 = __require("fs");
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var client_metadata_1 = require_client_metadata();
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var executor_1 = require_executor();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_preference_1 = require_read_preference();
  var resource_management_1 = require_resource_management();
  var server_selection_1 = require_server_selection();
  var topology_1 = require_topology();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  exports.ServerApiVersion = Object.freeze({
    v1: "1"
  });

  class MongoClient extends mongo_types_1.TypedEventEmitter {
    constructor(url, options) {
      super();
      this.on("error", utils_1.noop);
      this.options = (0, connection_string_1.parseOptions)(url, this, options);
      const shouldSetLogger = Object.values(this.options.mongoLoggerOptions.componentSeverities).some((value) => value !== mongo_logger_1.SeverityLevel.OFF);
      this.mongoLogger = shouldSetLogger ? new mongo_logger_1.MongoLogger(this.options.mongoLoggerOptions) : undefined;
      const client = this;
      this.s = {
        url,
        bsonOptions: (0, bson_1.resolveBSONOptions)(this.options),
        namespace: (0, utils_1.ns)("admin"),
        hasBeenClosed: false,
        sessionPool: new sessions_1.ServerSessionPool(this),
        activeSessions: new Set,
        activeCursors: new Set,
        authProviders: new mongo_client_auth_providers_1.MongoClientAuthProviders,
        get options() {
          return client.options;
        },
        get readConcern() {
          return client.options.readConcern;
        },
        get writeConcern() {
          return client.options.writeConcern;
        },
        get readPreference() {
          return client.options.readPreference;
        },
        get isMongoClient() {
          return true;
        }
      };
      this.checkForNonGenuineHosts();
    }
    async asyncDispose() {
      await this.close();
    }
    appendMetadata(driverInfo) {
      this.options.additionalDriverInfo.push(driverInfo);
      this.options.metadata = (0, client_metadata_1.makeClientMetadata)(this.options);
      this.options.extendedMetadata = (0, client_metadata_1.addContainerMetadata)(this.options.metadata).then(undefined, utils_1.squashError).then((result) => result ?? {});
    }
    checkForNonGenuineHosts() {
      const documentDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, hostAddress.host));
      const srvHostIsDocumentDB = (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, this.options.srvHost);
      const cosmosDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, hostAddress.host));
      const srvHostIsCosmosDB = (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, this.options.srvHost);
      if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
        this.mongoLogger?.info("client", utils_1.DOCUMENT_DB_MSG);
      } else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
        this.mongoLogger?.info("client", utils_1.COSMOS_DB_MSG);
      }
    }
    get serverApi() {
      return this.options.serverApi && Object.freeze({ ...this.options.serverApi });
    }
    get monitorCommands() {
      return this.options.monitorCommands;
    }
    set monitorCommands(value) {
      this.options.monitorCommands = value;
    }
    get autoEncrypter() {
      return this.options.autoEncrypter;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get readPreference() {
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get timeoutMS() {
      return this.s.options.timeoutMS;
    }
    async bulkWrite(models, options) {
      if (this.autoEncrypter) {
        throw new error_1.MongoInvalidArgumentError("MongoClient bulkWrite does not currently support automatic encryption.");
      }
      return await new executor_1.ClientBulkWriteExecutor(this, models, (0, utils_1.resolveOptions)(this, options)).execute();
    }
    async connect() {
      if (this.connectionLock) {
        return await this.connectionLock;
      }
      try {
        this.connectionLock = this._connect();
        await this.connectionLock;
      } finally {
        this.connectionLock = undefined;
      }
      return this;
    }
    async _connect() {
      if (this.topology && this.topology.isConnected()) {
        return this;
      }
      const options = this.options;
      if (options.tls) {
        if (typeof options.tlsCAFile === "string") {
          options.ca ??= await fs_1.promises.readFile(options.tlsCAFile);
        }
        if (typeof options.tlsCRLFile === "string") {
          options.crl ??= await fs_1.promises.readFile(options.tlsCRLFile);
        }
        if (typeof options.tlsCertificateKeyFile === "string") {
          if (!options.key || !options.cert) {
            const contents = await fs_1.promises.readFile(options.tlsCertificateKeyFile);
            options.key ??= contents;
            options.cert ??= contents;
          }
        }
      }
      if (typeof options.srvHost === "string") {
        const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
        for (const [index, host] of hosts.entries()) {
          options.hosts[index] = host;
        }
      }
      if (options.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        const allowedHosts = options.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
        const isServiceAuth = !!options.credentials?.mechanismProperties?.ENVIRONMENT;
        if (!isServiceAuth) {
          for (const host of options.hosts) {
            if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
              throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(",")}'`);
            }
          }
        }
      }
      this.topology = new topology_1.Topology(this, options.hosts, options);
      this.topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
      for (const event of constants_1.MONGO_CLIENT_EVENTS) {
        this.topology.on(event, (...args) => this.emit(event, ...args));
      }
      const topologyConnect = async () => {
        try {
          await this.topology?.connect(options);
        } catch (error) {
          this.topology?.close();
          throw error;
        }
      };
      if (this.autoEncrypter) {
        await this.autoEncrypter?.init();
        await topologyConnect();
        await options.encrypter.connectInternalClient();
      } else {
        await topologyConnect();
      }
      return this;
    }
    async close(_force = false) {
      if (this.closeLock) {
        return await this.closeLock;
      }
      try {
        this.closeLock = this._close();
        await this.closeLock;
      } finally {
        this.closeLock = undefined;
      }
    }
    async _close() {
      Object.defineProperty(this.s, "hasBeenClosed", {
        value: true,
        enumerable: true,
        configurable: false,
        writable: false
      });
      this.topology?.closeCheckedOutConnections();
      const activeCursorCloses = Array.from(this.s.activeCursors, (cursor) => cursor.close());
      this.s.activeCursors.clear();
      await Promise.all(activeCursorCloses);
      const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
      this.s.activeSessions.clear();
      await Promise.all(activeSessionEnds);
      if (this.topology == null) {
        return;
      }
      const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
      const topologyDescription = this.topology.description;
      const serverDescriptions = Array.from(topologyDescription.servers.values());
      const servers = selector(topologyDescription, serverDescriptions);
      if (servers.length !== 0) {
        const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
        if (endSessions.length !== 0) {
          try {
            await (0, execute_operation_1.executeOperation)(this, new run_command_1.RunAdminCommandOperation({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }));
          } catch (error) {
            (0, utils_1.squashError)(error);
          }
        }
      }
      const topology = this.topology;
      this.topology = undefined;
      topology.close();
      const { encrypter } = this.options;
      if (encrypter) {
        await encrypter.close(this);
      }
    }
    db(dbName, options) {
      options = options ?? {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.options, options);
      const db = new db_1.Db(this, dbName, finalOptions);
      return db;
    }
    static async connect(url, options) {
      const client = new this(url, options);
      return await client.connect();
    }
    startSession(options) {
      const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this.options);
      this.s.activeSessions.add(session);
      session.once("ended", () => {
        this.s.activeSessions.delete(session);
      });
      return session;
    }
    async withSession(optionsOrExecutor, executor) {
      const options = {
        owner: Symbol(),
        ...typeof optionsOrExecutor === "object" ? optionsOrExecutor : {}
      };
      const withSessionCallback = typeof optionsOrExecutor === "function" ? optionsOrExecutor : executor;
      if (withSessionCallback == null) {
        throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
      }
      const session = this.startSession(options);
      try {
        return await withSessionCallback(session);
      } finally {
        try {
          await session.endSession();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
      }
    }
    watch(pipeline2 = [], options = {}) {
      if (!Array.isArray(pipeline2)) {
        options = pipeline2;
        pipeline2 = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline2, (0, utils_1.resolveOptions)(this, options));
    }
  }
  exports.MongoClient = MongoClient;
  (0, resource_management_1.configureResourceManagement)(MongoClient.prototype);
});

// node_modules/mongodb/lib/resource_management.js
var require_resource_management = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.configureResourceManagement = configureResourceManagement;
  exports.configureExplicitResourceManagement = configureExplicitResourceManagement;
  function configureResourceManagement(target) {
    Symbol.asyncDispose && Object.defineProperty(target, Symbol.asyncDispose, {
      value: async function asyncDispose() {
        await this.asyncDispose();
      },
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  function configureExplicitResourceManagement() {
    const { MongoClient } = require_mongo_client();
    const { ClientSession } = require_sessions();
    const { AbstractCursor } = require_abstract_cursor();
    const { ChangeStream } = require_change_stream();
    configureResourceManagement(MongoClient.prototype);
    configureResourceManagement(ClientSession.prototype);
    configureResourceManagement(AbstractCursor.prototype);
    configureResourceManagement(ChangeStream.prototype);
  }
});

// node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = undefined;
  var stream_1 = __require("stream");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var kill_cursors_1 = require_kill_cursors();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var resource_management_1 = require_resource_management();
  var sessions_1 = require_sessions();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils();
  exports.CURSOR_FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];
  function removeActiveCursor() {
    this.client.s.activeCursors.delete(this);
  }
  exports.CursorTimeoutMode = Object.freeze({
    ITERATION: "iteration",
    LIFETIME: "cursorLifetime"
  });

  class AbstractCursor extends mongo_types_1.TypedEventEmitter {
    constructor(client, namespace, options = {}) {
      super();
      this.documents = null;
      this.hasEmittedClose = false;
      this.on("error", utils_1.noop);
      if (!client.s.isMongoClient) {
        throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
      }
      this.cursorClient = client;
      this.cursorNamespace = namespace;
      this.cursorId = null;
      this.initialized = false;
      this.isClosed = false;
      this.isKilled = false;
      this.cursorOptions = {
        readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,
        ...(0, bson_1.pluckBSONSerializeOptions)(options),
        timeoutMS: options?.timeoutContext?.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,
        tailable: options.tailable,
        awaitData: options.awaitData
      };
      if (this.cursorOptions.timeoutMS != null) {
        if (options.timeoutMode == null) {
          if (options.tailable) {
            if (options.awaitData) {
              if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS)
                throw new error_1.MongoInvalidArgumentError("Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor");
            }
            this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;
          } else {
            this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;
          }
        } else {
          if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {
            throw new error_1.MongoInvalidArgumentError("Cannot set tailable cursor's timeoutMode to LIFETIME");
          }
          this.cursorOptions.timeoutMode = options.timeoutMode;
        }
      } else {
        if (options.timeoutMode != null)
          throw new error_1.MongoInvalidArgumentError("Cannot set timeoutMode without setting timeoutMS");
      }
      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);
      const readConcern = read_concern_1.ReadConcern.fromOptions(options);
      if (readConcern) {
        this.cursorOptions.readConcern = readConcern;
      }
      if (typeof options.batchSize === "number") {
        this.cursorOptions.batchSize = options.batchSize;
      }
      if (options.comment !== undefined) {
        this.cursorOptions.comment = options.comment;
      }
      if (typeof options.maxTimeMS === "number") {
        this.cursorOptions.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.maxAwaitTimeMS === "number") {
        this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;
      }
      this.cursorSession = options.session ?? null;
      this.deserializationOptions = {
        ...this.cursorOptions,
        validation: {
          utf8: options?.enableUtf8Validation === false ? false : true
        }
      };
      this.timeoutContext = options.timeoutContext;
      this.signal = options.signal;
      this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(undefined, utils_1.squashError));
      this.trackCursor();
    }
    get id() {
      return this.cursorId ?? undefined;
    }
    get isDead() {
      return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;
    }
    get client() {
      return this.cursorClient;
    }
    get server() {
      return this.selectedServer;
    }
    get namespace() {
      return this.cursorNamespace;
    }
    get readPreference() {
      return this.cursorOptions.readPreference;
    }
    get readConcern() {
      return this.cursorOptions.readConcern;
    }
    get session() {
      return this.cursorSession;
    }
    set session(clientSession) {
      this.cursorSession = clientSession;
    }
    get closed() {
      return this.isClosed && (this.documents?.length ?? 0) === 0;
    }
    get killed() {
      return this.isKilled;
    }
    get loadBalanced() {
      return !!this.cursorClient.topology?.loadBalanced;
    }
    async asyncDispose() {
      await this.close();
    }
    trackCursor() {
      this.cursorClient.s.activeCursors.add(this);
      if (!this.listeners("close").includes(removeActiveCursor)) {
        this.once("close", removeActiveCursor);
      }
    }
    bufferedCount() {
      return this.documents?.length ?? 0;
    }
    readBufferedDocuments(number) {
      const bufferedDocs = [];
      const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);
      for (let count = 0;count < documentsToRead; count++) {
        const document2 = this.documents?.shift(this.deserializationOptions);
        if (document2 != null) {
          bufferedDocs.push(document2);
        }
      }
      return bufferedDocs;
    }
    async* [Symbol.asyncIterator]() {
      this.signal?.throwIfAborted();
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          if (this.isKilled) {
            return;
          }
          if (this.closed) {
            return;
          }
          if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {
            return;
          }
          const document2 = await this.next();
          if (document2 === null) {
            return;
          }
          yield document2;
          this.signal?.throwIfAborted();
        }
      } finally {
        if (!this.isClosed) {
          try {
            await this.close();
          } catch (error) {
            (0, utils_1.squashError)(error);
          }
        }
      }
    }
    stream(options) {
      const readable = new ReadableCursorStream(this);
      const abortListener = (0, utils_1.addAbortListener)(this.signal, function() {
        readable.destroy(this.reason);
      });
      readable.once("end", () => {
        abortListener?.[utils_1.kDispose]();
      });
      if (options?.transform) {
        const transform2 = options.transform;
        const transformedStream = readable.pipe(new stream_1.Transform({
          objectMode: true,
          highWaterMark: 1,
          transform(chunk, _, callback) {
            try {
              const transformed = transform2(chunk);
              callback(undefined, transformed);
            } catch (err2) {
              callback(err2);
            }
          }
        }));
        readable.on("error", (err2) => transformedStream.emit("error", err2));
        return transformedStream;
      }
      return readable;
    }
    async hasNext() {
      this.signal?.throwIfAborted();
      if (this.cursorId === bson_1.Long.ZERO) {
        return false;
      }
      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
        this.timeoutContext?.refresh();
      }
      try {
        do {
          if ((this.documents?.length ?? 0) !== 0) {
            return true;
          }
          await this.fetchBatch();
        } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
      } finally {
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
          this.timeoutContext?.clear();
        }
      }
      return false;
    }
    async next() {
      this.signal?.throwIfAborted();
      if (this.cursorId === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
        this.timeoutContext?.refresh();
      }
      try {
        do {
          const doc = this.documents?.shift(this.deserializationOptions);
          if (doc != null) {
            if (this.transform != null)
              return await this.transformDocument(doc);
            return doc;
          }
          await this.fetchBatch();
        } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
      } finally {
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
          this.timeoutContext?.clear();
        }
      }
      return null;
    }
    async tryNext() {
      this.signal?.throwIfAborted();
      if (this.cursorId === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
        this.timeoutContext?.refresh();
      }
      try {
        let doc = this.documents?.shift(this.deserializationOptions);
        if (doc != null) {
          if (this.transform != null)
            return await this.transformDocument(doc);
          return doc;
        }
        await this.fetchBatch();
        doc = this.documents?.shift(this.deserializationOptions);
        if (doc != null) {
          if (this.transform != null)
            return await this.transformDocument(doc);
          return doc;
        }
      } finally {
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
          this.timeoutContext?.clear();
        }
      }
      return null;
    }
    async forEach(iterator) {
      this.signal?.throwIfAborted();
      if (typeof iterator !== "function") {
        throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
      }
      for await (const document2 of this) {
        const result = iterator(document2);
        if (result === false) {
          break;
        }
      }
    }
    async close(options) {
      await this.cleanup(options?.timeoutMS);
    }
    async toArray() {
      this.signal?.throwIfAborted();
      const array = [];
      for await (const document2 of this) {
        array.push(document2);
        const docs = this.readBufferedDocuments();
        if (this.transform != null) {
          for (const doc of docs) {
            array.push(await this.transformDocument(doc));
          }
        } else {
          array.push(...docs);
        }
      }
      return array;
    }
    addCursorFlag(flag, value) {
      this.throwIfInitialized();
      if (!exports.CURSOR_FLAGS.includes(flag)) {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);
      }
      if (typeof value !== "boolean") {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
      }
      this.cursorOptions[flag] = value;
      return this;
    }
    map(transform2) {
      this.throwIfInitialized();
      const oldTransform = this.transform;
      if (oldTransform) {
        this.transform = (doc) => {
          return transform2(oldTransform(doc));
        };
      } else {
        this.transform = transform2;
      }
      return this;
    }
    withReadPreference(readPreference) {
      this.throwIfInitialized();
      if (readPreference instanceof read_preference_1.ReadPreference) {
        this.cursorOptions.readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      } else {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
      }
      return this;
    }
    withReadConcern(readConcern) {
      this.throwIfInitialized();
      const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
      if (resolvedReadConcern) {
        this.cursorOptions.readConcern = resolvedReadConcern;
      }
      return this;
    }
    maxTimeMS(value) {
      this.throwIfInitialized();
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this.cursorOptions.maxTimeMS = value;
      return this;
    }
    batchSize(value) {
      this.throwIfInitialized();
      if (this.cursorOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
      }
      this.cursorOptions.batchSize = value;
      return this;
    }
    rewind() {
      if (this.timeoutContext && this.timeoutContext.owner !== this) {
        throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);
      }
      if (!this.initialized) {
        return;
      }
      this.cursorId = null;
      this.documents?.clear();
      this.timeoutContext?.clear();
      this.timeoutContext = undefined;
      this.isClosed = false;
      this.isKilled = false;
      this.initialized = false;
      this.hasEmittedClose = false;
      this.trackCursor();
      if (this.cursorSession?.explicit === false) {
        if (!this.cursorSession.hasEnded) {
          this.cursorSession.endSession().then(undefined, utils_1.squashError);
        }
        this.cursorSession = null;
      }
    }
    async getMore(batchSize) {
      if (this.cursorId == null) {
        throw new error_1.MongoRuntimeError("Unexpected null cursor id. A cursor creating command should have set this");
      }
      if (this.selectedServer == null) {
        throw new error_1.MongoRuntimeError("Unexpected null selectedServer. A cursor creating command should have set this");
      }
      if (this.cursorSession == null) {
        throw new error_1.MongoRuntimeError("Unexpected null session. A cursor creating command should have set this");
      }
      const getMoreOptions = {
        ...this.cursorOptions,
        session: this.cursorSession,
        batchSize
      };
      const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);
      return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);
    }
    async cursorInit() {
      if (this.cursorOptions.timeoutMS != null) {
        this.timeoutContext ??= new CursorTimeoutContext(timeout_1.TimeoutContext.create({
          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
          timeoutMS: this.cursorOptions.timeoutMS
        }), this);
      }
      try {
        this.cursorSession ??= this.cursorClient.startSession({ owner: this, explicit: false });
        const state = await this._initialize(this.cursorSession);
        this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;
        const response = state.response;
        this.selectedServer = state.server;
        this.cursorId = response.id;
        this.cursorNamespace = response.ns ?? this.namespace;
        this.documents = response;
        this.initialized = true;
      } catch (error) {
        this.initialized = true;
        await this.cleanup(undefined, error);
        throw error;
      }
      if (this.isDead) {
        await this.cleanup();
      }
      return;
    }
    async fetchBatch() {
      if (this.isClosed) {
        return;
      }
      if (this.isDead) {
        await this.cleanup();
        return;
      }
      if (this.cursorId == null) {
        await this.cursorInit();
        if ((this.documents?.length ?? 0) !== 0 || this.isDead)
          return;
      }
      const batchSize = this.cursorOptions.batchSize || 1000;
      try {
        const response = await this.getMore(batchSize);
        this.cursorId = response.id;
        this.documents = response;
      } catch (error) {
        try {
          await this.cleanup(undefined, error);
        } catch (cleanupError) {
          (0, utils_1.squashError)(cleanupError);
        }
        throw error;
      }
      if (this.isDead) {
        await this.cleanup();
      }
    }
    async cleanup(timeoutMS, error) {
      this.abortListener?.[utils_1.kDispose]();
      this.isClosed = true;
      const timeoutContextForKillCursors = () => {
        if (timeoutMS != null) {
          this.timeoutContext?.clear();
          return new CursorTimeoutContext(timeout_1.TimeoutContext.create({
            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
            timeoutMS
          }), this);
        } else {
          return this.timeoutContext?.refreshed();
        }
      };
      const withEmitClose = async (fn) => {
        try {
          await fn();
        } finally {
          this.emitClose();
        }
      };
      const close = async () => {
        const session = this.cursorSession;
        if (!session)
          return;
        try {
          if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !session.hasEnded) {
            this.isKilled = true;
            const cursorId = this.cursorId;
            this.cursorId = bson_1.Long.ZERO;
            await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {
              session
            }), timeoutContextForKillCursors());
          }
        } catch (error2) {
          (0, utils_1.squashError)(error2);
        } finally {
          if (session.owner === this) {
            await session.endSession({ error });
          }
          if (!session.inTransaction()) {
            (0, sessions_1.maybeClearPinnedConnection)(session, { error });
          }
        }
      };
      await withEmitClose(close);
    }
    emitClose() {
      try {
        if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {
          this.emit("close");
        }
      } finally {
        this.hasEmittedClose = true;
      }
    }
    async transformDocument(document2) {
      if (this.transform == null)
        return document2;
      try {
        const transformedDocument = this.transform(document2);
        if (transformedDocument === null) {
          const TRANSFORM_TO_NULL_ERROR = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
          throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);
        }
        return transformedDocument;
      } catch (transformError) {
        try {
          await this.close();
        } catch (closeError) {
          (0, utils_1.squashError)(closeError);
        }
        throw transformError;
      }
    }
    throwIfInitialized() {
      if (this.initialized)
        throw new error_1.MongoCursorInUseError;
    }
  }
  exports.AbstractCursor = AbstractCursor;
  AbstractCursor.CLOSE = "close";

  class ReadableCursorStream extends stream_1.Readable {
    constructor(cursor) {
      super({
        objectMode: true,
        autoDestroy: false,
        highWaterMark: 1
      });
      this._readInProgress = false;
      this._cursor = cursor;
    }
    _read(size) {
      if (!this._readInProgress) {
        this._readInProgress = true;
        this._readNext();
      }
    }
    _destroy(error, callback) {
      this._cursor.close().then(() => callback(error), (closeError) => callback(closeError));
    }
    _readNext() {
      if (this._cursor.id === bson_1.Long.ZERO) {
        this.push(null);
        return;
      }
      this._cursor.next().then((result) => {
        if (result == null) {
          this.push(null);
        } else if (this.destroyed) {
          this._cursor.close().then(undefined, utils_1.squashError);
        } else {
          if (this.push(result)) {
            return this._readNext();
          }
          this._readInProgress = false;
        }
      }, (err2) => {
        if (err2.message.match(/server is closed/)) {
          this._cursor.close().then(undefined, utils_1.squashError);
          return this.push(null);
        }
        if (err2.message.match(/operation was interrupted/)) {
          return this.push(null);
        }
        return this.destroy(err2);
      }).catch((error) => {
        this._readInProgress = false;
        this.destroy(error);
      });
    }
  }
  (0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);

  class CursorTimeoutContext extends timeout_1.TimeoutContext {
    constructor(timeoutContext, owner) {
      super();
      this.timeoutContext = timeoutContext;
      this.owner = owner;
    }
    get serverSelectionTimeout() {
      return this.timeoutContext.serverSelectionTimeout;
    }
    get connectionCheckoutTimeout() {
      return this.timeoutContext.connectionCheckoutTimeout;
    }
    get clearServerSelectionTimeout() {
      return this.timeoutContext.clearServerSelectionTimeout;
    }
    get timeoutForSocketWrite() {
      return this.timeoutContext.timeoutForSocketWrite;
    }
    get timeoutForSocketRead() {
      return this.timeoutContext.timeoutForSocketRead;
    }
    csotEnabled() {
      return this.timeoutContext.csotEnabled();
    }
    refresh() {
      if (typeof this.owner !== "symbol")
        return this.timeoutContext.refresh();
    }
    clear() {
      if (typeof this.owner !== "symbol")
        return this.timeoutContext.clear();
    }
    get maxTimeMS() {
      return this.timeoutContext.maxTimeMS;
    }
    get timeoutMS() {
      return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;
    }
    refreshed() {
      return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);
    }
    addMaxTimeMSToCommand(command, options) {
      this.timeoutContext.addMaxTimeMSToCommand(command, options);
    }
    getSocketTimeoutMS() {
      return this.timeoutContext.getSocketTimeoutMS();
    }
  }
  exports.CursorTimeoutContext = CursorTimeoutContext;
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExplainableCursor = exports.Explain = exports.ExplainVerbosity = undefined;
  exports.validateExplainTimeoutOptions = validateExplainTimeoutOptions;
  exports.decorateWithExplain = decorateWithExplain;
  var abstract_cursor_1 = require_abstract_cursor();
  var error_1 = require_error();
  exports.ExplainVerbosity = Object.freeze({
    queryPlanner: "queryPlanner",
    queryPlannerExtended: "queryPlannerExtended",
    executionStats: "executionStats",
    allPlansExecution: "allPlansExecution"
  });

  class Explain {
    constructor(verbosity, maxTimeMS) {
      if (typeof verbosity === "boolean") {
        this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
      } else {
        this.verbosity = verbosity;
      }
      this.maxTimeMS = maxTimeMS;
    }
    static fromOptions({ explain } = {}) {
      if (explain == null)
        return;
      if (typeof explain === "boolean" || typeof explain === "string") {
        return new Explain(explain);
      }
      const { verbosity, maxTimeMS } = explain;
      return new Explain(verbosity, maxTimeMS);
    }
  }
  exports.Explain = Explain;
  function validateExplainTimeoutOptions(options, explain) {
    const { maxTimeMS, timeoutMS } = options;
    if (timeoutMS != null && (maxTimeMS != null || explain?.maxTimeMS != null)) {
      throw new error_1.MongoAPIError("Cannot use maxTimeMS with timeoutMS for explain commands.");
    }
  }
  function decorateWithExplain(command, explain) {
    const { verbosity, maxTimeMS } = explain;
    const baseCommand = { explain: command, verbosity };
    if (typeof maxTimeMS === "number") {
      baseCommand.maxTimeMS = maxTimeMS;
    }
    return baseCommand;
  }

  class ExplainableCursor extends abstract_cursor_1.AbstractCursor {
    resolveExplainTimeoutOptions(verbosity, options) {
      let explain;
      let timeout;
      if (verbosity == null && options == null) {
        explain = undefined;
        timeout = undefined;
      } else if (verbosity != null && options == null) {
        explain = typeof verbosity !== "object" ? verbosity : ("verbosity" in verbosity) ? verbosity : undefined;
        timeout = typeof verbosity === "object" && "timeoutMS" in verbosity ? verbosity : undefined;
      } else {
        explain = verbosity;
        timeout = options;
      }
      return { timeout, explain };
    }
  }
  exports.ExplainableCursor = ExplainableCursor;
});

// node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommandOperation = undefined;
  var error_1 = require_error();
  var explain_1 = require_explain();
  var read_concern_1 = require_read_concern();
  var server_selection_1 = require_server_selection();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var operation_1 = require_operation();

  class CommandOperation extends operation_1.AbstractOperation {
    constructor(parent, options) {
      super(options);
      this.options = options ?? {};
      const dbNameOverride = options?.dbName || options?.authdb;
      if (dbNameOverride) {
        this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
      } else {
        this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        this.explain = explain_1.Explain.fromOptions(options);
        if (this.explain)
          (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
      } else if (options?.explain != null) {
        throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
      }
    }
    get canRetryWrite() {
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        return this.explain == null;
      }
      return super.canRetryWrite;
    }
    async executeCommand(server, session, cmd, timeoutContext, responseType) {
      this.server = server;
      const options = {
        ...this.options,
        ...this.bsonOptions,
        timeoutContext,
        readPreference: this.readPreference,
        session
      };
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const inTransaction = this.session && this.session.inTransaction();
      if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
        Object.assign(cmd, { readConcern: this.readConcern });
      }
      if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        options.omitReadPreference = true;
      }
      if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
        write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
      }
      if (options.collation && typeof options.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
        Object.assign(cmd, { collation: options.collation });
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
        cmd = (0, explain_1.decorateWithExplain)(cmd, this.explain);
      }
      return await server.command(this.ns, cmd, options, responseType);
    }
  }
  exports.CommandOperation = CommandOperation;
});

// node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = undefined;
  exports.makeDeleteStatement = makeDeleteStatement;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DeleteOperation extends command_1.CommandOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get commandName() {
      return "delete";
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
    }
    async execute(server, session, timeoutContext) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        delete: this.ns.collection,
        deletes: this.statements,
        ordered
      };
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o) => o.hint)) {
          throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
        }
      }
      const res = await super.executeCommand(server, session, command, timeoutContext);
      return res;
    }
  }
  exports.DeleteOperation = DeleteOperation;

  class DeleteOneOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        deletedCount: res.n
      };
    }
  }
  exports.DeleteOneOperation = DeleteOneOperation;

  class DeleteManyOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        deletedCount: res.n
      };
    }
  }
  exports.DeleteManyOperation = DeleteManyOperation;
  function makeDeleteStatement(filter, options) {
    const op = {
      q: filter,
      limit: typeof options.limit === "number" ? options.limit : 0
    };
    if (options.collation) {
      op.collation = options.collation;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    return op;
  }
  (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DeleteOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(DeleteManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/bulk/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkOperationBase = exports.BulkWriteShimOperation = exports.FindOperators = exports.MongoBulkWriteError = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = undefined;
  exports.mergeBatchResults = mergeBatchResults;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var delete_1 = require_delete();
  var execute_operation_1 = require_execute_operation();
  var insert_1 = require_insert();
  var operation_1 = require_operation();
  var update_1 = require_update2();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  exports.BatchType = Object.freeze({
    INSERT: 1,
    UPDATE: 2,
    DELETE: 3
  });

  class Batch {
    constructor(batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    }
  }
  exports.Batch = Batch;

  class BulkWriteResult {
    static generateIdMap(ids) {
      const idMap = {};
      for (const doc of ids) {
        idMap[doc.index] = doc._id;
      }
      return idMap;
    }
    constructor(bulkResult, isOrdered) {
      this.result = bulkResult;
      this.insertedCount = this.result.nInserted ?? 0;
      this.matchedCount = this.result.nMatched ?? 0;
      this.modifiedCount = this.result.nModified ?? 0;
      this.deletedCount = this.result.nRemoved ?? 0;
      this.upsertedCount = this.result.upserted.length ?? 0;
      this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
      this.insertedIds = BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
      Object.defineProperty(this, "result", { value: this.result, enumerable: false });
    }
    get ok() {
      return this.result.ok;
    }
    getSuccessfullyInsertedIds(bulkResult, isOrdered) {
      if (bulkResult.writeErrors.length === 0)
        return bulkResult.insertedIds;
      if (isOrdered) {
        return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
      }
      return bulkResult.insertedIds.filter(({ index }) => !bulkResult.writeErrors.some((writeError) => index === writeError.index));
    }
    getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    getRawResponse() {
      return this.result;
    }
    hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    getWriteErrorAt(index) {
      return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    }
    getWriteErrors() {
      return this.result.writeErrors;
    }
    getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return;
      } else if (this.result.writeConcernErrors.length === 1) {
        return this.result.writeConcernErrors[0];
      } else {
        let errmsg = "";
        for (let i = 0;i < this.result.writeConcernErrors.length; i++) {
          const err2 = this.result.writeConcernErrors[i];
          errmsg = errmsg + err2.errmsg;
          if (i === 0)
            errmsg = errmsg + " and ";
        }
        return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernTimeout });
      }
    }
    toString() {
      return `BulkWriteResult(${bson_1.EJSON.stringify(this.result)})`;
    }
    isOk() {
      return this.result.ok === 1;
    }
  }
  exports.BulkWriteResult = BulkWriteResult;

  class WriteConcernError {
    constructor(error) {
      this.serverError = error;
    }
    get code() {
      return this.serverError.code;
    }
    get errmsg() {
      return this.serverError.errmsg;
    }
    get errInfo() {
      return this.serverError.errInfo;
    }
    toJSON() {
      return this.serverError;
    }
    toString() {
      return `WriteConcernError(${this.errmsg})`;
    }
  }
  exports.WriteConcernError = WriteConcernError;

  class WriteError {
    constructor(err2) {
      this.err = err2;
    }
    get code() {
      return this.err.code;
    }
    get index() {
      return this.err.index;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    get errInfo() {
      return this.err.errInfo;
    }
    getOperation() {
      return this.err.op;
    }
    toJSON() {
      return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
    }
    toString() {
      return `WriteError(${JSON.stringify(this.toJSON())})`;
    }
  }
  exports.WriteError = WriteError;
  function mergeBatchResults(batch, bulkResult, err2, result) {
    if (err2) {
      result = err2;
    } else if (result && result.result) {
      result = result.result;
    }
    if (result == null) {
      return;
    }
    if (result.ok === 0 && bulkResult.ok === 1) {
      bulkResult.ok = 0;
      const writeError = {
        index: 0,
        code: result.code || 0,
        errmsg: result.message,
        errInfo: result.errInfo,
        op: batch.operations[0]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
      return;
    } else if (result.ok === 0 && bulkResult.ok === 0) {
      return;
    }
    if (isInsertBatch(batch) && result.n) {
      bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    if (isDeleteBatch(batch) && result.n) {
      bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    let nUpserted = 0;
    if (Array.isArray(result.upserted)) {
      nUpserted = result.upserted.length;
      for (let i = 0;i < result.upserted.length; i++) {
        bulkResult.upserted.push({
          index: result.upserted[i].index + batch.originalZeroIndex,
          _id: result.upserted[i]._id
        });
      }
    } else if (result.upserted) {
      nUpserted = 1;
      bulkResult.upserted.push({
        index: batch.originalZeroIndex,
        _id: result.upserted
      });
    }
    if (isUpdateBatch(batch) && result.n) {
      const nModified = result.nModified;
      bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
      bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
      if (typeof nModified === "number") {
        bulkResult.nModified = bulkResult.nModified + nModified;
      } else {
        bulkResult.nModified = 0;
      }
    }
    if (Array.isArray(result.writeErrors)) {
      for (let i = 0;i < result.writeErrors.length; i++) {
        const writeError = {
          index: batch.originalIndexes[result.writeErrors[i].index],
          code: result.writeErrors[i].code,
          errmsg: result.writeErrors[i].errmsg,
          errInfo: result.writeErrors[i].errInfo,
          op: batch.operations[result.writeErrors[i].index]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
      }
    }
    if (result.writeConcernError) {
      bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
  }
  async function executeCommands(bulkOperation, options) {
    if (bulkOperation.s.batches.length === 0) {
      return new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
    }
    for (const batch of bulkOperation.s.batches) {
      const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
        ...options,
        ordered: bulkOperation.isOrdered
      });
      if (finalOptions.bypassDocumentValidation !== true) {
        delete finalOptions.bypassDocumentValidation;
      }
      if (bulkOperation.s.bypassDocumentValidation === true) {
        finalOptions.bypassDocumentValidation = true;
      }
      if (bulkOperation.s.checkKeys === false) {
        finalOptions.checkKeys = false;
      }
      if (finalOptions.retryWrites) {
        if (isUpdateBatch(batch)) {
          finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
        }
        if (isDeleteBatch(batch)) {
          finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
        }
      }
      const operation = isInsertBatch(batch) ? new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isUpdateBatch(batch) ? new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isDeleteBatch(batch) ? new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : null;
      if (operation == null)
        throw new error_1.MongoRuntimeError(`Unknown batchType: ${batch.batchType}`);
      let thrownError = null;
      let result;
      try {
        result = await (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, operation, finalOptions.timeoutContext);
      } catch (error) {
        thrownError = error;
      }
      if (thrownError != null) {
        if (thrownError instanceof error_1.MongoWriteConcernError) {
          mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
          const writeResult3 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
          throw new MongoBulkWriteError({
            message: thrownError.result.writeConcernError.errmsg,
            code: thrownError.result.writeConcernError.code
          }, writeResult3);
        } else {
          throw new MongoBulkWriteError(thrownError, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
        }
      }
      mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
      const writeResult2 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      bulkOperation.handleWriteError(writeResult2);
    }
    bulkOperation.s.batches.length = 0;
    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
    bulkOperation.handleWriteError(writeResult);
    return writeResult;
  }

  class MongoBulkWriteError extends error_1.MongoServerError {
    constructor(error, result) {
      super(error);
      this.writeErrors = [];
      if (error instanceof WriteConcernError)
        this.err = error;
      else if (!(error instanceof Error)) {
        this.message = error.message;
        this.code = error.code;
        this.writeErrors = error.writeErrors ?? [];
      }
      this.result = result;
      Object.assign(this, error);
    }
    get name() {
      return "MongoBulkWriteError";
    }
    get insertedCount() {
      return this.result.insertedCount;
    }
    get matchedCount() {
      return this.result.matchedCount;
    }
    get modifiedCount() {
      return this.result.modifiedCount;
    }
    get deletedCount() {
      return this.result.deletedCount;
    }
    get upsertedCount() {
      return this.result.upsertedCount;
    }
    get insertedIds() {
      return this.result.insertedIds;
    }
    get upsertedIds() {
      return this.result.upsertedIds;
    }
  }
  exports.MongoBulkWriteError = MongoBulkWriteError;

  class FindOperators {
    constructor(bulkOperation) {
      this.bulkOperation = bulkOperation;
    }
    update(updateDocument) {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
        ...currentOp,
        multi: true
      }));
    }
    updateOne(updateDocument) {
      if (!(0, utils_1.hasAtomicOperators)(updateDocument, this.bulkOperation.bsonOptions)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
    }
    replaceOne(replacement) {
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
    }
    deleteOne() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
    }
    delete() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
    }
    upsert() {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.upsert = true;
      return this;
    }
    collation(collation) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.collation = collation;
      return this;
    }
    arrayFilters(arrayFilters) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
      return this;
    }
    hint(hint) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.hint = hint;
      return this;
    }
  }
  exports.FindOperators = FindOperators;

  class BulkWriteShimOperation extends operation_1.AbstractOperation {
    constructor(bulkOperation, options) {
      super(options);
      this.bulkOperation = bulkOperation;
    }
    get commandName() {
      return "bulkWrite";
    }
    async execute(_server, session, timeoutContext) {
      if (this.options.session == null) {
        this.options.session = session;
      }
      return await executeCommands(this.bulkOperation, { ...this.options, timeoutContext });
    }
  }
  exports.BulkWriteShimOperation = BulkWriteShimOperation;

  class BulkOperationBase {
    constructor(collection, options, isOrdered) {
      this.collection = collection;
      this.isOrdered = isOrdered;
      const topology = (0, utils_1.getTopology)(collection);
      options = options == null ? {} : options;
      const namespace = collection.s.namespace;
      const executed = false;
      const currentOp = undefined;
      const hello = topology.lastHello();
      const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
      const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
      const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
      const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000;
      const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
      let finalOptions = Object.assign({}, options);
      finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
      const bulkResult = {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };
      this.s = {
        bulkResult,
        currentBatch: undefined,
        currentIndex: 0,
        currentBatchSize: 0,
        currentBatchSizeBytes: 0,
        currentInsertBatch: undefined,
        currentUpdateBatch: undefined,
        currentRemoveBatch: undefined,
        batches: [],
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        maxBsonObjectSize,
        maxBatchSizeBytes,
        maxWriteBatchSize,
        maxKeySize,
        namespace,
        topology,
        options: finalOptions,
        bsonOptions: (0, bson_1.resolveBSONOptions)(options),
        currentOp,
        executed,
        collection,
        err: undefined,
        checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : false
      };
      if (options.bypassDocumentValidation === true) {
        this.s.bypassDocumentValidation = true;
      }
    }
    insert(document2) {
      (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, {
        forceServerObjectId: this.shouldForceServerObjectId()
      });
      return this.addToOperationsList(exports.BatchType.INSERT, document2);
    }
    find(selector) {
      if (!selector) {
        throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
      }
      this.s.currentOp = {
        selector
      };
      return new FindOperators(this);
    }
    raw(op) {
      if (op == null || typeof op !== "object") {
        throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
      }
      if ("insertOne" in op) {
        const forceServerObjectId = this.shouldForceServerObjectId();
        const document2 = op.insertOne && op.insertOne.document == null ? op.insertOne : op.insertOne.document;
        (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, { forceServerObjectId });
        return this.addToOperationsList(exports.BatchType.INSERT, document2);
      }
      if ("replaceOne" in op || "updateOne" in op || "updateMany" in op) {
        if ("replaceOne" in op) {
          if ("q" in op.replaceOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
          if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateOne" in op) {
          if ("q" in op.updateOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
            ...op.updateOne,
            multi: false
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u, this.bsonOptions)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateMany" in op) {
          if ("q" in op.updateMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
            ...op.updateMany,
            multi: true
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u, this.bsonOptions)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
      }
      if ("deleteOne" in op) {
        if ("q" in op.deleteOne) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
      }
      if ("deleteMany" in op) {
        if ("q" in op.deleteMany) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
      }
      throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
    }
    get length() {
      return this.s.currentIndex;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get batches() {
      const batches = [...this.s.batches];
      if (this.isOrdered) {
        if (this.s.currentBatch)
          batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          batches.push(this.s.currentRemoveBatch);
      }
      return batches;
    }
    async execute(options = {}) {
      if (this.s.executed) {
        throw new error_1.MongoBatchReExecutionError;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        this.s.writeConcern = writeConcern;
      }
      if (this.isOrdered) {
        if (this.s.currentBatch)
          this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          this.s.batches.push(this.s.currentRemoveBatch);
      }
      if (this.s.batches.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
      }
      this.s.executed = true;
      const finalOptions = { ...this.s.options, ...options };
      const operation = new BulkWriteShimOperation(this, finalOptions);
      return await (0, execute_operation_1.executeOperation)(this.s.collection.client, operation, finalOptions.timeoutContext);
    }
    handleWriteError(writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
        throw new MongoBulkWriteError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }, writeResult);
      }
      const writeConcernError = writeResult.getWriteConcernError();
      if (writeConcernError) {
        throw new MongoBulkWriteError(writeConcernError, writeResult);
      }
    }
    shouldForceServerObjectId() {
      return this.s.options.forceServerObjectId === true || this.s.collection.s.db.options?.forceServerObjectId === true;
    }
  }
  exports.BulkOperationBase = BulkOperationBase;
  function isInsertBatch(batch) {
    return batch.batchType === exports.BatchType.INSERT;
  }
  function isUpdateBatch(batch) {
    return batch.batchType === exports.BatchType.UPDATE;
  }
  function isDeleteBatch(batch) {
    return batch.batchType === exports.BatchType.DELETE;
  }
  function buildCurrentOp(bulkOp) {
    let { currentOp } = bulkOp.s;
    bulkOp.s.currentOp = undefined;
    if (!currentOp)
      currentOp = {};
    return currentOp;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/bulkWriteResult.js
var require_bulkWriteResult = __commonJS((exports, module) => {
  var BulkWriteResult = require_common3().BulkWriteResult;
  module.exports = BulkWriteResult;
});

// node_modules/mongoose/lib/connectionState.js
var require_connectionState = __commonJS((exports, module) => {
  /*!
   * Connection states
   */
  var STATES = module.exports = exports = Object.create(null);
  var disconnected = "disconnected";
  var connected = "connected";
  var connecting = "connecting";
  var disconnecting = "disconnecting";
  var uninitialized = "uninitialized";
  STATES[0] = disconnected;
  STATES[1] = connected;
  STATES[2] = connecting;
  STATES[3] = disconnecting;
  STATES[99] = uninitialized;
  STATES[disconnected] = 0;
  STATES[connected] = 1;
  STATES[connecting] = 2;
  STATES[disconnecting] = 3;
  STATES[uninitialized] = 99;
});

// node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS((exports, module) => {
  /*!
   * Centralize this so we can more easily work around issues with people
   * stubbing out `process.nextTick()` in tests using sinon:
   * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
   * See gh-6074
   */
  var nextTick = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : (cb) => setTimeout(cb, 0);
  module.exports = function immediate(cb) {
    return nextTick(cb);
  };
});

// node_modules/mongoose/lib/collection.js
var require_collection2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EventEmitter = __require("events").EventEmitter;
  var STATES = require_connectionState();
  var immediate = require_immediate();
  function Collection(name, conn, opts) {
    if (opts === undefined) {
      opts = {};
    }
    this.opts = opts;
    this.name = name;
    this.collectionName = name;
    this.conn = conn;
    this.queue = [];
    this.buffer = !conn?._hasOpened;
    this.emitter = new EventEmitter;
    if (STATES.connected === this.conn.readyState) {
      this.onOpen();
    }
  }
  Collection.prototype.name;
  Collection.prototype.collectionName;
  Collection.prototype.conn;
  Collection.prototype.onOpen = function() {
    this.buffer = false;
    immediate(() => this.doQueue());
  };
  Collection.prototype.onClose = function() {
  };
  Collection.prototype.addQueue = function(name, args) {
    this.queue.push([name, args]);
    return this;
  };
  Collection.prototype.removeQueue = function(name, args) {
    const index = this.queue.findIndex((v) => v[0] === name && v[1] === args);
    if (index === -1) {
      return false;
    }
    this.queue.splice(index, 1);
    return true;
  };
  Collection.prototype.doQueue = function() {
    for (const method of this.queue) {
      if (typeof method[0] === "function") {
        method[0].apply(this, method[1]);
      } else {
        this[method[0]].apply(this, method[1]);
      }
    }
    this.queue = [];
    const _this = this;
    immediate(function() {
      _this.emitter.emit("queue");
    });
    return this;
  };
  Collection.prototype.ensureIndex = function() {
    throw new Error("Collection#ensureIndex unimplemented by driver");
  };
  Collection.prototype.createIndex = function() {
    throw new Error("Collection#createIndex unimplemented by driver");
  };
  Collection.prototype.findAndModify = function() {
    throw new Error("Collection#findAndModify unimplemented by driver");
  };
  Collection.prototype.findOneAndUpdate = function() {
    throw new Error("Collection#findOneAndUpdate unimplemented by driver");
  };
  Collection.prototype.findOneAndDelete = function() {
    throw new Error("Collection#findOneAndDelete unimplemented by driver");
  };
  Collection.prototype.findOneAndReplace = function() {
    throw new Error("Collection#findOneAndReplace unimplemented by driver");
  };
  Collection.prototype.findOne = function() {
    throw new Error("Collection#findOne unimplemented by driver");
  };
  Collection.prototype.find = function() {
    throw new Error("Collection#find unimplemented by driver");
  };
  Collection.prototype.insert = function() {
    throw new Error("Collection#insert unimplemented by driver");
  };
  Collection.prototype.insertOne = function() {
    throw new Error("Collection#insertOne unimplemented by driver");
  };
  Collection.prototype.insertMany = function() {
    throw new Error("Collection#insertMany unimplemented by driver");
  };
  Collection.prototype.save = function() {
    throw new Error("Collection#save unimplemented by driver");
  };
  Collection.prototype.updateOne = function() {
    throw new Error("Collection#updateOne unimplemented by driver");
  };
  Collection.prototype.updateMany = function() {
    throw new Error("Collection#updateMany unimplemented by driver");
  };
  Collection.prototype.deleteOne = function() {
    throw new Error("Collection#deleteOne unimplemented by driver");
  };
  Collection.prototype.deleteMany = function() {
    throw new Error("Collection#deleteMany unimplemented by driver");
  };
  Collection.prototype.getIndexes = function() {
    throw new Error("Collection#getIndexes unimplemented by driver");
  };
  Collection.prototype.watch = function() {
    throw new Error("Collection#watch unimplemented by driver");
  };
  /*!
   * ignore
   */
  Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    const opts = this.opts;
    if (opts.bufferCommands != null) {
      return opts.bufferCommands;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
      return opts.schemaUserProvidedOptions.bufferCommands;
    }
    return this.conn._shouldBufferCommands();
  };
  /*!
   * ignore
   */
  Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
    const conn = this.conn;
    const opts = this.opts;
    if (opts.bufferTimeoutMS != null) {
      return opts.bufferTimeoutMS;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
      return opts.schemaUserProvidedOptions.bufferTimeoutMS;
    }
    return conn._getBufferTimeoutMS();
  };
  /*!
   * Module exports.
   */
  module.exports = Collection;
});

// node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS((exports, module) => {
  /*!
   * ignore
   */

  class MongooseError extends Error {
  }
  Object.defineProperty(MongooseError.prototype, "name", {
    value: "MongooseError"
  });
  module.exports = MongooseError;
});

// node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS((exports) => {
  exports.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup");
  exports.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
  exports.arrayParentSymbol = Symbol("mongoose#Array#_parent");
  exports.arrayPathSymbol = Symbol("mongoose#Array#_path");
  exports.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
  exports.documentArrayParent = Symbol("mongoose#documentArrayParent");
  exports.documentIsSelected = Symbol("mongoose#Document#isSelected");
  exports.documentIsModified = Symbol("mongoose#Document#isModified");
  exports.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
  exports.documentSchemaSymbol = Symbol("mongoose#Document#schema");
  exports.getSymbol = Symbol("mongoose#Document#get");
  exports.modelSymbol = Symbol("mongoose#Model");
  exports.objectIdSymbol = Symbol("mongoose#ObjectId");
  exports.populateModelSymbol = Symbol("mongoose#PopulateOptions#Model");
  exports.schemaTypeSymbol = Symbol("mongoose#schemaType");
  exports.sessionNewDocuments = Symbol("mongoose#ClientSession#newDocuments");
  exports.scopeSymbol = Symbol("mongoose#Document#scope");
  exports.validatorErrorSymbol = Symbol("mongoose#validatorError");
});

// node_modules/mongoose/lib/types/objectid.js
var require_objectid = __commonJS((exports, module) => {
  var ObjectId2 = require_bson().ObjectId;
  var objectIdSymbol = require_symbols().objectIdSymbol;
  Object.defineProperty(ObjectId2.prototype, "_id", {
    enumerable: false,
    configurable: true,
    get: function() {
      return this;
    }
  });
  /*!
   * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299
   */
  if (!ObjectId2.prototype.hasOwnProperty("valueOf")) {
    ObjectId2.prototype.valueOf = function objectIdValueOf() {
      return this.toString();
    };
  }
  ObjectId2.prototype[objectIdSymbol] = true;
  module.exports = ObjectId2;
});

// node_modules/mongoose/lib/helpers/getConstructorName.js
var require_getConstructorName = __commonJS((exports, module) => {
  module.exports = function getConstructorName(val) {
    if (val == null) {
      return;
    }
    if (typeof val.constructor !== "function") {
      return;
    }
    return val.constructor.name;
  };
});

// node_modules/mongoose/lib/options.js
var require_options = __commonJS((exports) => {
  /*!
   * ignore
   */
  exports.internalToObjectOptions = {
    transform: false,
    virtuals: false,
    getters: false,
    _skipDepopulateTopLevel: true,
    depopulate: true,
    flattenDecimals: false,
    useProjection: false,
    versionKey: true,
    flattenObjectIds: false
  };
});

// node_modules/mongoose/lib/types/decimal128.js
var require_decimal128 = __commonJS((exports, module) => {
  module.exports = require_bson().Decimal128;
});

// node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS((exports, module) => {
  module.exports = new Set(["__proto__", "constructor", "prototype"]);
});

// node_modules/mongoose/lib/types/array/isMongooseArray.js
var require_isMongooseArray = __commonJS((exports) => {
  exports.isMongooseArray = function(mongooseArray) {
    return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;
  };
});

// node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS((exports, module) => {
  var isMongooseArray = require_isMongooseArray().isMongooseArray;
  module.exports = function(v) {
    return v != null && (isMongooseArray(v) || v.$__ != null || v.isMongooseBuffer || v.$isMongooseMap);
  };
});

// node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS((exports, module) => {
  var functionNameRE = /^function\s*([^\s(]+)/;
  module.exports = function(fn) {
    return fn.name || (fn.toString().trim().match(functionNameRE) || [])[1];
  };
});

// node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS((exports, module) => {
  function isBsonType(obj, typename) {
    return obj != null && obj._bsontype === typename;
  }
  module.exports = isBsonType;
});

// node_modules/mongoose/lib/helpers/isObject.js
var require_isObject = __commonJS((exports, module) => {
  module.exports = function(arg) {
    return Buffer.isBuffer(arg) || Object.prototype.toString.call(arg) === "[object Object]";
  };
});

// node_modules/mongoose/lib/helpers/isPOJO.js
var require_isPOJO = __commonJS((exports, module) => {
  module.exports = function isPOJO(arg) {
    if (arg == null || typeof arg !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(arg);
    return !proto || proto.constructor.name === "Object";
  };
});

// node_modules/mongoose/lib/helpers/query/trusted.js
var require_trusted = __commonJS((exports) => {
  var trustedSymbol = Symbol("mongoose#trustedSymbol");
  exports.trustedSymbol = trustedSymbol;
  exports.trusted = function trusted(obj) {
    if (obj == null || typeof obj !== "object") {
      return obj;
    }
    obj[trustedSymbol] = true;
    return obj;
  };
});

// node_modules/mongoose/lib/helpers/clone.js
var require_clone = __commonJS((exports, module) => {
  var Decimal = require_decimal128();
  var ObjectId2 = require_objectid();
  var specialProperties = require_specialProperties();
  var isMongooseObject = require_isMongooseObject();
  var getFunctionName = require_getFunctionName();
  var isBsonType = require_isBsonType();
  var isMongooseArray = require_isMongooseArray().isMongooseArray;
  var isObject2 = require_isObject();
  var isPOJO = require_isPOJO();
  var symbols = require_symbols();
  var trustedSymbol = require_trusted().trustedSymbol;
  var BSON = require_bson();
  function clone2(obj, options, isArrayChild) {
    if (obj == null) {
      return obj;
    }
    if (isBsonType(obj, "Double")) {
      return new BSON.Double(obj.value);
    }
    if (typeof obj === "number" || typeof obj === "string" || typeof obj === "boolean" || typeof obj === "bigint") {
      return obj;
    }
    if (Array.isArray(obj)) {
      return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);
    }
    if (isMongooseObject(obj)) {
      if (options) {
        if (options.retainDocuments && obj.$__ != null) {
          const clonedDoc = obj.$clone();
          if (obj.__index != null) {
            clonedDoc.__index = obj.__index;
          }
          if (obj.__parentArray != null) {
            clonedDoc.__parentArray = obj.__parentArray;
          }
          clonedDoc.$__parent = obj.$__parent;
          return clonedDoc;
        }
      }
      if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {
        return obj._doc;
      }
      let ret;
      if (options && options.json && typeof obj.toJSON === "function") {
        ret = obj.toJSON(options);
      } else {
        ret = obj.toObject(options);
      }
      return ret;
    }
    const objConstructor = obj.constructor;
    if (objConstructor) {
      switch (getFunctionName(objConstructor)) {
        case "Object":
          return cloneObject(obj, options, isArrayChild);
        case "Date":
          return new objConstructor(+obj);
        case "RegExp":
          return cloneRegExp(obj);
        default:
          break;
      }
    }
    if (isBsonType(obj, "ObjectId")) {
      if (options && options.flattenObjectIds) {
        return obj.toJSON();
      }
      return new ObjectId2(obj.id);
    }
    if (isBsonType(obj, "Decimal128")) {
      if (options && options.flattenDecimals) {
        return obj.toJSON();
      }
      return Decimal.fromString(obj.toString());
    }
    if (!objConstructor && isObject2(obj)) {
      return cloneObject(obj, options, isArrayChild);
    }
    if (typeof obj === "object" && obj[symbols.schemaTypeSymbol]) {
      return obj.clone();
    }
    if (options && options.bson && typeof obj.toBSON === "function") {
      return obj;
    }
    if (typeof obj.valueOf === "function") {
      return obj.valueOf();
    }
    return cloneObject(obj, options, isArrayChild);
  }
  module.exports = clone2;
  /*!
   * ignore
   */
  function cloneObject(obj, options, isArrayChild) {
    const minimize = options && options.minimize;
    const omitUndefined = options && options.omitUndefined;
    const seen = options && options._seen;
    const ret = {};
    let hasKeys;
    if (seen && seen.has(obj)) {
      return seen.get(obj);
    } else if (seen) {
      seen.set(obj, ret);
    }
    if (trustedSymbol in obj && options?.copyTrustedSymbol !== false) {
      ret[trustedSymbol] = obj[trustedSymbol];
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      const key = keys[i];
      if (specialProperties.has(key)) {
        continue;
      }
      const val = clone2(obj[key], options, false);
      if ((minimize === false || omitUndefined) && typeof val === "undefined") {
        delete ret[key];
      } else if (minimize !== true || typeof val !== "undefined") {
        hasKeys || (hasKeys = true);
        ret[key] = val;
      }
    }
    return minimize && !isArrayChild ? hasKeys && ret : ret;
  }
  function cloneArray(arr, options) {
    let i = 0;
    const len = arr.length;
    const ret = new Array(len);
    for (i = 0;i < len; ++i) {
      ret[i] = clone2(arr[i], options, true);
    }
    return ret;
  }
  function cloneRegExp(regexp) {
    const ret = new RegExp(regexp.source, regexp.flags);
    if (ret.lastIndex !== regexp.lastIndex) {
      ret.lastIndex = regexp.lastIndex;
    }
    return ret;
  }
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection3 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseCollection = require_collection2();
  var MongooseError = require_mongooseError();
  var Collection = require_lib3().Collection;
  var ObjectId2 = require_objectid();
  var getConstructorName = require_getConstructorName();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var stream = __require("stream");
  var util3 = __require("util");
  var formatToObjectOptions = Object.freeze({ ...internalToObjectOptions, copyTrustedSymbol: false });
  function NativeCollection(name, conn, options) {
    this.collection = null;
    this.Promise = options.Promise || Promise;
    this.modelName = options.modelName;
    delete options.modelName;
    this._closed = false;
    MongooseCollection.apply(this, arguments);
  }
  /*!
   * Inherit from abstract Collection.
   */
  Object.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);
  NativeCollection.prototype.onOpen = function() {
    this.collection = this.conn.db.collection(this.name);
    MongooseCollection.prototype.onOpen.call(this);
    return this.collection;
  };
  NativeCollection.prototype.onClose = function(force) {
    MongooseCollection.prototype.onClose.call(this, force);
  };
  NativeCollection.prototype._getCollection = function _getCollection() {
    if (this.collection) {
      return this.collection;
    }
    if (this.conn.db != null) {
      this.collection = this.conn.db.collection(this.name);
      return this.collection;
    }
    return null;
  };
  /*!
   * ignore
   */
  var syncCollectionMethods = { watch: true, find: true, aggregate: true };
  function iter(i) {
    NativeCollection.prototype[i] = function() {
      const collection = this._getCollection();
      const args = Array.from(arguments);
      const _this = this;
      const globalDebug = _this && _this.conn && _this.conn.base && _this.conn.base.options && _this.conn.base.options.debug;
      const connectionDebug = _this && _this.conn && _this.conn.options && _this.conn.options.debug;
      const debug2 = connectionDebug == null ? globalDebug : connectionDebug;
      const lastArg = arguments[arguments.length - 1];
      const opId = new ObjectId2;
      if (this.conn.$wasForceClosed) {
        const error = new MongooseError("Connection was force closed");
        if (args.length > 0 && typeof args[args.length - 1] === "function") {
          args[args.length - 1](error);
          return;
        } else {
          throw error;
        }
      }
      let _args = args;
      let callback = null;
      if (this._shouldBufferCommands() && this.buffer) {
        this.conn.emit("buffer", {
          _id: opId,
          modelName: _this.modelName,
          collectionName: _this.name,
          method: i,
          args
        });
        let callback2;
        let _args2 = args;
        let promise = null;
        let timeout = null;
        if (syncCollectionMethods[i] && typeof lastArg === "function") {
          this.addQueue(i, _args2);
          callback2 = lastArg;
        } else if (syncCollectionMethods[i]) {
          promise = new this.Promise((resolve, reject) => {
            callback2 = function collectionOperationCallback(err2, res) {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              if (err2 != null) {
                return reject(err2);
              }
              resolve(res);
            };
            _args2 = args.concat([callback2]);
            this.addQueue(i, _args2);
          });
        } else if (typeof lastArg === "function") {
          callback2 = function collectionOperationCallback() {
            if (timeout != null) {
              clearTimeout(timeout);
            }
            return lastArg.apply(this, arguments);
          };
          _args2 = args.slice(0, args.length - 1).concat([callback2]);
        } else {
          promise = new Promise((resolve, reject) => {
            callback2 = function collectionOperationCallback(err2, res) {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              if (err2 != null) {
                return reject(err2);
              }
              resolve(res);
            };
            _args2 = args.concat([callback2]);
            this.addQueue(i, _args2);
          });
        }
        const bufferTimeoutMS = this._getBufferTimeoutMS();
        timeout = setTimeout(() => {
          const removed = this.removeQueue(i, _args2);
          if (removed) {
            const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
            const err2 = new MongooseError(message);
            this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err2 });
            callback2(err2);
          }
        }, bufferTimeoutMS);
        if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          this.addQueue(i, _args2);
          return;
        }
        return promise;
      } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
        callback = function collectionOperationCallback(err2, res) {
          if (err2 != null) {
            _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err2 });
          } else {
            _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
          }
          return lastArg.apply(this, arguments);
        };
        _args = args.slice(0, args.length - 1).concat([callback]);
      }
      if (debug2) {
        if (typeof debug2 === "function") {
          let argsToAdd = null;
          if (typeof args[args.length - 1] == "function") {
            argsToAdd = args.slice(0, args.length - 1);
          } else {
            argsToAdd = args;
          }
          debug2.apply(_this, [_this.name, i].concat(argsToAdd));
        } else if (debug2 instanceof stream.Writable) {
          this.$printToStream(_this.name, i, args, debug2);
        } else {
          const color = debug2.color == null ? true : debug2.color;
          const shell = debug2.shell == null ? false : debug2.shell;
          this.$print(_this.name, i, args, color, shell);
        }
      }
      this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
      try {
        if (collection == null) {
          const message = "Cannot call `" + this.name + "." + i + "()` before initial connection " + "is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if " + "you have `bufferCommands = false`.";
          throw new MongooseError(message);
        }
        if (syncCollectionMethods[i] && typeof lastArg === "function") {
          const result = collection[i].apply(collection, _args.slice(0, _args.length - 1));
          this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, result });
          return lastArg.call(this, null, result);
        }
        const ret = collection[i].apply(collection, _args);
        if (ret != null && typeof ret.then === "function") {
          return ret.then((result) => {
            if (typeof lastArg === "function") {
              lastArg(null, result);
            } else {
              this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, result });
            }
            return result;
          }, (error) => {
            if (typeof lastArg === "function") {
              lastArg(error);
              return;
            } else {
              this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
            }
            throw error;
          });
        }
        return ret;
      } catch (error) {
        if (typeof lastArg === "function") {
          return lastArg(error);
        } else {
          this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
          throw error;
        }
      }
    };
  }
  for (const key of Object.getOwnPropertyNames(Collection.prototype)) {
    const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
    if (descriptor.get !== undefined) {
      continue;
    }
    if (typeof Collection.prototype[key] !== "function") {
      continue;
    }
    iter(key);
  }
  NativeCollection.prototype.$print = function(name, i, args, color, shell) {
    const moduleName = color ? "\x1B[0;36mMongoose:\x1B[0m " : "Mongoose: ";
    const functionCall = [name, i].join(".");
    const _args = [];
    for (let j = args.length - 1;j >= 0; --j) {
      if (this.$format(args[j]) || _args.length) {
        _args.unshift(this.$format(args[j], color, shell));
      }
    }
    const params = "(" + _args.join(", ") + ")";
    console.info(moduleName + functionCall + params);
  };
  NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
    const functionCall = [name, i].join(".");
    const _args = [];
    for (let j = args.length - 1;j >= 0; --j) {
      if (this.$format(args[j]) || _args.length) {
        _args.unshift(this.$format(args[j]));
      }
    }
    const params = "(" + _args.join(", ") + ")";
    stream2.write(functionCall + params, "utf8");
  };
  NativeCollection.prototype.$format = function(arg, color, shell) {
    const type = typeof arg;
    if (type === "function" || type === "undefined")
      return "";
    return format(arg, false, color, shell);
  };
  function inspectable(representation) {
    const ret = {
      inspect: function() {
        return representation;
      }
    };
    if (util3.inspect.custom) {
      ret[util3.inspect.custom] = ret.inspect;
    }
    return ret;
  }
  function map3(o) {
    return format(o, true);
  }
  function formatObjectId(x, key) {
    x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
  }
  function formatDate(x, key, shell) {
    if (shell) {
      x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
    } else {
      x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
    }
  }
  function format(obj, sub, color, shell) {
    if (obj && typeof obj.toBSON === "function") {
      obj = obj.toBSON();
    }
    if (obj == null) {
      return obj;
    }
    const clone2 = require_clone();
    let x = sub ? obj : clone2(obj, formatToObjectOptions);
    const constructorName = getConstructorName(x);
    if (constructorName === "Binary") {
      x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
    } else if (constructorName === "ObjectId") {
      x = inspectable('ObjectId("' + x.toHexString() + '")');
    } else if (constructorName === "Date") {
      x = inspectable('new Date("' + x.toUTCString() + '")');
    } else if (constructorName === "Object") {
      const keys = Object.keys(x);
      const numKeys = keys.length;
      let key;
      for (let i = 0;i < numKeys; ++i) {
        key = keys[i];
        if (x[key]) {
          let error;
          if (typeof x[key].toBSON === "function") {
            try {
              x[key] = x[key].toBSON();
            } catch (_error) {
              error = _error;
            }
          }
          const _constructorName = getConstructorName(x[key]);
          if (_constructorName === "Binary") {
            x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
          } else if (_constructorName === "Object") {
            x[key] = format(x[key], true);
          } else if (_constructorName === "ObjectId") {
            formatObjectId(x, key);
          } else if (_constructorName === "Date") {
            formatDate(x, key, shell);
          } else if (_constructorName === "ClientSession") {
            x[key] = inspectable('ClientSession("' + (x[key] && x[key].id && x[key].id.id && x[key].id.id.buffer || "").toString("hex") + '")');
          } else if (Array.isArray(x[key])) {
            x[key] = x[key].map(map3);
          } else if (error != null) {
            throw error;
          }
        }
      }
    }
    if (sub) {
      return x;
    }
    return util3.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
  }
  NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
  /*!
   * Module exports.
   */
  module.exports = NativeCollection;
});

// node_modules/mongoose/lib/cursor/changeStream.js
var require_changeStream = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EventEmitter = __require("events").EventEmitter;
  var MongooseError = require_mongooseError();
  /*!
   * ignore
   */
  var driverChangeStreamEvents = ["close", "change", "end", "error", "resumeTokenChanged"];
  /*!
   * ignore
   */

  class ChangeStream extends EventEmitter {
    constructor(changeStreamThunk, pipeline2, options) {
      super();
      this.driverChangeStream = null;
      this.closed = false;
      this.bindedEvents = false;
      this.pipeline = pipeline2;
      this.options = options;
      this.errored = false;
      if (options && options.hydrate && !options.model) {
        throw new Error("Cannot create change stream with `hydrate: true` " + "unless calling `Model.watch()`");
      }
      let syncError = null;
      this.$driverChangeStreamPromise = new Promise((resolve, reject) => {
        try {
          changeStreamThunk((err2, driverChangeStream) => {
            if (err2 != null) {
              this.errored = true;
              this.emit("error", err2);
              return reject(err2);
            }
            this.driverChangeStream = driverChangeStream;
            this.emit("ready");
            resolve();
          });
        } catch (err2) {
          syncError = err2;
          this.errored = true;
          this.emit("error", err2);
          reject(err2);
        }
      });
      if (syncError != null) {
        throw syncError;
      }
    }
    _bindEvents() {
      if (this.bindedEvents) {
        return;
      }
      this.bindedEvents = true;
      if (this.driverChangeStream == null) {
        this.$driverChangeStreamPromise.then(() => {
          this.driverChangeStream.on("close", () => {
            this.closed = true;
          });
          driverChangeStreamEvents.forEach((ev) => {
            this.driverChangeStream.on(ev, (data) => {
              if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
                data.fullDocument = this.options.model.hydrate(data.fullDocument);
              }
              this.emit(ev, data);
            });
          });
        }, () => {
        });
        return;
      }
      this.driverChangeStream.on("close", () => {
        this.closed = true;
      });
      driverChangeStreamEvents.forEach((ev) => {
        this.driverChangeStream.on(ev, (data) => {
          if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
            data.fullDocument = this.options.model.hydrate(data.fullDocument);
          }
          this.emit(ev, data);
        });
      });
    }
    hasNext(cb) {
      if (this.errored) {
        throw new MongooseError("Cannot call hasNext() on errored ChangeStream");
      }
      return this.driverChangeStream.hasNext(cb);
    }
    next(cb) {
      if (this.errored) {
        throw new MongooseError("Cannot call next() on errored ChangeStream");
      }
      if (this.options && this.options.hydrate) {
        if (cb != null) {
          const originalCb = cb;
          cb = (err2, data) => {
            if (err2 != null) {
              return originalCb(err2);
            }
            if (data.fullDocument != null) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            return originalCb(null, data);
          };
        }
        let maybePromise = this.driverChangeStream.next(cb);
        if (maybePromise && typeof maybePromise.then === "function") {
          maybePromise = maybePromise.then((data) => {
            if (data.fullDocument != null) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            return data;
          });
        }
        return maybePromise;
      }
      return this.driverChangeStream.next(cb);
    }
    addListener(event, handler) {
      if (this.errored) {
        throw new MongooseError("Cannot call addListener() on errored ChangeStream");
      }
      this._bindEvents();
      return super.addListener(event, handler);
    }
    on(event, handler) {
      if (this.errored) {
        throw new MongooseError("Cannot call on() on errored ChangeStream");
      }
      this._bindEvents();
      return super.on(event, handler);
    }
    once(event, handler) {
      if (this.errored) {
        throw new MongooseError("Cannot call once() on errored ChangeStream");
      }
      this._bindEvents();
      return super.once(event, handler);
    }
    _queue(cb) {
      this.once("ready", () => cb());
    }
    close() {
      this.closed = true;
      if (this.driverChangeStream) {
        return this.driverChangeStream.close();
      } else {
        return this.$driverChangeStreamPromise.then(() => this.driverChangeStream.close(), () => {
        });
      }
    }
  }
  /*!
   * ignore
   */
  module.exports = ChangeStream;
});

// node_modules/kareem/index.js
var require_kareem = __commonJS((exports, module) => {
  function Kareem() {
    this._pres = new Map;
    this._posts = new Map;
  }
  Kareem.skipWrappedFunction = function skipWrappedFunction() {
    if (!(this instanceof Kareem.skipWrappedFunction)) {
      return new Kareem.skipWrappedFunction(...arguments);
    }
    this.args = [...arguments];
  };
  Kareem.overwriteResult = function overwriteResult() {
    if (!(this instanceof Kareem.overwriteResult)) {
      return new Kareem.overwriteResult(...arguments);
    }
    this.args = [...arguments];
  };
  Kareem.prototype.execPre = function(name, context, args, callback) {
    if (arguments.length === 3) {
      callback = args;
      args = [];
    }
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    const numAsyncPres = pres.numAsync || 0;
    let currentPre = 0;
    let asyncPresLeft = numAsyncPres;
    let done = false;
    const $args = args;
    let shouldSkipWrappedFunction = null;
    if (!numPres) {
      return nextTick(function() {
        callback(null);
      });
    }
    function next() {
      if (currentPre >= numPres) {
        return;
      }
      const pre = pres[currentPre];
      if (pre.isAsync) {
        const args2 = [
          decorateNextFn(_next),
          decorateNextFn(function(error) {
            if (error) {
              if (done) {
                return;
              }
              if (error instanceof Kareem.skipWrappedFunction) {
                shouldSkipWrappedFunction = error;
              } else {
                done = true;
                return callback(error);
              }
            }
            if (--asyncPresLeft === 0 && currentPre >= numPres) {
              return callback(shouldSkipWrappedFunction);
            }
          })
        ];
        callMiddlewareFunction(pre.fn, context, args2, args2[0]);
      } else if (pre.fn.length > 0) {
        const args2 = [decorateNextFn(_next)];
        const _args = arguments.length >= 2 ? arguments : [null].concat($args);
        for (let i = 1;i < _args.length; ++i) {
          if (i === _args.length - 1 && typeof _args[i] === "function") {
            continue;
          }
          args2.push(_args[i]);
        }
        callMiddlewareFunction(pre.fn, context, args2, args2[0]);
      } else {
        let maybePromiseLike = null;
        try {
          maybePromiseLike = pre.fn.call(context);
        } catch (err2) {
          if (err2 != null) {
            return callback(err2);
          }
        }
        if (isPromiseLike(maybePromiseLike)) {
          maybePromiseLike.then(() => _next(), (err2) => _next(err2));
        } else {
          if (++currentPre >= numPres) {
            if (asyncPresLeft > 0) {
              return;
            } else {
              return nextTick(function() {
                callback(shouldSkipWrappedFunction);
              });
            }
          }
          next();
        }
      }
    }
    next.apply(null, [null].concat(args));
    function _next(error) {
      if (error) {
        if (done) {
          return;
        }
        if (error instanceof Kareem.skipWrappedFunction) {
          shouldSkipWrappedFunction = error;
        } else {
          done = true;
          return callback(error);
        }
      }
      if (++currentPre >= numPres) {
        if (asyncPresLeft > 0) {
          return;
        } else {
          return callback(shouldSkipWrappedFunction);
        }
      }
      next.apply(context, arguments);
    }
  };
  Kareem.prototype.execPreSync = function(name, context, args) {
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    for (let i = 0;i < numPres; ++i) {
      pres[i].fn.apply(context, args || []);
    }
  };
  Kareem.prototype.execPost = function(name, context, args, options, callback) {
    if (arguments.length < 5) {
      callback = options;
      options = null;
    }
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    let currentPost = 0;
    let firstError = null;
    if (options && options.error) {
      firstError = options.error;
    }
    if (!numPosts) {
      return nextTick(function() {
        callback.apply(null, [firstError].concat(args));
      });
    }
    function next() {
      const post = posts[currentPost].fn;
      let numArgs = 0;
      const argLength = args.length;
      const newArgs = [];
      for (let i = 0;i < argLength; ++i) {
        numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
        if (!args[i] || !args[i]._kareemIgnore) {
          newArgs.push(args[i]);
        }
      }
      if (firstError) {
        if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
          const _cb = decorateNextFn(function(error) {
            if (error) {
              if (error instanceof Kareem.overwriteResult) {
                args = error.args;
                if (++currentPost >= numPosts) {
                  return callback.call(null, firstError);
                }
                return next();
              }
              firstError = error;
            }
            if (++currentPost >= numPosts) {
              return callback.call(null, firstError);
            }
            next();
          });
          callMiddlewareFunction(post, context, [firstError].concat(newArgs).concat([_cb]), _cb);
        } else {
          if (++currentPost >= numPosts) {
            return callback.call(null, firstError);
          }
          next();
        }
      } else {
        const _cb = decorateNextFn(function(error) {
          if (error) {
            if (error instanceof Kareem.overwriteResult) {
              args = error.args;
              if (++currentPost >= numPosts) {
                return callback.apply(null, [null].concat(args));
              }
              return next();
            }
            firstError = error;
            return next();
          }
          if (++currentPost >= numPosts) {
            return callback.apply(null, [null].concat(args));
          }
          next();
        });
        if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
          if (++currentPost >= numPosts) {
            return callback.apply(null, [null].concat(args));
          }
          return next();
        }
        if (post.length === numArgs + 1) {
          callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);
        } else {
          let error;
          let maybePromiseLike;
          try {
            maybePromiseLike = post.apply(context, newArgs);
          } catch (err2) {
            error = err2;
            firstError = err2;
          }
          if (isPromiseLike(maybePromiseLike)) {
            return maybePromiseLike.then((res) => {
              _cb(res instanceof Kareem.overwriteResult ? res : null);
            }, (err2) => _cb(err2));
          }
          if (maybePromiseLike instanceof Kareem.overwriteResult) {
            args = maybePromiseLike.args;
          }
          if (++currentPost >= numPosts) {
            return callback.apply(null, [error].concat(args));
          }
          next();
        }
      }
    }
    next();
  };
  Kareem.prototype.execPostSync = function(name, context, args) {
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    for (let i = 0;i < numPosts; ++i) {
      const res = posts[i].fn.apply(context, args || []);
      if (res instanceof Kareem.overwriteResult) {
        args = res.args;
      }
    }
    return args;
  };
  Kareem.prototype.createWrapperSync = function(name, fn) {
    const _this = this;
    return function syncWrapper() {
      _this.execPreSync(name, this, arguments);
      const toReturn = fn.apply(this, arguments);
      const result = _this.execPostSync(name, this, [toReturn]);
      return result[0];
    };
  };
  function _handleWrapError(instance, error, name, context, args, options, callback) {
    if (options.useErrorHandlers) {
      return instance.execPost(name, context, args, { error }, function(error2) {
        return typeof callback === "function" && callback(error2);
      });
    } else {
      return typeof callback === "function" && callback(error);
    }
  }
  Kareem.prototype.wrap = function(name, fn, context, args, options) {
    const lastArg = args.length > 0 ? args[args.length - 1] : null;
    const argsWithoutCb = Array.from(args);
    typeof lastArg === "function" && argsWithoutCb.pop();
    const _this = this;
    options = options || {};
    const checkForPromise = options.checkForPromise;
    this.execPre(name, context, args, function(error) {
      if (error && !(error instanceof Kareem.skipWrappedFunction)) {
        const numCallbackParams = options.numCallbackParams || 0;
        const errorArgs = options.contextParameter ? [context] : [];
        for (let i = errorArgs.length;i < numCallbackParams; ++i) {
          errorArgs.push(null);
        }
        return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);
      }
      const numParameters = fn.length;
      let ret;
      if (error instanceof Kareem.skipWrappedFunction) {
        ret = error.args[0];
        return _cb(null, ...error.args);
      } else {
        try {
          ret = fn.apply(context, argsWithoutCb.concat(_cb));
        } catch (err2) {
          return _cb(err2);
        }
      }
      if (checkForPromise) {
        if (isPromiseLike(ret)) {
          return ret.then((res) => _cb(null, res), (err2) => _cb(err2));
        }
        if (numParameters < argsWithoutCb.length + 1) {
          return _cb(null, ret);
        }
      }
      function _cb() {
        const argsWithoutError = Array.from(arguments);
        argsWithoutError.shift();
        if (options.nullResultByDefault && argsWithoutError.length === 0) {
          argsWithoutError.push(null);
        }
        if (arguments[0]) {
          return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);
        } else {
          _this.execPost(name, context, argsWithoutError, function() {
            if (lastArg === null) {
              return;
            }
            arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);
          });
        }
      }
    });
  };
  Kareem.prototype.filter = function(fn) {
    const clone2 = this.clone();
    const pres = Array.from(clone2._pres.keys());
    for (const name of pres) {
      const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
      if (hooks.length === 0) {
        clone2._pres.delete(name);
        continue;
      }
      hooks.numAsync = hooks.filter((h) => h.isAsync).length;
      clone2._pres.set(name, hooks);
    }
    const posts = Array.from(clone2._posts.keys());
    for (const name of posts) {
      const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
      if (hooks.length === 0) {
        clone2._posts.delete(name);
        continue;
      }
      clone2._posts.set(name, hooks);
    }
    return clone2;
  };
  Kareem.prototype.hasHooks = function(name) {
    return this._pres.has(name) || this._posts.has(name);
  };
  Kareem.prototype.createWrapper = function(name, fn, context, options) {
    const _this = this;
    if (!this.hasHooks(name)) {
      return function() {
        nextTick(() => fn.apply(this, arguments));
      };
    }
    return function() {
      const _context = context || this;
      _this.wrap(name, fn, _context, Array.from(arguments), options);
    };
  };
  Kareem.prototype.pre = function(name, isAsync3, fn, error, unshift) {
    let options = {};
    if (typeof isAsync3 === "object" && isAsync3 !== null) {
      options = isAsync3;
      isAsync3 = options.isAsync;
    } else if (typeof arguments[1] !== "boolean") {
      fn = isAsync3;
      isAsync3 = false;
    }
    const pres = this._pres.get(name) || [];
    this._pres.set(name, pres);
    if (isAsync3) {
      pres.numAsync = pres.numAsync || 0;
      ++pres.numAsync;
    }
    if (typeof fn !== "function") {
      throw new Error('pre() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
      pres.unshift(Object.assign({}, options, { fn, isAsync: isAsync3 }));
    } else {
      pres.push(Object.assign({}, options, { fn, isAsync: isAsync3 }));
    }
    return this;
  };
  Kareem.prototype.post = function(name, options, fn, unshift) {
    const posts = this._posts.get(name) || [];
    if (typeof options === "function") {
      unshift = !!fn;
      fn = options;
      options = {};
    }
    if (typeof fn !== "function") {
      throw new Error('post() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
      posts.unshift(Object.assign({}, options, { fn }));
    } else {
      posts.push(Object.assign({}, options, { fn }));
    }
    this._posts.set(name, posts);
    return this;
  };
  Kareem.prototype.clone = function() {
    const n2 = new Kareem;
    for (const key of this._pres.keys()) {
      const clone2 = this._pres.get(key).slice();
      clone2.numAsync = this._pres.get(key).numAsync;
      n2._pres.set(key, clone2);
    }
    for (const key of this._posts.keys()) {
      n2._posts.set(key, this._posts.get(key).slice());
    }
    return n2;
  };
  Kareem.prototype.merge = function(other, clone2) {
    clone2 = arguments.length === 1 ? true : clone2;
    const ret = clone2 ? this.clone() : this;
    for (const key of other._pres.keys()) {
      const sourcePres = ret._pres.get(key) || [];
      const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
      const combined = sourcePres.concat(deduplicated);
      combined.numAsync = sourcePres.numAsync || 0;
      combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
      ret._pres.set(key, combined);
    }
    for (const key of other._posts.keys()) {
      const sourcePosts = ret._posts.get(key) || [];
      const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
      ret._posts.set(key, sourcePosts.concat(deduplicated));
    }
    return ret;
  };
  function callMiddlewareFunction(fn, context, args, next) {
    let maybePromiseLike;
    try {
      maybePromiseLike = fn.apply(context, args);
    } catch (error) {
      return next(error);
    }
    if (isPromiseLike(maybePromiseLike)) {
      maybePromiseLike.then(() => next(), (err2) => next(err2));
    }
  }
  function isPromiseLike(v) {
    return typeof v === "object" && v !== null && typeof v.then === "function";
  }
  function decorateNextFn(fn) {
    let called = false;
    const _this = this;
    return function() {
      if (called) {
        return;
      }
      called = true;
      return nextTick(() => fn.apply(_this, arguments));
    };
  }
  var nextTick = typeof process === "object" && process !== null && process.nextTick || function nextTick(cb) {
    setTimeout(cb, 0);
  };
  function isErrorHandlingMiddleware(post, numArgs) {
    if (post.errorHandler) {
      return true;
    }
    return post.fn.length === numArgs + 2;
  }
  module.exports = Kareem;
});

// node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS((exports, module) => {
  var msg = module.exports = exports = {};
  msg.DocumentNotFoundError = null;
  msg.general = {};
  msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
  msg.general.required = "Path `{PATH}` is required.";
  msg.Number = {};
  msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
  msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
  msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
  msg.Date = {};
  msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
  msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
  msg.String = {};
  msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
  msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
  msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
  msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
});

// node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var util3 = __require("util");

  class CastError extends MongooseError {
    constructor(type, value, path, reason, schemaType) {
      if (arguments.length > 0) {
        const valueType = getValueType(value);
        const messageFormat = getMessageFormat(schemaType);
        const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);
        super(msg);
        this.init(type, value, path, reason, schemaType);
      } else {
        super(formatMessage());
      }
    }
    toJSON() {
      return {
        stringValue: this.stringValue,
        valueType: this.valueType,
        kind: this.kind,
        value: this.value,
        path: this.path,
        reason: this.reason,
        name: this.name,
        message: this.message
      };
    }
    init(type, value, path, reason, schemaType) {
      /*!
         * ignore
         */
      this.stringValue = getStringValue(value);
      this.messageFormat = getMessageFormat(schemaType);
      this.kind = type;
      this.value = value;
      this.path = path;
      this.reason = reason;
      this.valueType = getValueType(value);
    }
    copy(other) {
      this.messageFormat = other.messageFormat;
      this.stringValue = other.stringValue;
      this.kind = other.kind;
      this.value = other.value;
      this.path = other.path;
      this.reason = other.reason;
      this.message = other.message;
      this.valueType = other.valueType;
    }
    setModel(model) {
      /*!
         * ignore
         */
      this.message = formatMessage(model, this.kind, this.value, this.path, this.messageFormat, this.valueType);
    }
  }
  Object.defineProperty(CastError.prototype, "name", {
    value: "CastError"
  });
  function getStringValue(value) {
    let stringValue = util3.inspect(value);
    stringValue = stringValue.replace(/^'|'$/g, '"');
    if (!stringValue.startsWith('"')) {
      stringValue = '"' + stringValue + '"';
    }
    return stringValue;
  }
  function getValueType(value) {
    if (value == null) {
      return "" + value;
    }
    const t2 = typeof value;
    if (t2 !== "object") {
      return t2;
    }
    if (typeof value.constructor !== "function") {
      return t2;
    }
    return value.constructor.name;
  }
  function getMessageFormat(schemaType) {
    const messageFormat = schemaType && schemaType._castErrorMessage || null;
    if (typeof messageFormat === "string" || typeof messageFormat === "function") {
      return messageFormat;
    }
  }
  /*!
   * ignore
   */
  function formatMessage(model, kind, value, path, messageFormat, valueType, reason) {
    if (typeof messageFormat === "string") {
      const stringValue = getStringValue(value);
      let ret = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
      if (model != null) {
        ret = ret.replace("{MODEL}", model.modelName);
      }
      return ret;
    } else if (typeof messageFormat === "function") {
      return messageFormat(value, path, model, kind);
    } else {
      const stringValue = getStringValue(value);
      const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
      let ret = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
      if (model != null) {
        ret += ' for model "' + model.modelName + '"';
      }
      if (reason != null && typeof reason.constructor === "function" && reason.constructor.name !== "AssertionError" && reason.constructor.name !== "Error") {
        ret += ' because of "' + reason.constructor.name + '"';
      }
      return ret;
    }
  }
  /*!
   * exports
   */
  module.exports = CastError;
});

// node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var util3 = __require("util");

  class DocumentNotFoundError extends MongooseError {
    constructor(filter, model, numAffected, result) {
      let msg;
      const messages = MongooseError.messages;
      if (messages.DocumentNotFoundError != null) {
        msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
      } else {
        msg = 'No document found for query "' + util3.inspect(filter) + '" on model "' + model + '"';
      }
      super(msg);
      this.result = result;
      this.numAffected = numAffected;
      this.filter = filter;
      this.query = filter;
    }
  }
  Object.defineProperty(DocumentNotFoundError.prototype, "name", {
    value: "DocumentNotFoundError"
  });
  /*!
   * exports
   */
  module.exports = DocumentNotFoundError;
});

// node_modules/mongoose/lib/helpers/error/combinePathErrors.js
var require_combinePathErrors = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function combinePathErrors(err2) {
    const keys = Object.keys(err2.errors || {});
    const len = keys.length;
    const msgs = [];
    let key;
    for (let i = 0;i < len; ++i) {
      key = keys[i];
      if (err2 === err2.errors[key]) {
        continue;
      }
      msgs.push(key + ": " + err2.errors[key].message);
    }
    return msgs.join(", ");
  };
});

// node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS((exports, module) => {
  /*!
   * Module requirements
   */
  var MongooseError = require_mongooseError();
  var getConstructorName = require_getConstructorName();
  var util3 = __require("util");
  var combinePathErrors = require_combinePathErrors();

  class ValidationError2 extends MongooseError {
    constructor(instance) {
      let _message;
      if (getConstructorName(instance) === "model") {
        _message = instance.constructor.modelName + " validation failed";
      } else {
        _message = "Validation failed";
      }
      super(_message);
      this.errors = {};
      this._message = _message;
      if (instance) {
        instance.$errors = this.errors;
      }
    }
    toString() {
      return this.name + ": " + combinePathErrors(this);
    }
    inspect() {
      return Object.assign(new Error(this.message), this);
    }
    addError(path, error) {
      if (error instanceof ValidationError2) {
        const { errors: errors2 } = error;
        for (const errorPath of Object.keys(errors2)) {
          this.addError(`${path}.${errorPath}`, errors2[errorPath]);
        }
        return;
      }
      this.errors[path] = error;
      this.message = this._message + ": " + combinePathErrors(this);
    }
  }
  if (util3.inspect.custom) {
    ValidationError2.prototype[util3.inspect.custom] = ValidationError2.prototype.inspect;
  }
  Object.defineProperty(ValidationError2.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
      return Object.assign({}, this, { name: this.name, message: this.message });
    }
  });
  Object.defineProperty(ValidationError2.prototype, "name", {
    value: "ValidationError"
  });
  /*!
   * Module exports
   */
  module.exports = ValidationError2;
});

// node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ValidatorError extends MongooseError {
    constructor(properties, doc) {
      let msg = properties.message;
      if (!msg) {
        msg = MongooseError.messages.general.default;
      }
      const message = formatMessage(msg, properties, doc);
      super(message);
      properties = Object.assign({}, properties, { message });
      this.properties = properties;
      this.kind = properties.type;
      this.path = properties.path;
      this.value = properties.value;
      this.reason = properties.reason;
    }
    toString() {
      return this.message;
    }
    toJSON() {
      return Object.assign({ name: this.name, message: this.message }, this);
    }
  }
  Object.defineProperty(ValidatorError.prototype, "name", {
    value: "ValidatorError"
  });
  Object.defineProperty(ValidatorError.prototype, "properties", {
    enumerable: false,
    writable: true,
    value: null
  });
  ValidatorError.prototype.formatMessage = formatMessage;
  function formatMessage(msg, properties, doc) {
    if (typeof msg === "function") {
      return msg(properties, doc);
    }
    const propertyNames = Object.keys(properties);
    for (const propertyName of propertyNames) {
      if (propertyName === "message") {
        continue;
      }
      msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
    }
    return msg;
  }
  /*!
   * exports
   */
  module.exports = ValidatorError;
});

// node_modules/mongoose/lib/error/version.js
var require_version = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class VersionError extends MongooseError {
    constructor(doc, currentVersion, modifiedPaths) {
      const modifiedPathsStr = modifiedPaths.join(", ");
      super('No matching document found for id "' + doc._doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
      this.version = currentVersion;
      this.modifiedPaths = modifiedPaths;
    }
  }
  Object.defineProperty(VersionError.prototype, "name", {
    value: "VersionError"
  });
  /*!
   * exports
   */
  module.exports = VersionError;
});

// node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ParallelSaveError extends MongooseError {
    constructor(doc) {
      const msg = "Can't save() the same doc multiple times in parallel. Document: ";
      super(msg + doc._doc._id);
    }
  }
  Object.defineProperty(ParallelSaveError.prototype, "name", {
    value: "ParallelSaveError"
  });
  /*!
   * exports
   */
  module.exports = ParallelSaveError;
});

// node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class OverwriteModelError extends MongooseError {
    constructor(name) {
      super("Cannot overwrite `" + name + "` model once compiled.");
    }
  }
  Object.defineProperty(OverwriteModelError.prototype, "name", {
    value: "OverwriteModelError"
  });
  /*!
   * exports
   */
  module.exports = OverwriteModelError;
});

// node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class MissingSchemaError extends MongooseError {
    constructor(name) {
      const msg = `Schema hasn't been registered for model "` + name + `".
` + "Use mongoose.model(name, schema)";
      super(msg);
    }
  }
  Object.defineProperty(MissingSchemaError.prototype, "name", {
    value: "MissingSchemaError"
  });
  /*!
   * exports
   */
  module.exports = MissingSchemaError;
});

// node_modules/mongoose/lib/error/bulkSaveIncompleteError.js
var require_bulkSaveIncompleteError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class MongooseBulkSaveIncompleteError extends MongooseError {
    constructor(modelName, documents, bulkWriteResult) {
      const matchedCount = bulkWriteResult?.matchedCount ?? 0;
      const insertedCount = bulkWriteResult?.insertedCount ?? 0;
      let preview = documents.map((doc) => doc._id).join(", ");
      if (preview.length > 100) {
        preview = preview.slice(0, 100) + "...";
      }
      const numDocumentsNotUpdated = documents.length - matchedCount - insertedCount;
      super(`${modelName}.bulkSave() was not able to update ${numDocumentsNotUpdated} of the given documents due to incorrect version or optimistic concurrency, document ids: ${preview}`);
      this.modelName = modelName;
      this.documents = documents;
      this.bulkWriteResult = bulkWriteResult;
      this.numDocumentsNotUpdated = numDocumentsNotUpdated;
    }
  }
  Object.defineProperty(MongooseBulkSaveIncompleteError.prototype, "name", {
    value: "MongooseBulkSaveIncompleteError"
  });
  /*!
   * exports
   */
  module.exports = MongooseBulkSaveIncompleteError;
});

// node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  module.exports = function allServersUnknown(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    const servers = Array.from(topologyDescription.servers.values());
    return servers.length > 0 && servers.every((server) => server.type === "Unknown");
  };
});

// node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  module.exports = function isAtlas(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    if (topologyDescription.servers.size === 0) {
      return false;
    }
    for (const server of topologyDescription.servers.values()) {
      if (server.host.endsWith(".mongodb.net") === false || server.port !== 27017) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  var nonSSLMessage = "Client network socket disconnected before secure TLS " + "connection was established";
  module.exports = function isSSLError(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    const descriptions = Array.from(topologyDescription.servers.values());
    return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
  };
});

// node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var allServersUnknown = require_allServersUnknown();
  var isAtlas = require_isAtlas();
  var isSSLError = require_isSSLError();
  /*!
   * ignore
   */
  var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. " + "One common reason is that you're trying to access the database from " + "an IP that isn't whitelisted. Make sure your current IP address is on your Atlas " + "cluster's IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/";
  var sslMessage = "Mongoose is connecting with SSL enabled, but the server is " + "not accepting SSL connections. Please ensure that the MongoDB server you are " + "connecting to is configured to accept SSL connections. Learn more: " + "https://mongoosejs.com/docs/tutorials/ssl.html";

  class MongooseServerSelectionError extends MongooseError {
    assimilateError(err2) {
      const reason = err2.reason;
      const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err2.message.indexOf("bad auth") === -1 && err2.message.indexOf("Authentication failed") === -1;
      if (isAtlasWhitelistError) {
        this.message = atlasMessage;
      } else if (isSSLError(reason)) {
        this.message = sslMessage;
      } else {
        this.message = err2.message;
      }
      for (const key in err2) {
        if (key !== "name") {
          this[key] = err2[key];
        }
      }
      this.cause = reason;
      return this;
    }
  }
  Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
    value: "MongooseServerSelectionError"
  });
  module.exports = MongooseServerSelectionError;
});

// node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class DivergentArrayError extends MongooseError {
    constructor(paths) {
      const msg = "For your own good, using `document.save()` to update an array " + "which was selected using an $elemMatch projection OR " + "populated using skip, limit, query conditions, or exclusion of " + "the _id field when the operation results in a $pop or $set of " + "the entire array is not supported. The following " + `path(s) would have been modified unsafely:
` + "  " + paths.join(`
  `) + `
` + "Use Model.updateOne() to update these arrays instead.";
      super(msg);
    }
  }
  Object.defineProperty(DivergentArrayError.prototype, "name", {
    value: "DivergentArrayError"
  });
  /*!
   * exports
   */
  module.exports = DivergentArrayError;
});

// node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class StrictModeError extends MongooseError {
    constructor(path, msg, immutable) {
      msg = msg || "Field `" + path + "` is not in schema and strict " + "mode is set to throw.";
      super(msg);
      this.isImmutableError = !!immutable;
      this.path = path;
    }
  }
  Object.defineProperty(StrictModeError.prototype, "name", {
    value: "StrictModeError"
  });
  module.exports = StrictModeError;
});

// node_modules/mongoose/lib/error/strictPopulate.js
var require_strictPopulate = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class StrictPopulateError extends MongooseError {
    constructor(path, msg) {
      msg = msg || "Cannot populate path `" + path + "` because it is not in your schema. " + "Set the `strictPopulate` option to false to override.";
      super(msg);
      this.path = path;
    }
  }
  Object.defineProperty(StrictPopulateError.prototype, "name", {
    value: "StrictPopulateError"
  });
  module.exports = StrictPopulateError;
});

// node_modules/mongoose/lib/error/index.js
var require_error2 = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  /*!
   * Module exports.
   */
  module.exports = exports = MongooseError;
  MongooseError.messages = require_messages();
  MongooseError.Messages = MongooseError.messages;
  MongooseError.CastError = require_cast();
  MongooseError.DocumentNotFoundError = require_notFound();
  MongooseError.ValidationError = require_validation();
  MongooseError.ValidatorError = require_validator();
  MongooseError.VersionError = require_version();
  MongooseError.ParallelSaveError = require_parallelSave();
  MongooseError.OverwriteModelError = require_overwriteModel();
  MongooseError.MissingSchemaError = require_missingSchema();
  MongooseError.MongooseBulkSaveIncompleteError = require_bulkSaveIncompleteError();
  MongooseError.MongooseServerSelectionError = require_serverSelection();
  MongooseError.DivergentArrayError = require_divergentArray();
  MongooseError.StrictModeError = require_strict();
  MongooseError.StrictPopulateError = require_strictPopulate();
});

// node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS((exports, module) => {
  module.exports = Object.freeze({
    enumerable: true,
    configurable: true,
    writable: true,
    value: undefined
  });
});

// node_modules/mongoose/lib/options/schemaTypeOptions.js
var require_schemaTypeOptions = __commonJS((exports, module) => {
  var clone2 = require_clone();

  class SchemaTypeOptions {
    constructor(obj) {
      if (obj == null) {
        return this;
      }
      Object.assign(this, clone2(obj));
    }
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "refPath", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
  module.exports = SchemaTypeOptions;
});

// node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS((exports, module) => {
  var CastError = require_cast();
  module.exports = function castBoolean(value, path) {
    if (module.exports.convertToTrue.has(value)) {
      return true;
    }
    if (module.exports.convertToFalse.has(value)) {
      return false;
    }
    if (value == null) {
      return value;
    }
    throw new CastError("boolean", value, path);
  };
  module.exports.convertToTrue = new Set([true, "true", 1, "1", "yes"]);
  module.exports.convertToFalse = new Set([false, "false", 0, "0", "no"]);
});

// node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS((exports, module) => {
  var castBoolean = require_boolean();
  /*!
   * ignore
   */
  module.exports = function(val) {
    const path = this != null ? this.path : null;
    return castBoolean(val, path);
  };
});

// node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function(val) {
    if (Array.isArray(val)) {
      if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
        throw new Error("$type array values must be strings or numbers");
      }
      return val;
    }
    if (typeof val !== "number" && typeof val !== "string") {
      throw new Error("$type parameter must be number, string, or array of numbers and strings");
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS((exports, module) => {
  var StrictModeError = require_strict();
  /*!
   * ignore
   */
  module.exports = function(schematype) {
    if (schematype.$immutable) {
      schematype.$immutableSetter = createImmutableSetter(schematype.path, schematype.options.immutable);
      schematype.set(schematype.$immutableSetter);
    } else if (schematype.$immutableSetter) {
      schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
      delete schematype.$immutableSetter;
    }
  };
  function createImmutableSetter(path, immutable) {
    return function immutableSetter(v, _priorVal, _doc, options) {
      if (this == null || this.$__ == null) {
        return v;
      }
      if (this.isNew) {
        return v;
      }
      if (options && options.overwriteImmutable) {
        return v;
      }
      const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
      if (!_immutable) {
        return v;
      }
      const _value = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(path) : this.$__getValue(path);
      if (this.$__.strictMode === "throw" && v !== _value) {
        throw new StrictModeError(path, "Path `" + path + "` is immutable " + "and strict mode is set to throw.", true);
      }
      return _value;
    };
  }
});

// node_modules/mongoose/lib/helpers/isAsyncFunction.js
var require_isAsyncFunction = __commonJS((exports, module) => {
  module.exports = function isAsyncFunction(v) {
    return typeof v === "function" && v.constructor && v.constructor.name === "AsyncFunction";
  };
});

// node_modules/mongoose/lib/helpers/isSimpleValidator.js
var require_isSimpleValidator = __commonJS((exports, module) => {
  module.exports = function isSimpleValidator(obj) {
    const keys = Object.keys(obj);
    let result = true;
    for (let i = 0, len = keys.length;i < len; ++i) {
      if (typeof obj[keys[i]] === "object" && obj[keys[i]] !== null) {
        result = false;
        break;
      }
    }
    return result;
  };
});

// node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS((exports, module) => {
  module.exports = function stringToParts(str) {
    const result = [];
    let curPropertyName = "";
    let state = "DEFAULT";
    for (let i = 0;i < str.length; ++i) {
      if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
        state = "DEFAULT";
        curPropertyName = result[result.length - 1] + "[" + curPropertyName;
        result.splice(result.length - 1, 1);
      }
      if (str[i] === "[") {
        if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
          result.push(curPropertyName);
          curPropertyName = "";
        }
        state = "IN_SQUARE_BRACKETS";
      } else if (str[i] === "]") {
        if (state === "IN_SQUARE_BRACKETS") {
          state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
          result.push(curPropertyName);
          curPropertyName = "";
        } else {
          state = "DEFAULT";
          curPropertyName += str[i];
        }
      } else if (str[i] === ".") {
        if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
          result.push(curPropertyName);
          curPropertyName = "";
        }
        state = "DEFAULT";
      } else {
        curPropertyName += str[i];
      }
    }
    if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
      result.push(curPropertyName);
    }
    return result;
  };
});

// node_modules/mpath/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var stringToParts = require_stringToParts();
  var ignoreProperties = ["__proto__", "constructor", "prototype"];
  exports.get = function(path, o, special, map3) {
    var lookup;
    if (typeof special == "function") {
      if (special.length < 2) {
        map3 = special;
        special = undefined;
      } else {
        lookup = special;
        special = undefined;
      }
    }
    map3 || (map3 = K2);
    var parts = typeof path == "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var obj = o, part;
    for (var i = 0;i < parts.length; ++i) {
      part = parts[i];
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `get()` must be a string or number, got " + typeof parts[i]);
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        var paths = parts.slice(i);
        return [].concat(obj).map(function(item) {
          return item ? exports.get(paths, item, special || lookup, map3) : map3(undefined);
        });
      }
      if (lookup) {
        obj = lookup(obj, part);
      } else {
        var _from = special && obj[special] ? obj[special] : obj;
        obj = _from instanceof Map ? _from.get(part) : _from[part];
      }
      if (!obj)
        return map3(obj);
    }
    return map3(obj);
  };
  exports.has = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for (var i = 0;i < len; ++i) {
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `has()` must be a string or number, got " + typeof parts[i]);
      }
      if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
        return false;
      }
      cur = cur[parts[i]];
    }
    return true;
  };
  exports.unset = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for (var i = 0;i < len; ++i) {
      if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
        return false;
      }
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + typeof parts[i]);
      }
      if (ignoreProperties.indexOf(parts[i]) !== -1) {
        return false;
      }
      if (i === len - 1) {
        delete cur[parts[i]];
        return true;
      }
      cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
    }
    return true;
  };
  exports.set = function(path, val, o, special, map3, _copying) {
    var lookup;
    if (typeof special == "function") {
      if (special.length < 2) {
        map3 = special;
        special = undefined;
      } else {
        lookup = special;
        special = undefined;
      }
    }
    map3 || (map3 = K2);
    var parts = typeof path == "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    if (o == null)
      return;
    for (var i = 0;i < parts.length; ++i) {
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `set()` must be a string or number, got " + typeof parts[i]);
      }
      if (ignoreProperties.indexOf(parts[i]) !== -1) {
        return;
      }
    }
    var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
    for (var i = 0, len = parts.length - 1;i < len; ++i) {
      part = parts[i];
      if (part == "$") {
        if (i == len - 1) {
          break;
        } else {
          continue;
        }
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        var paths = parts.slice(i);
        if (!copy && Array.isArray(val)) {
          for (var j = 0;j < obj.length && j < val.length; ++j) {
            exports.set(paths, val[j], obj[j], special || lookup, map3, copy);
          }
        } else {
          for (var j = 0;j < obj.length; ++j) {
            exports.set(paths, val, obj[j], special || lookup, map3, copy);
          }
        }
        return;
      }
      if (lookup) {
        obj = lookup(obj, part);
      } else {
        var _to = special && obj[special] ? obj[special] : obj;
        obj = _to instanceof Map ? _to.get(part) : _to[part];
      }
      if (!obj)
        return;
    }
    part = parts[len];
    if (special && obj[special]) {
      obj = obj[special];
    }
    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
      if (!copy && Array.isArray(val)) {
        _setArray(obj, val, part, lookup, special, map3);
      } else {
        for (var j = 0;j < obj.length; ++j) {
          var item = obj[j];
          if (item) {
            if (lookup) {
              lookup(item, part, map3(val));
            } else {
              if (item[special])
                item = item[special];
              item[part] = map3(val);
            }
          }
        }
      }
    } else {
      if (lookup) {
        lookup(obj, part, map3(val));
      } else if (obj instanceof Map) {
        obj.set(part, map3(val));
      } else {
        obj[part] = map3(val);
      }
    }
  };
  /*!
   * Split a string path into components delimited by '.' or
   * '[\d+]'
   *
   * #### Example:
   *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']
   */
  exports.stringToParts = stringToParts;
  /*!
   * Recursively set nested arrays
   */
  function _setArray(obj, val, part, lookup, special, map3) {
    for (var item, j = 0;j < obj.length && j < val.length; ++j) {
      item = obj[j];
      if (Array.isArray(item) && Array.isArray(val[j])) {
        _setArray(item, val[j], part, lookup, special, map3);
      } else if (item) {
        if (lookup) {
          lookup(item, part, map3(val[j]));
        } else {
          if (item[special])
            item = item[special];
          item[part] = map3(val[j]);
        }
      }
    }
  }
  /*!
   * Returns the value passed to it.
   */
  function K2(v) {
    return v;
  }
});

// node_modules/mpath/index.js
var require_mpath = __commonJS((exports, module) => {
  module.exports = exports = require_lib4();
});

// node_modules/mongoose/lib/options/populateOptions.js
var require_populateOptions = __commonJS((exports, module) => {
  var clone2 = require_clone();

  class PopulateOptions {
    constructor(obj) {
      this._docs = {};
      this._childDocs = [];
      if (obj == null) {
        return;
      }
      obj = clone2(obj);
      Object.assign(this, obj);
      if (typeof obj.subPopulate === "object") {
        this.populate = obj.subPopulate;
      }
      if (obj.perDocumentLimit != null && obj.limit != null) {
        throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
      }
    }
  }
  module.exports = PopulateOptions;
});

// node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js
var require_isMongooseDocumentArray = __commonJS((exports) => {
  exports.isMongooseDocumentArray = function(mongooseDocumentArray) {
    return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;
  };
});

// node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS((exports, module) => {
  var immediate = require_immediate();
  var emittedSymbol = Symbol("mongoose#emitted");
  module.exports = function promiseOrCallback(callback, fn, ee, Promise3) {
    if (typeof callback === "function") {
      try {
        return fn(function(error) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            try {
              callback(error);
            } catch (error2) {
              return immediate(() => {
                throw error2;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
      } catch (error) {
        if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
          error[emittedSymbol] = true;
          ee.emit("error", error);
        }
        return callback(error);
      }
    }
    Promise3 = Promise3 || global.Promise;
    return new Promise3((resolve, reject) => {
      fn(function(error, res) {
        if (error != null) {
          if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
            error[emittedSymbol] = true;
            ee.emit("error", error);
          }
          return reject(error);
        }
        if (arguments.length > 2) {
          return resolve(Array.prototype.slice.call(arguments, 1));
        }
        resolve(res);
      });
    });
  };
});

// node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS((exports, module) => {
  module.exports = function merge(s1, s2, skipConflictingPaths) {
    const paths = Object.keys(s2.tree);
    const pathsToAdd = {};
    for (const key of paths) {
      if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
        continue;
      }
      pathsToAdd[key] = s2.tree[key];
    }
    s1.options._isMerging = true;
    s1.add(pathsToAdd, null);
    delete s1.options._isMerging;
    s1.callQueue = s1.callQueue.concat(s2.callQueue);
    s1.method(s2.methods);
    s1.static(s2.statics);
    for (const [option, value] of Object.entries(s2._userProvidedOptions)) {
      if (!(option in s1._userProvidedOptions)) {
        s1.set(option, value);
      }
    }
    for (const query in s2.query) {
      s1.query[query] = s2.query[query];
    }
    for (const virtual in s2.virtuals) {
      s1.virtuals[virtual] = s2.virtuals[virtual].clone();
    }
    s1._indexes = s1._indexes.concat(s2._indexes || []);
    s1.s.hooks.merge(s2.s.hooks, false);
  };
});

// node_modules/mongoose/lib/stateMachine.js
var require_stateMachine = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var utils = require_utils3();
  var StateMachine = module.exports = exports = function StateMachine() {
  };
  StateMachine.ctor = function() {
    const states = [...arguments];
    const ctor = function() {
      StateMachine.apply(this, arguments);
      this.paths = {};
      this.states = {};
    };
    ctor.prototype = new StateMachine;
    ctor.prototype.constructor = ctor;
    ctor.prototype.stateNames = states;
    states.forEach(function(state) {
      ctor.prototype[state] = function(path) {
        this._changeState(path, state);
      };
    });
    return ctor;
  };
  StateMachine.prototype._changeState = function _changeState(path, nextState) {
    const prevState = this.paths[path];
    if (prevState === nextState) {
      return;
    }
    const prevBucket = this.states[prevState];
    if (prevBucket)
      delete prevBucket[path];
    this.paths[path] = nextState;
    this.states[nextState] = this.states[nextState] || {};
    this.states[nextState][path] = true;
  };
  /*!
   * ignore
   */
  StateMachine.prototype.clear = function clear(state) {
    if (this.states[state] == null) {
      return;
    }
    const keys = Object.keys(this.states[state]);
    let i = keys.length;
    let path;
    while (i--) {
      path = keys[i];
      delete this.states[state][path];
      delete this.paths[path];
    }
  };
  /*!
   * ignore
   */
  StateMachine.prototype.clearPath = function clearPath(path) {
    const state = this.paths[path];
    if (!state) {
      return;
    }
    delete this.paths[path];
    delete this.states[state][path];
  };
  StateMachine.prototype.getStatePaths = function getStatePaths(state) {
    if (this.states[state] != null) {
      return this.states[state];
    }
    return {};
  };
  StateMachine.prototype.some = function some() {
    const _this = this;
    const what = arguments.length ? arguments : this.stateNames;
    return Array.prototype.some.call(what, function(state) {
      if (_this.states[state] == null) {
        return false;
      }
      return Object.keys(_this.states[state]).length;
    });
  };
  StateMachine.prototype._iter = function _iter(iterMethod) {
    return function() {
      let states = [...arguments];
      const callback = states.pop();
      if (!states.length)
        states = this.stateNames;
      const _this = this;
      const paths = states.reduce(function(paths2, state) {
        if (_this.states[state] == null) {
          return paths2;
        }
        return paths2.concat(Object.keys(_this.states[state]));
      }, []);
      return paths[iterMethod](function(path, i, paths2) {
        return callback(path, i, paths2);
      });
    };
  };
  StateMachine.prototype.forEach = function forEach() {
    this.forEach = this._iter("forEach");
    return this.forEach.apply(this, arguments);
  };
  StateMachine.prototype.map = function map() {
    this.map = this._iter("map");
    return this.map.apply(this, arguments);
  };
  StateMachine.prototype.clone = function clone() {
    const result = new this.constructor;
    result.paths = { ...this.paths };
    for (const state of this.stateNames) {
      if (!(state in this.states)) {
        continue;
      }
      result.states[state] = this.states[state] == null ? this.states[state] : { ...this.states[state] };
    }
    return result;
  };
});

// node_modules/mongoose/lib/internal.js
var require_internal = __commonJS((exports, module) => {
  /*!
   * Dependencies
   */
  var StateMachine = require_stateMachine();
  var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
  module.exports = exports = InternalCache;
  function InternalCache() {
    this.activePaths = new ActiveRoster;
  }
  InternalCache.prototype.strictMode = true;
  InternalCache.prototype.fullPath = undefined;
  InternalCache.prototype.selected = undefined;
  InternalCache.prototype.shardval = undefined;
  InternalCache.prototype.saveError = undefined;
  InternalCache.prototype.validationError = undefined;
  InternalCache.prototype.adhocPaths = undefined;
  InternalCache.prototype.removing = undefined;
  InternalCache.prototype.inserting = undefined;
  InternalCache.prototype.saving = undefined;
  InternalCache.prototype.version = undefined;
  InternalCache.prototype._id = undefined;
  InternalCache.prototype.ownerDocument = undefined;
  InternalCache.prototype.populate = undefined;
  InternalCache.prototype.populated = undefined;
  InternalCache.prototype.primitiveAtomics = undefined;
  InternalCache.prototype.wasPopulated = false;
  InternalCache.prototype.scope = undefined;
  InternalCache.prototype.session = null;
  InternalCache.prototype.pathsToScopes = null;
  InternalCache.prototype.cachedRequired = null;
});

// node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var Binary = require_bson().Binary;
  var UUID = require_bson().UUID;
  var utils = require_utils3();
  function MongooseBuffer(value, encode2, offset) {
    let val = value;
    if (value == null) {
      val = 0;
    }
    let encoding;
    let path;
    let doc;
    if (Array.isArray(encode2)) {
      path = encode2[0];
      doc = encode2[1];
    } else {
      encoding = encode2;
    }
    let buf;
    if (typeof val === "number" || val instanceof Number) {
      buf = Buffer.alloc(val);
    } else {
      buf = Buffer.from(val, encoding, offset);
    }
    utils.decorate(buf, MongooseBuffer.mixin);
    buf.isMongooseBuffer = true;
    buf[MongooseBuffer.pathSymbol] = path;
    buf[parentSymbol] = doc;
    buf._subtype = 0;
    return buf;
  }
  var pathSymbol = Symbol.for("mongoose#Buffer#_path");
  var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
  MongooseBuffer.pathSymbol = pathSymbol;
  /*!
   * Inherit from Buffer.
   */
  MongooseBuffer.mixin = {
    _subtype: undefined,
    _markModified: function() {
      const parent = this[parentSymbol];
      if (parent) {
        parent.markModified(this[MongooseBuffer.pathSymbol]);
      }
      return this;
    },
    write: function() {
      const written = Buffer.prototype.write.apply(this, arguments);
      if (written > 0) {
        this._markModified();
      }
      return written;
    },
    copy: function(target) {
      const ret = Buffer.prototype.copy.apply(this, arguments);
      if (target && target.isMongooseBuffer) {
        target._markModified();
      }
      return ret;
    }
  };
  /*!
   * Compile other Buffer methods marking this buffer as modified.
   */
  utils.each([
    "writeUInt8",
    "writeUInt16",
    "writeUInt32",
    "writeInt8",
    "writeInt16",
    "writeInt32",
    "writeFloat",
    "writeDouble",
    "fill",
    "utf8Write",
    "binaryWrite",
    "asciiWrite",
    "set",
    "writeUInt16LE",
    "writeUInt16BE",
    "writeUInt32LE",
    "writeUInt32BE",
    "writeInt16LE",
    "writeInt16BE",
    "writeInt32LE",
    "writeInt32BE",
    "writeFloatLE",
    "writeFloatBE",
    "writeDoubleLE",
    "writeDoubleBE"
  ], function(method) {
    if (!Buffer.prototype[method]) {
      return;
    }
    MongooseBuffer.mixin[method] = function() {
      const ret = Buffer.prototype[method].apply(this, arguments);
      this._markModified();
      return ret;
    };
  });
  MongooseBuffer.mixin.toObject = function(options) {
    const subtype = typeof options === "number" ? options : this._subtype || 0;
    return new Binary(Buffer.from(this), subtype);
  };
  MongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;
  MongooseBuffer.mixin.toBSON = function() {
    return new Binary(this, this._subtype || 0);
  };
  MongooseBuffer.mixin.toUUID = function() {
    if (this._subtype !== 4) {
      throw new Error("Cannot convert a Buffer with subtype " + this._subtype + " to a UUID");
    }
    return new UUID(this);
  };
  MongooseBuffer.mixin.equals = function(other) {
    if (!Buffer.isBuffer(other)) {
      return false;
    }
    if (this.length !== other.length) {
      return false;
    }
    for (let i = 0;i < this.length; ++i) {
      if (this[i] !== other[i]) {
        return false;
      }
    }
    return true;
  };
  MongooseBuffer.mixin.subtype = function(subtype) {
    if (typeof subtype !== "number") {
      throw new TypeError("Invalid subtype. Expected a number");
    }
    if (this._subtype !== subtype) {
      this._markModified();
    }
    this._subtype = subtype;
  };
  /*!
   * Module exports.
   */
  MongooseBuffer.Binary = Binary;
  module.exports = MongooseBuffer;
});

// node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS((exports) => {
  exports.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
  exports.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
});

// node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schemaType();
  var symbols = require_symbols2();
  var isObject2 = require_isObject();
  var utils = require_utils3();
  function SchemaMixed(path, options) {
    if (options && options.default) {
      const def = options.default;
      if (Array.isArray(def) && def.length === 0) {
        options.default = Array;
      } else if (!options.shared && isObject2(def) && Object.keys(def).length === 0) {
        options.default = function() {
          return {};
        };
      }
    }
    SchemaType.call(this, path, options, "Mixed");
    this[symbols.schemaMixedSymbol] = true;
  }
  SchemaMixed.schemaName = "Mixed";
  SchemaMixed.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaMixed.prototype = Object.create(SchemaType.prototype);
  SchemaMixed.prototype.constructor = SchemaMixed;
  SchemaMixed.get = SchemaType.get;
  SchemaMixed.set = SchemaType.set;
  SchemaMixed.setters = [];
  SchemaMixed.prototype.cast = function(val) {
    if (val instanceof Error) {
      return utils.errorToPOJO(val);
    }
    return val;
  };
  SchemaMixed.prototype.castForQuery = function($cond, val) {
    return val;
  };
  SchemaMixed.prototype.toJSONSchema = function toJSONSchema(_options) {
    return {};
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaMixed;
});

// node_modules/mongoose/lib/modifiedPathsSnapshot.js
var require_modifiedPathsSnapshot = __commonJS((exports, module) => {
  module.exports = class ModifiedPathsSnapshot {
    constructor(subdocSnapshot, activePaths, version) {
      this.subdocSnapshot = subdocSnapshot;
      this.activePaths = activePaths;
      this.version = version;
    }
  };
});

// node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ObjectExpectedError extends MongooseError {
    constructor(path, val) {
      const typeDescription = Array.isArray(val) ? "array" : "primitive value";
      super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "`");
      this.path = path;
    }
  }
  Object.defineProperty(ObjectExpectedError.prototype, "name", {
    value: "ObjectExpectedError"
  });
  module.exports = ObjectExpectedError;
});

// node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ObjectParameterError extends MongooseError {
    constructor(value, paramName, fnName) {
      super('Parameter "' + paramName + '" to ' + fnName + '() must be an object, got "' + value.toString() + '" (type ' + typeof value + ")");
    }
  }
  Object.defineProperty(ObjectParameterError.prototype, "name", {
    value: "ObjectParameterError"
  });
  module.exports = ObjectParameterError;
});

// node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ParallelValidateError extends MongooseError {
    constructor(doc) {
      const msg = "Can't validate() the same doc multiple times in parallel. Document: ";
      super(msg + doc._doc._id);
    }
  }
  Object.defineProperty(ParallelValidateError.prototype, "name", {
    value: "ParallelValidateError"
  });
  /*!
   * exports
   */
  module.exports = ParallelValidateError;
});

// node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js
var require_hasIncludedChildren = __commonJS((exports, module) => {
  module.exports = function hasIncludedChildren(fields) {
    const hasIncludedChildren = {};
    const keys = Object.keys(fields);
    for (const key of keys) {
      if (key.indexOf(".") === -1) {
        hasIncludedChildren[key] = 1;
        continue;
      }
      const parts = key.split(".");
      let c = parts[0];
      for (let i = 0;i < parts.length; ++i) {
        hasIncludedChildren[c] = 1;
        if (i + 1 < parts.length) {
          c = c + "." + parts[i + 1];
        }
      }
    }
    return hasIncludedChildren;
  };
});

// node_modules/mongoose/lib/helpers/projection/isNestedProjection.js
var require_isNestedProjection = __commonJS((exports, module) => {
  module.exports = function isNestedProjection(val) {
    if (val == null || typeof val !== "object") {
      return false;
    }
    return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;
  };
});

// node_modules/mongoose/lib/helpers/document/applyDefaults.js
var require_applyDefaults = __commonJS((exports, module) => {
  var isNestedProjection = require_isNestedProjection();
  module.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip, options) {
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    const skipParentChangeTracking = options && options.skipParentChangeTracking;
    for (let i = 0;i < plen; ++i) {
      let def;
      let curPath = "";
      const p = paths[i];
      if (p === "_id" && doc.$__.skipId) {
        continue;
      }
      const type = doc.$__schema.paths[p];
      const path = type.splitPath();
      const len = path.length;
      if (path[len - 1] === "$*") {
        continue;
      }
      let included = false;
      let doc_ = doc._doc;
      for (let j = 0;j < len; ++j) {
        if (doc_ == null) {
          break;
        }
        const piece = path[j];
        curPath += (!curPath.length ? "" : ".") + piece;
        if (exclude === true) {
          if (curPath in fields) {
            break;
          }
        } else if (exclude === false && fields && !included) {
          const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;
          if (curPath in fields && !isNestedProjection(fields[curPath]) || j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath]) {
            included = true;
          } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {
            break;
          }
        }
        if (j === len - 1) {
          if (doc_[piece] !== undefined) {
            break;
          }
          if (isBeforeSetters != null) {
            if (typeof type.defaultValue === "function") {
              if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                break;
              }
              if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                break;
              }
            } else if (!isBeforeSetters) {
              continue;
            }
          }
          if (pathsToSkip && pathsToSkip[curPath]) {
            break;
          }
          if (fields && exclude !== null) {
            if (exclude === true) {
              if (p in fields) {
                continue;
              }
              try {
                def = type.getDefault(doc, false);
              } catch (err2) {
                doc.invalidate(p, err2);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p, skipParentChangeTracking);
              }
            } else if (included) {
              try {
                def = type.getDefault(doc, false);
              } catch (err2) {
                doc.invalidate(p, err2);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p, skipParentChangeTracking);
              }
            }
          } else {
            try {
              def = type.getDefault(doc, false);
            } catch (err2) {
              doc.invalidate(p, err2);
              break;
            }
            if (typeof def !== "undefined") {
              doc_[piece] = def;
              applyChangeTracking(doc, p, skipParentChangeTracking);
            }
          }
        } else {
          doc_ = doc_[piece];
        }
      }
    }
  };
  /*!
   * ignore
   */
  function applyChangeTracking(doc, fullPath, skipParentChangeTracking) {
    doc.$__.activePaths.default(fullPath);
    if (!skipParentChangeTracking && doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {
      doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));
    }
  }
});

// node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function cleanModifiedSubpaths(doc, path, options) {
    options = options || {};
    const skipDocArrays = options.skipDocArrays;
    let deleted = 0;
    if (!doc) {
      return deleted;
    }
    for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths("modify"))) {
      if (skipDocArrays) {
        const schemaType = doc.$__schema.path(modifiedPath);
        if (schemaType && schemaType.$isMongooseDocumentArray) {
          continue;
        }
      }
      if (modifiedPath.startsWith(path + ".")) {
        doc.$__.activePaths.clearPath(modifiedPath);
        ++deleted;
        if (doc.$isSubdocument) {
          cleanParent(doc, modifiedPath);
        }
      }
    }
    return deleted;
  };
  function cleanParent(doc, path, seen = new Set) {
    if (seen.has(doc)) {
      throw new Error("Infinite subdocument loop: subdoc with _id " + doc._id + " is a parent of itself");
    }
    const parent = doc.$parent();
    const newPath = doc.$__pathRelativeToParent(undefined, false) + "." + path;
    parent.$__.activePaths.clearPath(newPath);
    if (parent.$isSubdocument) {
      cleanParent(parent, newPath, seen);
    }
  }
});

// node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS((exports) => {
  var clone2 = require_clone();
  var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var utils = require_utils3();
  var Document;
  var getSymbol = require_symbols().getSymbol;
  var scopeSymbol = require_symbols().scopeSymbol;
  var isPOJO = utils.isPOJO;
  /*!
   * exports
   */
  exports.compile = compile2;
  exports.defineKey = defineKey;
  var _isEmptyOptions = Object.freeze({
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  });
  var noDottedPathGetOptions = Object.freeze({
    noDottedPath: true
  });
  function compile2(tree, proto, prefix, options) {
    Document = Document || require_document2();
    const typeKey = options.typeKey;
    for (const key of Object.keys(tree)) {
      const limb = tree[key];
      const hasSubprops = isPOJO(limb) && Object.keys(limb).length > 0 && (!limb[typeKey] || typeKey === "type" && isPOJO(limb.type) && limb.type.type);
      const subprops = hasSubprops ? limb : null;
      defineKey({ prop: key, subprops, prototype: proto, prefix, options });
    }
  }
  function defineKey({ prop, subprops, prototype, prefix, options }) {
    Document = Document || require_document2();
    const path = (prefix ? prefix + "." : "") + prop;
    prefix = prefix || "";
    const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;
    if (subprops) {
      Object.defineProperty(prototype, prop, {
        enumerable: true,
        configurable: true,
        get: function() {
          const _this = this;
          if (!this.$__.getters) {
            this.$__.getters = {};
          }
          if (!this.$__.getters[path]) {
            const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
            if (!prefix) {
              nested.$__[scopeSymbol] = this;
            }
            nested.$__.nestedPath = path;
            Object.defineProperty(nested, "schema", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, "$__schema", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, documentSchemaSymbol, {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, "toObject", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return clone2(_this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                }));
              }
            });
            Object.defineProperty(nested, "$__get", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return _this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                });
              }
            });
            Object.defineProperty(nested, "toJSON", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return _this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null
                });
              }
            });
            Object.defineProperty(nested, "$__isNested", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: true
            });
            Object.defineProperty(nested, "$isEmpty", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
              }
            });
            Object.defineProperty(nested, "$__parent", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: this
            });
            compile2(subprops, nested, path, options);
            this.$__.getters[path] = nested;
          }
          return this.$__.getters[path];
        },
        set: function(v) {
          if (v != null && v.$__isNested) {
            v = v.$__get();
          } else if (v instanceof Document && !v.$__isNested) {
            v = v.$toObject(internalToObjectOptions);
          }
          const doc = this.$__[scopeSymbol] || this;
          doc.$set(path, v);
        }
      });
    } else {
      Object.defineProperty(prototype, prop, {
        enumerable: true,
        configurable: true,
        get: function() {
          return this[getSymbol].call(this.$__[scopeSymbol] || this, path, null, useGetOptions);
        },
        set: function(v) {
          this.$set.call(this.$__[scopeSymbol] || this, path, v);
        }
      });
    }
  }
  function getOwnPropertyDescriptors(object) {
    const result = {};
    Object.getOwnPropertyNames(object).forEach(function(key) {
      const skip = [
        "isNew",
        "$__",
        "$errors",
        "errors",
        "_doc",
        "$locals",
        "$op",
        "__parentArray",
        "__index",
        "$isDocumentArrayElement"
      ].indexOf(key) === -1;
      if (skip) {
        return;
      }
      result[key] = Object.getOwnPropertyDescriptor(object, key);
      result[key].enumerable = false;
    });
    return result;
  }
});

// node_modules/mongoose/lib/helpers/firstKey.js
var require_firstKey = __commonJS((exports, module) => {
  module.exports = function firstKey(obj) {
    if (obj == null) {
      return null;
    }
    return Object.keys(obj)[0];
  };
});

// node_modules/mongoose/lib/helpers/common.js
var require_common4 = __commonJS((exports) => {
  /*!
   * Module dependencies.
   */
  var Binary = require_bson().Binary;
  var isBsonType = require_isBsonType();
  var isMongooseObject = require_isMongooseObject();
  var MongooseError = require_error2();
  var util3 = __require("util");
  exports.flatten = flatten;
  exports.modifiedPaths = modifiedPaths;
  /*!
   * ignore
   */
  function flatten(update, path, options, schema) {
    let keys;
    if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
      keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});
    } else {
      keys = Object.keys(update || {});
    }
    const numKeys = keys.length;
    const result = {};
    path = path ? path + "." : "";
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const val = update[key];
      result[path + key] = val;
      const keySchema = schema && schema.path && schema.path(path + key);
      const isNested = schema && schema.nested && schema.nested[path + key];
      if (keySchema && keySchema.instance === "Mixed")
        continue;
      if (shouldFlatten(val)) {
        if (options && options.skipArrays && Array.isArray(val)) {
          continue;
        }
        const flat = flatten(val, path + key, options, schema);
        for (const k in flat) {
          result[k] = flat[k];
        }
        if (Array.isArray(val)) {
          result[path + key] = val;
        }
      }
      if (isNested) {
        const paths = Object.keys(schema.paths);
        for (const p of paths) {
          if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
            result[p] = undefined;
          }
        }
      }
    }
    return result;
  }
  /*!
   * ignore
   */
  function modifiedPaths(update, path, result, recursion = null) {
    if (update == null || typeof update !== "object") {
      return;
    }
    if (recursion == null) {
      recursion = {
        raw: { update, path },
        trace: new WeakSet
      };
    }
    if (recursion.trace.has(update)) {
      throw new MongooseError(`a circular reference in the update value, updateValue:
${util3.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}
updatePath: '${recursion.raw.path}'`);
    }
    recursion.trace.add(update);
    const keys = Object.keys(update || {});
    const numKeys = keys.length;
    result = result || {};
    path = path ? path + "." : "";
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      let val = update[key];
      const _path = path + key;
      result[_path] = true;
      if (!Buffer.isBuffer(val) && isMongooseObject(val)) {
        val = val.toObject({ transform: false, virtuals: false });
      }
      if (shouldFlatten(val)) {
        modifiedPaths(val, path + key, result, recursion);
      }
    }
    recursion.trace.delete(update);
    return result;
  }
  /*!
   * ignore
   */
  function shouldFlatten(val) {
    return val && typeof val === "object" && !(val instanceof Date) && !isBsonType(val, "ObjectId") && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, "Decimal128") && !(val instanceof Binary);
  }
});

// node_modules/mongoose/lib/helpers/get.js
var require_get = __commonJS((exports, module) => {
  module.exports = function get(obj, path, def) {
    let parts;
    let isPathArray = false;
    if (typeof path === "string") {
      if (path.indexOf(".") === -1) {
        const _v = getProperty(obj, path);
        if (_v == null) {
          return def;
        }
        return _v;
      }
      parts = path.split(".");
    } else {
      isPathArray = true;
      parts = path;
      if (parts.length === 1) {
        const _v = getProperty(obj, parts[0]);
        if (_v == null) {
          return def;
        }
        return _v;
      }
    }
    let rest = path;
    let cur = obj;
    for (const part of parts) {
      if (cur == null) {
        return def;
      }
      if (!isPathArray && cur[rest] != null) {
        return cur[rest];
      }
      cur = getProperty(cur, part);
      if (!isPathArray) {
        rest = rest.substr(part.length + 1);
      }
    }
    return cur == null ? def : cur;
  };
  function getProperty(obj, prop) {
    if (obj == null) {
      return obj;
    }
    if (obj instanceof Map) {
      return obj.get(prop);
    }
    return obj[prop];
  }
});

// node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  module.exports = function areDiscriminatorValuesEqual(a12, b) {
    if (typeof a12 === "string" && typeof b === "string") {
      return a12 === b;
    }
    if (typeof a12 === "number" && typeof b === "number") {
      return a12 === b;
    }
    if (isBsonType(a12, "ObjectId") && isBsonType(b, "ObjectId")) {
      return a12.toString() === b.toString();
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS((exports, module) => {
  var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
  module.exports = function getSchemaDiscriminatorByValue(schema, value) {
    if (schema == null || schema.discriminators == null) {
      return null;
    }
    for (const key of Object.keys(schema.discriminators)) {
      const discriminatorSchema = schema.discriminators[key];
      if (discriminatorSchema.discriminatorMapping == null) {
        continue;
      }
      if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
        return discriminatorSchema;
      }
    }
    return null;
  };
});

// node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS((exports, module) => {
  var get = require_get();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  module.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {
    options = options || {};
    const typeOnly = options.typeOnly;
    const parts = Array.isArray(path) ? path : path.indexOf(".") === -1 ? [path] : path.split(".");
    let schemaType = null;
    let type = "adhocOrUndefined";
    const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;
    for (let i = 0;i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join(".");
      schemaType = schema.path(subpath);
      if (schemaType == null) {
        type = "adhocOrUndefined";
        continue;
      }
      if (schemaType.instance === "Mixed") {
        return typeOnly ? "real" : schemaType;
      }
      type = schema.pathType(subpath);
      if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {
        const discriminators = schemaType.schema.discriminators;
        const discriminatorKey = doc.get(subpath + "." + get(schemaType, "schema.options.discriminatorKey"));
        if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
          continue;
        }
        const rest = parts.slice(i + 1).join(".");
        return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
      }
    }
    return typeOnly ? type : schemaType;
  };
});

// node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js
var require_getKeysInSchemaOrder = __commonJS((exports, module) => {
  var get = require_get();
  module.exports = function getKeysInSchemaOrder(schema, val, path) {
    const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);
    const valKeys = new Set(Object.keys(val));
    let keys;
    if (valKeys.size > 1) {
      keys = new Set;
      for (const key of schemaKeys) {
        if (valKeys.has(key)) {
          keys.add(key);
        }
      }
      for (const key of valKeys) {
        if (!keys.has(key)) {
          keys.add(key);
        }
      }
      keys = Array.from(keys);
    } else {
      keys = Array.from(valKeys);
    }
    return keys;
  };
});

// node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js
var require_getSubdocumentStrictValue = __commonJS((exports, module) => {
  module.exports = function getSubdocumentStrictValue(schema, parts) {
    if (parts.length === 1) {
      return;
    }
    let cur = parts[0];
    let strict = undefined;
    for (let i = 0;i < parts.length - 1; ++i) {
      const curSchemaType = schema.path(cur);
      if (curSchemaType && curSchemaType.schema) {
        strict = curSchemaType.schema.options.strict;
        schema = curSchemaType.schema;
        cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? "" : parts[i + 1];
      } else {
        cur += cur.length ? "." + parts[i + 1] : parts[i + 1];
      }
    }
    return strict;
  };
});

// node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS((exports, module) => {
  var utils = require_utils3();
  var keysToSkip = new Set(["__index", "__parentArray", "_doc"]);
  module.exports = function handleSpreadDoc(v, includeExtraKeys) {
    if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {
      if (includeExtraKeys) {
        const extraKeys = {};
        for (const key of Object.keys(v)) {
          if (typeof key === "symbol") {
            continue;
          }
          if (key[0] === "$") {
            continue;
          }
          if (keysToSkip.has(key)) {
            continue;
          }
          extraKeys[key] = v[key];
        }
        return { ...v._doc, ...extraKeys };
      }
      return v._doc;
    }
    return v;
  };
});

// node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function isDefiningProjection(val) {
    if (val == null) {
      return true;
    }
    if (typeof val === "object") {
      return !("$meta" in val) && !("$slice" in val);
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  var isPOJO = require_isPOJO();
  /*!
   * ignore
   */
  module.exports = function isExclusive(projection) {
    if (projection == null) {
      return null;
    }
    const keys = Object.keys(projection);
    let exclude = null;
    if (keys.length === 1 && keys[0] === "_id") {
      exclude = !projection._id;
    } else {
      for (let ki = 0;ki < keys.length; ++ki) {
        const key = keys[ki];
        if (key !== "_id" && isDefiningProjection(projection[key])) {
          exclude = isPOJO(projection[key]) ? isExclusive(projection[key]) ?? exclude : !projection[key];
          if (exclude != null) {
            break;
          }
        }
      }
    }
    return exclude;
  };
});

// node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  module.exports = function isPathExcluded(projection, path) {
    if (projection == null) {
      return false;
    }
    if (path === "_id") {
      return projection._id === 0;
    }
    const paths = Object.keys(projection);
    let type = null;
    for (const _path of paths) {
      if (isDefiningProjection(projection[_path])) {
        type = projection[path] === 1 ? "inclusive" : "exclusive";
        break;
      }
    }
    if (type === "inclusive") {
      return projection[path] !== 1;
    }
    if (type === "exclusive") {
      return projection[path] === 0;
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js
var require_markArraySubdocsPopulated = __commonJS((exports, module) => {
  var utils = require_utils3();
  module.exports = function markArraySubdocsPopulated(doc, populated) {
    if (doc._doc._id == null || populated == null || populated.length === 0) {
      return;
    }
    const id = String(doc._doc._id);
    for (const item of populated) {
      if (item.isVirtual) {
        continue;
      }
      const path = item.path;
      const pieces = path.split(".");
      for (let i = 0;i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const rest = pieces.slice(i + 1).join(".");
        const val = doc.get(subpath);
        if (val == null) {
          continue;
        }
        if (utils.isMongooseDocumentArray(val)) {
          for (let j = 0;j < val.length; ++j) {
            if (val[j]) {
              val[j].populated(rest, item._docs[id] == null ? undefined : item._docs[id][j], item);
            }
          }
          break;
        }
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/minimize.js
var require_minimize = __commonJS((exports, module) => {
  var { isPOJO } = require_utils3();
  module.exports = minimize;
  function minimize(obj) {
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys;
    let key;
    let val;
    while (i--) {
      key = keys[i];
      val = obj[key];
      if (isPOJO(val)) {
        obj[key] = minimize(val);
      }
      if (obj[key] === undefined) {
        delete obj[key];
        continue;
      }
      hasKeys = true;
    }
    return hasKeys ? obj : undefined;
  }
});

// node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS((exports, module) => {
  var dotRE = /\./g;
  module.exports = function parentPaths(path) {
    if (path.indexOf(".") === -1) {
      return [path];
    }
    const pieces = path.split(dotRE);
    const len = pieces.length;
    const ret = new Array(len);
    let cur = "";
    for (let i = 0;i < len; ++i) {
      cur += cur.length !== 0 ? "." + pieces[i] : pieces[i];
      ret[i] = cur;
    }
    return ret;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS((exports, module) => {
  module.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
    const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path + "."), false);
    const _discriminatorKey = path + "." + schema.options.discriminatorKey;
    if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
      selected.splice(selected.indexOf(_discriminatorKey), 1);
    }
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS((exports, module) => {
  var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
  module.exports = function getDiscriminatorByValue(discriminators, value) {
    if (discriminators == null) {
      return null;
    }
    for (const name of Object.keys(discriminators)) {
      const it = discriminators[name];
      if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
        return it;
      }
    }
    return null;
  };
});

// node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function isPathSelectedInclusive(fields, path) {
    const chunks = path.split(".");
    let cur = "";
    let j;
    let keys;
    let numKeys;
    for (let i = 0;i < chunks.length; ++i) {
      cur += cur.length ? "." : "" + chunks[i];
      if (fields[cur]) {
        keys = Object.keys(fields);
        numKeys = keys.length;
        for (j = 0;j < numKeys; ++j) {
          if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
            continue;
          }
        }
        return true;
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/queryHelpers.js
var require_queryHelpers = __commonJS((exports) => {
  /*!
   * Module dependencies
   */
  var PopulateOptions = require_populateOptions();
  var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var isDefiningProjection = require_isDefiningProjection();
  var clone2 = require_clone();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
    const _populate = query._mongooseOptions.populate;
    const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
    if (options.lean != null) {
      pop.filter((p) => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
    }
    const session = query && query.options && query.options.session || null;
    if (session != null) {
      pop.forEach((path) => {
        if (path.options == null) {
          path.options = { session };
          return;
        }
        if (!("session" in path.options)) {
          path.options.session = session;
        }
      });
    }
    const projection = query._fieldsForExec();
    for (let i = 0;i < pop.length; ++i) {
      if (pop[i] instanceof PopulateOptions) {
        pop[i] = new PopulateOptions({
          ...pop[i],
          _queryProjection: projection,
          _localModel: query.model
        });
      } else {
        pop[i]._queryProjection = projection;
        pop[i]._localModel = query.model;
      }
    }
    return pop;
  };
  exports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
    model.hooks.execPreSync("createModel", doc);
    const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
    const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
    const value = doc[key];
    if (key && value && model.discriminators) {
      const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
      if (discriminator) {
        const _fields = clone2(userProvidedFields);
        exports.applyPaths(_fields, discriminator.schema);
        return new discriminator(undefined, _fields, true);
      }
    }
    const _opts = {
      skipId: true,
      isNew: false,
      willInit: true
    };
    if (options != null && "defaults" in options) {
      _opts.defaults = options.defaults;
    }
    return new model(undefined, fields, _opts);
  };
  /*!
   * ignore
   */
  exports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {
    const initOpts = populatedIds ? { populated: populatedIds } : undefined;
    const casted = exports.createModel(model, doc, fields, userProvidedFields, options);
    try {
      casted.$init(doc, initOpts, callback);
    } catch (error) {
      callback(error, casted);
    }
  };
  /*!
   * ignore
   */
  exports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {
    let exclude;
    let keys;
    const minusPathsToSkip = new Set;
    if (fields) {
      keys = Object.keys(fields);
      const minusPaths = [];
      for (let i = 0;i < keys.length; ++i) {
        const key = keys[i];
        if (keys[i][0] !== "-") {
          continue;
        }
        delete fields[key];
        if (key === "-_id") {
          fields["_id"] = 0;
        } else {
          minusPaths.push(key.slice(1));
        }
      }
      keys = Object.keys(fields);
      for (let keyIndex = 0;keyIndex < keys.length; ++keyIndex) {
        if (keys[keyIndex][0] === "+") {
          continue;
        }
        const field = fields[keys[keyIndex]];
        if (!isDefiningProjection(field)) {
          continue;
        }
        if (keys[keyIndex] === "_id" && keys.length > 1) {
          continue;
        }
        if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {
          continue;
        }
        exclude = !field;
        break;
      }
      for (const path of minusPaths) {
        const type = schema.path(path);
        if (!type || !type.selected || exclude !== false) {
          fields[path] = 0;
          exclude = true;
        } else if (type && type.selected && exclude === false) {
          minusPathsToSkip.add(path);
        }
      }
    }
    const selected = [];
    const excluded = [];
    const stack = [];
    analyzeSchema(schema);
    switch (exclude) {
      case true:
        for (const fieldName of excluded) {
          fields[fieldName] = 0;
        }
        break;
      case false:
        if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
          fields._id = 0;
        }
        for (const fieldName of selected) {
          if (minusPathsToSkip.has(fieldName)) {
            continue;
          }
          if (isPathSelectedInclusive(fields, fieldName)) {
            continue;
          }
          fields[fieldName] = fields[fieldName] || 1;
        }
        break;
      case undefined:
        if (fields == null) {
          break;
        }
        for (const key of Object.keys(fields || {})) {
          if (key.startsWith("+")) {
            delete fields[key];
          }
        }
        for (const fieldName of excluded) {
          if (fields[fieldName] != null) {
            continue;
          }
          fields[fieldName] = 0;
        }
        break;
    }
    function analyzeSchema(schema2, prefix) {
      prefix || (prefix = "");
      if (stack.indexOf(schema2) !== -1) {
        return [];
      }
      stack.push(schema2);
      const addedPaths = [];
      schema2.eachPath(function(path, type) {
        if (prefix)
          path = prefix + "." + path;
        if (type.$isSchemaMap || path.endsWith(".$*")) {
          const plusPath = "+" + path;
          const hasPlusPath = fields && plusPath in fields;
          if (type.options && type.options.select === false && !hasPlusPath) {
            excluded.push(path);
          }
          return;
        }
        let addedPath = analyzePath(path, type);
        if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
          addedPath = analyzePath(path, type.caster);
        }
        if (addedPath != null) {
          addedPaths.push(addedPath);
        }
        if (type.schema) {
          const _addedPaths = analyzeSchema(type.schema, path);
          if (exclude === false) {
            checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
          }
        }
      });
      stack.pop();
      return addedPaths;
    }
    function analyzePath(path, type) {
      if (fields == null) {
        return;
      }
      if (typeof type.selected !== "boolean") {
        return;
      }
      if (type.selected === false && fields[path]) {
        if (sanitizeProjection) {
          fields[path] = 0;
        }
        return;
      }
      if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {
        delete fields[path];
        return;
      }
      if (exclude === false && type.selected && fields[path] != null && !fields[path]) {
        delete fields[path];
        return;
      }
      const plusPath = "+" + path;
      const hasPlusPath = fields && plusPath in fields;
      if (hasPlusPath) {
        delete fields[plusPath];
        if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {
          fields[path] = 1;
        } else if (exclude == null && sanitizeProjection && type.selected === false) {
          fields[path] = 0;
        }
        return;
      }
      const pieces = path.split(".");
      let cur = "";
      for (let i = 0;i < pieces.length; ++i) {
        cur += cur.length ? "." + pieces[i] : pieces[i];
        if (excluded.indexOf(cur) !== -1) {
          return;
        }
      }
      if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {
        let cur2 = "";
        for (let i = 0;i < pieces.length; ++i) {
          cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
          const projection = get(fields, cur2, false) || get(fields, cur2 + ".$", false);
          if (projection && typeof projection !== "object") {
            return;
          }
        }
      }
      (type.selected ? selected : excluded).push(path);
      return path;
    }
  };
  function makeLean(val) {
    return function(option) {
      option.options || (option.options = {});
      if (val != null && Array.isArray(val.virtuals)) {
        val = Object.assign({}, val);
        val.virtuals = val.virtuals.filter((path) => typeof path === "string" && path.startsWith(option.path + ".")).map((path) => path.slice(option.path.length + 1));
      }
      option.options.lean = val;
    };
  }
});

// node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS((exports, module) => {
  function isPromise(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
  }
  module.exports = isPromise;
});

// node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js
var require_getDeepestSubdocumentForPath = __commonJS((exports, module) => {
  module.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {
    let curPath = parts[0];
    let curSchema = schema;
    let subdoc = doc;
    for (let i = 0;i < parts.length - 1; ++i) {
      const curSchemaType = curSchema.path(curPath);
      if (curSchemaType && curSchemaType.schema) {
        let newSubdoc = subdoc.get(curPath);
        curSchema = curSchemaType.schema;
        curPath = parts[i + 1];
        if (Array.isArray(newSubdoc) && !isNaN(curPath)) {
          newSubdoc = newSubdoc[curPath];
          curPath = "";
        }
        if (newSubdoc == null) {
          break;
        }
        subdoc = newSubdoc;
      } else {
        curPath += curPath.length ? "." + parts[i + 1] : parts[i + 1];
      }
    }
    return subdoc;
  };
});

// node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS((exports, module) => {
  var Document = require_document2();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var util3 = __require("util");
  var utils = require_utils3();
  module.exports = Subdocument;
  function Subdocument(value, fields, parent, skipId, options) {
    if (typeof skipId === "object" && skipId != null && options == null) {
      options = skipId;
      skipId = undefined;
    }
    if (parent != null) {
      const parentOptions = { isNew: parent.isNew };
      if ("defaults" in parent.$__) {
        parentOptions.defaults = parent.$__.defaults;
      }
      options = Object.assign(parentOptions, options);
    }
    if (options != null && options.path != null) {
      this.$basePath = options.path;
    }
    Document.call(this, value, fields, skipId, options);
    delete this.$__.priorDoc;
  }
  Subdocument.prototype = Object.create(Document.prototype);
  Object.defineProperty(Subdocument.prototype, "$isSubdocument", {
    configurable: false,
    writable: false,
    value: true
  });
  Object.defineProperty(Subdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: true
  });
  /*!
   * ignore
   */
  Subdocument.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  Subdocument.prototype.save = async function save(options) {
    options = options || {};
    if (!options.suppressWarning) {
      utils.warn("mongoose: calling `save()` on a subdoc does **not** save " + "the document to MongoDB, it only runs save middleware. " + "Use `subdoc.save({ suppressWarning: true })` to hide this warning " + "if you're sure this behavior is right for your app.");
    }
    return new Promise((resolve, reject) => {
      this.$__save((err2) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve(this);
      });
    });
  };
  Subdocument.prototype.$__fullPath = function(path) {
    if (!this.$__.fullPath) {
      this.ownerDocument();
    }
    return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
  };
  Subdocument.prototype.$__pathRelativeToParent = function(p) {
    if (p == null) {
      return this.$basePath;
    }
    return [this.$basePath, p].join(".");
  };
  Subdocument.prototype.$__save = function(fn) {
    return immediate(() => fn(null, this));
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$isValid = function(path) {
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      return parent.$isValid(fullPath);
    }
    return Document.prototype.$isValid.call(this, path);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.markModified = function(path) {
    Document.prototype.markModified.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent == null || fullPath == null) {
      return;
    }
    const myPath = this.$__pathRelativeToParent().replace(/\.$/, "");
    if (parent.isDirectModified(myPath) || this.isNew) {
      return;
    }
    this.$__parent.markModified(fullPath, this);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.isModified = function(paths, options, modifiedPaths) {
    const parent = this.$parent();
    if (parent != null) {
      if (Array.isArray(paths) || typeof paths === "string") {
        paths = Array.isArray(paths) ? paths : paths.split(" ");
        paths = paths.map((p) => this.$__pathRelativeToParent(p)).filter((p) => p != null);
      } else if (!paths) {
        paths = this.$__pathRelativeToParent();
      }
      return parent.$isModified(paths, options, modifiedPaths);
    }
    return Document.prototype.isModified.call(this, paths, options, modifiedPaths);
  };
  Subdocument.prototype.$markValid = function(path) {
    Document.prototype.$markValid.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.$markValid(fullPath);
    }
  };
  /*!
   * ignore
   */
  Subdocument.prototype.invalidate = function(path, err2, val) {
    Document.prototype.invalidate.call(this, path, err2, val);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.invalidate(fullPath, err2, val);
    } else if (err2.kind === "cast" || err2.name === "CastError" || fullPath == null) {
      throw err2;
    }
    return this.ownerDocument().$__.validationError;
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$ignore = function(path) {
    Document.prototype.$ignore.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.$ignore(fullPath);
    }
  };
  Subdocument.prototype.ownerDocument = function() {
    if (this.$__.ownerDocument) {
      return this.$__.ownerDocument;
    }
    let parent = this;
    const paths = [];
    const seenDocs = new Set([parent]);
    while (true) {
      if (typeof parent.$__pathRelativeToParent !== "function") {
        break;
      }
      paths.unshift(parent.$__pathRelativeToParent(undefined, true));
      const _parent = parent.$parent();
      if (_parent == null) {
        break;
      }
      parent = _parent;
      if (seenDocs.has(parent)) {
        throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
      }
      seenDocs.add(parent);
    }
    this.$__.fullPath = paths.join(".");
    this.$__.ownerDocument = parent;
    return this.$__.ownerDocument;
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$__fullPathWithIndexes = function() {
    let parent = this;
    const paths = [];
    const seenDocs = new Set([parent]);
    while (true) {
      if (typeof parent.$__pathRelativeToParent !== "function") {
        break;
      }
      paths.unshift(parent.$__pathRelativeToParent(undefined, false));
      const _parent = parent.$parent();
      if (_parent == null) {
        break;
      }
      parent = _parent;
      if (seenDocs.has(parent)) {
        throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
      }
      seenDocs.add(parent);
    }
    return paths.join(".");
  };
  Subdocument.prototype.parent = function() {
    return this.$__parent;
  };
  Subdocument.prototype.$parent = Subdocument.prototype.parent;
  Subdocument.prototype.$__deleteOne = function(cb) {
    if (cb == null) {
      return;
    }
    return cb(null, this);
  };
  Subdocument.prototype.$__removeFromParent = function() {
    this.$__parent.set(this.$basePath, null);
  };
  Subdocument.prototype.deleteOne = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    registerRemoveListener(this);
    if (!options || !options.noop) {
      this.$__removeFromParent();
      const owner = this.ownerDocument();
      owner.$__.removedSubdocs = owner.$__.removedSubdocs || [];
      owner.$__.removedSubdocs.push(this);
    }
    return this.$__deleteOne(callback);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.populate = function() {
    throw new Error("Mongoose does not support calling populate() on nested " + 'docs. Instead of `doc.nested.populate("path")`, use ' + '`doc.populate("nested.path")`');
  };
  Subdocument.prototype.inspect = function() {
    return this.toObject();
  };
  if (util3.inspect.custom) {
    Subdocument.prototype[util3.inspect.custom] = Subdocument.prototype.inspect;
  }
  Subdocument.prototype.$toObject = function $toObject(options, json) {
    const ret = Document.prototype.$toObject.call(this, options, json);
    if (Object.keys(ret).length === 0 && options?._calledWithOptions != null) {
      const minimize = options._calledWithOptions?.minimize ?? this?.$__schemaTypeOptions?.minimize ?? options.minimize;
      if (minimize && !this.constructor.$__required) {
        return;
      }
    }
    return ret;
  };
  function registerRemoveListener(sub) {
    const owner = sub.ownerDocument();
    function emitRemove() {
      owner.$removeListener("save", emitRemove);
      owner.$removeListener("deleteOne", emitRemove);
      sub.emit("deleteOne", sub);
      sub.constructor.emit("deleteOne", sub);
    }
    owner.$on("save", emitRemove);
    owner.$on("deleteOne", emitRemove);
  }
});

// node_modules/mongoose/lib/types/arraySubdocument.js
var require_arraySubdocument = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EventEmitter = __require("events").EventEmitter;
  var Subdocument = require_subdocument();
  var utils = require_utils3();
  var documentArrayParent = require_symbols().documentArrayParent;
  function ArraySubdocument(obj, parentArr, skipId, fields, index) {
    if (utils.isMongooseDocumentArray(parentArr)) {
      this.__parentArray = parentArr;
      this[documentArrayParent] = parentArr.$parent();
    } else {
      this.__parentArray = undefined;
      this[documentArrayParent] = undefined;
    }
    this.$setIndex(index);
    this.$__parent = this[documentArrayParent];
    let options;
    if (typeof skipId === "object" && skipId != null) {
      options = { isNew: true, ...skipId };
      skipId = undefined;
    } else {
      options = { isNew: true };
    }
    Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);
  }
  /*!
   * Inherit from Subdocument
   */
  ArraySubdocument.prototype = Object.create(Subdocument.prototype);
  ArraySubdocument.prototype.constructor = ArraySubdocument;
  Object.defineProperty(ArraySubdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: false
  });
  Object.defineProperty(ArraySubdocument.prototype, "$isDocumentArrayElement", {
    configurable: false,
    writable: false,
    value: true
  });
  for (const i in EventEmitter.prototype) {
    ArraySubdocument[i] = EventEmitter.prototype[i];
  }
  /*!
   * ignore
   */
  ArraySubdocument.prototype.$setIndex = function(index) {
    this.__index = index;
    if (this.$__ != null && this.$__.validationError != null) {
      const keys = Object.keys(this.$__.validationError.errors);
      for (const key of keys) {
        this.invalidate(key, this.$__.validationError.errors[key]);
      }
    }
  };
  /*!
   * ignore
   */
  ArraySubdocument.prototype.populate = function() {
    throw new Error("Mongoose does not support calling populate() on nested " + 'docs. Instead of `doc.arr[0].populate("path")`, use ' + '`doc.populate("arr.0.path")`');
  };
  /*!
   * ignore
   */
  ArraySubdocument.prototype.$__removeFromParent = function() {
    const _id = this._doc._id;
    if (!_id) {
      throw new Error("For your own good, Mongoose does not know " + "how to remove an ArraySubdocument that has no _id");
    }
    this.__parentArray.pull({ _id });
  };
  ArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {
    if (this.__index == null) {
      return null;
    }
    if (!this.$__.fullPath) {
      this.ownerDocument();
    }
    if (skipIndex) {
      return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    }
    return path ? this.$__.fullPath + "." + this.__index + "." + path : this.$__.fullPath + "." + this.__index;
  };
  ArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {
    if (this.__index == null || (!this.__parentArray || !this.__parentArray.$path)) {
      return null;
    }
    if (skipIndex) {
      return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + path;
    }
    if (path == null) {
      return this.__parentArray.$path() + "." + this.__index;
    }
    return this.__parentArray.$path() + "." + this.__index + "." + path;
  };
  ArraySubdocument.prototype.$parent = function() {
    return this[documentArrayParent];
  };
  ArraySubdocument.prototype.parentArray = function() {
    return this.__parentArray;
  };
  /*!
   * Module exports.
   */
  module.exports = ArraySubdocument;
});

// node_modules/mongoose/lib/types/array/methods/index.js
var require_methods = __commonJS((exports, module) => {
  var Document = require_document2();
  var ArraySubdocument = require_arraySubdocument();
  var MongooseError = require_mongooseError();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var clone2 = require_clone();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var mpath = require_mpath();
  var utils = require_utils3();
  var isBsonType = require_isBsonType();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var slicedSymbol = Symbol("mongoose#Array#sliced");
  var _basePush = Array.prototype.push;
  /*!
   * ignore
   */
  var methods = {
    $__getAtomics() {
      const ret = [];
      const keys = Object.keys(this[arrayAtomicsSymbol] || {});
      let i = keys.length;
      const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
      if (i === 0) {
        ret[0] = ["$set", this.toObject(opts)];
        return ret;
      }
      while (i--) {
        const op = keys[i];
        let val = this[arrayAtomicsSymbol][op];
        if (utils.isMongooseObject(val)) {
          val = val.toObject(opts);
        } else if (Array.isArray(val)) {
          val = this.toObject.call(val, opts);
        } else if (val != null && Array.isArray(val.$each)) {
          val.$each = this.toObject.call(val.$each, opts);
        } else if (val != null && typeof val.valueOf === "function") {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        ret.push([op, val]);
      }
      return ret;
    },
    $atomics() {
      /*!
         * ignore
         */
      return this[arrayAtomicsSymbol];
    },
    $parent() {
      /*!
         * ignore
         */
      return this[arrayParentSymbol];
    },
    $path() {
      /*!
         * ignore
         */
      return this[arrayPathSymbol];
    },
    $shift() {
      this._registerAtomic("$pop", -1);
      this._markModified();
      const __array = this.__array;
      if (__array._shifted) {
        return;
      }
      __array._shifted = true;
      return [].shift.call(__array);
    },
    $pop() {
      this._registerAtomic("$pop", 1);
      this._markModified();
      if (this._popped) {
        return;
      }
      this._popped = true;
      return [].pop.call(this);
    },
    $schema() {
      /*!
         * ignore
         */
      return this[arraySchemaSymbol];
    },
    _cast(value) {
      let populated = false;
      let Model;
      const parent = this[arrayParentSymbol];
      if (parent) {
        populated = parent.$populated(this[arrayPathSymbol], true);
      }
      if (populated && value !== null && value !== undefined) {
        Model = populated.options[populateModelSymbol];
        if (Model == null) {
          throw new MongooseError("No populated model found for path `" + this[arrayPathSymbol] + "`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.");
        }
        if (Buffer.isBuffer(value) || isBsonType(value, "ObjectId") || !utils.isObject(value)) {
          value = { _id: value };
        }
        const isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;
        if (!isDisc) {
          value = new Model(value);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, parent, true);
      }
      return this[arraySchemaSymbol].caster.applySetters(value, parent, false);
    },
    _mapCast(val, index) {
      return this._cast(val, this.length + index);
    },
    _markModified(elem) {
      const parent = this[arrayParentSymbol];
      let dirtyPath;
      if (parent) {
        dirtyPath = this[arrayPathSymbol];
        if (arguments.length) {
          dirtyPath = dirtyPath + "." + elem;
        }
        if (dirtyPath != null && dirtyPath.endsWith(".$")) {
          return this;
        }
        parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
      }
      return this;
    },
    _registerAtomic(op, val) {
      if (this[slicedSymbol]) {
        return;
      }
      if (op === "$set") {
        this[arrayAtomicsSymbol] = { $set: val };
        cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
        this._markModified();
        return this;
      }
      const atomics = this[arrayAtomicsSymbol];
      if (op === "$pop" && !("$pop" in atomics)) {
        const _this = this;
        this[arrayParentSymbol].once("save", function() {
          _this._popped = _this._shifted = null;
        });
      }
      if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {
        this[arrayAtomicsSymbol] = { $set: this };
        return this;
      }
      let selector;
      if (op === "$pullAll" || op === "$addToSet") {
        atomics[op] || (atomics[op] = []);
        atomics[op] = atomics[op].concat(val);
      } else if (op === "$pullDocs") {
        const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
        if (val[0] instanceof ArraySubdocument) {
          selector = pullOp["$or"] || (pullOp["$or"] = []);
          Array.prototype.push.apply(selector, val.map((v) => {
            return v.toObject({
              transform: (doc, ret) => {
                if (v == null || v.$__ == null) {
                  return ret;
                }
                Object.keys(v.$__.activePaths.getStatePaths("default")).forEach((path) => {
                  mpath.unset(path, ret);
                  _minimizePath(ret, path);
                });
                return ret;
              },
              virtuals: false
            });
          }));
        } else {
          selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
          selector["$in"] = selector["$in"].concat(val);
        }
      } else if (op === "$push") {
        atomics.$push = atomics.$push || { $each: [] };
        if (val != null && utils.hasUserDefinedProperty(val, "$each")) {
          atomics.$push = val;
        } else {
          if (val.length === 1) {
            atomics.$push.$each.push(val[0]);
          } else if (val.length < 1e4) {
            atomics.$push.$each.push(...val);
          } else {
            for (const v of val) {
              atomics.$push.$each.push(v);
            }
          }
        }
      } else {
        atomics[op] = val;
      }
      return this;
    },
    addToSet() {
      _checkManualPopulation(this, arguments);
      _depopulateIfNecessary(this, arguments);
      const values = [].map.call(arguments, this._mapCast, this);
      const added = [];
      let type = "";
      if (values[0] instanceof ArraySubdocument) {
        type = "doc";
      } else if (values[0] instanceof Date) {
        type = "date";
      } else if (isBsonType(values[0], "ObjectId")) {
        type = "ObjectId";
      }
      const rawValues = utils.isMongooseArray(values) ? values.__array : values;
      const rawArray = utils.isMongooseArray(this) ? this.__array : this;
      rawValues.forEach(function(v) {
        let found;
        const val = +v;
        switch (type) {
          case "doc":
            found = this.some(function(doc) {
              return doc.equals(v);
            });
            break;
          case "date":
            found = this.some(function(d) {
              return +d === val;
            });
            break;
          case "ObjectId":
            found = this.find((o) => o.toString() === v.toString());
            break;
          default:
            found = ~this.indexOf(v);
            break;
        }
        if (!found) {
          this._markModified();
          rawArray.push(v);
          this._registerAtomic("$addToSet", v);
          [].push.call(added, v);
        }
      }, this);
      return added;
    },
    hasAtomics() {
      if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
        return 0;
      }
      return Object.keys(this[arrayAtomicsSymbol]).length;
    },
    includes(obj, fromIndex) {
      const ret = this.indexOf(obj, fromIndex);
      return ret !== -1;
    },
    indexOf(obj, fromIndex) {
      if (isBsonType(obj, "ObjectId")) {
        obj = obj.toString();
      }
      fromIndex = fromIndex == null ? 0 : fromIndex;
      const len = this.length;
      for (let i = fromIndex;i < len; ++i) {
        if (obj == this[i]) {
          return i;
        }
      }
      return -1;
    },
    inspect() {
      return JSON.stringify(this);
    },
    nonAtomicPush() {
      const values = [].map.call(arguments, this._mapCast, this);
      this._markModified();
      const ret = [].push.apply(this, values);
      this._registerAtomic("$set", this);
      return ret;
    },
    pop() {
      this._markModified();
      const ret = [].pop.call(this);
      this._registerAtomic("$set", this);
      return ret;
    },
    pull() {
      const values = [].map.call(arguments, (v, i2) => this._cast(v, i2, { defaults: false }), this);
      let cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
      if (utils.isMongooseArray(cur)) {
        cur = cur.__array;
      }
      let i = cur.length;
      let mem;
      this._markModified();
      while (i--) {
        mem = cur[i];
        if (mem instanceof Document) {
          const some = values.some(function(v) {
            return mem.equals(v);
          });
          if (some) {
            cur.splice(i, 1);
          }
        } else if (~this.indexOf.call(values, mem)) {
          cur.splice(i, 1);
        }
      }
      if (values[0] instanceof ArraySubdocument) {
        this._registerAtomic("$pullDocs", values.map(function(v) {
          const _id = v.$__getValue("_id");
          if (_id === undefined || v.$isDefault("_id")) {
            return v;
          }
          return _id;
        }));
      } else {
        this._registerAtomic("$pullAll", values);
      }
      if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
        this._registerAtomic("$set", this);
      }
      return this;
    },
    push() {
      let values = arguments;
      let atomic = values;
      const isOverwrite = values[0] != null && utils.hasUserDefinedProperty(values[0], "$each");
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      if (isOverwrite) {
        atomic = values[0];
        values = values[0].$each;
      }
      if (this[arraySchemaSymbol] == null) {
        return _basePush.apply(this, values);
      }
      _checkManualPopulation(this, values);
      _depopulateIfNecessary(this, values);
      values = [].map.call(values, this._mapCast, this);
      let ret;
      const atomics = this[arrayAtomicsSymbol];
      this._markModified();
      if (isOverwrite) {
        atomic.$each = values;
        if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != atomic.$position) {
          if (atomic.$position != null) {
            [].splice.apply(arr, [atomic.$position, 0].concat(values));
            ret = arr.length;
          } else {
            ret = [].push.apply(arr, values);
          }
          this._registerAtomic("$set", this);
        } else if (atomic.$position != null) {
          [].splice.apply(arr, [atomic.$position, 0].concat(values));
          ret = this.length;
        } else {
          ret = [].push.apply(arr, values);
        }
      } else {
        atomic = values;
        ret = _basePush.apply(arr, values);
      }
      this._registerAtomic("$push", atomic);
      return ret;
    },
    remove() {
      return this.pull.apply(this, arguments);
    },
    set(i, val, skipModified) {
      const arr = this.__array;
      if (skipModified) {
        arr[i] = val;
        return this;
      }
      const value = methods._cast.call(this, val, i);
      methods._markModified.call(this, i);
      arr[i] = value;
      return this;
    },
    shift() {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      const ret = [].shift.call(arr);
      this._registerAtomic("$set", this);
      return ret;
    },
    sort() {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      const ret = [].sort.apply(arr, arguments);
      this._registerAtomic("$set", this);
      return ret;
    },
    splice() {
      let ret;
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
      if (arguments.length) {
        let vals;
        if (this[arraySchemaSymbol] == null) {
          vals = arguments;
        } else {
          vals = [];
          for (let i = 0;i < arguments.length; ++i) {
            vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
          }
        }
        ret = [].splice.apply(arr, vals);
        this._registerAtomic("$set", this);
      }
      return ret;
    },
    toBSON() {
      /*!
         * ignore
         */
      return this.toObject(internalToObjectOptions);
    },
    toObject(options) {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      if (options && options.depopulate) {
        options = clone2(options);
        options._isNested = true;
        return [].concat(arr).map(function(doc) {
          return doc instanceof Document ? doc.toObject(options) : doc;
        });
      }
      return [].concat(arr);
    },
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    },
    unshift() {
      _checkManualPopulation(this, arguments);
      let values;
      if (this[arraySchemaSymbol] == null) {
        values = arguments;
      } else {
        values = [].map.call(arguments, this._cast, this);
      }
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      [].unshift.apply(arr, values);
      this._registerAtomic("$set", this);
      return this.length;
    }
  };
  /*!
   * ignore
   */
  function _isAllSubdocs(docs, ref) {
    if (!ref) {
      return false;
    }
    for (const arg of docs) {
      if (arg == null) {
        return false;
      }
      const model = arg.constructor;
      if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {
        return false;
      }
    }
    return true;
  }
  /*!
   * Minimize _just_ empty objects along the path chain specified
   * by `parts`, ignoring all other paths. Useful in cases where
   * you want to minimize after unsetting a path.
   *
   * #### Example:
   *
   *     const obj = { foo: { bar: { baz: {} } }, a: {} };
   *     _minimizePath(obj, 'foo.bar.baz');
   *     obj; // { a: {} }
   */
  function _minimizePath(obj, parts, i) {
    if (typeof parts === "string") {
      if (parts.indexOf(".") === -1) {
        return;
      }
      parts = mpath.stringToParts(parts);
    }
    i = i || 0;
    if (i >= parts.length) {
      return;
    }
    if (obj == null || typeof obj !== "object") {
      return;
    }
    _minimizePath(obj[parts[0]], parts, i + 1);
    if (obj[parts[0]] != null && typeof obj[parts[0]] === "object" && Object.keys(obj[parts[0]]).length === 0) {
      delete obj[parts[0]];
    }
  }
  /*!
   * ignore
   */
  function _checkManualPopulation(arr, docs) {
    const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
    if (arr.length === 0 && docs.length !== 0) {
      if (_isAllSubdocs(docs, ref)) {
        arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {
          [populateModelSymbol]: docs[0].constructor
        });
      }
    }
  }
  /*!
   * If `docs` isn't all instances of the right model, depopulate `arr`
   */
  function _depopulateIfNecessary(arr, docs) {
    const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
    const parentDoc = arr[arrayParentSymbol];
    const path = arr[arrayPathSymbol];
    if (!ref || !parentDoc.populated(path)) {
      return;
    }
    for (const doc of docs) {
      if (doc == null) {
        continue;
      }
      if (typeof doc !== "object" || doc instanceof String || doc instanceof Number || doc instanceof Buffer || utils.isMongooseType(doc)) {
        parentDoc.depopulate(path);
        break;
      }
    }
  }
  var returnVanillaArrayMethods = [
    "filter",
    "flat",
    "flatMap",
    "map",
    "slice"
  ];
  for (const method of returnVanillaArrayMethods) {
    if (Array.prototype[method] == null) {
      continue;
    }
    methods[method] = function() {
      const _arr = utils.isMongooseArray(this) ? this.__array : this;
      const arr = [].concat(_arr);
      return arr[method].apply(arr, arguments);
    };
  }
  module.exports = methods;
});

// node_modules/mongoose/lib/types/array/index.js
var require_array = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var mongooseArrayMethods = require_methods();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var _basePush = Array.prototype.push;
  var numberRE = /^\d+$/;
  function MongooseArray(values, path, doc, schematype) {
    let __array;
    if (Array.isArray(values)) {
      const len = values.length;
      if (len === 0) {
        __array = new Array;
      } else if (len === 1) {
        __array = new Array(1);
        __array[0] = values[0];
      } else if (len < 1e4) {
        __array = new Array;
        _basePush.apply(__array, values);
      } else {
        __array = new Array;
        for (let i = 0;i < len; ++i) {
          _basePush.call(__array, values[i]);
        }
      }
    } else {
      __array = [];
    }
    const internals = {
      [arrayAtomicsSymbol]: {},
      [arrayAtomicsBackupSymbol]: undefined,
      [arrayPathSymbol]: path,
      [arraySchemaSymbol]: schematype,
      [arrayParentSymbol]: undefined,
      isMongooseArray: true,
      isMongooseArrayProxy: true,
      __array
    };
    if (values && values[arrayAtomicsSymbol] != null) {
      internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
    }
    if (doc != null && doc.$__) {
      internals[arrayParentSymbol] = doc;
      internals[arraySchemaSymbol] = schematype || doc.schema.path(path);
    }
    const proxy = new Proxy(__array, {
      get: function(target, prop) {
        if (internals.hasOwnProperty(prop)) {
          return internals[prop];
        }
        if (mongooseArrayMethods.hasOwnProperty(prop)) {
          return mongooseArrayMethods[prop];
        }
        if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          return schematype.virtuals[prop].applyGetters(undefined, target);
        }
        if (typeof prop === "string" && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {
          return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);
        }
        return __array[prop];
      },
      set: function(target, prop, value) {
        if (typeof prop === "string" && numberRE.test(prop)) {
          mongooseArrayMethods.set.call(proxy, prop, value, false);
        } else if (internals.hasOwnProperty(prop)) {
          internals[prop] = value;
        } else if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          schematype.virtuals[prop].applySetters(value, target);
        } else {
          __array[prop] = value;
        }
        return true;
      }
    });
    return proxy;
  }
  /*!
   * Module exports.
   */
  module.exports = exports = MongooseArray;
});

// node_modules/mongoose/lib/cast/objectid.js
var require_objectid2 = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  var ObjectId2 = require_objectid();
  module.exports = function castObjectId(value) {
    if (value == null) {
      return value;
    }
    if (isBsonType(value, "ObjectId")) {
      return value;
    }
    if (value._id) {
      if (isBsonType(value._id, "ObjectId")) {
        return value._id;
      }
      if (value._id.toString instanceof Function) {
        return new ObjectId2(value._id.toString());
      }
    }
    if (value.toString instanceof Function) {
      return new ObjectId2(value.toString());
    }
    return new ObjectId2(value);
  };
});

// node_modules/mongoose/lib/types/documentArray/methods/index.js
var require_methods2 = __commonJS((exports, module) => {
  var ArrayMethods = require_methods();
  var Document = require_document2();
  var castObjectId = require_objectid2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var utils = require_utils3();
  var isBsonType = require_isBsonType();
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var _baseToString = Array.prototype.toString;
  var methods = {
    toBSON() {
      /*!
         * ignore
         */
      return this.toObject(internalToObjectOptions);
    },
    toString() {
      return _baseToString.call(this.__array.map((subdoc) => {
        if (subdoc != null && subdoc.$__ != null) {
          return subdoc.toString();
        }
        return subdoc;
      }));
    },
    getArrayParent() {
      /*!
         * ignore
         */
      return this[arrayParentSymbol];
    },
    _cast(value, index, options) {
      if (this[arraySchemaSymbol] == null) {
        return value;
      }
      let Constructor2 = this[arraySchemaSymbol].casterConstructor;
      const isInstance = Constructor2.$isMongooseDocumentArray ? utils.isMongooseDocumentArray(value) : value instanceof Constructor2;
      if (isInstance || value && value.constructor && value.constructor.baseCasterConstructor === Constructor2) {
        if (!(value[documentArrayParent] && value.__parentArray)) {
          value[documentArrayParent] = this[arrayParentSymbol];
          value.__parentArray = this;
        }
        value.$setIndex(index);
        return value;
      }
      if (value === undefined || value === null) {
        return null;
      }
      if (Buffer.isBuffer(value) || isBsonType(value, "ObjectId") || !utils.isObject(value)) {
        value = { _id: value };
      }
      if (value && Constructor2.discriminators && Constructor2.schema && Constructor2.schema.options && Constructor2.schema.options.discriminatorKey) {
        if (typeof value[Constructor2.schema.options.discriminatorKey] === "string" && Constructor2.discriminators[value[Constructor2.schema.options.discriminatorKey]]) {
          Constructor2 = Constructor2.discriminators[value[Constructor2.schema.options.discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor2.discriminators, value[Constructor2.schema.options.discriminatorKey]);
          if (constructorByValue) {
            Constructor2 = constructorByValue;
          }
        }
      }
      if (Constructor2.$isMongooseDocumentArray) {
        return Constructor2.cast(value, this, undefined, undefined, index);
      }
      const ret = new Constructor2(value, this, options, undefined, index);
      ret.isNew = true;
      return ret;
    },
    id(id) {
      let casted;
      let sid;
      let _id;
      try {
        casted = castObjectId(id).toString();
      } catch (e) {
        casted = null;
      }
      for (const val of this) {
        if (!val) {
          continue;
        }
        _id = val.get("_id");
        if (_id === null || typeof _id === "undefined") {
          continue;
        } else if (_id instanceof Document) {
          sid || (sid = String(id));
          if (sid == _id._id) {
            return val;
          }
        } else if (!isBsonType(id, "ObjectId") && !isBsonType(_id, "ObjectId")) {
          if (id == _id || utils.deepEqual(id, _id)) {
            return val;
          }
        } else if (casted == _id) {
          return val;
        }
      }
      return null;
    },
    toObject(options) {
      return [].concat(this.map(function(doc) {
        if (doc == null) {
          return null;
        }
        if (typeof doc.toObject !== "function") {
          return doc;
        }
        return doc.toObject(options);
      }));
    },
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    },
    push() {
      const ret = ArrayMethods.push.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    pull() {
      const ret = ArrayMethods.pull.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    shift() {
      const ret = ArrayMethods.shift.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    splice() {
      const ret = ArrayMethods.splice.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    inspect() {
      return this.toObject();
    },
    create(obj) {
      let Constructor2 = this[arraySchemaSymbol].casterConstructor;
      if (obj && Constructor2.discriminators && Constructor2.schema && Constructor2.schema.options && Constructor2.schema.options.discriminatorKey) {
        if (typeof obj[Constructor2.schema.options.discriminatorKey] === "string" && Constructor2.discriminators[obj[Constructor2.schema.options.discriminatorKey]]) {
          Constructor2 = Constructor2.discriminators[obj[Constructor2.schema.options.discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor2.discriminators, obj[Constructor2.schema.options.discriminatorKey]);
          if (constructorByValue) {
            Constructor2 = constructorByValue;
          }
        }
      }
      return new Constructor2(obj, this);
    },
    notify(event) {
      /*!
         * ignore
         */
      const _this = this;
      return function notify(val, _arr) {
        _arr = _arr || _this;
        let i = _arr.length;
        while (i--) {
          if (_arr[i] == null) {
            continue;
          }
          switch (event) {
            case "save":
              val = _this[i];
              break;
            default:
              break;
          }
          if (utils.isMongooseArray(_arr[i])) {
            notify(val, _arr[i]);
          } else if (_arr[i]) {
            _arr[i].emit(event, val);
          }
        }
      };
    },
    set(i, val, skipModified) {
      const arr = this.__array;
      if (skipModified) {
        arr[i] = val;
        return this;
      }
      const value = methods._cast.call(this, val, i);
      methods._markModified.call(this, i);
      arr[i] = value;
      return this;
    },
    _markModified(elem, embeddedPath) {
      const parent = this[arrayParentSymbol];
      let dirtyPath;
      if (parent) {
        dirtyPath = this[arrayPathSymbol];
        if (arguments.length) {
          if (embeddedPath != null) {
            const index = elem.__index;
            dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
          } else {
            dirtyPath = dirtyPath + "." + elem;
          }
        }
        if (dirtyPath != null && dirtyPath.endsWith(".$")) {
          return this;
        }
        parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
      }
      return this;
    }
  };
  module.exports = methods;
  function _updateParentPopulated(arr) {
    const parent = arr[arrayParentSymbol];
    if (!parent || parent.$__.populated == null)
      return;
    const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
    for (const path of populatedPaths) {
      const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
      if (!Array.isArray(parent.$__.populated[path].value)) {
        continue;
      }
      parent.$__.populated[path].value = arr.map((val) => val.$populated(remnant));
    }
  }
});

// node_modules/mongoose/lib/types/documentArray/index.js
var require_documentArray = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var ArrayMethods = require_methods();
  var DocumentArrayMethods = require_methods2();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var _basePush = Array.prototype.push;
  var numberRE = /^\d+$/;
  function MongooseDocumentArray(values, path, doc, schematype) {
    const __array = [];
    const internals = {
      [arrayAtomicsSymbol]: {},
      [arrayAtomicsBackupSymbol]: undefined,
      [arrayPathSymbol]: path,
      [arraySchemaSymbol]: undefined,
      [arrayParentSymbol]: undefined
    };
    if (Array.isArray(values)) {
      if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
        internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
      }
      values.forEach((v) => {
        _basePush.call(__array, v);
      });
    }
    internals[arrayPathSymbol] = path;
    internals.__array = __array;
    if (doc && doc.$__) {
      internals[arrayParentSymbol] = doc;
      internals[arraySchemaSymbol] = doc.$__schema.path(path);
      while (internals[arraySchemaSymbol] != null && internals[arraySchemaSymbol].$isMongooseArray && !internals[arraySchemaSymbol].$isMongooseDocumentArray) {
        internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;
      }
    }
    const proxy = new Proxy(__array, {
      get: function(target, prop) {
        if (prop === "isMongooseArray" || prop === "isMongooseArrayProxy" || prop === "isMongooseDocumentArray" || prop === "isMongooseDocumentArrayProxy") {
          return true;
        }
        if (internals.hasOwnProperty(prop)) {
          return internals[prop];
        }
        if (DocumentArrayMethods.hasOwnProperty(prop)) {
          return DocumentArrayMethods[prop];
        }
        if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          return schematype.virtuals[prop].applyGetters(undefined, target);
        }
        if (ArrayMethods.hasOwnProperty(prop)) {
          return ArrayMethods[prop];
        }
        return __array[prop];
      },
      set: function(target, prop, value) {
        if (typeof prop === "string" && numberRE.test(prop)) {
          DocumentArrayMethods.set.call(proxy, prop, value, false);
        } else if (internals.hasOwnProperty(prop)) {
          internals[prop] = value;
        } else if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          schematype.virtuals[prop].applySetters(value, target);
        } else {
          __array[prop] = value;
        }
        return true;
      }
    });
    return proxy;
  }
  /*!
   * Module exports.
   */
  module.exports = MongooseDocumentArray;
});

// node_modules/mongoose/lib/document.js
var require_document2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var DivergentArrayError = require_divergentArray();
  var EventEmitter = __require("events").EventEmitter;
  var InternalCache = require_internal();
  var MongooseBuffer = require_buffer();
  var MongooseError = require_error2();
  var MixedSchema = require_mixed();
  var ModifiedPathsSnapshot = require_modifiedPathsSnapshot();
  var ObjectExpectedError = require_objectExpected();
  var ObjectParameterError = require_objectParameter();
  var ParallelValidateError = require_parallelValidate();
  var Schema = require_schema2();
  var StrictModeError = require_strict();
  var ValidationError2 = require_validation();
  var ValidatorError = require_validator();
  var $__hasIncludedChildren = require_hasIncludedChildren();
  var applyDefaults = require_applyDefaults();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var clone2 = require_clone();
  var compile2 = require_compile().compile;
  var defineKey = require_compile().defineKey;
  var firstKey = require_firstKey();
  var flatten = require_common4().flatten;
  var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
  var getKeysInSchemaOrder = require_getKeysInSchemaOrder();
  var getSubdocumentStrictValue = require_getSubdocumentStrictValue();
  var handleSpreadDoc = require_handleSpreadDoc();
  var immediate = require_immediate();
  var isBsonType = require_isBsonType();
  var isDefiningProjection = require_isDefiningProjection();
  var isExclusive = require_isExclusive();
  var isPathExcluded = require_isPathExcluded();
  var inspect = __require("util").inspect;
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
  var minimize = require_minimize();
  var mpath = require_mpath();
  var parentPaths = require_parentPaths();
  var queryhelpers = require_queryHelpers();
  var utils = require_utils3();
  var isPromise = require_isPromise();
  var deepEqual = utils.deepEqual;
  var isMongooseObject = utils.isMongooseObject;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var documentIsModified = require_symbols().documentIsModified;
  var documentModifiedPaths = require_symbols().documentModifiedPaths;
  var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
  var getSymbol = require_symbols().getSymbol;
  var modelSymbol = require_symbols().modelSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var scopeSymbol = require_symbols().scopeSymbol;
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var getDeepestSubdocumentForPath = require_getDeepestSubdocumentForPath();
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var DocumentArray;
  var MongooseArray;
  var Embedded;
  var specialProperties = utils.specialProperties;
  var VERSION_WHERE = 1;
  var VERSION_INC = 2;
  var VERSION_ALL = VERSION_WHERE | VERSION_INC;
  function Document(obj, fields, skipId, options) {
    if (typeof skipId === "object" && skipId != null) {
      options = skipId;
      skipId = options.skipId;
    }
    options = Object.assign({}, options);
    if (this.$__schema == null) {
      const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;
      this.$__setSchema(_schema);
      fields = skipId;
      skipId = options;
      options = arguments[4] || {};
    }
    this.$__ = new InternalCache;
    if (options.isNew != null && options.isNew !== true) {
      this.$isNew = options.isNew;
    }
    if (options.priorDoc != null) {
      this.$__.priorDoc = options.priorDoc;
    }
    if (skipId) {
      this.$__.skipId = skipId;
    }
    if (obj != null && typeof obj !== "object") {
      throw new ObjectParameterError(obj, "obj", "Document");
    }
    let defaults = true;
    if (options.defaults !== undefined) {
      this.$__.defaults = options.defaults;
      defaults = options.defaults;
    }
    const schema = this.$__schema;
    if (typeof fields === "boolean" || fields === "throw") {
      if (fields !== true) {
        this.$__.strictMode = fields;
      }
      fields = undefined;
    } else if (schema.options.strict !== true) {
      this.$__.strictMode = schema.options.strict;
    }
    const requiredPaths = schema.requiredPaths(true);
    for (const path of requiredPaths) {
      this.$__.activePaths.require(path);
    }
    let exclude = null;
    if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {
      exclude = isExclusive(fields);
      this.$__.selected = fields;
      this.$__.exclude = exclude;
    }
    const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;
    if (this._doc == null) {
      this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
      if (defaults) {
        applyDefaults(this, fields, exclude, hasIncludedChildren, true, null, {
          skipParentChangeTracking: true
        });
      }
    }
    if (obj) {
      if (this.$__original_set) {
        this.$__original_set(obj, undefined, true, options);
      } else {
        this.$set(obj, undefined, true, options);
      }
      if (obj instanceof Document) {
        this.$isNew = obj.$isNew;
      }
    }
    if (options.willInit && defaults) {
      if (options.skipDefaults) {
        this.$__.skipDefaults = options.skipDefaults;
      }
    } else if (defaults) {
      applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);
    }
    if (!this.$__.strictMode && obj) {
      const _this = this;
      const keys = Object.keys(this._doc);
      keys.forEach(function(key) {
        if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith("$")) {
          defineKey({ prop: key, subprops: null, prototype: _this });
        }
      });
    }
    applyQueue(this);
  }
  Document.prototype.$isMongooseDocumentPrototype = true;
  Object.defineProperty(Document.prototype, "isNew", {
    get: function() {
      return this.$isNew;
    },
    set: function(value) {
      this.$isNew = value;
    }
  });
  Object.defineProperty(Document.prototype, "errors", {
    get: function() {
      return this.$errors;
    },
    set: function(value) {
      this.$errors = value;
    }
  });
  /*!
   * ignore
   */
  Document.prototype.$isNew = true;
  /*!
   * Document exposes the NodeJS event emitter API, so you can use
   * `on`, `once`, etc.
   */
  utils.each([
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
  ], function(emitterFn) {
    Document.prototype[emitterFn] = function() {
      if (!this.$__.emitter) {
        if (emitterFn === "emit") {
          return;
        }
        this.$__.emitter = new EventEmitter;
        this.$__.emitter.setMaxListeners(0);
      }
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];
  });
  Document.prototype.constructor = Document;
  for (const i in EventEmitter.prototype) {
    Document[i] = EventEmitter.prototype[i];
  }
  Document.prototype.$__schema;
  Document.prototype.schema;
  Object.defineProperty(Document.prototype, "$locals", {
    configurable: false,
    enumerable: false,
    get: function() {
      if (this.$__.locals == null) {
        this.$__.locals = {};
      }
      return this.$__.locals;
    },
    set: function(v) {
      this.$__.locals = v;
    }
  });
  Document.prototype.isNew;
  Object.defineProperty(Document.prototype, "$where", {
    configurable: false,
    enumerable: false,
    writable: true
  });
  Document.prototype.id;
  Document.prototype.$errors;
  Object.defineProperty(Document.prototype, "$op", {
    get: function() {
      return this.$__.op || null;
    },
    set: function(value) {
      this.$__.op = value;
    }
  });
  /*!
   * ignore
   */
  function $applyDefaultsToNested(val, path, doc) {
    if (val == null) {
      return;
    }
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    const pathPieces = path.indexOf(".") === -1 ? [path] : path.split(".");
    for (let i = 0;i < plen; ++i) {
      let curPath = "";
      const p = paths[i];
      if (!p.startsWith(path + ".")) {
        continue;
      }
      const type = doc.$__schema.paths[p];
      const pieces = type.splitPath().slice(pathPieces.length);
      const len = pieces.length;
      if (type.defaultValue === undefined) {
        continue;
      }
      let cur = val;
      for (let j = 0;j < len; ++j) {
        if (cur == null) {
          break;
        }
        const piece = pieces[j];
        if (j === len - 1) {
          if (cur[piece] !== undefined) {
            break;
          }
          try {
            const def = type.getDefault(doc, false);
            if (def !== undefined) {
              cur[piece] = def;
            }
          } catch (err2) {
            doc.invalidate(path + "." + curPath, err2);
            break;
          }
          break;
        }
        curPath += (!curPath.length ? "" : ".") + piece;
        cur[piece] = cur[piece] || {};
        cur = cur[piece];
      }
    }
  }
  Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
    const doc = {};
    const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
    const plen = paths.length;
    let ii = 0;
    for (;ii < plen; ++ii) {
      const p = paths[ii];
      if (p === "_id") {
        if (skipId) {
          continue;
        }
        if (obj && "_id" in obj) {
          continue;
        }
      }
      const path = this.$__schema.paths[p].splitPath();
      const len = path.length;
      const last = len - 1;
      let curPath = "";
      let doc_ = doc;
      let included = false;
      for (let i = 0;i < len; ++i) {
        const piece = path[i];
        if (!curPath.length) {
          curPath = piece;
        } else {
          curPath += "." + piece;
        }
        if (exclude === true) {
          if (curPath in fields) {
            break;
          }
        } else if (exclude === false && fields && !included) {
          if (curPath in fields) {
            included = true;
          } else if (!hasIncludedChildren[curPath]) {
            break;
          }
        }
        if (i < last) {
          doc_ = doc_[piece] || (doc_[piece] = {});
        }
      }
    }
    this._doc = doc;
  };
  /*!
   * Converts to POJO when you use the document for querying
   */
  Document.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  Document.prototype.init = function(doc, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = null;
    }
    this.$__init(doc, opts);
    if (fn) {
      fn(null, this);
    }
    return this;
  };
  Document.prototype.$init = function() {
    return this.constructor.prototype.init.apply(this, arguments);
  };
  Document.prototype.$__init = function(doc, opts) {
    this.$isNew = false;
    opts = opts || {};
    if (doc._id != null && opts.populated && opts.populated.length) {
      const id = String(doc._id);
      for (const item of opts.populated) {
        if (item.isVirtual) {
          this.$populated(item.path, utils.getValue(item.path, doc), item);
        } else {
          this.$populated(item.path, item._docs[id], item);
        }
        if (item._childDocs == null) {
          continue;
        }
        for (const child of item._childDocs) {
          if (child == null || child.$__ == null) {
            continue;
          }
          child.$__.parent = this;
        }
        item._childDocs = [];
      }
    }
    init(this, doc, this._doc, opts);
    markArraySubdocsPopulated(this, opts.populated);
    this.$emit("init", this);
    this.constructor.emit("init", this);
    const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ? $__hasIncludedChildren(this.$__.selected) : null;
    applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);
    return this;
  };
  function init(self2, obj, doc, opts, prefix) {
    prefix = prefix || "";
    if (obj.$__ != null) {
      obj = obj._doc;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    let schemaType;
    let path;
    let i;
    const strict = self2.$__.strictMode;
    const docSchema = self2.$__schema;
    for (let index = 0;index < len; ++index) {
      i = keys[index];
      if (specialProperties.has(i)) {
        continue;
      }
      path = prefix ? prefix + i : i;
      schemaType = docSchema.path(path);
      if (docSchema.$isRootDiscriminator && !self2.$__isSelected(path)) {
        continue;
      }
      const value = obj[i];
      if (!schemaType && utils.isPOJO(value)) {
        if (!doc[i]) {
          doc[i] = {};
          if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {
            self2[i] = doc[i];
          }
        }
        init(self2, value, doc[i], opts, path + ".");
      } else if (!schemaType) {
        doc[i] = value;
        if (!strict && !prefix) {
          self2[i] = value;
        }
      } else {
        if (doc.hasOwnProperty(i) && value !== undefined && !opts.hydratedPopulatedDocs) {
          delete doc[i];
        }
        if (value === null) {
          doc[i] = schemaType._castNullish(null);
        } else if (value !== undefined) {
          const wasPopulated = value.$__ == null ? null : value.$__.wasPopulated;
          if (schemaType && !wasPopulated && !opts.hydratedPopulatedDocs) {
            try {
              if (opts && opts.setters) {
                const overrideInit = false;
                doc[i] = schemaType.applySetters(value, self2, overrideInit);
              } else {
                doc[i] = schemaType.cast(value, self2, true);
              }
            } catch (e) {
              self2.invalidate(e.path, new ValidatorError({
                path: e.path,
                message: e.message,
                type: "cast",
                value: e.value,
                reason: e
              }));
            }
          } else if (schemaType && opts.hydratedPopulatedDocs) {
            doc[i] = schemaType.cast(value, self2, true, undefined, { hydratedPopulatedDocs: true });
            if (doc[i] && doc[i].$__ && doc[i].$__.wasPopulated) {
              self2.$populated(path, doc[i].$__.wasPopulated.value, doc[i].$__.wasPopulated.options);
            } else if (Array.isArray(doc[i]) && doc[i].length && doc[i][0]?.$__?.wasPopulated) {
              self2.$populated(path, doc[i].map((populatedDoc) => populatedDoc?.$__?.wasPopulated?.value).filter((val) => val != null), doc[i][0].$__.wasPopulated.options);
            }
          } else {
            doc[i] = value;
          }
        }
        if (!self2.$isModified(path)) {
          self2.$__.activePaths.init(path);
        }
      }
    }
  }
  Document.prototype.updateOne = function updateOne(doc, options, callback) {
    const query = this.constructor.updateOne({ _id: this._doc._id }, doc, options);
    const self2 = this;
    query.pre(function queryPreUpdateOne(cb) {
      self2.constructor._middleware.execPre("updateOne", self2, [self2], cb);
    });
    query.post(function queryPostUpdateOne(cb) {
      self2.constructor._middleware.execPost("updateOne", self2, [self2], {}, cb);
    });
    if (this.$session() != null) {
      if (!("session" in query.options)) {
        query.options.session = this.$session();
      }
    }
    if (callback != null) {
      return query.exec(callback);
    }
    return query;
  };
  Document.prototype.replaceOne = function replaceOne() {
    const args = [...arguments];
    args.unshift({ _id: this._doc._id });
    return this.constructor.replaceOne.apply(this.constructor, args);
  };
  Document.prototype.$session = function $session(session) {
    if (arguments.length === 0) {
      if (this.$__.session != null && this.$__.session.hasEnded) {
        this.$__.session = null;
        return null;
      }
      return this.$__.session;
    }
    if (session != null && session.hasEnded) {
      throw new MongooseError("Cannot set a document's session to a session that has ended. Make sure you haven't " + "called `endSession()` on the session you are passing to `$session()`.");
    }
    if (session == null && this.$__.session == null) {
      return;
    }
    this.$__.session = session;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        child.$session(session);
      }
    }
    return session;
  };
  Document.prototype.$timestamps = function $timestamps(value) {
    if (arguments.length === 0) {
      if (this.$__.timestamps != null) {
        return this.$__.timestamps;
      }
      if (this.$__schema) {
        return this.$__schema.options.timestamps;
      }
      return;
    }
    const currentValue = this.$timestamps();
    if (value !== currentValue) {
      this.$__.timestamps = value;
    }
    return this;
  };
  Document.prototype.overwrite = function overwrite(obj) {
    const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
    for (const key of keys) {
      if (key === "_id") {
        continue;
      }
      if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
        continue;
      }
      if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
        continue;
      }
      this.$set(key, obj[key]);
    }
    return this;
  };
  Document.prototype.$set = function $set(path, val, type, options) {
    if (utils.isPOJO(type)) {
      options = type;
      type = undefined;
    }
    const merge = options && options.merge;
    const adhoc = type && type !== true;
    const constructing = type === true;
    let adhocs;
    let keys;
    let i = 0;
    let pathtype;
    let key;
    let prefix;
    const userSpecifiedStrict = options && "strict" in options;
    let strict = userSpecifiedStrict ? options.strict : this.$__.strictMode;
    if (adhoc) {
      adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
      adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    if (path == null) {
      [path, val] = [val, path];
    } else if (typeof path !== "string") {
      if (path instanceof Document) {
        if (path.$__isNested) {
          path = path.toObject();
        } else {
          path = path.$__schema === this.$__schema ? applyVirtuals(path, { ...path._doc }) : path._doc;
        }
      }
      if (path == null) {
        [path, val] = [val, path];
      }
      prefix = val ? val + "." : "";
      keys = getKeysInSchemaOrder(this.$__schema, path);
      const len = keys.length;
      const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;
      if (len === 0 && _skipMinimizeTopLevel) {
        delete options._skipMinimizeTopLevel;
        if (val) {
          this.$set(val, {});
        }
        return this;
      }
      options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
      for (let i2 = 0;i2 < len; ++i2) {
        key = keys[i2];
        const pathName = prefix ? prefix + key : key;
        pathtype = this.$__schema.pathType(pathName);
        const valForKey = path[key];
        if (type === true && !prefix && valForKey != null && pathtype === "nested" && this._doc[key] != null) {
          delete this._doc[key];
        }
        if (utils.isNonBuiltinObject(valForKey) && pathtype === "nested") {
          this.$set(pathName, valForKey, constructing, options);
          $applyDefaultsToNested(this.$get(pathName), pathName, this);
          continue;
        } else if (strict) {
          if (constructing && valForKey === undefined && this.$get(pathName) !== undefined) {
            continue;
          }
          if (pathtype === "adhocOrUndefined") {
            pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
          }
          if (pathtype === "real" || pathtype === "virtual") {
            this.$set(pathName, valForKey, constructing, options);
          } else if (pathtype === "nested" && valForKey instanceof Document) {
            this.$set(pathName, valForKey.toObject({ transform: false }), constructing, options);
          } else if (strict === "throw") {
            if (pathtype === "nested") {
              throw new ObjectExpectedError(key, valForKey);
            } else {
              throw new StrictModeError(key);
            }
          } else if (pathtype === "nested" && valForKey == null) {
            this.$set(pathName, valForKey, constructing, options);
          }
        } else {
          this.$set(pathName, valForKey, constructing, options);
        }
      }
      const orderedDoc = {};
      const orderedKeys = Object.keys(this.$__schema.tree);
      for (let i2 = 0, len2 = orderedKeys.length;i2 < len2; ++i2) {
        (key = orderedKeys[i2]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = undefined);
      }
      this._doc = Object.assign(orderedDoc, this._doc);
      return this;
    }
    let pathType = this.$__schema.pathType(path);
    let parts = null;
    if (pathType === "adhocOrUndefined") {
      parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });
    }
    if (pathType === "adhocOrUndefined" && !userSpecifiedStrict) {
      if (parts == null) {
        parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      }
      const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);
      if (subdocStrict !== undefined) {
        strict = subdocStrict;
      }
    }
    val = handleSpreadDoc(val, true);
    const priorVal = (() => {
      if (this.$__.priorDoc != null) {
        return this.$__.priorDoc.$__getValue(path);
      }
      if (constructing) {
        return;
      }
      return this.$__getValue(path);
    })();
    if (pathType === "nested" && val) {
      if (typeof val === "object" && val != null) {
        if (val.$__ != null) {
          val = val.toObject(internalToObjectOptions);
        }
        if (val == null) {
          this.invalidate(path, new MongooseError.CastError("Object", val, path));
          return this;
        }
        const wasModified = this.$isModified(path);
        const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
        if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {
          const initialVal = this.$__getValue(path);
          this.$__.savedState[path] = initialVal;
          const keys3 = Object.keys(initialVal || {});
          for (const key2 of keys3) {
            this.$__.savedState[path + "." + key2] = initialVal[key2];
          }
        }
        if (!merge) {
          this.$__setValue(path, null);
          cleanModifiedSubpaths(this, path);
        } else {
          return this.$set(val, path, constructing, options);
        }
        const keys2 = getKeysInSchemaOrder(this.$__schema, val, path);
        this.$__setValue(path, {});
        for (const key2 of keys2) {
          this.$set(path + "." + key2, val[key2], constructing, { ...options, _skipMarkModified: true });
        }
        if (priorVal != null && (!wasModified || hasInitialVal) && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {
          this.unmarkModified(path);
        } else {
          this.markModified(path);
        }
        return this;
      }
      this.invalidate(path, new MongooseError.CastError("Object", val, path));
      return this;
    }
    let schema;
    if (parts == null) {
      parts = path.indexOf(".") === -1 ? [path] : path.split(".");
    }
    if (typeof this.$__schema.aliases[parts[0]] === "string") {
      parts[0] = this.$__schema.aliases[parts[0]];
    }
    if (pathType === "adhocOrUndefined" && strict) {
      let mixed;
      for (i = 0;i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
          mpath.set(path, val, this);
          return this;
        }
        schema = this.$__schema.path(subpath);
        if (schema == null) {
          continue;
        }
        if (schema instanceof MixedSchema) {
          mixed = true;
          break;
        } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {
          mixed = true;
          schema = schema.$__schemaType;
          break;
        }
      }
      if (schema == null) {
        schema = getEmbeddedDiscriminatorPath(this, path);
      }
      if (!mixed && !schema) {
        if (strict === "throw") {
          throw new StrictModeError(path);
        }
        return this;
      }
    } else if (pathType === "virtual") {
      schema = this.$__schema.virtualpath(path);
      schema.applySetters(val, this);
      return this;
    } else {
      schema = this.$__path(path);
    }
    let cur = this._doc;
    let curPath = "";
    for (i = 0;i < parts.length - 1; ++i) {
      cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
      curPath += (curPath.length !== 0 ? "." : "") + parts[i];
      if (!cur) {
        this.$set(curPath, {});
        if (!this.$__isSelected(curPath)) {
          this.unmarkModified(curPath);
        }
        cur = this.$__getValue(curPath);
      }
    }
    let pathToMark;
    if (parts.length <= 1) {
      pathToMark = path;
    } else {
      const len = parts.length;
      for (i = 0;i < len; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        if (this.$get(subpath, null, { getters: false }) === null) {
          pathToMark = subpath;
          break;
        }
      }
      if (!pathToMark) {
        pathToMark = path;
      }
    }
    if (!schema) {
      this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
      if (pathType === "nested" && val == null) {
        cleanModifiedSubpaths(this, path);
      }
      return this;
    }
    if (schema.$isSingleNested || schema.$isMongooseArray) {
      _markValidSubpaths(this, path);
    }
    if (val != null && merge && schema.$isSingleNested) {
      if (val instanceof Document) {
        val = val.toObject({ virtuals: false, transform: false });
      }
      const keys2 = Object.keys(val);
      for (const key2 of keys2) {
        this.$set(path + "." + key2, val[key2], constructing, options);
      }
      return this;
    }
    let shouldSet = true;
    try {
      const refMatches = (() => {
        if (schema.options == null) {
          return false;
        }
        if (!(val instanceof Document)) {
          return false;
        }
        const model = val.constructor;
        const refOpt = typeof schema.options.ref === "function" && !schema.options.ref[modelSymbol] ? schema.options.ref.call(this, this) : schema.options.ref;
        const ref = refOpt?.modelName || refOpt;
        if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
          return true;
        }
        const refPath = schema.options.refPath;
        if (refPath == null) {
          return false;
        }
        const modelName = val.get(refPath);
        return modelName === model.modelName || modelName === model.baseModelName;
      })();
      let didPopulate = false;
      if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._doc._id))) {
        const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._doc._id;
        this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });
        val.$__.wasPopulated = { value: unpopulatedValue };
        didPopulate = true;
      }
      let popOpts;
      const typeKey = this.$__schema.options.typeKey;
      if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0] && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.$populated(path, val.map(function(v) {
          return v._doc._id;
        }), popOpts);
        for (const doc of val) {
          doc.$__.wasPopulated = { value: doc._doc._id };
        }
        didPopulate = true;
      }
      if (!refMatches || !schema.$isSingleNested || !val.$__) {
        let setterContext = this;
        if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {
          setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);
        }
        if (options != null && options.overwriteImmutable) {
          val = schema.applySetters(val, setterContext, false, priorVal, { path, overwriteImmutable: true });
        } else {
          val = schema.applySetters(val, setterContext, false, priorVal, { path });
        }
      }
      if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
        const populatedPaths = Object.keys(val[0].$__.populated);
        for (const populatedPath of populatedPaths) {
          this.$populated(path + "." + populatedPath, val.map((v) => v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);
        }
        didPopulate = true;
      }
      if (!didPopulate && this.$__.populated) {
        if (Array.isArray(val) && this.$__.populated[path]) {
          for (let i2 = 0;i2 < val.length; ++i2) {
            if (val[i2] instanceof Document) {
              val.set(i2, val[i2]._doc._id, true);
            }
          }
        }
        delete this.$__.populated[path];
      }
      if (val != null && schema.$isSingleNested) {
        _checkImmutableSubpaths(val, schema, priorVal);
      }
      this.$markValid(path);
    } catch (e) {
      if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
        this.invalidate(path, e);
      } else if (e instanceof MongooseError.CastError) {
        this.invalidate(e.path, e);
        if (e.$originalErrorPath) {
          this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
        }
      } else {
        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));
      }
      shouldSet = false;
    }
    if (shouldSet) {
      let savedState = null;
      let savedStatePath = null;
      if (!constructing) {
        const doc = this.$isSubdocument ? this.ownerDocument() : this;
        savedState = doc.$__.savedState;
        savedStatePath = this.$isSubdocument ? this.$__.fullPath + "." + path : path;
        doc.$__saveInitialState(savedStatePath);
      }
      this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
      const isInTransaction = !!this.$__.session?.transaction;
      const isModifiedWithinTransaction = this.$__.session && this.$__.session[sessionNewDocuments] && this.$__.session[sessionNewDocuments].has(this) && this.$__.session[sessionNewDocuments].get(this).modifiedPaths && !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);
      if (savedState != null && savedState.hasOwnProperty(savedStatePath) && (!isInTransaction || isModifiedWithinTransaction) && utils.deepEqual(val, savedState[savedStatePath])) {
        this.unmarkModified(path);
      }
    }
    if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
      cleanModifiedSubpaths(this, path);
    } else if (schema.$isSchemaMap && val == null) {
      cleanModifiedSubpaths(this, path);
    }
    return this;
  };
  /*!
   * ignore
   */
  function _isManuallyPopulatedArray(val, ref) {
    if (!Array.isArray(val)) {
      return false;
    }
    if (val.length === 0) {
      return false;
    }
    for (const el of val) {
      if (!(el instanceof Document)) {
        return false;
      }
      const modelName = el.constructor.modelName;
      if (modelName == null) {
        return false;
      }
      if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
        return false;
      }
    }
    return true;
  }
  Document.prototype.set = Document.prototype.$set;
  Document.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    if (options && options._skipMarkModified) {
      return false;
    }
    if (this.$isNew) {
      return true;
    }
    if (path in this.$__.activePaths.getStatePaths("modify")) {
      return true;
    }
    if (val === undefined && !this.$__isSelected(path)) {
      return true;
    }
    if (val === undefined && path in this.$__.activePaths.getStatePaths("default")) {
      return false;
    }
    if (this.$populated(path) && val instanceof Document && deepEqual(val._doc._id, priorVal)) {
      return false;
    }
    if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {
      return true;
    }
    if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.getStatePaths("default") && deepEqual(val, schema.getDefault(this, constructing))) {
      return true;
    }
    return false;
  };
  Document.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    Embedded = Embedded || require_arraySubdocument();
    const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);
    if (shouldModify) {
      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {
        delete this.$__.primitiveAtomics[path];
        if (Object.keys(this.$__.primitiveAtomics).length === 0) {
          delete this.$__.primitiveAtomics;
        }
      }
      this.markModified(pathToMark);
      MongooseArray || (MongooseArray = require_array());
      if (val && utils.isMongooseArray(val)) {
        val._registerAtomic("$set", val);
        if (utils.isMongooseDocumentArray(val)) {
          val.forEach(function(item) {
            item && item.__parentArray && (item.__parentArray = val);
          });
        }
      }
    } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {
      val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];
      val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];
      if (utils.isMongooseDocumentArray(val)) {
        val.forEach((doc) => {
          if (doc != null) {
            doc.$isNew = false;
          }
        });
      }
    }
    let obj = this._doc;
    let i = 0;
    const l2 = parts.length;
    let cur = "";
    for (;i < l2; i++) {
      const next = i + 1;
      const last = next === l2;
      cur += cur ? "." + parts[i] : parts[i];
      if (specialProperties.has(parts[i])) {
        continue;
      }
      if (last) {
        if (obj instanceof Map) {
          obj.set(parts[i], val);
        } else if (obj.$isSingleNested) {
          if (!(parts[i] in obj)) {
            obj[parts[i]] = val;
            obj._doc[parts[i]] = val;
          } else {
            obj._doc[parts[i]] = val;
          }
          if (shouldModify) {
            obj.markModified(parts[i]);
          }
        } else {
          obj[parts[i]] = val;
        }
      } else {
        const isMap = obj instanceof Map;
        let value = isMap ? obj.get(parts[i]) : obj[parts[i]];
        if (utils.isPOJO(value)) {
          obj = value;
        } else if (value && value instanceof Embedded) {
          obj = value;
        } else if (value && !Array.isArray(value) && value.$isSingleNested) {
          obj = value;
        } else if (value && Array.isArray(value)) {
          obj = value;
        } else if (value == null) {
          value = {};
          if (isMap) {
            obj.set(parts[i], value);
          } else {
            obj[parts[i]] = value;
          }
          obj = value;
        } else {
          obj = value;
        }
      }
    }
  };
  Document.prototype.$__getValue = function(path) {
    if (typeof path !== "string" && !Array.isArray(path)) {
      throw new TypeError(`Invalid \`path\`. Must be either string or array. Got "${path}" (type ${typeof path})`);
    }
    return utils.getValue(path, this._doc);
  };
  Document.prototype.$inc = function $inc(path, val) {
    if (val == null) {
      val = 1;
    }
    if (Array.isArray(path)) {
      path.forEach((p) => this.$inc(p, val));
      return this;
    }
    const schemaType = this.$__path(path);
    if (schemaType == null) {
      if (this.$__.strictMode === "throw") {
        throw new StrictModeError(path);
      } else if (this.$__.strictMode === true) {
        return this;
      }
    } else if (schemaType.instance !== "Number") {
      this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));
      return this;
    }
    const currentValue = this.$__getValue(path) || 0;
    let shouldSet = false;
    let valToSet = null;
    let valToInc = val;
    try {
      val = schemaType.cast(val);
      valToSet = schemaType.applySetters(currentValue + val, this);
      valToInc = valToSet - currentValue;
      shouldSet = true;
    } catch (err2) {
      this.invalidate(path, new MongooseError.CastError("number", val, path, err2));
    }
    if (shouldSet) {
      this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};
      if (this.$__.primitiveAtomics[path] == null) {
        this.$__.primitiveAtomics[path] = { $inc: valToInc };
      } else {
        this.$__.primitiveAtomics[path].$inc += valToInc;
      }
      this.markModified(path);
      this.$__setValue(path, valToSet);
    }
    return this;
  };
  Document.prototype.$__setValue = function(path, val) {
    utils.setValue(path, val, this._doc);
    return this;
  };
  Document.prototype.get = function(path, type, options) {
    let adhoc;
    if (options == null) {
      options = {};
    }
    if (type) {
      adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    const noDottedPath = options.noDottedPath;
    let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);
    if (schema == null) {
      schema = this.$__schema.virtualpath(path);
      if (schema != null) {
        return schema.applyGetters(undefined, this);
      }
    }
    if (noDottedPath) {
      let obj2 = this._doc[path];
      if (adhoc) {
        obj2 = adhoc.cast(obj2);
      }
      if (schema != null && options.getters !== false) {
        return schema.applyGetters(obj2, this);
      }
      return obj2;
    }
    if (schema != null && schema.instance === "Mixed") {
      const virtual = this.$__schema.virtualpath(path);
      if (virtual != null) {
        schema = virtual;
      }
    }
    const hasDot = path.indexOf(".") !== -1;
    let obj = this._doc;
    const pieces = hasDot ? path.split(".") : [path];
    if (typeof this.$__schema.aliases[pieces[0]] === "string") {
      pieces[0] = this.$__schema.aliases[pieces[0]];
    }
    for (let i = 0, l2 = pieces.length;i < l2; i++) {
      if (obj && obj._doc) {
        obj = obj._doc;
      }
      if (obj == null) {
        obj = undefined;
      } else if (obj instanceof Map) {
        obj = obj.get(pieces[i], { getters: false });
      } else if (i === l2 - 1) {
        obj = utils.getValue(pieces[i], obj);
      } else {
        obj = obj[pieces[i]];
      }
    }
    if (adhoc) {
      obj = adhoc.cast(obj);
    }
    if (schema != null && options.getters !== false) {
      obj = schema.applyGetters(obj, this);
    } else if (this.$__schema.nested[path] && options.virtuals) {
      return applyVirtuals(this, clone2(obj) || {}, { path });
    }
    return obj;
  };
  /*!
   * ignore
   */
  Document.prototype[getSymbol] = Document.prototype.get;
  Document.prototype.$get = Document.prototype.get;
  Document.prototype.$__path = function(path) {
    const adhocs = this.$__.adhocPaths;
    const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
    if (adhocType) {
      return adhocType;
    }
    return this.$__schema.path(path);
  };
  Document.prototype.markModified = function(path, scope) {
    this.$__saveInitialState(path);
    this.$__.activePaths.modify(path);
    if (scope != null && !this.$isSubdocument) {
      this.$__.pathsToScopes = this.$__pathsToScopes || {};
      this.$__.pathsToScopes[path] = scope;
    }
  };
  /*!
   * ignore
   */
  Document.prototype.$__saveInitialState = function $__saveInitialState(path) {
    const savedState = this.$__.savedState;
    const savedStatePath = path;
    if (savedState != null) {
      const firstDot = savedStatePath.indexOf(".");
      const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);
      if (!savedState.hasOwnProperty(topLevelPath)) {
        savedState[topLevelPath] = clone2(this.$__getValue(topLevelPath));
      }
    }
  };
  Document.prototype.unmarkModified = function(path) {
    this.$__.activePaths.init(path);
    if (this.$__.pathsToScopes != null) {
      delete this.$__.pathsToScopes[path];
    }
  };
  Document.prototype.$ignore = function(path) {
    this.$__.activePaths.ignore(path);
  };
  Document.prototype.directModifiedPaths = function() {
    return Object.keys(this.$__.activePaths.getStatePaths("modify"));
  };
  Document.prototype.$isEmpty = function(path) {
    const isEmptyOptions = {
      minimize: true,
      virtuals: false,
      getters: false,
      transform: false
    };
    if (arguments.length !== 0) {
      const v = this.$get(path);
      if (v == null) {
        return true;
      }
      if (typeof v !== "object") {
        return false;
      }
      if (utils.isPOJO(v)) {
        return _isEmpty(v);
      }
      return Object.keys(v.toObject(isEmptyOptions)).length === 0;
    }
    return Object.keys(this.toObject(isEmptyOptions)).length === 0;
  };
  /*!
   * ignore
   */
  function _isEmpty(v) {
    if (v == null) {
      return true;
    }
    if (typeof v !== "object" || Array.isArray(v)) {
      return false;
    }
    for (const key of Object.keys(v)) {
      if (!_isEmpty(v[key])) {
        return false;
      }
    }
    return true;
  }
  Document.prototype.modifiedPaths = function(options) {
    options = options || {};
    const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths("modify"));
    const result = new Set;
    let i = 0;
    let j = 0;
    const len = directModifiedPaths.length;
    for (i = 0;i < len; ++i) {
      const path = directModifiedPaths[i];
      const parts = parentPaths(path);
      const pLen = parts.length;
      for (j = 0;j < pLen; ++j) {
        result.add(parts[j]);
      }
      if (!options.includeChildren) {
        continue;
      }
      let ii = 0;
      let cur = this.$get(path);
      if (typeof cur === "object" && cur !== null) {
        if (cur._doc) {
          cur = cur._doc;
        }
        const len2 = cur.length;
        if (Array.isArray(cur)) {
          for (ii = 0;ii < len2; ++ii) {
            const subPath = path + "." + ii;
            if (!result.has(subPath)) {
              result.add(subPath);
              if (cur[ii] != null && cur[ii].$__) {
                const modified = cur[ii].modifiedPaths();
                let iii = 0;
                const iiiLen = modified.length;
                for (iii = 0;iii < iiiLen; ++iii) {
                  result.add(subPath + "." + modified[iii]);
                }
              }
            }
          }
        } else {
          const keys = Object.keys(cur);
          let ii2 = 0;
          const len3 = keys.length;
          for (ii2 = 0;ii2 < len3; ++ii2) {
            result.add(path + "." + keys[ii2]);
          }
        }
      }
    }
    return Array.from(result);
  };
  Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;
  Document.prototype.isModified = function(paths, options, modifiedPaths) {
    if (paths) {
      const ignoreAtomics = options && options.ignoreAtomics;
      const directModifiedPathsObj = this.$__.activePaths.states.modify;
      if (directModifiedPathsObj == null) {
        return false;
      }
      if (typeof paths === "string") {
        paths = paths.indexOf(" ") === -1 ? [paths] : paths.split(" ");
      }
      for (const path of paths) {
        if (directModifiedPathsObj[path] != null) {
          return true;
        }
      }
      const modified = modifiedPaths || this[documentModifiedPaths]();
      const isModifiedChild = paths.some(function(path) {
        return !!~modified.indexOf(path);
      });
      let directModifiedPaths = Object.keys(directModifiedPathsObj);
      if (ignoreAtomics) {
        directModifiedPaths = directModifiedPaths.filter((path) => {
          const value = this.$__getValue(path);
          if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === undefined) {
            return false;
          }
          return true;
        });
      }
      return isModifiedChild || paths.some(function(path) {
        return directModifiedPaths.some(function(mod) {
          return mod === path || path.startsWith(mod + ".");
        });
      });
    }
    return this.$__.activePaths.some("modify");
  };
  Document.prototype.$isModified = Document.prototype.isModified;
  Document.prototype[documentIsModified] = Document.prototype.isModified;
  Document.prototype.$isDefault = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("default");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("default").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("default").hasOwnProperty(path2));
  };
  Document.prototype.$isDeleted = function(val) {
    if (arguments.length === 0) {
      return !!this.$__.isDeleted;
    }
    this.$__.isDeleted = !!val;
    return this;
  };
  Document.prototype.isDirectModified = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("modify");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      const res = this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path);
      if (res || path.indexOf(".") === -1) {
        return res;
      }
      const pieces = path.split(".");
      for (let i = 0;i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.$get(subpath);
        if (subdoc != null && subdoc.$__ != null && subdoc.isDirectModified(pieces.slice(i + 1).join("."))) {
          return true;
        }
      }
      return false;
    }
    let paths = path;
    if (typeof paths === "string") {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.isDirectModified(path2));
  };
  Document.prototype.isInit = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("init");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("init").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("init").hasOwnProperty(path2));
  };
  Document.prototype.isSelected = function isSelected(path) {
    if (this.$__.selected == null) {
      return true;
    }
    if (!path) {
      return false;
    }
    if (path === "_id") {
      return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.$__isSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
      return this.$__.selected._id === 0;
    }
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (path in this.$__.selected) {
      return inclusive;
    }
    const pathDot = path + ".";
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (cur.startsWith(pathDot)) {
        return inclusive || cur !== pathDot;
      }
      if (pathDot.startsWith(cur + ".")) {
        return inclusive;
      }
    }
    return !inclusive;
  };
  Document.prototype.$__isSelected = Document.prototype.isSelected;
  Document.prototype.isDirectSelected = function isDirectSelected(path) {
    if (this.$__.selected == null) {
      return true;
    }
    if (path === "_id") {
      return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.isDirectSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
      return this.$__.selected._id === 0;
    }
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (this.$__.selected.hasOwnProperty(path)) {
      return inclusive;
    }
    return !inclusive;
  };
  Document.prototype.validate = async function validate(pathsToValidate, options) {
    if (typeof pathsToValidate === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Document.prototype.validate() no longer accepts a callback");
    }
    this.$op = "validate";
    if (arguments.length === 1) {
      if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
      }
    }
    if (options && typeof options.pathsToSkip === "string") {
      const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
      options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(" ");
    }
    const _skipParallelValidateCheck = options && options._skipParallelValidateCheck;
    if (this.$isSubdocument != null) {
    } else if (this.$__.validating && !_skipParallelValidateCheck) {
      throw new ParallelValidateError(this);
    } else if (!_skipParallelValidateCheck) {
      this.$__.validating = true;
    }
    return new Promise((resolve, reject) => {
      this.$__validate(pathsToValidate, options, (error) => {
        this.$op = null;
        this.$__.validating = null;
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  };
  Document.prototype.$validate = Document.prototype.validate;
  /*!
   * ignore
   */
  function _evaluateRequiredFunctions(doc) {
    const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths("require"));
    let i = 0;
    const len = requiredFields.length;
    for (i = 0;i < len; ++i) {
      const path = requiredFields[i];
      const p = doc.$__schema.path(path);
      if (p != null && typeof p.originalRequiredValue === "function") {
        doc.$__.cachedRequired = doc.$__.cachedRequired || {};
        try {
          doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
        } catch (err2) {
          doc.invalidate(path, err2);
        }
      }
    }
  }
  /*!
   * ignore
   */
  function _getPathsToValidate(doc, pathsToValidate, pathsToSkip, isNestedValidate) {
    const doValidateOptions = {};
    _evaluateRequiredFunctions(doc);
    let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths("require")).filter(function(path) {
      if (!doc.$__isSelected(path) && !doc.$isModified(path)) {
        return false;
      }
      if (path.endsWith(".$*")) {
        return false;
      }
      if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {
        return doc.$__.cachedRequired[path];
      }
      return true;
    }));
    Object.keys(doc.$__.activePaths.getStatePaths("init")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("modify")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("default")).forEach(addToPaths);
    function addToPaths(p) {
      if (p.endsWith(".$*")) {
        return;
      }
      paths.add(p);
    }
    if (!isNestedValidate) {
      const topLevelSubdocs = [];
      for (const path of Object.keys(doc.$__schema.paths)) {
        const schemaType = doc.$__schema.path(path);
        if (schemaType.$isSingleNested) {
          const subdoc = doc.$get(path);
          if (subdoc) {
            topLevelSubdocs.push(subdoc);
          }
        } else if (schemaType.$isMongooseDocumentArray) {
          const arr = doc.$get(path);
          if (arr && arr.length) {
            for (const subdoc of arr) {
              if (subdoc) {
                topLevelSubdocs.push(subdoc);
              }
            }
          }
        }
      }
      const modifiedPaths = doc.modifiedPaths();
      for (const subdoc of topLevelSubdocs) {
        if (subdoc.$basePath) {
          const fullPathToSubdoc = subdoc.$__pathRelativeToParent();
          for (const modifiedPath of subdoc.modifiedPaths()) {
            paths.delete(fullPathToSubdoc + "." + modifiedPath);
          }
          const subdocParent = subdoc.$parent();
          if (subdocParent == null) {
            throw new Error("Cannot validate subdocument that does not have a parent");
          }
          if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) && !subdocParent.$__.activePaths.getStatePaths("modify").hasOwnProperty(fullPathToSubdoc) && !subdocParent.$isDefault(fullPathToSubdoc)) {
            paths.add(fullPathToSubdoc);
            if (doc.$__.pathsToScopes == null) {
              doc.$__.pathsToScopes = {};
            }
            doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ? subdoc.__parentArray : subdoc.$parent();
            doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };
            if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {
              doValidateOptions[fullPathToSubdoc].index = subdoc.__index;
            }
          }
        }
      }
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (_pathType.$isMongooseDocumentArray) {
        for (const p of paths) {
          if (p == null || p.startsWith(_pathType.path + ".")) {
            paths.delete(p);
          }
        }
      }
      if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {
        paths.delete(path);
      } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && !_pathType.$embeddedSchemaType.$isMongooseArray && _pathType.validators.length === 0 && _pathType.$embeddedSchemaType.validators.length === 0) {
        paths.delete(path);
      }
    }
    if (Array.isArray(pathsToValidate)) {
      paths = _handlePathsToValidate(paths, pathsToValidate);
    } else if (Array.isArray(pathsToSkip)) {
      paths = _handlePathsToSkip(paths, pathsToSkip);
    }
    _addArrayPathsToValidate(doc, paths);
    const flattenOptions = { skipArrays: true };
    for (const pathToCheck of paths) {
      if (doc.$__schema.nested[pathToCheck]) {
        let _v = doc.$__getValue(pathToCheck);
        if (isMongooseObject(_v)) {
          _v = _v.toObject({ transform: false });
        }
        const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
        Object.keys(flat).filter((path) => !doc.$__schema.singleNestedPaths.hasOwnProperty(path)).forEach(addToPaths);
      }
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === "string") {
        paths.add(_pathType.$parentSchemaDocArray.path);
      }
      if (!_pathType.$isSchemaMap) {
        continue;
      }
      const val = doc.$__getValue(path);
      if (val == null) {
        continue;
      }
      for (const key of val.keys()) {
        paths.add(path + "." + key);
      }
    }
    paths = Array.from(paths);
    return [paths, doValidateOptions];
  }
  function _addArrayPathsToValidate(doc, paths) {
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (!_pathType.$isMongooseArray || !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {
        continue;
      }
      if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && !_pathType.$embeddedSchemaType.$isMongooseArray && _pathType.$embeddedSchemaType.validators.length === 0) {
        continue;
      }
      const val = doc.$__getValue(path);
      _pushNestedArrayPaths(val, paths, path);
    }
  }
  function _pushNestedArrayPaths(val, paths, path) {
    if (val != null) {
      const numElements = val.length;
      for (let j = 0;j < numElements; ++j) {
        if (Array.isArray(val[j])) {
          _pushNestedArrayPaths(val[j], paths, path + "." + j);
        } else {
          paths.add(path + "." + j);
        }
      }
    }
  }
  /*!
   * ignore
   */
  Document.prototype.$__validate = function(pathsToValidate, options, callback) {
    if (this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !pathsToValidate) {
      pathsToValidate = [...this.$__.saveOptions.pathsToSave];
    } else if (typeof pathsToValidate === "function") {
      callback = pathsToValidate;
      options = null;
      pathsToValidate = null;
    } else if (typeof options === "function") {
      callback = options;
      options = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
    const pathsToSkip = options && options.pathsToSkip || null;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
      shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
      shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    const validateAllPaths = options && options.validateAllPaths;
    if (validateAllPaths) {
      if (pathsToSkip) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
      }
      if (pathsToValidate) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
      }
      if (hasValidateModifiedOnlyOption && shouldValidateModifiedOnly) {
        throw new TypeError("Cannot set both `validateAllPaths` and `validateModifiedOnly`");
      }
    }
    const _this = this;
    const _complete = () => {
      let validationError = this.$__.validationError;
      this.$__.validationError = null;
      this.$__.validating = null;
      if (shouldValidateModifiedOnly && validationError != null) {
        const errors2 = Object.keys(validationError.errors);
        for (const errPath of errors2) {
          if (!this.$isModified(errPath)) {
            delete validationError.errors[errPath];
          }
        }
        if (Object.keys(validationError.errors).length === 0) {
          validationError = undefined;
        }
      }
      this.$__.cachedRequired = {};
      this.$emit("validate", _this);
      this.constructor.emit("validate", _this);
      if (validationError) {
        for (const key in validationError.errors) {
          if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
            this.invalidate(key, validationError.errors[key]);
          }
        }
        return validationError;
      }
    };
    let paths;
    let doValidateOptionsByPath;
    if (validateAllPaths) {
      paths = new Set(Object.keys(this.$__schema.paths));
      for (const path of paths) {
        const schemaType = this.$__schema.path(path);
        if (!schemaType || !schemaType.$isMongooseArray) {
          continue;
        }
        const val = this.$__getValue(path);
        if (!val) {
          continue;
        }
        _pushNestedArrayPaths(val, paths, path);
      }
      paths = [...paths];
      doValidateOptionsByPath = {};
    } else {
      const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip, options && options._nestedValidate);
      paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
      doValidateOptionsByPath = pathDetails[1];
    }
    if (typeof pathsToValidate === "string") {
      pathsToValidate = pathsToValidate.split(" ");
    }
    if (paths.length === 0) {
      return immediate(function() {
        const error = _complete();
        if (error) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
            callback(error2);
          });
        }
        callback(null, _this);
      });
    }
    const validated = {};
    let total = 0;
    let pathsToSave = this.$__.saveOptions?.pathsToSave;
    if (Array.isArray(pathsToSave)) {
      pathsToSave = new Set(pathsToSave);
      for (const path of paths) {
        if (!pathsToSave.has(path)) {
          continue;
        }
        validatePath(path);
      }
    } else {
      for (const path of paths) {
        validatePath(path);
      }
    }
    function validatePath(path) {
      if (path == null || validated[path]) {
        return;
      }
      validated[path] = true;
      total++;
      immediate(function() {
        const schemaType = _this.$__schema.path(path);
        if (!schemaType) {
          return --total || complete();
        }
        if (!_this.$isValid(path)) {
          --total || complete();
          return;
        }
        if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
          return --total || complete();
        }
        let val = _this.$__getValue(path);
        let pop;
        if (pop = _this.$populated(path)) {
          val = pop;
        } else if (val != null && val.$__ != null && val.$__.wasPopulated) {
          val = val._doc._id;
        }
        const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;
        const doValidateOptions = {
          ...doValidateOptionsByPath[path],
          path,
          validateAllPaths,
          _nestedValidate: true
        };
        schemaType.doValidate(val, function(err2) {
          if (err2) {
            const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;
            if (isSubdoc && err2 instanceof ValidationError2) {
              return --total || complete();
            }
            _this.invalidate(path, err2, undefined, true);
          }
          --total || complete();
        }, scope, doValidateOptions);
      });
    }
    function complete() {
      const error = _complete();
      if (error) {
        return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
          callback(error2);
        });
      }
      callback(null, _this);
    }
  };
  /*!
   * ignore
   */
  function _handlePathsToValidate(paths, pathsToValidate) {
    const _pathsToValidate = new Set(pathsToValidate);
    const parentPaths2 = new Map([]);
    for (const path of pathsToValidate) {
      if (path.indexOf(".") === -1) {
        continue;
      }
      const pieces = path.split(".");
      let cur = pieces[0];
      for (let i = 1;i < pieces.length; ++i) {
        parentPaths2.set(cur, path);
        cur = cur + "." + pieces[i];
      }
    }
    const ret = new Set;
    for (const path of paths) {
      if (_pathsToValidate.has(path)) {
        ret.add(path);
      } else if (parentPaths2.has(path)) {
        ret.add(parentPaths2.get(path));
      }
    }
    return ret;
  }
  /*!
   * ignore
   */
  function _handlePathsToSkip(paths, pathsToSkip) {
    pathsToSkip = new Set(pathsToSkip);
    paths = Array.from(paths).filter((p) => !pathsToSkip.has(p));
    return new Set(paths);
  }
  Document.prototype.validateSync = function(pathsToValidate, options) {
    const _this = this;
    if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
      options = arguments[0];
      pathsToValidate = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
      shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
      shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    let pathsToSkip = options && options.pathsToSkip;
    const validateAllPaths = options && options.validateAllPaths;
    if (validateAllPaths) {
      if (pathsToSkip) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
      }
      if (pathsToValidate) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
      }
    }
    if (typeof pathsToValidate === "string") {
      const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
      pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
    } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
      pathsToSkip = pathsToSkip.split(" ");
    }
    let paths;
    let skipSchemaValidators;
    if (validateAllPaths) {
      paths = new Set(Object.keys(this.$__schema.paths));
      for (const path of paths) {
        const schemaType = this.$__schema.path(path);
        if (!schemaType || !schemaType.$isMongooseArray) {
          continue;
        }
        const val = this.$__getValue(path);
        if (!val) {
          continue;
        }
        _pushNestedArrayPaths(val, paths, path);
      }
      paths = [...paths];
      skipSchemaValidators = {};
    } else {
      const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);
      paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
      skipSchemaValidators = pathDetails[1];
    }
    const validating = {};
    for (let i = 0, len = paths.length;i < len; ++i) {
      const path = paths[i];
      if (validating[path]) {
        continue;
      }
      validating[path] = true;
      const p = _this.$__schema.path(path);
      if (!p) {
        continue;
      }
      if (!_this.$isValid(path)) {
        continue;
      }
      const val = _this.$__getValue(path);
      const err3 = p.doValidateSync(val, _this, {
        skipSchemaValidators: skipSchemaValidators[path],
        path,
        validateModifiedOnly: shouldValidateModifiedOnly,
        validateAllPaths
      });
      if (err3) {
        const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;
        if (isSubdoc && err3 instanceof ValidationError2) {
          continue;
        }
        _this.invalidate(path, err3, undefined, true);
      }
    }
    const err2 = _this.$__.validationError;
    _this.$__.validationError = undefined;
    _this.$emit("validate", _this);
    _this.constructor.emit("validate", _this);
    if (err2) {
      for (const key in err2.errors) {
        if (err2.errors[key] instanceof MongooseError.CastError) {
          _this.invalidate(key, err2.errors[key]);
        }
      }
    }
    return err2;
  };
  Document.prototype.invalidate = function(path, err2, val, kind) {
    if (!this.$__.validationError) {
      this.$__.validationError = new ValidationError2(this);
    }
    if (this.$__.validationError.errors[path]) {
      return;
    }
    if (!err2 || typeof err2 === "string") {
      err2 = new ValidatorError({
        path,
        message: err2,
        type: kind || "user defined",
        value: val
      });
    }
    if (this.$__.validationError === err2) {
      return this.$__.validationError;
    }
    this.$__.validationError.addError(path, err2);
    return this.$__.validationError;
  };
  Document.prototype.$markValid = function(path) {
    if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
      return;
    }
    delete this.$__.validationError.errors[path];
    if (Object.keys(this.$__.validationError.errors).length === 0) {
      this.$__.validationError = null;
    }
  };
  /*!
   * ignore
   */
  function _markValidSubpaths(doc, path) {
    if (!doc.$__.validationError) {
      return;
    }
    const keys = Object.keys(doc.$__.validationError.errors);
    for (const key of keys) {
      if (key.startsWith(path + ".")) {
        delete doc.$__.validationError.errors[key];
      }
    }
    if (Object.keys(doc.$__.validationError.errors).length === 0) {
      doc.$__.validationError = null;
    }
  }
  /*!
   * ignore
   */
  function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
    const schema = schematype.schema;
    if (schema == null) {
      return;
    }
    for (const key of Object.keys(schema.paths)) {
      const path = schema.paths[key];
      if (path.$immutableSetter == null) {
        continue;
      }
      const oldVal = priorVal == null ? undefined : priorVal.$__getValue(key);
      path.$immutableSetter.call(subdoc, oldVal);
    }
  }
  Document.prototype.$isValid = function(path) {
    if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
      return true;
    }
    if (path == null) {
      return false;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.$__.validationError.errors[p] == null);
    }
    return this.$__.validationError.errors[path] == null;
  };
  Document.prototype.$__reset = function reset() {
    let _this = this;
    const subdocs = !this.$isSubdocument ? this.$getAllSubdocs({ useCache: true }) : null;
    if (subdocs && subdocs.length > 0) {
      for (const subdoc of subdocs) {
        subdoc.$__reset();
      }
    }
    this.$__dirty().forEach(function(dirt) {
      const type = dirt.value;
      if (type && type[arrayAtomicsSymbol]) {
        type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
        type[arrayAtomicsSymbol] = {};
      }
    });
    this.$__.backup = {};
    this.$__.backup.activePaths = {
      modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")),
      default: Object.assign({}, this.$__.activePaths.getStatePaths("default"))
    };
    this.$__.backup.validationError = this.$__.validationError;
    this.$__.backup.errors = this.$errors;
    this.$__.activePaths.clear("modify");
    this.$__.activePaths.clear("default");
    this.$__.validationError = undefined;
    this.$errors = undefined;
    _this = this;
    this.$__schema.requiredPaths().forEach(function(path) {
      _this.$__.activePaths.require(path);
    });
    return this;
  };
  /*!
   * ignore
   */
  Document.prototype.$__undoReset = function $__undoReset() {
    if (this.$__.backup == null || this.$__.backup.activePaths == null) {
      return;
    }
    this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
    this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
    this.$__.validationError = this.$__.backup.validationError;
    this.$errors = this.$__.backup.errors;
    for (const dirt of this.$__dirty()) {
      const type = dirt.value;
      if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
        type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
      }
    }
    if (!this.$isSubdocument) {
      for (const subdoc of this.$getAllSubdocs()) {
        subdoc.$__undoReset();
      }
    }
  };
  Document.prototype.$__dirty = function() {
    const _this = this;
    let all = this.$__.activePaths.map("modify", function(path) {
      return {
        path,
        value: _this.$__getValue(path),
        schema: _this.$__path(path)
      };
    });
    all = all.concat(this.$__.activePaths.map("default", function(path) {
      if (path === "_id" || _this.$__getValue(path) == null) {
        return;
      }
      return {
        path,
        value: _this.$__getValue(path),
        schema: _this.$__path(path)
      };
    }));
    const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));
    const minimal = [];
    all.forEach(function(item) {
      if (!item) {
        return;
      }
      let top = null;
      const array = parentPaths(item.path);
      for (let i = 0;i < array.length - 1; i++) {
        if (allPaths.has(array[i])) {
          top = allPaths.get(array[i]);
          break;
        }
      }
      if (top == null) {
        minimal.push(item);
      } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {
        top[arrayAtomicsSymbol] = {};
        top[arrayAtomicsSymbol].$set = top;
      }
    });
    return minimal;
  };
  Document.prototype.$__setSchema = function(schema) {
    compile2(schema.tree, this, undefined, schema.options);
    for (const key of Object.keys(schema.virtuals)) {
      schema.virtuals[key]._applyDefaultGetters();
    }
    if (schema.path("schema") == null) {
      this.schema = schema;
    }
    this.$__schema = schema;
    this[documentSchemaSymbol] = schema;
  };
  Document.prototype.$__getArrayPathsToValidate = function() {
    DocumentArray || (DocumentArray = require_documentArray());
    return this.$__.activePaths.map("init", "modify", function(i) {
      return this.$__getValue(i);
    }.bind(this)).filter(function(val) {
      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, []).filter(function(doc) {
      return doc;
    });
  };
  Document.prototype.$getAllSubdocs = function(options) {
    if (options?.useCache && this.$__.saveOptions?.__subdocs) {
      return this.$__.saveOptions.__subdocs;
    }
    DocumentArray || (DocumentArray = require_documentArray());
    Embedded = Embedded || require_arraySubdocument();
    const subDocs = [];
    function getSubdocs(doc) {
      const newSubdocs = [];
      for (const { model } of doc.$__schema.childSchemas) {
        const val = doc.$__getValue(model.path);
        if (val == null) {
          continue;
        }
        if (val.$__) {
          newSubdocs.push(val);
        }
        if (Array.isArray(val)) {
          for (const el of val) {
            if (el != null && el.$__) {
              newSubdocs.push(el);
            }
          }
        }
        if (val instanceof Map) {
          for (const el of val.values()) {
            if (el != null && el.$__) {
              newSubdocs.push(el);
            }
          }
        }
      }
      for (const subdoc of newSubdocs) {
        getSubdocs(subdoc);
      }
      subDocs.push(...newSubdocs);
    }
    getSubdocs(this);
    if (this.$__.saveOptions) {
      this.$__.saveOptions.__subdocs = subDocs;
    }
    return subDocs;
  };
  /*!
   * Runs queued functions
   */
  function applyQueue(doc) {
    const q = doc.$__schema && doc.$__schema.callQueue;
    if (!q.length) {
      return;
    }
    for (const pair of q) {
      if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
        doc[pair[0]].apply(doc, pair[1]);
      }
    }
  }
  /*!
   * ignore
   */
  Document.prototype.$__handleReject = function handleReject(err2) {
    if (this.$listeners("error").length) {
      this.$emit("error", err2);
    } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
      this.constructor.emit("error", err2);
    }
  };
  Document.prototype.$toObject = function(options, json) {
    const defaultOptions = this.$__schema._defaultToObjectOptions(json);
    const hasOnlyPrimitiveValues = this.$__hasOnlyPrimitiveValues();
    options = utils.isPOJO(options) ? { ...options } : {};
    options._calledWithOptions = options._calledWithOptions || { ...options };
    let _minimize;
    if (options._calledWithOptions.minimize != null) {
      _minimize = options.minimize;
    } else if (this.$__schemaTypeOptions?.minimize != null) {
      _minimize = this.$__schemaTypeOptions.minimize;
    } else if (defaultOptions != null && defaultOptions.minimize != null) {
      _minimize = defaultOptions.minimize;
    } else {
      _minimize = this.$__schema.options.minimize;
    }
    options.minimize = _minimize;
    if (!hasOnlyPrimitiveValues) {
      options._seen = options._seen || new Map;
    }
    const depopulate = options._calledWithOptions.depopulate ?? defaultOptions?.depopulate ?? options.depopulate ?? false;
    if (depopulate && options._isNested && this.$__.wasPopulated) {
      return clone2(this.$__.wasPopulated.value || this._doc._id, options);
    }
    if (depopulate) {
      options.depopulate = true;
    }
    if (defaultOptions != null) {
      for (const key of Object.keys(defaultOptions)) {
        if (options[key] == null) {
          options[key] = defaultOptions[key];
        }
      }
    }
    options._isNested = true;
    options.json = json;
    options.minimize = _minimize;
    const parentOptions = options._parentOptions;
    options._parentOptions = this.$isSubdocument ? options : null;
    const schemaFieldsOnly = options._calledWithOptions.schemaFieldsOnly ?? options.schemaFieldsOnly ?? defaultOptions.schemaFieldsOnly ?? false;
    let ret;
    if (hasOnlyPrimitiveValues && !options.flattenObjectIds) {
      ret = this.$__toObjectShallow(schemaFieldsOnly);
    } else if (schemaFieldsOnly) {
      ret = {};
      for (const path of Object.keys(this.$__schema.paths)) {
        const value = this.$__getValue(path);
        if (value === undefined) {
          continue;
        }
        let pathToSet = path;
        let objToSet = ret;
        if (path.indexOf(".") !== -1) {
          const segments = path.split(".");
          pathToSet = segments[segments.length - 1];
          for (let i = 0;i < segments.length - 1; ++i) {
            objToSet[segments[i]] = objToSet[segments[i]] ?? {};
            objToSet = objToSet[segments[i]];
          }
        }
        if (value === null) {
          objToSet[pathToSet] = null;
          continue;
        }
        objToSet[pathToSet] = clone2(value, options);
      }
    } else {
      ret = clone2(this._doc, options) || {};
    }
    const getters = options._calledWithOptions.getters ?? options.getters ?? defaultOptions.getters ?? false;
    if (getters) {
      applyGetters(this, ret);
      if (options.minimize) {
        ret = minimize(ret) || {};
      }
    }
    const virtuals = options._calledWithOptions.virtuals ?? defaultOptions.virtuals ?? parentOptions?.virtuals ?? undefined;
    if (virtuals || getters && virtuals !== false) {
      applyVirtuals(this, ret, options, options);
    }
    if (options.versionKey === false && this.$__schema.options.versionKey) {
      delete ret[this.$__schema.options.versionKey];
    }
    const transform2 = options._calledWithOptions.transform ?? true;
    let transformFunction = undefined;
    if (transform2 === true) {
      transformFunction = defaultOptions.transform;
    } else if (typeof transform2 === "function") {
      transformFunction = transform2;
    }
    if (transform2) {
      applySchemaTypeTransforms(this, ret);
    }
    if (options.useProjection) {
      omitDeselectedFields(this, ret);
    }
    if (typeof transformFunction === "function") {
      const xformed = transformFunction(this, ret, options);
      if (typeof xformed !== "undefined") {
        ret = xformed;
      }
    }
    return ret;
  };
  /*!
   * Internal shallow clone alternative to `$toObject()`: much faster, no options processing
   */
  Document.prototype.$__toObjectShallow = function $__toObjectShallow(schemaFieldsOnly) {
    const ret = {};
    if (this._doc != null) {
      const keys = schemaFieldsOnly ? Object.keys(this.$__schema.paths) : Object.keys(this._doc);
      for (const key of keys) {
        const value = this._doc[key];
        if (value instanceof Date) {
          ret[key] = new Date(value);
        } else if (value !== undefined) {
          ret[key] = value;
        }
      }
    }
    return ret;
  };
  Document.prototype.toObject = function(options) {
    return this.$toObject(options);
  };
  /*!
   * Applies virtuals properties to `json`.
   */
  function applyVirtuals(self2, json, options, toObjectOptions) {
    const schema = self2.$__schema;
    const virtuals = schema.virtuals;
    const paths = Object.keys(virtuals);
    let i = paths.length;
    const numPaths = i;
    let path;
    let assignPath;
    let cur = self2._doc;
    let v;
    const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === "boolean" ? toObjectOptions.aliases : true;
    options = options || {};
    let virtualsToApply = null;
    if (Array.isArray(options.virtuals)) {
      virtualsToApply = new Set(options.virtuals);
    } else if (options.virtuals && options.virtuals.pathsToSkip) {
      virtualsToApply = new Set(paths);
      for (let i2 = 0;i2 < options.virtuals.pathsToSkip.length; i2++) {
        if (virtualsToApply.has(options.virtuals.pathsToSkip[i2])) {
          virtualsToApply.delete(options.virtuals.pathsToSkip[i2]);
        }
      }
    }
    if (!cur) {
      return json;
    }
    for (i = 0;i < numPaths; ++i) {
      path = paths[i];
      if (virtualsToApply != null && !virtualsToApply.has(path)) {
        continue;
      }
      if (!aliases && schema.aliases.hasOwnProperty(path)) {
        continue;
      }
      assignPath = path;
      if (options.path != null) {
        if (!path.startsWith(options.path + ".")) {
          continue;
        }
        assignPath = path.substring(options.path.length + 1);
      }
      if (assignPath.indexOf(".") === -1 && assignPath === path) {
        v = virtuals[path].applyGetters(undefined, self2);
        if (v === undefined) {
          continue;
        }
        v = clone2(v, options);
        json[assignPath] = v;
        continue;
      }
      const parts = assignPath.split(".");
      v = clone2(self2.get(path), options);
      if (v === undefined) {
        continue;
      }
      const plen = parts.length;
      cur = json;
      for (let j = 0;j < plen - 1; ++j) {
        cur[parts[j]] = cur[parts[j]] || {};
        cur = cur[parts[j]];
      }
      cur[parts[plen - 1]] = v;
    }
    return json;
  }
  function applyGetters(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths);
    let i = paths.length;
    let path;
    let cur = self2._doc;
    let v;
    if (!cur) {
      return json;
    }
    while (i--) {
      path = paths[i];
      const parts = path.split(".");
      const plen = parts.length;
      const last = plen - 1;
      let branch = json;
      let part;
      cur = self2._doc;
      if (!self2.$__isSelected(path)) {
        continue;
      }
      for (let ii = 0;ii < plen; ++ii) {
        part = parts[ii];
        v = cur[part];
        if (branch != null && typeof branch !== "object") {
          break;
        } else if (ii === last) {
          branch[part] = schema.paths[path].applyGetters(branch[part], self2);
          if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {
            for (let i2 = 0;i2 < branch[part].length; ++i2) {
              branch[part][i2] = schema.paths[path].$embeddedSchemaType.applyGetters(branch[part][i2], self2);
            }
          }
        } else if (v == null) {
          if (part in cur) {
            branch[part] = v;
          }
          break;
        } else {
          branch = branch[part] || (branch[part] = {});
        }
        cur = v;
      }
    }
    return json;
  }
  function applySchemaTypeTransforms(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self2._doc;
    if (!cur) {
      return json;
    }
    for (const path of paths) {
      const schematype = schema.paths[path];
      const topLevelTransformFunction = schematype.options.transform ?? schematype.constructor?.defaultOptions?.transform;
      const embeddedSchemaTypeTransformFunction = schematype.$embeddedSchemaType?.options?.transform ?? schematype.$embeddedSchemaType?.constructor?.defaultOptions?.transform;
      if (typeof topLevelTransformFunction === "function") {
        const val = self2.$get(path);
        if (val === undefined) {
          continue;
        }
        const transformedValue = topLevelTransformFunction.call(self2, val);
        throwErrorIfPromise(path, transformedValue);
        utils.setValue(path, transformedValue, json);
      } else if (typeof embeddedSchemaTypeTransformFunction === "function") {
        const val = self2.$get(path);
        if (val === undefined) {
          continue;
        }
        const vals = [].concat(val);
        for (let i = 0;i < vals.length; ++i) {
          const transformedValue = embeddedSchemaTypeTransformFunction.call(self2, vals[i]);
          vals[i] = transformedValue;
          throwErrorIfPromise(path, transformedValue);
        }
        json[path] = vals;
      }
    }
    return json;
  }
  function throwErrorIfPromise(path, transformedValue) {
    if (isPromise(transformedValue)) {
      throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
    }
  }
  /*!
   * ignore
   */
  function omitDeselectedFields(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self2._doc;
    if (!cur) {
      return json;
    }
    let selected = self2.$__.selected;
    if (selected === undefined) {
      selected = {};
      queryhelpers.applyPaths(selected, schema);
    }
    if (selected == null || Object.keys(selected).length === 0) {
      return json;
    }
    for (const path of paths) {
      if (selected[path] != null && !selected[path]) {
        delete json[path];
      }
    }
    return json;
  }
  Document.prototype.toJSON = function(options) {
    return this.$toObject(options, true);
  };
  /*!
   * ignore
   */
  Document.prototype.ownerDocument = function() {
    return this;
  };
  Document.prototype.parent = function() {
    if (this.$isSubdocument || this.$__.wasPopulated) {
      return this.$__.parent;
    }
    return this;
  };
  Document.prototype.$parent = Document.prototype.parent;
  Document.prototype.inspect = function(options) {
    const isPOJO = utils.isPOJO(options);
    let opts;
    if (isPOJO) {
      opts = options;
      opts.minimize = false;
    }
    const ret = arguments.length > 0 ? this.toObject(opts) : this.toObject();
    if (ret == null) {
      return "MongooseDocument { " + ret + " }";
    }
    return ret;
  };
  if (inspect.custom) {
    Document.prototype[inspect.custom] = Document.prototype.inspect;
  }
  Document.prototype.toString = function() {
    const ret = this.inspect();
    if (typeof ret === "string") {
      return ret;
    }
    return inspect(ret);
  };
  Document.prototype.equals = function(doc) {
    if (!doc) {
      return false;
    }
    const tid = this.$__getValue("_id");
    const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
    if (!tid && !docid) {
      return deepEqual(this, doc);
    }
    return tid && tid.equals ? tid.equals(docid) : tid === docid;
  };
  Document.prototype.populate = async function populate() {
    const pop = {};
    const args = [...arguments];
    if (typeof args[args.length - 1] === "function") {
      throw new MongooseError("Document.prototype.populate() no longer accepts a callback");
    }
    if (args.length !== 0) {
      const res = utils.populate.apply(null, args);
      for (const populateOptions of res) {
        pop[populateOptions.path] = populateOptions;
      }
    }
    const paths = utils.object.vals(pop);
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
      topLevelModel = this.$__[scopeSymbol].constructor;
      const nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) {
        populateOptions.path = nestedPath + "." + populateOptions.path;
      });
    }
    if (this.$session() != null) {
      const session = this.$session();
      paths.forEach((path) => {
        if (path.options == null) {
          path.options = { session };
          return;
        }
        if (!("session" in path.options)) {
          path.options.session = session;
        }
      });
    }
    paths.forEach((p) => {
      p._localModel = topLevelModel;
    });
    return topLevelModel.populate(this, paths);
  };
  Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
    let keys = [];
    if (this.$__.populated != null) {
      keys = keys.concat(Object.keys(this.$__.populated));
    }
    let result = [];
    for (const key of keys) {
      const value = this.$get(key);
      if (Array.isArray(value)) {
        result = result.concat(value);
      } else if (value instanceof Document) {
        result.push(value);
      }
    }
    return result;
  };
  Document.prototype.populated = function(path, val, options) {
    if (val == null || val === true) {
      if (!this.$__.populated) {
        return;
      }
      if (typeof path !== "string") {
        return;
      }
      const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
      const v = this.$__.populated[_path];
      if (v) {
        return val === true ? v : v.value;
      }
      return;
    }
    this.$__.populated || (this.$__.populated = {});
    this.$__.populated[path] = { value: val, options };
    const pieces = path.split(".");
    for (let i = 0;i < pieces.length - 1; ++i) {
      const subpath = pieces.slice(0, i + 1).join(".");
      const subdoc = this.$get(subpath);
      if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {
        const rest = pieces.slice(i + 1).join(".");
        subdoc.$populated(rest, val, options);
        break;
      }
    }
    return val;
  };
  Document.prototype.$populated = Document.prototype.populated;
  Document.prototype.$assertPopulated = function $assertPopulated(path, values) {
    if (Array.isArray(path)) {
      path.forEach((p) => this.$assertPopulated(p, values));
      return this;
    }
    if (arguments.length > 1) {
      this.$set(values);
    }
    if (!this.$populated(path)) {
      throw new MongooseError(`Expected path "${path}" to be populated`);
    }
    return this;
  };
  Document.prototype.depopulate = function(path) {
    if (typeof path === "string") {
      path = path.indexOf(" ") === -1 ? [path] : path.split(" ");
    }
    let populatedIds;
    const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
    const populated = this.$__ && this.$__.populated || {};
    if (arguments.length === 0) {
      for (const virtualKey of virtualKeys) {
        delete this.$$populatedVirtuals[virtualKey];
        delete this._doc[virtualKey];
        delete populated[virtualKey];
      }
      const keys = Object.keys(populated);
      for (const key of keys) {
        populatedIds = this.$populated(key);
        if (!populatedIds) {
          continue;
        }
        delete populated[key];
        if (Array.isArray(populatedIds)) {
          const arr = utils.getValue(key, this._doc);
          if (arr.isMongooseArray) {
            const rawArray = arr.__array;
            for (let i = 0;i < rawArray.length; ++i) {
              const subdoc = rawArray[i];
              if (subdoc == null) {
                continue;
              }
              rawArray[i] = subdoc instanceof Document ? subdoc._doc._id : subdoc._id;
            }
          } else {
            utils.setValue(key, populatedIds, this._doc);
          }
        } else {
          utils.setValue(key, populatedIds, this._doc);
        }
      }
      return this;
    }
    for (const singlePath of path) {
      populatedIds = this.$populated(singlePath);
      delete populated[singlePath];
      if (virtualKeys.indexOf(singlePath) !== -1) {
        delete this.$$populatedVirtuals[singlePath];
        delete this._doc[singlePath];
      } else if (populatedIds) {
        if (Array.isArray(populatedIds)) {
          const arr = utils.getValue(singlePath, this._doc);
          if (arr.isMongooseArray) {
            const rawArray = arr.__array;
            for (let i = 0;i < rawArray.length; ++i) {
              const subdoc = rawArray[i];
              if (subdoc == null) {
                continue;
              }
              rawArray[i] = subdoc instanceof Document ? subdoc._doc._id : subdoc._id;
            }
          } else {
            utils.setValue(singlePath, populatedIds, this._doc);
          }
        } else {
          utils.setValue(singlePath, populatedIds, this._doc);
        }
      }
    }
    return this;
  };
  Document.prototype.$__fullPath = function(path) {
    return path || "";
  };
  Document.prototype.getChanges = function() {
    const delta2 = this.$__delta();
    const changes = delta2 ? delta2[1] : {};
    return changes;
  };
  Document.prototype.$__delta = function $__delta() {
    const dirty = this.$__dirty();
    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
    if (optimisticConcurrency) {
      if (Array.isArray(optimisticConcurrency)) {
        const optCon = new Set(optimisticConcurrency);
        const modPaths = this.modifiedPaths();
        if (modPaths.find((path) => optCon.has(path))) {
          this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
        }
      } else {
        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
      }
    }
    if (!dirty.length && VERSION_ALL !== this.$__.version) {
      return;
    }
    const where = {};
    const delta2 = {};
    const len = dirty.length;
    const divergent = [];
    let d = 0;
    where._id = this._doc._id;
    if ((where && where._id && where._id.$__ || null) != null) {
      where._id = where._id.toObject({ transform: false, depopulate: true });
    }
    for (;d < len; ++d) {
      const data = dirty[d];
      let value = data.value;
      const match = checkDivergentArray(this, data.path, value);
      if (match) {
        divergent.push(match);
        continue;
      }
      const pop = this.$populated(data.path, true);
      if (!pop && this.$__.selected) {
        const pathSplit = data.path.split(".");
        const top = pathSplit[0];
        if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
          if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
            where[top] = this.$__.selected[top];
            pathSplit[1] = "$";
            data.path = pathSplit.join(".");
          } else {
            divergent.push(data.path);
            continue;
          }
        }
      }
      if (this.$isDefault(data.path) && this.$__.selected) {
        if (data.path.indexOf(".") === -1 && isPathExcluded(this.$__.selected, data.path)) {
          continue;
        }
        const pathsToCheck = parentPaths(data.path);
        if (pathsToCheck.find((path) => isPathExcluded(this.$__.isSelected, path))) {
          continue;
        }
      }
      if (divergent.length)
        continue;
      if (value === undefined) {
        operand(this, where, delta2, data, 1, "$unset");
      } else if (value === null) {
        operand(this, where, delta2, data, null);
      } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {
        handleAtomics(this, where, delta2, data, value);
      } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
        value = value.toObject();
        operand(this, where, delta2, data, value);
      } else {
        if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {
          const val = this.$__.primitiveAtomics[data.path];
          const op = firstKey(val);
          operand(this, where, delta2, data, val[op], op);
        } else {
          value = clone2(value, {
            depopulate: true,
            transform: false,
            virtuals: false,
            getters: false,
            omitUndefined: true,
            _isNested: true
          });
          operand(this, where, delta2, data, value);
        }
      }
    }
    if (divergent.length) {
      return new DivergentArrayError(divergent);
    }
    if (this.$__.version) {
      this.$__version(where, delta2);
    }
    if (Object.keys(delta2).length === 0) {
      return [where, null];
    }
    return [where, delta2];
  };
  function checkDivergentArray(doc, path, array) {
    const pop = doc.$populated(path, true);
    if (!pop && doc.$__.selected) {
      const top = path.split(".")[0];
      if (doc.$__.selected[top + ".$"]) {
        return top;
      }
    }
    if (!(pop && utils.isMongooseArray(array)))
      return;
    const check2 = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, "limit") || pop.options.options && pop.options.options.skip || pop.options.select && (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
    if (check2) {
      const atomics = array[arrayAtomicsSymbol];
      if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
        return path;
      }
    }
  }
  function operand(self2, where, delta2, data, val, op) {
    op || (op = "$set");
    if (!delta2[op])
      delta2[op] = {};
    delta2[op][data.path] = val;
    if (self2.$__schema.options.versionKey === false)
      return;
    if (shouldSkipVersioning(self2, data.path))
      return;
    if (VERSION_ALL === (VERSION_ALL & self2.$__.version))
      return;
    if (self2.$__schema.options.optimisticConcurrency) {
      return;
    }
    switch (op) {
      case "$set":
      case "$unset":
      case "$pop":
      case "$pull":
      case "$pullAll":
      case "$push":
      case "$addToSet":
      case "$inc":
        break;
      default:
        return;
    }
    if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
      if (/\.\d+\.|\.\d+$/.test(data.path)) {
        self2.$__.version = VERSION_ALL;
      } else {
        self2.$__.version = VERSION_INC;
      }
    } else if (/^\$p/.test(op)) {
      self2.$__.version = VERSION_ALL;
    } else if (Array.isArray(val)) {
      self2.$__.version = VERSION_ALL;
    } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
      self2.$__.version = VERSION_WHERE;
    }
  }
  function handleAtomics(self2, where, delta2, data, value) {
    if (delta2.$set && delta2.$set[data.path]) {
      return;
    }
    if (typeof value.$__getAtomics === "function") {
      value.$__getAtomics().forEach(function(atomic) {
        const op2 = atomic[0];
        const val2 = atomic[1];
        operand(self2, where, delta2, data, val2, op2);
      });
      return;
    }
    const atomics = value[arrayAtomicsSymbol];
    const ops = Object.keys(atomics);
    let i = ops.length;
    let val;
    let op;
    if (i === 0) {
      if (utils.isMongooseObject(value)) {
        value = value.toObject({ depopulate: 1, _isNested: true });
      } else if (value.valueOf) {
        value = value.valueOf();
      }
      return operand(self2, where, delta2, data, value);
    }
    function iter(mem) {
      return utils.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
    }
    while (i--) {
      op = ops[i];
      val = atomics[op];
      if (utils.isMongooseObject(val)) {
        val = val.toObject({ depopulate: true, transform: false, _isNested: true });
      } else if (Array.isArray(val)) {
        val = val.map(iter);
      } else if (val.valueOf) {
        val = val.valueOf();
      }
      if (op === "$addToSet") {
        val = { $each: val };
      }
      operand(self2, where, delta2, data, val, op);
    }
  }
  function shouldSkipVersioning(self2, path) {
    const skipVersioning = self2.$__schema.options.skipVersioning;
    if (!skipVersioning)
      return false;
    path = path.replace(/\.\d+\./, ".");
    return skipVersioning[path];
  }
  Document.prototype.$clone = function() {
    const Model = this.constructor;
    const clonedDoc = new Model;
    clonedDoc.$isNew = this.$isNew;
    if (this._doc) {
      clonedDoc._doc = clone2(this._doc, { retainDocuments: true });
    }
    if (this.$__) {
      const Cache = this.$__.constructor;
      const clonedCache = new Cache;
      for (const key of Object.getOwnPropertyNames(this.$__)) {
        if (key === "activePaths") {
          continue;
        }
        clonedCache[key] = clone2(this.$__[key]);
      }
      Object.assign(clonedCache.activePaths, clone2({ ...this.$__.activePaths }));
      clonedDoc.$__ = clonedCache;
    }
    return clonedDoc;
  };
  Document.prototype.$createModifiedPathsSnapshot = function $createModifiedPathsSnapshot() {
    const subdocSnapshot = new WeakMap;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        subdocSnapshot.set(child, child.$__.activePaths.clone());
      }
    }
    return new ModifiedPathsSnapshot(subdocSnapshot, this.$__.activePaths.clone(), this.$__.version);
  };
  Document.prototype.$restoreModifiedPathsSnapshot = function $restoreModifiedPathsSnapshot(snapshot) {
    this.$__.activePaths = snapshot.activePaths.clone();
    this.$__.version = snapshot.version;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        if (snapshot.subdocSnapshot.has(child)) {
          child.$__.activePaths = snapshot.subdocSnapshot.get(child);
        }
      }
    }
    return this;
  };
  Document.prototype.$clearModifiedPaths = function $clearModifiedPaths() {
    this.$__.activePaths.clear("modify");
    this.$__.activePaths.clear("init");
    this.$__.version = 0;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        child.$clearModifiedPaths();
      }
    }
    return this;
  };
  /*!
   * Check if the given document only has primitive values
   */
  Document.prototype.$__hasOnlyPrimitiveValues = function $__hasOnlyPrimitiveValues() {
    return !this.$__.populated && !this.$__.wasPopulated && (this._doc == null || Object.values(this._doc).every((v) => {
      return v == null || typeof v !== "object" || utils.isNativeObject(v) && !Array.isArray(v) || isBsonType(v, "ObjectId") || isBsonType(v, "Decimal128");
    }));
  };
  /*!
   * Module exports.
   */
  Document.VERSION_WHERE = VERSION_WHERE;
  Document.VERSION_INC = VERSION_INC;
  Document.VERSION_ALL = VERSION_ALL;
  Document.ValidationError = ValidationError2;
  module.exports = exports = Document;
});

// node_modules/mongoose/lib/utils.js
var require_utils3 = __commonJS((exports) => {
  /*!
   * Module dependencies.
   */
  var UUID = require_bson().UUID;
  var ms = require_ms();
  var mpath = require_mpath();
  var ObjectId2 = require_objectid();
  var PopulateOptions = require_populateOptions();
  var clone2 = require_clone();
  var immediate = require_immediate();
  var isObject2 = require_isObject();
  var isMongooseArray = require_isMongooseArray();
  var isMongooseDocumentArray = require_isMongooseDocumentArray();
  var isBsonType = require_isBsonType();
  var isPOJO = require_isPOJO();
  var getFunctionName = require_getFunctionName();
  var isMongooseObject = require_isMongooseObject();
  var promiseOrCallback = require_promiseOrCallback();
  var schemaMerge = require_merge();
  var specialProperties = require_specialProperties();
  var { trustedSymbol } = require_trusted();
  var Document;
  exports.specialProperties = specialProperties;
  exports.isMongooseArray = isMongooseArray.isMongooseArray;
  exports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;
  exports.registerMongooseArray = isMongooseArray.registerMongooseArray;
  exports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;
  var oneSpaceRE = /\s/;
  var manySpaceRE = /\s+/;
  exports.toCollectionName = function(name, pluralize) {
    if (name === "system.profile") {
      return name;
    }
    if (name === "system.indexes") {
      return name;
    }
    if (typeof pluralize === "function") {
      if (typeof name !== "string") {
        throw new TypeError("Collection name must be a string");
      }
      if (name.length === 0) {
        throw new TypeError("Collection name cannot be empty");
      }
      return pluralize(name);
    }
    return name;
  };
  exports.deepEqual = function deepEqual(a12, b) {
    if (a12 === b) {
      return true;
    }
    if (typeof a12 !== "object" || typeof b !== "object") {
      return a12 === b;
    }
    if (a12 instanceof Date && b instanceof Date) {
      return a12.getTime() === b.getTime();
    }
    if (isBsonType(a12, "ObjectId") && isBsonType(b, "ObjectId") || isBsonType(a12, "Decimal128") && isBsonType(b, "Decimal128")) {
      return a12.toString() === b.toString();
    }
    if (a12 instanceof RegExp && b instanceof RegExp) {
      return a12.source === b.source && a12.ignoreCase === b.ignoreCase && a12.multiline === b.multiline && a12.global === b.global && a12.dotAll === b.dotAll && a12.unicode === b.unicode && a12.sticky === b.sticky && a12.hasIndices === b.hasIndices;
    }
    if (a12 == null || b == null) {
      return false;
    }
    if (a12.prototype !== b.prototype) {
      return false;
    }
    if (a12 instanceof Map || b instanceof Map) {
      if (!(a12 instanceof Map) || !(b instanceof Map)) {
        return false;
      }
      return deepEqual(Array.from(a12.keys()), Array.from(b.keys())) && deepEqual(Array.from(a12.values()), Array.from(b.values()));
    }
    if (a12 instanceof Number && b instanceof Number) {
      return a12.valueOf() === b.valueOf();
    }
    if (Buffer.isBuffer(a12)) {
      return exports.buffer.areEqual(a12, b);
    }
    if (Array.isArray(a12) || Array.isArray(b)) {
      if (!Array.isArray(a12) || !Array.isArray(b)) {
        return false;
      }
      const len = a12.length;
      if (len !== b.length) {
        return false;
      }
      for (let i = 0;i < len; ++i) {
        if (!deepEqual(a12[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a12.$__ != null) {
      a12 = a12._doc;
    } else if (isMongooseObject(a12)) {
      a12 = a12.toObject();
    }
    if (b.$__ != null) {
      b = b._doc;
    } else if (isMongooseObject(b)) {
      b = b.toObject();
    }
    const ka = Object.keys(a12);
    const kb = Object.keys(b);
    const kaLength = ka.length;
    if (kaLength !== kb.length) {
      return false;
    }
    for (let i = kaLength - 1;i >= 0; i--) {
      if (ka[i] !== kb[i]) {
        return false;
      }
    }
    for (const key of ka) {
      if (!deepEqual(a12[key], b[key])) {
        return false;
      }
    }
    return true;
  };
  exports.last = function(arr) {
    if (arr.length > 0) {
      return arr[arr.length - 1];
    }
    return;
  };
  /*!
   * ignore
   */
  exports.promiseOrCallback = promiseOrCallback;
  /*!
   * ignore
   */
  exports.cloneArrays = function cloneArrays(arr) {
    if (!Array.isArray(arr)) {
      return arr;
    }
    return arr.map((el) => exports.cloneArrays(el));
  };
  /*!
   * ignore
   */
  exports.omit = function omit(obj, keys) {
    if (keys == null) {
      return Object.assign({}, obj);
    }
    if (!Array.isArray(keys)) {
      keys = [keys];
    }
    const ret = Object.assign({}, obj);
    for (const key of keys) {
      delete ret[key];
    }
    return ret;
  };
  exports.clonePOJOsAndArrays = function clonePOJOsAndArrays(val) {
    if (val == null) {
      return val;
    }
    if (val.$__ != null) {
      return val;
    }
    if (isPOJO(val)) {
      val = { ...val };
      for (const key of Object.keys(val)) {
        val[key] = exports.clonePOJOsAndArrays(val[key]);
      }
      return val;
    }
    if (Array.isArray(val)) {
      val = [...val];
      for (let i = 0;i < val.length; ++i) {
        val[i] = exports.clonePOJOsAndArrays(val[i]);
      }
      return val;
    }
    return val;
  };
  exports.merge = function merge(to, from, options, path) {
    options = options || {};
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    if (from[trustedSymbol]) {
      to[trustedSymbol] = from[trustedSymbol];
    }
    path = path || "";
    const omitNested = options.omitNested || {};
    while (i < len) {
      key = keys[i++];
      if (options.omit && options.omit[key]) {
        continue;
      }
      if (omitNested[path]) {
        continue;
      }
      if (specialProperties.has(key)) {
        continue;
      }
      if (to[key] == null) {
        to[key] = exports.clonePOJOsAndArrays(from[key]);
      } else if (exports.isObject(from[key])) {
        if (!exports.isObject(to[key])) {
          to[key] = {};
        }
        if (from[key] != null) {
          if (options.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
            continue;
          } else if (from[key].instanceOfSchema) {
            if (to[key].instanceOfSchema) {
              schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
            } else {
              to[key] = from[key].clone();
            }
            continue;
          } else if (isBsonType(from[key], "ObjectId")) {
            to[key] = new ObjectId2(from[key]);
            continue;
          }
        }
        merge(to[key], from[key], options, path ? path + "." + key : key);
      } else if (options.overwrite) {
        to[key] = from[key];
      }
    }
    return to;
  };
  exports.toObject = function toObject(obj) {
    Document || (Document = require_document2());
    let ret;
    if (obj == null) {
      return obj;
    }
    if (obj instanceof Document) {
      return obj.toObject();
    }
    if (Array.isArray(obj)) {
      ret = [];
      for (const doc of obj) {
        ret.push(toObject(doc));
      }
      return ret;
    }
    if (exports.isPOJO(obj)) {
      ret = {};
      if (obj[trustedSymbol]) {
        ret[trustedSymbol] = obj[trustedSymbol];
      }
      for (const k of Object.keys(obj)) {
        if (specialProperties.has(k)) {
          continue;
        }
        ret[k] = toObject(obj[k]);
      }
      return ret;
    }
    return obj;
  };
  exports.isObject = isObject2;
  exports.isPOJO = require_isPOJO();
  exports.isNonBuiltinObject = function isNonBuiltinObject(val) {
    return typeof val === "object" && !exports.isNativeObject(val) && !exports.isMongooseType(val) && !(val instanceof UUID) && val != null;
  };
  exports.isNativeObject = function(arg) {
    return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
  };
  exports.isEmptyObject = function(val) {
    return val != null && typeof val === "object" && Object.keys(val).length === 0;
  };
  exports.hasKey = function hasKey(obj, key) {
    const props = Object.keys(obj);
    for (const prop of props) {
      if (prop === key) {
        return true;
      }
      if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {
        return true;
      }
    }
    return false;
  };
  exports.tick = function tick(callback) {
    if (typeof callback !== "function") {
      return;
    }
    return function() {
      try {
        callback.apply(this, arguments);
      } catch (err2) {
        immediate(function() {
          throw err2;
        });
      }
    };
  };
  exports.isMongooseType = function(v) {
    return isBsonType(v, "ObjectId") || isBsonType(v, "Decimal128") || v instanceof Buffer;
  };
  exports.isMongooseObject = isMongooseObject;
  exports.expires = function expires(object) {
    if (!(object && object.constructor.name === "Object")) {
      return;
    }
    if (!("expires" in object)) {
      return;
    }
    object.expireAfterSeconds = typeof object.expires !== "string" ? object.expires : Math.round(ms(object.expires) / 1000);
    delete object.expires;
  };
  exports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {
    let obj = null;
    if (arguments.length === 1) {
      if (path instanceof PopulateOptions) {
        path._docs = {};
        path._childDocs = [];
        return [path];
      }
      if (Array.isArray(path)) {
        const singles = makeSingles(path);
        return singles.map((o) => exports.populate(o)[0]);
      }
      if (exports.isObject(path)) {
        obj = Object.assign({}, path);
      } else {
        obj = { path };
      }
    } else if (typeof model === "object") {
      obj = {
        path,
        select,
        match: model,
        options: match
      };
    } else {
      obj = {
        path,
        select,
        model,
        match,
        options,
        populate: subPopulate,
        justOne,
        count
      };
    }
    if (typeof obj.path !== "string" && !(Array.isArray(obj.path) && obj.path.every((el) => typeof el === "string"))) {
      throw new TypeError("utils.populate: invalid path. Expected string or array of strings. Got typeof `" + typeof path + "`");
    }
    return _populateObj(obj);
    function makeSingles(arr) {
      const ret = [];
      arr.forEach(function(obj2) {
        if (oneSpaceRE.test(obj2.path)) {
          const paths = obj2.path.split(manySpaceRE);
          paths.forEach(function(p) {
            const copy = Object.assign({}, obj2);
            copy.path = p;
            ret.push(copy);
          });
        } else {
          ret.push(obj2);
        }
      });
      return ret;
    }
  };
  function _populateObj(obj) {
    if (Array.isArray(obj.populate)) {
      const ret2 = [];
      obj.populate.forEach(function(obj2) {
        if (oneSpaceRE.test(obj2.path)) {
          const copy = Object.assign({}, obj2);
          const paths2 = copy.path.split(manySpaceRE);
          paths2.forEach(function(p) {
            copy.path = p;
            ret2.push(exports.populate(copy)[0]);
          });
        } else {
          ret2.push(exports.populate(obj2)[0]);
        }
      });
      obj.populate = exports.populate(ret2);
    } else if (obj.populate != null && typeof obj.populate === "object") {
      obj.populate = exports.populate(obj.populate);
    }
    const ret = [];
    const paths = oneSpaceRE.test(obj.path) ? obj.path.split(manySpaceRE) : Array.isArray(obj.path) ? obj.path : [obj.path];
    if (obj.options != null) {
      obj.options = clone2(obj.options);
    }
    for (const path of paths) {
      ret.push(new PopulateOptions(Object.assign({}, obj, { path })));
    }
    return ret;
  }
  exports.getValue = function(path, obj, map3) {
    return mpath.get(path, obj, getValueLookup, map3);
  };
  /*!
   * ignore
   */
  var mapGetterOptions = Object.freeze({ getters: false });
  function getValueLookup(obj, part) {
    if (part === "$*" && obj instanceof Map) {
      return obj;
    }
    let _from = obj?._doc || obj;
    if (_from != null && _from.isMongooseArrayProxy) {
      _from = _from.__array;
    }
    return _from instanceof Map ? _from.get(part, mapGetterOptions) : _from[part];
  }
  exports.setValue = function(path, val, obj, map3, _copying) {
    mpath.set(path, val, obj, "_doc", map3, _copying);
  };
  exports.object = {};
  exports.object.vals = function vals(o) {
    const keys = Object.keys(o);
    let i = keys.length;
    const ret = [];
    while (i--) {
      ret.push(o[keys[i]]);
    }
    return ret;
  };
  var hop = Object.prototype.hasOwnProperty;
  exports.object.hasOwnProperty = function(obj, prop) {
    return hop.call(obj, prop);
  };
  exports.isNullOrUndefined = function(val) {
    return val === null || val === undefined;
  };
  /*!
   * ignore
   */
  exports.array = {};
  exports.array.flatten = function flatten(arr, filter, ret) {
    ret || (ret = []);
    arr.forEach(function(item) {
      if (Array.isArray(item)) {
        flatten(item, filter, ret);
      } else {
        if (!filter || filter(item)) {
          ret.push(item);
        }
      }
    });
    return ret;
  };
  /*!
   * ignore
   */
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  exports.hasUserDefinedProperty = function(obj, key) {
    if (obj == null) {
      return false;
    }
    if (Array.isArray(key)) {
      for (const k of key) {
        if (exports.hasUserDefinedProperty(obj, k)) {
          return true;
        }
      }
      return false;
    }
    if (_hasOwnProperty.call(obj, key)) {
      return true;
    }
    if (typeof obj === "object" && key in obj) {
      const v = obj[key];
      return v !== Object.prototype[key] && v !== Array.prototype[key];
    }
    return false;
  };
  /*!
   * ignore
   */
  var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
  exports.isArrayIndex = function(val) {
    if (typeof val === "number") {
      return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    if (typeof val === "string") {
      if (!/^\d+$/.test(val)) {
        return false;
      }
      val = +val;
      return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    return false;
  };
  exports.array.unique = function(arr) {
    const primitives = new Set;
    const ids = new Set;
    const ret = [];
    for (const item of arr) {
      if (typeof item === "number" || typeof item === "string" || item == null) {
        if (primitives.has(item)) {
          continue;
        }
        ret.push(item);
        primitives.add(item);
      } else if (isBsonType(item, "ObjectId")) {
        if (ids.has(item.toString())) {
          continue;
        }
        ret.push(item);
        ids.add(item.toString());
      } else {
        ret.push(item);
      }
    }
    return ret;
  };
  exports.buffer = {};
  exports.buffer.areEqual = function(a12, b) {
    if (!Buffer.isBuffer(a12)) {
      return false;
    }
    if (!Buffer.isBuffer(b)) {
      return false;
    }
    if (a12.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a12.length;i < len; ++i) {
      if (a12[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  exports.getFunctionName = getFunctionName;
  exports.decorate = function(destination, source) {
    for (const key in source) {
      if (specialProperties.has(key)) {
        continue;
      }
      destination[key] = source[key];
    }
  };
  exports.mergeClone = function(to, fromObj) {
    if (isMongooseObject(fromObj)) {
      fromObj = fromObj.toObject({
        transform: false,
        virtuals: false,
        depopulate: true,
        getters: false,
        flattenDecimals: false
      });
    }
    const keys = Object.keys(fromObj);
    const len = keys.length;
    let i = 0;
    let key;
    while (i < len) {
      key = keys[i++];
      if (specialProperties.has(key)) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = clone2(fromObj[key], {
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      } else {
        let val = fromObj[key];
        if (val != null && val.valueOf && !(val instanceof Date)) {
          val = val.valueOf();
        }
        if (exports.isObject(val)) {
          let obj = val;
          if (isMongooseObject(val) && !val.isMongooseBuffer) {
            obj = obj.toObject({
              transform: false,
              virtuals: false,
              depopulate: true,
              getters: false,
              flattenDecimals: false
            });
          }
          if (val.isMongooseBuffer) {
            obj = Buffer.from(obj);
          }
          exports.mergeClone(to[key], obj);
        } else {
          to[key] = clone2(val, {
            flattenDecimals: false
          });
        }
      }
    }
  };
  exports.each = function(arr, fn) {
    for (const item of arr) {
      fn(item);
    }
  };
  exports.renameObjKey = function(oldObj, oldKey, newKey) {
    const keys = Object.keys(oldObj);
    return keys.reduce((acc, val) => {
      if (val === oldKey) {
        acc[newKey] = oldObj[oldKey];
      } else {
        acc[val] = oldObj[val];
      }
      return acc;
    }, {});
  };
  /*!
   * ignore
   */
  exports.getOption = function(name) {
    const sources = Array.prototype.slice.call(arguments, 1);
    for (const source of sources) {
      if (source == null) {
        continue;
      }
      if (source[name] != null) {
        return source[name];
      }
    }
    return null;
  };
  /*!
   * ignore
   */
  exports.noop = function() {
  };
  exports.errorToPOJO = function errorToPOJO(error) {
    const isError = error instanceof Error;
    if (!isError) {
      throw new Error("`error` must be `instanceof Error`.");
    }
    const ret = {};
    for (const properyName of Object.getOwnPropertyNames(error)) {
      ret[properyName] = error[properyName];
    }
    return ret;
  };
  /*!
   * ignore
   */
  exports.warn = function warn(message) {
    return process.emitWarning(message, { code: "MONGOOSE" });
  };
  exports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {
    if (timestampsOption == null) {
      return;
    }
    writeOperation.timestamps = timestampsOption;
  };
});

// node_modules/mongoose/lib/schemaType.js
var require_schemaType = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();
  var SchemaTypeOptions = require_schemaTypeOptions();
  var $exists = require_exists();
  var $type = require_type();
  var clone2 = require_clone();
  var handleImmutable = require_handleImmutable();
  var isAsyncFunction = require_isAsyncFunction();
  var isSimpleValidator = require_isSimpleValidator();
  var immediate = require_immediate();
  var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
  var utils = require_utils3();
  var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
  var documentIsModified = require_symbols().documentIsModified;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var CastError = MongooseError.CastError;
  var ValidatorError = MongooseError.ValidatorError;
  var setOptionsForDefaults = { _skipMarkModified: true };
  function SchemaType(path, options, instance) {
    this[schemaTypeSymbol] = true;
    this.path = path;
    this.instance = instance;
    this.validators = [];
    this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
    this.setters = this.constructor.hasOwnProperty("setters") ? this.constructor.setters.slice() : [];
    this.splitPath();
    options = options || {};
    const defaultOptions = this.constructor.defaultOptions || {};
    const defaultOptionsKeys = Object.keys(defaultOptions);
    for (const option of defaultOptionsKeys) {
      if (option === "validate") {
        this.validate(defaultOptions.validate);
      } else if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {
        options[option] = defaultOptions[option];
      }
    }
    if (options.select == null) {
      delete options.select;
    }
    const Options = this.OptionsConstructor || SchemaTypeOptions;
    this.options = new Options(options);
    this._index = null;
    if (utils.hasUserDefinedProperty(this.options, "immutable")) {
      this.$immutable = this.options.immutable;
      handleImmutable(this);
    }
    const keys = Object.keys(this.options);
    for (const prop of keys) {
      if (prop === "cast") {
        if (Array.isArray(this.options[prop])) {
          this.castFunction.apply(this, this.options[prop]);
        } else {
          this.castFunction(this.options[prop]);
        }
        continue;
      }
      if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
        if (prop === "index" && this._index) {
          if (options.index === false) {
            const index = this._index;
            if (typeof index === "object" && index != null) {
              if (index.unique) {
                throw new Error('Path "' + this.path + '" may not have `index` ' + "set to false and `unique` set to true");
              }
              if (index.sparse) {
                throw new Error('Path "' + this.path + '" may not have `index` ' + "set to false and `sparse` set to true");
              }
            }
            this._index = false;
          }
          continue;
        }
        const val = options[prop];
        if (prop === "default") {
          this.default(val);
          continue;
        }
        const opts = Array.isArray(val) ? val : [val];
        this[prop].apply(this, opts);
      }
    }
    Object.defineProperty(this, "$$context", {
      enumerable: false,
      configurable: false,
      writable: true,
      value: null
    });
  }
  SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
  SchemaType.prototype.path;
  SchemaType.prototype.validators;
  SchemaType.prototype.isRequired;
  SchemaType.prototype.splitPath = function() {
    if (this._presplitPath != null) {
      return this._presplitPath;
    }
    if (this.path == null) {
      return;
    }
    this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
    return this._presplitPath;
  };
  SchemaType.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = (v) => v;
    }
    this._cast = caster;
    return this._cast;
  };
  SchemaType.prototype.castFunction = function castFunction(caster, message) {
    if (arguments.length === 0) {
      return this._castFunction;
    }
    if (caster === false) {
      caster = this.constructor._defaultCaster || ((v) => v);
    }
    if (typeof caster === "string") {
      this._castErrorMessage = caster;
      return this._castFunction;
    }
    if (caster != null) {
      this._castFunction = caster;
    }
    if (message != null) {
      this._castErrorMessage = message;
    }
    return this._castFunction;
  };
  SchemaType.prototype.cast = function cast() {
    throw new Error("Base SchemaType class does not implement a `cast()` function");
  };
  SchemaType.set = function set(option, value) {
    if (!this.hasOwnProperty("defaultOptions")) {
      this.defaultOptions = Object.assign({}, this.defaultOptions);
    }
    this.defaultOptions[option] = value;
  };
  SchemaType.get = function(getter) {
    this.getters = this.hasOwnProperty("getters") ? this.getters : [];
    this.getters.push(getter);
  };
  SchemaType.prototype.default = function(val) {
    if (arguments.length === 1) {
      if (val === undefined) {
        this.defaultValue = undefined;
        return;
      }
      if (val != null && val.instanceOfSchema) {
        throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
      }
      this.defaultValue = val;
      return this.defaultValue;
    } else if (arguments.length > 1) {
      this.defaultValue = [...arguments];
    }
    return this.defaultValue;
  };
  SchemaType.prototype.index = function(options) {
    this._index = options;
    utils.expires(this._index);
    return this;
  };
  SchemaType.prototype.unique = function unique(value, message) {
    if (this._index === false) {
      if (!value) {
        return;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `unique` set to true");
    }
    if (!this.options.hasOwnProperty("index") && value === false) {
      return this;
    }
    if (this._index == null || this._index === true) {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.unique = !!value;
    if (typeof message === "string") {
      this._duplicateKeyErrorMessage = message;
    }
    return this;
  };
  SchemaType.prototype.text = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return this;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `text` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index === null || this._index === undefined || typeof this._index === "boolean") {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.text = bool;
    return this;
  };
  SchemaType.prototype.sparse = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return this;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `sparse` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index == null || typeof this._index === "boolean") {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.sparse = bool;
    return this;
  };
  SchemaType.prototype.immutable = function(bool) {
    this.$immutable = bool;
    handleImmutable(this);
    return this;
  };
  SchemaType.prototype.transform = function(fn) {
    this.options.transform = fn;
    return this;
  };
  SchemaType.prototype.set = function(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("A setter must be a function.");
    }
    this.setters.push(fn);
    return this;
  };
  SchemaType.prototype.get = function(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("A getter must be a function.");
    }
    this.getters.push(fn);
    return this;
  };
  SchemaType.prototype.validateAll = function(validators) {
    for (let i = 0;i < validators.length; i++) {
      this.validate(validators[i]);
    }
    return this;
  };
  SchemaType.prototype.validate = function(obj, message, type) {
    if (typeof obj === "function" || obj && utils.getFunctionName(obj.constructor) === "RegExp") {
      let properties;
      if (typeof message === "function") {
        properties = { validator: obj, message };
        properties.type = type || "user defined";
      } else if (message instanceof Object && !type) {
        properties = isSimpleValidator(message) ? Object.assign({}, message) : clone2(message);
        if (!properties.message) {
          properties.message = properties.msg;
        }
        properties.validator = obj;
        properties.type = properties.type || "user defined";
      } else {
        if (message == null) {
          message = MongooseError.messages.general.default;
        }
        if (!type) {
          type = "user defined";
        }
        properties = { message, type, validator: obj };
      }
      this.validators.push(properties);
      return this;
    }
    let i;
    let length;
    let arg;
    for (i = 0, length = arguments.length;i < length; i++) {
      arg = arguments[i];
      if (!utils.isPOJO(arg)) {
        const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()";
        throw new Error(msg);
      }
      this.validate(arg.validator, arg);
    }
    return this;
  };
  SchemaType.prototype.required = function(required, message) {
    let customOptions = {};
    if (arguments.length > 0 && required == null) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.requiredValidator;
      }, this);
      this.isRequired = false;
      delete this.originalRequiredValue;
      return this;
    }
    if (typeof required === "object") {
      customOptions = required;
      message = customOptions.message || message;
      required = required.isRequired;
    }
    if (required === false) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.requiredValidator;
      }, this);
      this.isRequired = false;
      delete this.originalRequiredValue;
      return this;
    }
    const _this = this;
    this.isRequired = true;
    this.requiredValidator = function(v) {
      const cachedRequired = this && this.$__ && this.$__.cachedRequired;
      if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
        return true;
      }
      if (cachedRequired != null && _this.path in cachedRequired) {
        const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
        delete cachedRequired[_this.path];
        return res;
      } else if (typeof required === "function") {
        return required.apply(this) ? _this.checkRequired(v, this) : true;
      }
      return _this.checkRequired(v, this);
    };
    this.originalRequiredValue = required;
    if (typeof required === "string") {
      message = required;
      required = undefined;
    }
    const msg = message || MongooseError.messages.general.required;
    this.validators.unshift(Object.assign({}, customOptions, {
      validator: this.requiredValidator,
      message: msg,
      type: "required"
    }));
    return this;
  };
  SchemaType.prototype.ref = function(ref) {
    this.options.ref = ref;
    return this;
  };
  SchemaType.prototype.getDefault = function(scope, init, options) {
    let ret;
    if (typeof this.defaultValue === "function") {
      if (this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid") {
        ret = this.defaultValue.call(scope);
      } else {
        ret = this.defaultValue.call(scope, scope);
      }
    } else {
      ret = this.defaultValue;
    }
    if (ret !== null && ret !== undefined) {
      if (typeof ret === "object" && (!this.options || !this.options.shared)) {
        ret = clone2(ret);
      }
      if (options && options.skipCast) {
        return this._applySetters(ret, scope);
      }
      const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);
      if (casted && !Array.isArray(casted) && casted.$isSingleNested) {
        casted.$__parent = scope;
      }
      return casted;
    }
    return ret;
  };
  SchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {
    let v = value;
    if (init) {
      return v;
    }
    const setters = this.setters;
    for (let i = setters.length - 1;i >= 0; i--) {
      v = setters[i].call(scope, v, priorVal, this, options);
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaType.prototype._castNullish = function _castNullish(v) {
    return v;
  };
  SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
    let v = this._applySetters(value, scope, init, priorVal, options);
    if (v == null) {
      return this._castNullish(v);
    }
    v = this.cast(v, scope, init, priorVal, options);
    return v;
  };
  SchemaType.prototype.applyGetters = function(value, scope) {
    let v = value;
    const getters = this.getters;
    const len = getters.length;
    if (len === 0) {
      return v;
    }
    for (let i = 0;i < len; ++i) {
      v = getters[i].call(scope, v, this);
    }
    return v;
  };
  SchemaType.prototype.select = function select(val) {
    this.selected = !!val;
    return this;
  };
  SchemaType.prototype.doValidate = function(value, fn, scope, options) {
    let err2 = false;
    const path = this.path;
    if (typeof fn !== "function") {
      throw new TypeError(`Must pass callback function to doValidate(), got ${typeof fn}`);
    }
    const validators = this.validators.filter((v) => typeof v === "object" && v !== null);
    let count = validators.length;
    if (!count) {
      return fn(null);
    }
    for (let i = 0, len = validators.length;i < len; ++i) {
      if (err2) {
        break;
      }
      const v = validators[i];
      const validator = v.validator;
      let ok;
      const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone2(v);
      validatorProperties.path = options && options.path ? options.path : path;
      validatorProperties.fullPath = this.$fullPath;
      validatorProperties.value = value;
      if (validator instanceof RegExp) {
        validate(validator.test(value), validatorProperties, scope);
        continue;
      }
      if (typeof validator !== "function") {
        continue;
      }
      if (value === undefined && validator !== this.requiredValidator) {
        validate(true, validatorProperties, scope);
        continue;
      }
      try {
        if (validatorProperties.propsParameter) {
          ok = validator.call(scope, value, validatorProperties);
        } else {
          ok = validator.call(scope, value);
        }
      } catch (error) {
        ok = false;
        validatorProperties.reason = error;
        if (error.message) {
          validatorProperties.message = error.message;
        }
      }
      if (ok != null && typeof ok.then === "function") {
        ok.then(function(ok2) {
          validate(ok2, validatorProperties, scope);
        }, function(error) {
          validatorProperties.reason = error;
          validatorProperties.message = error.message;
          ok = false;
          validate(ok, validatorProperties, scope);
        });
      } else {
        validate(ok, validatorProperties, scope);
      }
    }
    function validate(ok, validatorProperties, scope2) {
      if (err2) {
        return;
      }
      if (ok === undefined || ok) {
        if (--count <= 0) {
          immediate(function() {
            fn(null);
          });
        }
      } else {
        const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
        err2 = new ErrorConstructor(validatorProperties, scope2);
        err2[validatorErrorSymbol] = true;
        immediate(function() {
          fn(err2);
        });
      }
    }
  };
  function _validate(ok, validatorProperties) {
    if (ok !== undefined && !ok) {
      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
      const err2 = new ErrorConstructor(validatorProperties);
      err2[validatorErrorSymbol] = true;
      return err2;
    }
  }
  SchemaType.prototype.doValidateSync = function(value, scope, options) {
    const path = this.path;
    const count = this.validators.length;
    if (!count) {
      return null;
    }
    let validators = this.validators;
    if (value === undefined) {
      if (this.validators.length !== 0 && this.validators[0].type === "required") {
        validators = [this.validators[0]];
      } else {
        return null;
      }
    }
    let err2 = null;
    let i = 0;
    const len = validators.length;
    for (i = 0;i < len; ++i) {
      const v = validators[i];
      if (v === null || typeof v !== "object") {
        continue;
      }
      const validator = v.validator;
      const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone2(v);
      validatorProperties.path = options && options.path ? options.path : path;
      validatorProperties.fullPath = this.$fullPath;
      validatorProperties.value = value;
      let ok = false;
      if (isAsyncFunction(validator)) {
        continue;
      }
      if (validator instanceof RegExp) {
        err2 = _validate(validator.test(value), validatorProperties);
        continue;
      }
      if (typeof validator !== "function") {
        continue;
      }
      try {
        if (validatorProperties.propsParameter) {
          ok = validator.call(scope, value, validatorProperties);
        } else {
          ok = validator.call(scope, value);
        }
      } catch (error) {
        ok = false;
        validatorProperties.reason = error;
      }
      if (ok != null && typeof ok.then === "function") {
        continue;
      }
      err2 = _validate(ok, validatorProperties);
      if (err2) {
        break;
      }
    }
    return err2;
  };
  SchemaType._isRef = function(self2, value, doc, init) {
    let ref = init && self2.options && (self2.options.ref || self2.options.refPath);
    if (!ref && doc && doc.$__ != null) {
      const path = doc.$__fullPath(self2.path, true);
      const owner = doc.ownerDocument();
      ref = path != null && owner.$populated(path) || doc.$populated(self2.path);
    }
    if (ref) {
      if (value == null) {
        return true;
      }
      if (!Buffer.isBuffer(value) && value._bsontype !== "Binary" && utils.isObject(value)) {
        return true;
      }
      return init;
    }
    return false;
  };
  /*!
   * ignore
   */
  SchemaType.prototype._castRef = function _castRef(value, doc, init, options) {
    if (value == null) {
      return value;
    }
    if (value.$__ != null) {
      value.$__.wasPopulated = value.$__.wasPopulated || { value: value._doc._id };
      return value;
    }
    if (Buffer.isBuffer(value) || !utils.isObject(value)) {
      if (init) {
        return value;
      }
      throw new CastError(this.instance, value, this.path, null, this);
    }
    const path = doc.$__fullPath(this.path, true);
    const owner = doc.ownerDocument();
    const pop = owner.$populated(path, true);
    let ret = value;
    if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
      const PopulatedModel = pop ? pop.options[populateModelSymbol] : doc.constructor.db.model(this.options.ref);
      ret = PopulatedModel.hydrate(value, null, options);
      ret.$__.wasPopulated = { value: ret._doc._id, options: { [populateModelSymbol]: PopulatedModel } };
    }
    return ret;
  };
  /*!
   * ignore
   */
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  /*!
   * ignore
   */
  function handleArray(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m2) {
      return _this.castForQuery(null, m2, context);
    });
  }
  function handle$in(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m2) {
      if (Array.isArray(m2) && m2.length === 0) {
        return m2;
      }
      return _this.castForQuery(null, m2, context);
    });
  }
  SchemaType.prototype.$conditionalHandlers = {
    $all: handleArray,
    $eq: handleSingle,
    $in: handle$in,
    $ne: handleSingle,
    $nin: handle$in,
    $exists,
    $type
  };
  SchemaType.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional);
      }
      return handler.call(this, val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
  };
  SchemaType.checkRequired = function(fn) {
    if (arguments.length !== 0) {
      this._checkRequired = fn;
    }
    return this._checkRequired;
  };
  SchemaType.prototype.checkRequired = function(val) {
    return val != null;
  };
  SchemaType.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, options, this.instance);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined)
      schematype.requiredValidator = this.requiredValidator;
    if (this.defaultValue !== undefined)
      schematype.defaultValue = this.defaultValue;
    if (this.$immutable !== undefined && this.options.immutable === undefined) {
      schematype.$immutable = this.$immutable;
      handleImmutable(schematype);
    }
    if (this._index !== undefined)
      schematype._index = this._index;
    if (this.selected !== undefined)
      schematype.selected = this.selected;
    if (this.isRequired !== undefined)
      schematype.isRequired = this.isRequired;
    if (this.originalRequiredValue !== undefined)
      schematype.originalRequiredValue = this.originalRequiredValue;
    schematype.getters = this.getters.slice();
    schematype.setters = this.setters.slice();
    return schematype;
  };
  SchemaType.prototype.getEmbeddedSchemaType = function getEmbeddedSchemaType() {
    return this.$embeddedSchemaType;
  };
  /*!
   * If _duplicateKeyErrorMessage is a string, replace unique index errors "E11000 duplicate key error" with this string.
   *
   * @api private
   */
  SchemaType.prototype._duplicateKeyErrorMessage = null;
  SchemaType.prototype.toJSONSchema = function toJSONSchema(_options) {
    throw new Error(`Converting unsupported SchemaType to JSON Schema: ${this.instance} at path "${this.path}"`);
  };
  SchemaType.prototype.autoEncryptionType = function autoEncryptionType() {
    return null;
  };
  /*!
   * Module exports.
   */
  module.exports = exports = SchemaType;
  exports.CastError = CastError;
  exports.ValidatorError = ValidatorError;
});

// node_modules/mongoose/lib/options/virtualOptions.js
var require_virtualOptions = __commonJS((exports, module) => {
  var opts = require_propertyOptions();

  class VirtualOptions {
    constructor(obj) {
      Object.assign(this, obj);
      if (obj != null && obj.options != null) {
        this.options = Object.assign({}, obj.options);
      }
    }
  }
  Object.defineProperty(VirtualOptions.prototype, "ref", opts);
  Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
  Object.defineProperty(VirtualOptions.prototype, "localField", opts);
  Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
  Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
  Object.defineProperty(VirtualOptions.prototype, "count", opts);
  Object.defineProperty(VirtualOptions.prototype, "match", opts);
  Object.defineProperty(VirtualOptions.prototype, "options", opts);
  Object.defineProperty(VirtualOptions.prototype, "skip", opts);
  Object.defineProperty(VirtualOptions.prototype, "limit", opts);
  Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
  module.exports = VirtualOptions;
});

// node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS((exports, module) => {
  module.exports = function lookupLocalFields(cur, path, val) {
    if (cur == null) {
      return cur;
    }
    if (cur._doc != null) {
      cur = cur._doc;
    }
    if (arguments.length >= 3) {
      if (typeof cur !== "object") {
        return;
      }
      if (val === undefined) {
        return;
      }
      if (cur instanceof Map) {
        cur.set(path, val);
      } else {
        cur[path] = val;
      }
      return val;
    }
    if (path === "$*") {
      return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
    }
    if (cur instanceof Map) {
      return cur.get(path);
    }
    return cur[path];
  };
});

// node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js
var require_modelNamesFromRefPath = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  var isPathExcluded = require_isPathExcluded();
  var lookupLocalFields = require_lookupLocalFields();
  var mpath = require_mpath();
  var util3 = __require("util");
  var utils = require_utils3();
  var hasNumericPropRE = /(\.\d+$|\.\d+\.)/g;
  module.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {
    if (refPath == null) {
      return [];
    }
    if (typeof refPath === "string" && queryProjection != null && isPathExcluded(queryProjection, refPath)) {
      throw new MongooseError("refPath `" + refPath + "` must not be excluded in projection, got " + util3.inspect(queryProjection));
    }
    if (hasNumericPropRE.test(populatedPath)) {
      const chunks = populatedPath.split(hasNumericPropRE);
      if (chunks[chunks.length - 1] === "") {
        throw new Error("Can't populate individual element in an array");
      }
      let _refPath = "";
      let _remaining = refPath;
      for (let i = 0;i < chunks.length; i += 2) {
        const chunk = chunks[i];
        if (_remaining.startsWith(chunk + ".")) {
          _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];
          _remaining = _remaining.substring(chunk.length + 1);
        } else if (i === chunks.length - 1) {
          _refPath += _remaining;
          _remaining = "";
          break;
        } else {
          throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
        }
      }
      const refValue2 = mpath.get(_refPath, doc, lookupLocalFields);
      let modelNames2 = Array.isArray(refValue2) ? refValue2 : [refValue2];
      modelNames2 = utils.array.flatten(modelNames2);
      return modelNames2;
    }
    const refValue = mpath.get(refPath, doc, lookupLocalFields);
    let modelNames;
    if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {
      modelNames = [modelSchema.virtuals[refPath].applyGetters(undefined, doc)];
    } else {
      modelNames = Array.isArray(refValue) ? refValue : [refValue];
    }
    return modelNames;
  };
});

// node_modules/mongoose/lib/virtualType.js
var require_virtualType = __commonJS((exports, module) => {
  var modelNamesFromRefPath = require_modelNamesFromRefPath();
  var utils = require_utils3();
  var modelSymbol = require_symbols().modelSymbol;
  function VirtualType(options, name) {
    this.path = name;
    this.getters = [];
    this.setters = [];
    this.options = Object.assign({}, options);
  }
  VirtualType.prototype._applyDefaultGetters = function() {
    if (this.getters.length > 0 || this.setters.length > 0) {
      return;
    }
    const path = this.path;
    const internalProperty = "$" + path;
    this.getters.push(function() {
      return this.$locals[internalProperty];
    });
    this.setters.push(function(v) {
      this.$locals[internalProperty] = v;
    });
  };
  /*!
   * ignore
   */
  VirtualType.prototype.clone = function() {
    const clone2 = new VirtualType(this.options, this.path);
    clone2.getters = [].concat(this.getters);
    clone2.setters = [].concat(this.setters);
    return clone2;
  };
  VirtualType.prototype.get = function(fn) {
    this.getters.push(fn);
    return this;
  };
  VirtualType.prototype.set = function(fn) {
    this.setters.push(fn);
    return this;
  };
  VirtualType.prototype.applyGetters = function(value, doc) {
    if (utils.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
      value = doc.$$populatedVirtuals[this.path];
    }
    let v = value;
    for (const getter of this.getters) {
      v = getter.call(doc, v, this, doc);
    }
    return v;
  };
  VirtualType.prototype.applySetters = function(value, doc) {
    let v = value;
    for (const setter of this.setters) {
      v = setter.call(doc, v, this, doc);
    }
    return v;
  };
  VirtualType.prototype._getModelNamesForPopulate = function _getModelNamesForPopulate(doc) {
    if (this.options.refPath) {
      return modelNamesFromRefPath(this.options.refPath, doc, this.path);
    }
    let normalizedRef = null;
    if (typeof this.options.ref === "function" && !this.options.ref[modelSymbol]) {
      normalizedRef = this.options.ref.call(doc, doc);
    } else {
      normalizedRef = this.options.ref;
    }
    if (normalizedRef != null && !Array.isArray(normalizedRef)) {
      return [normalizedRef];
    }
    return normalizedRef;
  };
  /*!
   * exports
   */
  module.exports = VirtualType;
});

// node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS((exports, module) => {
  module.exports = function addAutoId(schema) {
    const _obj = { _id: { auto: true } };
    _obj._id[schema.options.typeKey] = "ObjectId";
    schema.add(_obj);
  };
});

// node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js
var require_decorateDiscriminatorIndexOptions = __commonJS((exports, module) => {
  module.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {
    const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;
    if (discriminatorName && !("sparse" in indexOptions)) {
      const discriminatorKey = schema.options.discriminatorKey;
      indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};
      indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;
    }
    return indexOptions;
  };
});

// node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS((exports, module) => {
  var get = require_get();
  var helperIsObject = require_isObject();
  var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
  module.exports = function getIndexes(schema) {
    let indexes = [];
    const schemaStack = new WeakMap;
    const indexTypes = schema.constructor.indexTypes;
    const indexByName = new Map;
    collectIndexes(schema);
    return indexes;
    function collectIndexes(schema2, prefix, baseSchema) {
      if (schemaStack.has(schema2)) {
        return;
      }
      schemaStack.set(schema2, true);
      prefix = prefix || "";
      const keys = Object.keys(schema2.paths);
      for (const key of keys) {
        const path = schema2.paths[key];
        if (baseSchema != null && baseSchema.paths[key]) {
          continue;
        }
        if (path._duplicateKeyErrorMessage != null) {
          schema2._duplicateKeyErrorMessagesByPath = schema2._duplicateKeyErrorMessagesByPath || {};
          schema2._duplicateKeyErrorMessagesByPath[key] = path._duplicateKeyErrorMessage;
        }
        if (path.$isMongooseDocumentArray || path.$isSingleNested) {
          if (get(path, "options.excludeIndexes") !== true && get(path, "schemaOptions.excludeIndexes") !== true && get(path, "schema.options.excludeIndexes") !== true) {
            collectIndexes(path.schema, prefix + key + ".");
          }
          if (path.schema.discriminators != null) {
            const discriminators = path.schema.discriminators;
            const discriminatorKeys = Object.keys(discriminators);
            for (const discriminatorKey of discriminatorKeys) {
              collectIndexes(discriminators[discriminatorKey], prefix + key + ".", path.schema);
            }
          }
          if (path.$isMongooseDocumentArray) {
            continue;
          }
        }
        const index = path._index || path.caster && path.caster._index;
        if (index !== false && index !== null && index !== undefined) {
          const field = {};
          const isObject2 = helperIsObject(index);
          const options = isObject2 ? index : {};
          const type = typeof index === "string" ? index : isObject2 ? index.type : false;
          if (type && indexTypes.indexOf(type) !== -1) {
            field[prefix + key] = type;
          } else if (options.text) {
            field[prefix + key] = "text";
            delete options.text;
          } else {
            let isDescendingIndex = false;
            if (index === "descending" || index === "desc") {
              isDescendingIndex = true;
            } else if (index === "ascending" || index === "asc") {
              isDescendingIndex = false;
            } else {
              isDescendingIndex = Number(index) === -1;
            }
            field[prefix + key] = isDescendingIndex ? -1 : 1;
          }
          delete options.type;
          if (!("background" in options)) {
            options.background = true;
          }
          if (schema2.options.autoIndex != null) {
            options._autoIndex = schema2.options.autoIndex;
          }
          const indexName = options && options.name;
          if (typeof indexName === "string") {
            if (indexByName.has(indexName)) {
              Object.assign(indexByName.get(indexName), field);
            } else {
              indexes.push([field, options]);
              indexByName.set(indexName, field);
            }
          } else {
            indexes.push([field, options]);
            indexByName.set(indexName, field);
          }
        }
      }
      schemaStack.delete(schema2);
      if (prefix) {
        fixSubIndexPaths(schema2, prefix);
      } else {
        schema2._indexes.forEach(function(index) {
          const options = index[1];
          if (!("background" in options)) {
            options.background = true;
          }
          decorateDiscriminatorIndexOptions(schema2, options);
        });
        indexes = indexes.concat(schema2._indexes);
      }
    }
    function fixSubIndexPaths(schema2, prefix) {
      const subindexes = schema2._indexes;
      const len = subindexes.length;
      for (let i = 0;i < len; ++i) {
        const indexObj = subindexes[i][0];
        const indexOptions = subindexes[i][1];
        const keys = Object.keys(indexObj);
        const klen = keys.length;
        const newindex = {};
        for (let j = 0;j < klen; ++j) {
          const key = keys[j];
          newindex[prefix + key] = indexObj[key];
        }
        const newIndexOptions = Object.assign({}, indexOptions);
        if (indexOptions != null && indexOptions.partialFilterExpression != null) {
          newIndexOptions.partialFilterExpression = {};
          const partialFilterExpression = indexOptions.partialFilterExpression;
          for (const key of Object.keys(partialFilterExpression)) {
            newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
          }
        }
        indexes.push([newindex, newIndexOptions]);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js
var require_handleReadPreferenceAliases = __commonJS((exports, module) => {
  module.exports = function handleReadPreferenceAliases(pref) {
    switch (pref) {
      case "p":
        pref = "primary";
        break;
      case "pp":
        pref = "primaryPreferred";
        break;
      case "s":
        pref = "secondary";
        break;
      case "sp":
        pref = "secondaryPreferred";
        break;
      case "n":
        pref = "nearest";
        break;
    }
    return pref;
  };
});

// node_modules/mongoose/lib/helpers/schema/idGetter.js
var require_idGetter = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function addIdGetter(schema) {
    const autoIdGetter = !schema.paths["id"] && schema.paths["_id"] && schema.options.id;
    if (!autoIdGetter) {
      return schema;
    }
    if (schema.aliases && schema.aliases.id) {
      return schema;
    }
    schema.virtual("id").get(idGetter);
    return schema;
  };
  function idGetter() {
    if (this._id != null) {
      return this._id.toString();
    }
    return null;
  }
});

// node_modules/mongoose/lib/helpers/indexes/isIndexSpecEqual.js
var require_isIndexSpecEqual = __commonJS((exports, module) => {
  module.exports = function isIndexSpecEqual(spec1, spec2) {
    const spec1Keys = Object.keys(spec1);
    const spec2Keys = Object.keys(spec2);
    if (spec1Keys.length !== spec2Keys.length) {
      return false;
    }
    for (let i = 0;i < spec1Keys.length; i++) {
      const key = spec1Keys[i];
      if (key !== spec2Keys[i] || spec1[key] !== spec2[key]) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js
var require_setPopulatedVirtualValue = __commonJS((exports, module) => {
  module.exports = function setPopulatedVirtualValue(populatedVirtuals, name, v, options) {
    if (options.justOne || options.count) {
      populatedVirtuals[name] = Array.isArray(v) ? v[0] : v;
      if (typeof populatedVirtuals[name] !== "object") {
        populatedVirtuals[name] = options.count ? v : null;
      }
    } else {
      populatedVirtuals[name] = Array.isArray(v) ? v : v == null ? [] : [v];
      populatedVirtuals[name] = populatedVirtuals[name].filter(function(doc) {
        return doc && typeof doc === "object";
      });
    }
    return populatedVirtuals[name];
  };
});

// node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS((exports, module) => {
  module.exports = function cleanPositionalOperators(path) {
    return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
  };
});

// node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS((exports, module) => {
  module.exports = handleTimestampOption;
  /*!
   * ignore
   */
  function handleTimestampOption(arg, prop) {
    if (arg == null) {
      return null;
    }
    if (typeof arg === "boolean") {
      return prop;
    }
    if (typeof arg[prop] === "boolean") {
      return arg[prop] ? prop : null;
    }
    if (!(prop in arg)) {
      return prop;
    }
    return arg[prop];
  }
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS((exports, module) => {
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var handleTimestampOption = require_handleTimestampOption();
  module.exports = applyTimestampsToChildren;
  /*!
   * ignore
   */
  function applyTimestampsToChildren(now, update, schema) {
    if (update == null) {
      return;
    }
    const keys = Object.keys(update);
    const hasDollarKey = keys.some((key) => key[0] === "$");
    if (hasDollarKey) {
      if (update.$push) {
        _applyTimestampToUpdateOperator(update.$push);
      }
      if (update.$addToSet) {
        _applyTimestampToUpdateOperator(update.$addToSet);
      }
      if (update.$set != null) {
        const keys2 = Object.keys(update.$set);
        for (const key of keys2) {
          applyTimestampsToUpdateKey(schema, key, update.$set, now);
        }
      }
      if (update.$setOnInsert != null) {
        const keys2 = Object.keys(update.$setOnInsert);
        for (const key of keys2) {
          applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
        }
      }
    }
    const updateKeys = Object.keys(update).filter((key) => key[0] !== "$");
    for (const key of updateKeys) {
      applyTimestampsToUpdateKey(schema, key, update, now);
    }
    function _applyTimestampToUpdateOperator(op) {
      for (const key of Object.keys(op)) {
        const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
        if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
          const timestamps = $path.schema.options.timestamps;
          const createdAt = handleTimestampOption(timestamps, "createdAt");
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (op[key].$each) {
            op[key].$each.forEach(function(subdoc) {
              if (updatedAt != null) {
                subdoc[updatedAt] = now;
              }
              if (createdAt != null) {
                subdoc[createdAt] = now;
              }
              applyTimestampsToChildren(now, subdoc, $path.schema);
            });
          } else {
            if (updatedAt != null) {
              op[key][updatedAt] = now;
            }
            if (createdAt != null) {
              op[key][createdAt] = now;
            }
            applyTimestampsToChildren(now, op[key], $path.schema);
          }
        }
      }
    }
  }
  function applyTimestampsToDocumentArray(arr, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    const len = arr.length;
    if (!timestamps) {
      for (let i = 0;i < len; ++i) {
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    for (let i = 0;i < len; ++i) {
      if (updatedAt != null) {
        arr[i][updatedAt] = now;
      }
      if (createdAt != null) {
        arr[i][createdAt] = now;
      }
      applyTimestampsToChildren(now, arr[i], schematype.schema);
    }
  }
  function applyTimestampsToSingleNested(subdoc, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    if (!timestamps) {
      applyTimestampsToChildren(now, subdoc, schematype.schema);
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    if (updatedAt != null) {
      subdoc[updatedAt] = now;
    }
    if (createdAt != null) {
      subdoc[createdAt] = now;
    }
    applyTimestampsToChildren(now, subdoc, schematype.schema);
  }
  function applyTimestampsToUpdateKey(schema, key, update, now) {
    const keyToSearch = cleanPositionalOperators(key);
    const path = schema.path(keyToSearch);
    if (!path) {
      return;
    }
    const parentSchemaTypes = [];
    const pieces = keyToSearch.split(".");
    for (let i = pieces.length - 1;i > 0; --i) {
      const s = schema.path(pieces.slice(0, i).join("."));
      if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
        parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s });
      }
    }
    if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
      applyTimestampsToDocumentArray(update[key], path, now);
    } else if (update[key] && path.$isSingleNested) {
      applyTimestampsToSingleNested(update[key], path, now);
    } else if (parentSchemaTypes.length > 0) {
      for (const item of parentSchemaTypes) {
        const parentPath = item.parentPath;
        const parentSchemaType = item.parentSchemaType;
        const timestamps = parentSchemaType.schema.options.timestamps;
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps || updatedAt == null) {
          continue;
        }
        if (parentSchemaType.$isSingleNested) {
          update[parentPath + "." + updatedAt] = now;
        } else if (parentSchemaType.$isMongooseDocumentArray) {
          let childPath = key.substring(parentPath.length + 1);
          if (/^\d+$/.test(childPath)) {
            update[parentPath + "." + childPath][updatedAt] = now;
            continue;
          }
          const firstDot = childPath.indexOf(".");
          childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;
          update[parentPath + "." + childPath + "." + updatedAt] = now;
        }
      }
    } else if (path.schema != null && path.schema != schema && update[key]) {
      const timestamps = path.schema.options.timestamps;
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (!timestamps) {
        return;
      }
      if (updatedAt != null) {
        update[key][updatedAt] = now;
      }
      if (createdAt != null) {
        update[key][createdAt] = now;
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var get = require_get();
  module.exports = applyTimestampsToUpdate;
  /*!
   * ignore
   */
  function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options, isReplace) {
    const updates = currentUpdate;
    let _updates = updates;
    const timestamps = get(options, "timestamps", true);
    if (!timestamps || updates == null) {
      return currentUpdate;
    }
    const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
    const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
    if (isReplace) {
      if (currentUpdate && currentUpdate.$set) {
        currentUpdate = currentUpdate.$set;
        updates.$set = {};
        _updates = updates.$set;
      }
      if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
        _updates[updatedAt] = now;
      }
      if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
        _updates[createdAt] = now;
      }
      return updates;
    }
    currentUpdate = currentUpdate || {};
    if (Array.isArray(updates)) {
      if (updatedAt == null) {
        return updates;
      }
      updates.push({ $set: { [updatedAt]: now } });
      return updates;
    }
    updates.$set = updates.$set || {};
    if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
      let timestampSet = false;
      if (updatedAt.indexOf(".") !== -1) {
        const pieces = updatedAt.split(".");
        for (let i = 1;i < pieces.length; ++i) {
          const remnant = pieces.slice(-i).join(".");
          const start = pieces.slice(0, -i).join(".");
          if (currentUpdate[start] != null) {
            currentUpdate[start][remnant] = now;
            timestampSet = true;
            break;
          } else if (currentUpdate.$set && currentUpdate.$set[start]) {
            currentUpdate.$set[start][remnant] = now;
            timestampSet = true;
            break;
          }
        }
      }
      if (!timestampSet) {
        updates.$set[updatedAt] = now;
      }
      if (updates.hasOwnProperty(updatedAt)) {
        delete updates[updatedAt];
      }
    }
    if (!skipCreatedAt && createdAt) {
      if (currentUpdate[createdAt]) {
        delete currentUpdate[createdAt];
      }
      if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
        delete currentUpdate.$set[createdAt];
      }
      let timestampSet = false;
      if (createdAt.indexOf(".") !== -1) {
        const pieces = createdAt.split(".");
        for (let i = 1;i < pieces.length; ++i) {
          const remnant = pieces.slice(-i).join(".");
          const start = pieces.slice(0, -i).join(".");
          if (currentUpdate[start] != null) {
            currentUpdate[start][remnant] = now;
            timestampSet = true;
            break;
          } else if (currentUpdate.$set && currentUpdate.$set[start]) {
            currentUpdate.$set[start][remnant] = now;
            timestampSet = true;
            break;
          }
        }
      }
      if (!timestampSet) {
        updates.$setOnInsert = updates.$setOnInsert || {};
        updates.$setOnInsert[createdAt] = now;
      }
    }
    if (Object.keys(updates.$set).length === 0) {
      delete updates.$set;
    }
    return updates;
  }
});

// node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js
var require_setDocumentTimestamps = __commonJS((exports, module) => {
  module.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {
    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
    const defaultTimestamp = currentTime != null ? currentTime() : doc.ownerDocument().constructor.base.now();
    if (!skipCreatedAt && (doc.isNew || doc.$isSubdocument) && createdAt && !doc.$__getValue(createdAt) && doc.$__isSelected(createdAt)) {
      doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });
    }
    if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {
      let ts = defaultTimestamp;
      if (doc.isNew && createdAt != null) {
        ts = doc.$__getValue(createdAt);
      }
      doc.$set(updatedAt, ts);
    }
  };
});

// node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS((exports, module) => {
  var applyTimestampsToChildren = require_applyTimestampsToChildren();
  var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
  var get = require_get();
  var handleTimestampOption = require_handleTimestampOption();
  var setDocumentTimestamps = require_setDocumentTimestamps();
  var symbols = require_symbols2();
  var replaceOps = new Set([
    "replaceOne",
    "findOneAndReplace"
  ]);
  module.exports = function setupTimestamps(schema, timestamps) {
    const childHasTimestamp = schema.childSchemas.find(withTimestamp);
    function withTimestamp(s) {
      const ts = s.schema.options.timestamps;
      return !!ts;
    }
    if (!timestamps && !childHasTimestamp) {
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
    const schemaAdditions = {};
    schema.$timestamps = { createdAt, updatedAt };
    if (createdAt && !schema.paths[createdAt]) {
      const baseImmutableCreatedAt = schema.base != null ? schema.base.get("timestamps.createdAt.immutable") : null;
      const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
      schemaAdditions[createdAt] = { [schema.options.typeKey || "type"]: Date, immutable };
    }
    if (updatedAt && !schema.paths[updatedAt]) {
      schemaAdditions[updatedAt] = Date;
    }
    schema.add(schemaAdditions);
    schema.pre("save", function timestampsPreSave(next) {
      const timestampOption = get(this, "$__.saveOptions.timestamps");
      if (timestampOption === false) {
        return next();
      }
      setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
      next();
    });
    schema.methods.initializeTimestamps = function() {
      const ts = currentTime != null ? currentTime() : this.constructor.base.now();
      if (createdAt && !this.get(createdAt)) {
        this.$set(createdAt, ts);
      }
      if (updatedAt && !this.get(updatedAt)) {
        this.$set(updatedAt, ts);
      }
      if (this.$isSubdocument) {
        return this;
      }
      const subdocs = this.$getAllSubdocs();
      for (const subdoc of subdocs) {
        if (subdoc.initializeTimestamps) {
          subdoc.initializeTimestamps();
        }
      }
      return this;
    };
    _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
    const opts = { query: true, model: false };
    schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
    schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
    schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
    schema.pre("update", opts, _setTimestampsOnUpdate);
    schema.pre("updateOne", opts, _setTimestampsOnUpdate);
    schema.pre("updateMany", opts, _setTimestampsOnUpdate);
    function _setTimestampsOnUpdate(next) {
      const now = currentTime != null ? currentTime() : this.model.base.now();
      if (replaceOps.has(this.op) && this.getUpdate() == null) {
        this.setUpdate({});
      }
      applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this._mongooseOptions, replaceOps.has(this.op));
      applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
      next();
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  var util3 = __require("util");
  module.exports = validateRef;
  function validateRef(ref, path) {
    if (typeof ref === "string") {
      return;
    }
    if (typeof ref === "function") {
      return;
    }
    throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util3.inspect(ref, { depth: 0 }));
  }
});

// node_modules/mongoose/lib/constants.js
var require_constants3 = __commonJS((exports) => {
  /*!
   * ignore
   */
  var queryOperations = Object.freeze([
    "countDocuments",
    "distinct",
    "estimatedDocumentCount",
    "find",
    "findOne",
    "findOneAndReplace",
    "findOneAndUpdate",
    "replaceOne",
    "updateMany",
    "updateOne",
    "deleteMany",
    "deleteOne",
    "findOneAndDelete"
  ]);
  exports.queryOperations = queryOperations;
  /*!
   * ignore
   */
  var queryMiddlewareFunctions = queryOperations.concat([
    "validate"
  ]);
  exports.queryMiddlewareFunctions = queryMiddlewareFunctions;
  /*!
   * ignore
   */
  var aggregateMiddlewareFunctions = [
    "aggregate"
  ];
  exports.aggregateMiddlewareFunctions = aggregateMiddlewareFunctions;
  /*!
   * ignore
   */
  var modelMiddlewareFunctions = [
    "bulkWrite",
    "createCollection",
    "insertMany"
  ];
  exports.modelMiddlewareFunctions = modelMiddlewareFunctions;
  /*!
   * ignore
   */
  var documentMiddlewareFunctions = [
    "validate",
    "save",
    "remove",
    "updateOne",
    "deleteOne",
    "init"
  ];
  exports.documentMiddlewareFunctions = documentMiddlewareFunctions;
});

// node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS((exports, module) => {
  var symbols = require_symbols2();
  var promiseOrCallback = require_promiseOrCallback();
  /*!
   * ignore
   */
  module.exports = applyHooks;
  /*!
   * ignore
   */
  applyHooks.middlewareFunctions = [
    "deleteOne",
    "save",
    "validate",
    "remove",
    "updateOne",
    "init"
  ];
  /*!
   * ignore
   */
  var alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap((fn) => [fn, `$__${fn}`]));
  function applyHooks(model, schema, options) {
    options = options || {};
    const kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1,
      nullResultByDefault: true,
      contextParameter: true
    };
    const objToDecorate = options.decorateDoc ? model : model.prototype;
    model.$appliedHooks = true;
    for (const key of Object.keys(schema.paths)) {
      const type = schema.paths[key];
      let childModel = null;
      if (type.$isSingleNested) {
        childModel = type.caster;
      } else if (type.$isMongooseDocumentArray) {
        childModel = type.Constructor;
      } else {
        continue;
      }
      if (childModel.$appliedHooks) {
        continue;
      }
      applyHooks(childModel, type.schema, { ...options, isChildSchema: true });
      if (childModel.discriminators != null) {
        const keys = Object.keys(childModel.discriminators);
        for (const key2 of keys) {
          applyHooks(childModel.discriminators[key2], childModel.discriminators[key2].schema, options);
        }
      }
    }
    const middleware = schema.s.hooks.filter((hook) => {
      if (hook.name === "updateOne" || hook.name === "deleteOne") {
        return !!hook["document"];
      }
      if (hook.name === "remove" || hook.name === "init") {
        return hook["document"] == null || !!hook["document"];
      }
      if (hook.query != null || hook.document != null) {
        return hook.document !== false;
      }
      return true;
    }).filter((hook) => {
      if (schema.methods[hook.name]) {
        return !hook.fn[symbols.builtInMiddleware];
      }
      return true;
    });
    model._middleware = middleware;
    objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
    const internalMethodsToWrap = options && options.isChildSchema ? ["save", "validate", "deleteOne"] : ["save", "validate"];
    for (const method of internalMethodsToWrap) {
      const toWrap = method === "validate" ? "$__originalValidate" : `$__${method}`;
      const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
      objToDecorate[`$__${method}`] = wrapped;
    }
    objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
    const customMethods = Object.keys(schema.methods);
    const customMethodOptions = Object.assign({}, kareemOptions, {
      checkForPromise: true
    });
    for (const method of customMethods) {
      if (alreadyHookedFunctions.has(method)) {
        continue;
      }
      if (!middleware.hasHooks(method)) {
        continue;
      }
      const originalMethod = objToDecorate[method];
      objToDecorate[method] = function() {
        const args = Array.prototype.slice.call(arguments);
        const cb = args.slice(-1).pop();
        const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
        return promiseOrCallback(cb, (callback) => {
          return this[`$__${method}`].apply(this, argsWithoutCallback.concat([callback]));
        }, model.events);
      };
      objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
    }
  }
});

// node_modules/mongoose/lib/types/double.js
var require_double = __commonJS((exports, module) => {
  module.exports = require_bson().Double;
});

// node_modules/mongoose/lib/types/map.js
var require_map = __commonJS((exports, module) => {
  var Mixed = require_mixed();
  var MongooseError = require_mongooseError();
  var clone2 = require_clone();
  var deepEqual = require_utils3().deepEqual;
  var getConstructorName = require_getConstructorName();
  var handleSpreadDoc = require_handleSpreadDoc();
  var util3 = __require("util");
  var specialProperties = require_specialProperties();
  var isBsonType = require_isBsonType();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var populateModelSymbol = require_symbols().populateModelSymbol;
  /*!
   * ignore
   */

  class MongooseMap extends Map {
    constructor(v, path, doc, schemaType) {
      if (getConstructorName(v) === "Object") {
        v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
      }
      super(v);
      this.$__parent = doc != null && doc.$__ != null ? doc : null;
      this.$__path = path;
      this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
      this.$__runDeferred();
    }
    $init(key, value) {
      checkValidKey(key);
      super.set(key, value);
      if (value != null && value.$isSingleNested) {
        value.$basePath = this.$__path + "." + key;
      }
    }
    $__set(key, value) {
      super.set(key, value);
    }
    get(key, options) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      options = options || {};
      if (options.getters === false) {
        return super.get(key);
      }
      return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
    }
    set(key, value) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      checkValidKey(key);
      value = handleSpreadDoc(value);
      if (this.$__schemaType == null) {
        this.$__deferred = this.$__deferred || [];
        this.$__deferred.push({ key, value });
        return;
      }
      let _fullPath;
      const parent = this.$__parent;
      const populated = parent != null && parent.$__ && parent.$__.populated ? parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) : null;
      const priorVal = this.get(key);
      if (populated != null) {
        if (this.$__schemaType.$isSingleNested) {
          throw new MongooseError("Cannot manually populate single nested subdoc underneath Map " + `at path "${this.$__path}". Try using an array instead of a Map.`);
        }
        if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {
          value = value.map((v) => {
            if (v.$__ == null) {
              v = new populated.options[populateModelSymbol](v);
            }
            v.$__.wasPopulated = { value: v._doc._id };
            return v;
          });
        } else if (value != null) {
          if (value.$__ == null) {
            value = new populated.options[populateModelSymbol](value);
          }
          value.$__.wasPopulated = { value: value._doc._id };
        }
      } else {
        try {
          const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested || this.$__schemaType.$isMongooseArray || this.$__schemaType.$isSchemaMap ? { path: fullPath.call(this) } : null;
          value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), options);
        } catch (error) {
          if (this.$__parent != null && this.$__parent.$__ != null) {
            this.$__parent.invalidate(fullPath.call(this), error);
            return;
          }
          throw error;
        }
      }
      super.set(key, value);
      if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
        const path = fullPath.call(this);
        parent.markModified(path);
        if (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested) {
          cleanModifiedSubpaths(parent, path);
        }
      }
      function fullPath() {
        if (_fullPath) {
          return _fullPath;
        }
        _fullPath = this.$__path + "." + key;
        return _fullPath;
      }
    }
    clear() {
      super.clear();
      const parent = this.$__parent;
      if (parent != null) {
        parent.markModified(this.$__path);
      }
    }
    delete(key) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      this.set(key, undefined);
      return super.delete(key);
    }
    toBSON() {
      return new Map(this);
    }
    toObject(options) {
      if (options && options.flattenMaps) {
        const ret = {};
        const keys = this.keys();
        for (const key of keys) {
          ret[key] = clone2(this.get(key), options);
        }
        return ret;
      }
      return new Map(this);
    }
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    }
    toJSON(options) {
      if (typeof (options && options.flattenMaps) === "boolean" ? options.flattenMaps : true) {
        const ret = {};
        const keys = this.keys();
        for (const key of keys) {
          ret[key] = clone2(this.get(key), options);
        }
        return ret;
      }
      return new Map(this);
    }
    inspect() {
      return new Map(this);
    }
    $__runDeferred() {
      if (!this.$__deferred) {
        return;
      }
      for (const keyValueObject of this.$__deferred) {
        this.set(keyValueObject.key, keyValueObject.value);
      }
      this.$__deferred = null;
    }
  }
  if (util3.inspect.custom) {
    Object.defineProperty(MongooseMap.prototype, util3.inspect.custom, {
      enumerable: false,
      writable: false,
      configurable: false,
      value: MongooseMap.prototype.inspect
    });
  }
  Object.defineProperty(MongooseMap.prototype, "$__set", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__parent", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__path", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
  });
  Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
  });
  function checkValidKey(key) {
    const keyType = typeof key;
    if (keyType !== "string") {
      throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
    }
    if (key.startsWith("$")) {
      throw new Error(`Mongoose maps do not support keys that start with "$", got "${key}"`);
    }
    if (key.includes(".")) {
      throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
    }
    if (specialProperties.has(key)) {
      throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
    }
  }
  module.exports = MongooseMap;
});

// node_modules/mongoose/lib/types/uuid.js
var require_uuid = __commonJS((exports, module) => {
  module.exports = require_bson().UUID;
});

// node_modules/mongoose/lib/types/index.js
var require_types = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Array = require_array();
  exports.Buffer = require_buffer();
  exports.Document = exports.Embedded = require_arraySubdocument();
  exports.DocumentArray = require_documentArray();
  exports.Double = require_double();
  exports.Decimal128 = require_decimal128();
  exports.ObjectId = require_objectid();
  exports.Map = require_map();
  exports.Subdocument = require_subdocument();
  exports.UUID = require_uuid();
});

// node_modules/mongoose/lib/options/schemaArrayOptions.js
var require_schemaArrayOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaArrayOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
  Object.defineProperty(SchemaArrayOptions.prototype, "castNonArrays", opts);
  /*!
   * ignore
   */
  module.exports = SchemaArrayOptions;
});

// node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS((exports, module) => {
  module.exports = arrayDepth;
  function arrayDepth(arr) {
    if (!Array.isArray(arr)) {
      return { min: 0, max: 0, containsNonArrayItem: true };
    }
    if (arr.length === 0) {
      return { min: 1, max: 1, containsNonArrayItem: false };
    }
    if (arr.length === 1 && !Array.isArray(arr[0])) {
      return { min: 1, max: 1, containsNonArrayItem: false };
    }
    const res = arrayDepth(arr[0]);
    for (let i = 1;i < arr.length; ++i) {
      const _res = arrayDepth(arr[i]);
      if (_res.min < res.min) {
        res.min = _res.min;
      }
      if (_res.max > res.max) {
        res.max = _res.max;
      }
      res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
    }
    res.min = res.min + 1;
    res.max = res.max + 1;
    return res;
  }
});

// node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS((exports, module) => {
  var assert2 = __require("assert");
  module.exports = function castNumber(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    if (typeof val === "string" || typeof val === "boolean") {
      val = Number(val);
    }
    assert2.ok(!isNaN(val));
    if (val instanceof Number) {
      return val.valueOf();
    }
    if (typeof val === "number") {
      return val;
    }
    if (!Array.isArray(val) && typeof val.valueOf === "function") {
      return Number(val.valueOf());
    }
    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
      return Number(val);
    }
    assert2.ok(false);
  };
});

// node_modules/mongoose/lib/helpers/omitUndefined.js
var require_omitUndefined = __commonJS((exports, module) => {
  module.exports = function omitUndefined(val) {
    if (val == null || typeof val !== "object") {
      return val;
    }
    if (Array.isArray(val)) {
      for (let i = val.length - 1;i >= 0; --i) {
        if (val[i] === undefined) {
          val.splice(i, 1);
        }
      }
    }
    for (const key of Object.keys(val)) {
      if (val[key] === undefined) {
        delete val[key];
      }
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/query/cast$expr.js
var require_cast$expr = __commonJS((exports, module) => {
  var CastError = require_cast();
  var StrictModeError = require_strict();
  var castNumber = require_number();
  var omitUndefined = require_omitUndefined();
  var booleanComparison = new Set(["$and", "$or"]);
  var comparisonOperator = new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]);
  var arithmeticOperatorArray = new Set([
    "$multiply",
    "$divide",
    "$log",
    "$mod",
    "$trunc",
    "$avg",
    "$max",
    "$min",
    "$stdDevPop",
    "$stdDevSamp",
    "$sum"
  ]);
  var arithmeticOperatorNumber = new Set([
    "$abs",
    "$exp",
    "$ceil",
    "$floor",
    "$ln",
    "$log10",
    "$sqrt",
    "$sin",
    "$cos",
    "$tan",
    "$asin",
    "$acos",
    "$atan",
    "$atan2",
    "$asinh",
    "$acosh",
    "$atanh",
    "$sinh",
    "$cosh",
    "$tanh",
    "$degreesToRadians",
    "$radiansToDegrees"
  ]);
  var arrayElementOperators = new Set([
    "$arrayElemAt",
    "$first",
    "$last"
  ]);
  var dateOperators = new Set([
    "$year",
    "$month",
    "$week",
    "$dayOfMonth",
    "$dayOfYear",
    "$hour",
    "$minute",
    "$second",
    "$isoDayOfWeek",
    "$isoWeekYear",
    "$isoWeek",
    "$millisecond"
  ]);
  var expressionOperator = new Set(["$not"]);
  module.exports = function cast$expr(val, schema, strictQuery) {
    if (typeof val === "boolean") {
      return val;
    }
    if (typeof val !== "object" || val === null) {
      throw new Error("`$expr` must be an object or boolean literal");
    }
    return _castExpression(val, schema, strictQuery);
  };
  function _castExpression(val, schema, strictQuery) {
    if (isPath(val) || val === null) {
      return val;
    }
    if (val.$cond != null) {
      if (Array.isArray(val.$cond)) {
        val.$cond = val.$cond.map((expr) => _castExpression(expr, schema, strictQuery));
      } else {
        val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);
        val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);
        val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);
      }
    } else if (val.$ifNull != null) {
      val.$ifNull.map((v) => _castExpression(v, schema, strictQuery));
    } else if (val.$switch != null) {
      if (Array.isArray(val.$switch.branches)) {
        val.$switch.branches = val.$switch.branches.map((v) => _castExpression(v, schema, strictQuery));
      }
      if ("default" in val.$switch) {
        val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);
      }
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      if (booleanComparison.has(key)) {
        val[key] = val[key].map((v) => _castExpression(v, schema, strictQuery));
      } else if (comparisonOperator.has(key)) {
        val[key] = castComparison(val[key], schema, strictQuery);
      } else if (arithmeticOperatorArray.has(key)) {
        val[key] = castArithmetic(val[key], schema, strictQuery);
      } else if (arithmeticOperatorNumber.has(key)) {
        val[key] = castNumberOperator(val[key], schema, strictQuery);
      } else if (expressionOperator.has(key)) {
        val[key] = _castExpression(val[key], schema, strictQuery);
      }
    }
    if (val.$in) {
      val.$in = castIn(val.$in, schema, strictQuery);
    }
    if (val.$size) {
      val.$size = castNumberOperator(val.$size, schema, strictQuery);
    }
    if (val.$round) {
      const $round = val.$round;
      if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {
        throw new CastError("Array", $round, "$round");
      }
      val.$round = $round.map((v) => castNumberOperator(v, schema, strictQuery));
    }
    omitUndefined(val);
    return val;
  }
  function castNumberOperator(val) {
    if (!isLiteral(val)) {
      return val;
    }
    try {
      return castNumber(val);
    } catch (err2) {
      throw new CastError("Number", val);
    }
  }
  function castIn(val, schema, strictQuery) {
    const path = val[1];
    if (!isPath(path)) {
      return val;
    }
    const search = val[0];
    const schematype = schema.path(path.slice(1));
    if (schematype === null) {
      if (strictQuery === false) {
        return val;
      } else if (strictQuery === "throw") {
        throw new StrictModeError("$in");
      }
      return;
    }
    if (!schematype.$isMongooseArray) {
      throw new Error("Path must be an array for $in");
    }
    return [
      schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),
      path
    ];
  }
  function castArithmetic(val) {
    if (!Array.isArray(val)) {
      if (!isLiteral(val)) {
        return val;
      }
      try {
        return castNumber(val);
      } catch (err2) {
        throw new CastError("Number", val);
      }
    }
    return val.map((v) => {
      if (!isLiteral(v)) {
        return v;
      }
      try {
        return castNumber(v);
      } catch (err2) {
        throw new CastError("Number", v);
      }
    });
  }
  function castComparison(val, schema, strictQuery) {
    if (!Array.isArray(val) || val.length !== 2) {
      throw new Error("Comparison operator must be an array of length 2");
    }
    val[0] = _castExpression(val[0], schema, strictQuery);
    const lhs = val[0];
    if (isLiteral(val[1])) {
      let path = null;
      let schematype = null;
      let caster = null;
      if (isPath(lhs)) {
        path = lhs.slice(1);
        schematype = schema.path(path);
      } else if (typeof lhs === "object" && lhs != null) {
        for (const key of Object.keys(lhs)) {
          if (dateOperators.has(key) && isPath(lhs[key])) {
            path = lhs[key].slice(1) + "." + key;
            caster = castNumber;
          } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {
            path = lhs[key].slice(1) + "." + key;
            schematype = schema.path(lhs[key].slice(1));
            if (schematype != null) {
              if (schematype.$isMongooseDocumentArray) {
                schematype = schematype.$embeddedSchemaType;
              } else if (schematype.$isMongooseArray) {
                schematype = schematype.caster;
              }
            }
          }
        }
      }
      const is$literal = typeof val[1] === "object" && val[1] != null && val[1].$literal != null;
      if (schematype != null) {
        if (is$literal) {
          val[1] = { $literal: schematype.cast(val[1].$literal) };
        } else {
          val[1] = schematype.cast(val[1]);
        }
      } else if (caster != null) {
        if (is$literal) {
          try {
            val[1] = { $literal: caster(val[1].$literal) };
          } catch (err2) {
            throw new CastError(caster.name.replace(/^cast/, ""), val[1], path + ".$literal");
          }
        } else {
          try {
            val[1] = caster(val[1]);
          } catch (err2) {
            throw new CastError(caster.name.replace(/^cast/, ""), val[1], path);
          }
        }
      } else if (path != null && strictQuery === true) {
        return;
      } else if (path != null && strictQuery === "throw") {
        throw new StrictModeError(path);
      }
    } else {
      val[1] = _castExpression(val[1]);
    }
    return val;
  }
  function isPath(val) {
    return typeof val === "string" && val[0] === "$";
  }
  function isLiteral(val) {
    if (typeof val === "string" && val[0] === "$") {
      return false;
    }
    if (typeof val === "object" && val !== null && Object.keys(val).find((key) => key[0] === "$")) {
      return val.$literal != null;
    }
    return true;
  }
});

// node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS((exports, module) => {
  var CastError = require_cast();
  module.exports = function castString(value, path) {
    if (value == null) {
      return value;
    }
    if (value._id && typeof value._id === "string") {
      return value._id;
    }
    if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
      return value.toString();
    }
    throw new CastError("string", value, path);
  };
});

// node_modules/mongoose/lib/schema/operators/text.js
var require_text = __commonJS((exports, module) => {
  var CastError = require_cast();
  var castBoolean = require_boolean();
  var castString = require_string();
  module.exports = function castTextSearch(val, path) {
    if (val == null || typeof val !== "object") {
      throw new CastError("$text", val, path);
    }
    if (val.$search != null) {
      val.$search = castString(val.$search, path + ".$search");
    }
    if (val.$language != null) {
      val.$language = castString(val.$language, path + ".$language");
    }
    if (val.$caseSensitive != null) {
      val.$caseSensitive = castBoolean(val.$caseSensitive, path + ".$castSensitive");
    }
    if (val.$diacriticSensitive != null) {
      val.$diacriticSensitive = castBoolean(val.$diacriticSensitive, path + ".$diacriticSensitive");
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS((exports, module) => {
  var specialKeys = new Set([
    "$ref",
    "$id",
    "$db"
  ]);
  module.exports = function isOperator(path) {
    return path[0] === "$" && !specialKeys.has(path);
  };
});

// node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var StrictModeError = require_strict();
  var Types = require_schema();
  var cast$expr = require_cast$expr();
  var castString = require_string();
  var castTextSearch = require_text();
  var get = require_get();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  var isOperator = require_isOperator();
  var util3 = __require("util");
  var isObject2 = require_isObject();
  var isMongooseObject = require_isMongooseObject();
  var utils = require_utils3();
  var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
  module.exports = function cast(schema, obj, options, context) {
    if (Array.isArray(obj)) {
      throw new Error("Query filter must be an object, got an array ", util3.inspect(obj));
    }
    if (obj == null) {
      return obj;
    }
    if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
    }
    const paths = Object.keys(obj);
    let i = paths.length;
    let _keys;
    let any$conditionals;
    let schematype;
    let nested;
    let path;
    let type;
    let val;
    options = options || {};
    while (i--) {
      path = paths[i];
      val = obj[path];
      if (path === "$or" || path === "$nor" || path === "$and") {
        if (!Array.isArray(val)) {
          throw new CastError("Array", val, path);
        }
        for (let k = val.length - 1;k >= 0; k--) {
          if (val[k] == null || typeof val[k] !== "object") {
            throw new CastError("Object", val[k], path + "." + k);
          }
          const beforeCastKeysLength = Object.keys(val[k]).length;
          const discriminatorValue = val[k][schema.options.discriminatorKey];
          if (discriminatorValue == null) {
            val[k] = cast(schema, val[k], options, context);
          } else {
            const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);
            val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);
          }
          if (Object.keys(val[k]).length === 0 && beforeCastKeysLength !== 0) {
            val.splice(k, 1);
          }
        }
        if (val.length === 0) {
          delete obj[path];
        }
      } else if (path === "$where") {
        type = typeof val;
        if (type !== "string" && type !== "function") {
          throw new Error("Must have a string or function for $where");
        }
        if (type === "function") {
          obj[path] = val.toString();
        }
        continue;
      } else if (path === "$expr") {
        val = cast$expr(val, schema);
        continue;
      } else if (path === "$elemMatch") {
        val = cast(schema, val, options, context);
      } else if (path === "$text") {
        val = castTextSearch(val, path);
      } else if (path === "$comment" && !schema.paths.hasOwnProperty("$comment")) {
        val = castString(val, path);
        obj[path] = val;
      } else {
        if (!schema) {
          continue;
        }
        schematype = schema.path(path);
        if (!schematype) {
          const split = path.split(".");
          let j = split.length;
          while (j--) {
            const pathFirstHalf = split.slice(0, j).join(".");
            const pathLastHalf = split.slice(j).join(".");
            const _schematype = schema.path(pathFirstHalf);
            const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;
            if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
              const discriminatorVal = get(obj, pathFirstHalf + "." + discriminatorKey);
              const discriminators = _schematype.schema.discriminators;
              if (typeof discriminatorVal === "string" && discriminators[discriminatorVal] != null) {
                schematype = discriminators[discriminatorVal].path(pathLastHalf);
              } else if (discriminatorVal != null && Object.keys(discriminatorVal).length === 1 && Array.isArray(discriminatorVal.$in) && discriminatorVal.$in.length === 1 && typeof discriminatorVal.$in[0] === "string" && discriminators[discriminatorVal.$in[0]] != null) {
                schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);
              }
            }
          }
        }
        if (!schematype) {
          const split = path.split(".");
          let j = split.length;
          let pathFirstHalf;
          let pathLastHalf;
          let remainingConds;
          while (j--) {
            pathFirstHalf = split.slice(0, j).join(".");
            schematype = schema.path(pathFirstHalf);
            if (schematype) {
              break;
            }
          }
          if (schematype) {
            if (schematype.caster && schematype.caster.schema) {
              remainingConds = {};
              pathLastHalf = split.slice(j).join(".");
              remainingConds[pathLastHalf] = val;
              const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
              if (ret === undefined) {
                delete obj[path];
              } else {
                obj[path] = ret;
              }
            } else {
              obj[path] = val;
            }
            continue;
          }
          if (isObject2(val)) {
            let geo = "";
            if (val.$near) {
              geo = "$near";
            } else if (val.$nearSphere) {
              geo = "$nearSphere";
            } else if (val.$within) {
              geo = "$within";
            } else if (val.$geoIntersects) {
              geo = "$geoIntersects";
            } else if (val.$geoWithin) {
              geo = "$geoWithin";
            }
            if (geo) {
              const numbertype = new Types.Number("__QueryCasting__");
              let value = val[geo];
              if (val.$maxDistance != null) {
                val.$maxDistance = numbertype.castForQuery(null, val.$maxDistance, context);
              }
              if (val.$minDistance != null) {
                val.$minDistance = numbertype.castForQuery(null, val.$minDistance, context);
              }
              if (geo === "$within") {
                const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                if (!withinType) {
                  throw new Error("Bad $within parameter: " + JSON.stringify(val));
                }
                value = withinType;
              } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                value = value.coordinates;
              } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                if (value.$maxDistance != null) {
                  value.$maxDistance = numbertype.castForQuery(null, value.$maxDistance, context);
                }
                if (value.$minDistance != null) {
                  value.$minDistance = numbertype.castForQuery(null, value.$minDistance, context);
                }
                if (isMongooseObject(value.$geometry)) {
                  value.$geometry = value.$geometry.toObject({
                    transform: false,
                    virtuals: false
                  });
                }
                value = value.$geometry.coordinates;
              } else if (geo === "$geoWithin") {
                if (value.$geometry) {
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({ virtuals: false });
                  }
                  const geoWithinType = value.$geometry.type;
                  if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                    throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                  }
                  value = value.$geometry.coordinates;
                } else {
                  value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                  if (isMongooseObject(value)) {
                    value = value.toObject({ virtuals: false });
                  }
                }
              }
              _cast(value, numbertype, context);
              continue;
            }
          }
          if (schema.nested[path]) {
            continue;
          }
          const strict = "strict" in options ? options.strict : schema.options.strict;
          const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
          if (options.upsert && strict) {
            if (strict === "throw") {
              throw new StrictModeError(path);
            }
            throw new StrictModeError(path, 'Path "' + path + '" is not in ' + "schema, strict mode is `true`, and upsert is `true`.");
          }
          if (strictQuery === "throw") {
            throw new StrictModeError(path, 'Path "' + path + '" is not in ' + "schema and strictQuery is 'throw'.");
          } else if (strictQuery) {
            delete obj[path];
          }
        } else if (val == null) {
          continue;
        } else if (utils.isPOJO(val)) {
          any$conditionals = Object.keys(val).some(isOperator);
          if (!any$conditionals) {
            obj[path] = schematype.castForQuery(null, val, context);
          } else {
            const ks = Object.keys(val);
            let $cond;
            let k = ks.length;
            while (k--) {
              $cond = ks[k];
              nested = val[$cond];
              if ($cond === "$elemMatch") {
                if (nested && schematype != null && schematype.schema != null) {
                  cast(schematype.schema, nested, options, context);
                } else if (nested && schematype != null && schematype.$isMongooseArray) {
                  if (utils.isPOJO(nested) && nested.$not != null) {
                    cast(schema, nested, options, context);
                  } else {
                    val[$cond] = schematype.castForQuery($cond, nested, context);
                  }
                }
              } else if ($cond === "$not") {
                if (nested && schematype) {
                  _keys = Object.keys(nested);
                  if (_keys.length && isOperator(_keys[0])) {
                    for (const key in nested) {
                      nested[key] = schematype.castForQuery(key, nested[key], context);
                    }
                  } else {
                    val[$cond] = schematype.castForQuery($cond, nested, context);
                  }
                  continue;
                }
              } else {
                val[$cond] = schematype.castForQuery($cond, nested, context);
              }
            }
          }
        } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1 && !options.sanitizeFilter) {
          const casted = [];
          const valuesArray = val;
          for (const _val of valuesArray) {
            casted.push(schematype.castForQuery(null, _val, context));
          }
          obj[path] = { $in: casted };
        } else {
          obj[path] = schematype.castForQuery(null, val, context);
        }
      }
    }
    return obj;
  };
  function _cast(val, numbertype, context) {
    if (Array.isArray(val)) {
      val.forEach(function(item, i) {
        if (Array.isArray(item) || isObject2(item)) {
          return _cast(item, numbertype, context);
        }
        val[i] = numbertype.castForQuery(null, item, context);
      });
    } else {
      const nearKeys = Object.keys(val);
      let nearLen = nearKeys.length;
      while (nearLen--) {
        const nkey = nearKeys[nearLen];
        const item = val[nkey];
        if (Array.isArray(item) || isObject2(item)) {
          _cast(item, numbertype, context);
          val[nkey] = item;
        } else {
          val[nkey] = numbertype.castForQuery({ val: item, context });
        }
      }
    }
  }
  function getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
    if ("strictQuery" in queryOptions) {
      return queryOptions.strictQuery;
    }
    if ("strictQuery" in schemaUserProvidedOptions) {
      return schemaUserProvidedOptions.strictQuery;
    }
    const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;
    if (mongooseOptions) {
      if ("strictQuery" in mongooseOptions) {
        return mongooseOptions.strictQuery;
      }
    }
    return schemaOptions.strictQuery;
  }
});

// node_modules/mongoose/lib/options/schemaNumberOptions.js
var require_schemaNumberOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaNumberOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaNumberOptions;
});

// node_modules/mongoose/lib/helpers/createJSONSchemaTypeDefinition.js
var require_createJSONSchemaTypeDefinition = __commonJS((exports, module) => {
  module.exports = function createJSONSchemaTypeArray(type, bsonType, useBsonType, isRequired) {
    if (useBsonType) {
      if (isRequired) {
        return { bsonType };
      }
      return { bsonType: [bsonType, "null"] };
    } else {
      if (isRequired) {
        return { type };
      }
      return { type: [type, "null"] };
    }
  };
});

// node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS((exports, module) => {
  /*!
   * Module requirements.
   */
  var CastError = require_cast();
  /*!
   * ignore
   */
  function handleBitwiseOperator(val) {
    const _this = this;
    if (Array.isArray(val)) {
      return val.map(function(v) {
        return _castNumber(_this.path, v);
      });
    } else if (Buffer.isBuffer(val)) {
      return val;
    }
    return _castNumber(_this.path, val);
  }
  /*!
   * ignore
   */
  function _castNumber(path, num) {
    const v = Number(num);
    if (isNaN(v)) {
      throw new CastError("number", num, path);
    }
    return v;
  }
  module.exports = handleBitwiseOperator;
});

// node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS((exports, module) => {
  /*!
   * Module requirements.
   */
  var MongooseError = require_error2();
  var SchemaNumberOptions = require_schemaNumberOptions();
  var SchemaType = require_schemaType();
  var castNumber = require_number();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var handleBitwiseOperator = require_bitwise();
  var utils = require_utils3();
  var CastError = SchemaType.CastError;
  function SchemaNumber(key, options) {
    SchemaType.call(this, key, options, "Number");
  }
  SchemaNumber.get = SchemaType.get;
  SchemaNumber.set = SchemaType.set;
  SchemaNumber.setters = [];
  /*!
   * ignore
   */
  SchemaNumber._cast = castNumber;
  SchemaNumber.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaNumber._defaultCaster = (v) => {
    if (typeof v !== "number") {
      throw new Error;
    }
    return v;
  };
  SchemaNumber.schemaName = "Number";
  SchemaNumber.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaNumber.prototype = Object.create(SchemaType.prototype);
  SchemaNumber.prototype.constructor = SchemaNumber;
  SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
  /*!
   * ignore
   */
  SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
  SchemaNumber.checkRequired = SchemaType.checkRequired;
  SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
    return _checkRequired(value);
  };
  SchemaNumber.prototype.min = function(value, message) {
    if (this.minValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.Number.min;
      msg = msg.replace(/{MIN}/, value);
      this.validators.push({
        validator: this.minValidator = function(v) {
          return v == null || v >= value;
        },
        message: msg,
        type: "min",
        min: value
      });
    }
    return this;
  };
  SchemaNumber.prototype.max = function(value, message) {
    if (this.maxValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.Number.max;
      msg = msg.replace(/{MAX}/, value);
      this.validators.push({
        validator: this.maxValidator = function(v) {
          return v == null || v <= value;
        },
        message: msg,
        type: "max",
        max: value
      });
    }
    return this;
  };
  SchemaNumber.prototype.enum = function(values, message) {
    if (this.enumValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.enumValidator;
      }, this);
    }
    if (!Array.isArray(values)) {
      const isObjectSyntax = utils.isPOJO(values) && values.values != null;
      if (isObjectSyntax) {
        message = values.message;
        values = values.values;
      } else if (typeof values === "number") {
        values = Array.prototype.slice.call(arguments);
        message = null;
      }
      if (utils.isPOJO(values)) {
        values = Object.values(values);
      }
      message = message || MongooseError.messages.Number.enum;
    }
    message = message == null ? MongooseError.messages.Number.enum : message;
    this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
    this.validators.push({
      validator: this.enumValidator,
      message,
      type: "enum",
      enumValues: values
    });
    return this;
  };
  SchemaNumber.prototype.cast = function(value, doc, init, prev, options) {
    if (typeof value !== "number" && SchemaType._isRef(this, value, doc, init)) {
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init, options);
      }
    }
    const val = value && typeof value._id !== "undefined" ? value._id : value;
    let castNumber2;
    if (typeof this._castFunction === "function") {
      castNumber2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castNumber2 = this.constructor.cast();
    } else {
      castNumber2 = SchemaNumber.cast();
    }
    try {
      return castNumber2(val);
    } catch (err2) {
      throw new CastError("Number", val, this.path, err2, this);
    }
  };
  /*!
   * ignore
   */
  function handleSingle(val) {
    return this.cast(val);
  }
  function handleArray(val) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.cast(val)];
    }
    return val.map(function(m2) {
      return _this.cast(m2);
    });
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $mod: handleArray
  };
  Object.defineProperty(SchemaNumber.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaNumber.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new CastError("number", val, this.path, null, this);
      }
      return handler.call(this, val, context);
    }
    try {
      val = this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
    return val;
  };
  SchemaNumber.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function" || this.path === "_id";
    return createJSONSchemaTypeDefinition("number", "number", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaNumber;
});

// node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers = __commonJS((exports) => {
  /*!
   * Module requirements.
   */
  var SchemaNumber = require_number2();
  /*!
   * ignore
   */
  exports.castToNumber = castToNumber;
  exports.castArraysOfNumbers = castArraysOfNumbers;
  /*!
   * ignore
   */
  function castToNumber(val) {
    return SchemaNumber.cast()(val);
  }
  function castArraysOfNumbers(arr, self2) {
    arr.forEach(function(v, i) {
      if (Array.isArray(v)) {
        castArraysOfNumbers(v, self2);
      } else {
        arr[i] = castToNumber.call(self2, v);
      }
    });
  }
});

// node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS((exports) => {
  /*!
   * Module requirements.
   */
  var castArraysOfNumbers = require_helpers().castArraysOfNumbers;
  var castToNumber = require_helpers().castToNumber;
  /*!
   * ignore
   */
  exports.cast$geoIntersects = cast$geoIntersects;
  exports.cast$near = cast$near;
  exports.cast$within = cast$within;
  function cast$near(val) {
    const SchemaArray = require_array2();
    if (Array.isArray(val)) {
      castArraysOfNumbers(val, this);
      return val;
    }
    _castMinMaxDistance(this, val);
    if (val && val.$geometry) {
      return cast$geometry(val, this);
    }
    if (!Array.isArray(val)) {
      throw new TypeError("$near must be either an array or an object " + "with a $geometry property");
    }
    return SchemaArray.prototype.castForQuery.call(this, null, val);
  }
  function cast$geometry(val, self2) {
    switch (val.$geometry.type) {
      case "Polygon":
      case "LineString":
      case "Point":
        castArraysOfNumbers(val.$geometry.coordinates, self2);
        break;
      default:
        break;
    }
    _castMinMaxDistance(self2, val);
    return val;
  }
  function cast$within(val) {
    _castMinMaxDistance(this, val);
    if (val.$box || val.$polygon) {
      const type = val.$box ? "$box" : "$polygon";
      val[type].forEach((arr) => {
        if (!Array.isArray(arr)) {
          const msg = "Invalid $within $box argument. " + "Expected an array, received " + arr;
          throw new TypeError(msg);
        }
        arr.forEach((v, i) => {
          arr[i] = castToNumber.call(this, v);
        });
      });
    } else if (val.$center || val.$centerSphere) {
      const type = val.$center ? "$center" : "$centerSphere";
      val[type].forEach((item, i) => {
        if (Array.isArray(item)) {
          item.forEach((v, j) => {
            item[j] = castToNumber.call(this, v);
          });
        } else {
          val[type][i] = castToNumber.call(this, item);
        }
      });
    } else if (val.$geometry) {
      cast$geometry(val, this);
    }
    return val;
  }
  function cast$geoIntersects(val) {
    const geo = val.$geometry;
    if (!geo) {
      return;
    }
    cast$geometry(val, this);
    return val;
  }
  function _castMinMaxDistance(self2, val) {
    if (val.$maxDistance) {
      val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
    }
    if (val.$minDistance) {
      val.$minDistance = castToNumber.call(self2, val.$minDistance);
    }
  }
});

// node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var $exists = require_exists();
  var $type = require_type();
  var MongooseError = require_mongooseError();
  var SchemaArrayOptions = require_schemaArrayOptions();
  var SchemaType = require_schemaType();
  var CastError = SchemaType.CastError;
  var Mixed = require_mixed();
  var VirtualOptions = require_virtualOptions();
  var VirtualType = require_virtualType();
  var arrayDepth = require_arrayDepth();
  var cast2 = require_cast2();
  var clone2 = require_clone();
  var getConstructorName = require_getConstructorName();
  var isOperator = require_isOperator();
  var util3 = __require("util");
  var utils = require_utils3();
  var castToNumber = require_helpers().castToNumber;
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var geospatial = require_geospatial();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var MongooseArray;
  var EmbeddedDoc;
  var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
  var emptyOpts = Object.freeze({});
  function SchemaArray(key, cast3, options, schemaOptions) {
    EmbeddedDoc || (EmbeddedDoc = require_types().Embedded);
    let typeKey = "type";
    if (schemaOptions && schemaOptions.typeKey) {
      typeKey = schemaOptions.typeKey;
    }
    this.schemaOptions = schemaOptions;
    if (cast3) {
      let castOptions = {};
      if (utils.isPOJO(cast3)) {
        if (cast3[typeKey]) {
          castOptions = clone2(cast3);
          delete castOptions[typeKey];
          cast3 = cast3[typeKey];
        } else {
          cast3 = Mixed;
        }
      }
      if (options != null && options.ref != null && castOptions.ref == null) {
        castOptions.ref = options.ref;
      }
      if (cast3 === Object) {
        cast3 = Mixed;
      }
      const name = typeof cast3 === "string" ? cast3 : utils.getFunctionName(cast3);
      const Types = require_schema();
      const caster = Types.hasOwnProperty(name) ? Types[name] : cast3;
      this.casterConstructor = caster;
      if (this.casterConstructor instanceof SchemaArray) {
        this.casterConstructor[isNestedArraySymbol] = true;
      }
      if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
        const path = this.caster instanceof EmbeddedDoc ? null : key;
        this.caster = new caster(path, castOptions);
      } else {
        this.caster = caster;
        if (!(this.caster instanceof EmbeddedDoc)) {
          this.caster.path = key;
        }
      }
      this.$embeddedSchemaType = this.caster;
    }
    this.$isMongooseArray = true;
    SchemaType.call(this, key, options, "Array");
    let defaultArr;
    let fn;
    if (this.defaultValue != null) {
      defaultArr = this.defaultValue;
      fn = typeof defaultArr === "function";
    }
    if (!("defaultValue" in this) || this.defaultValue != null) {
      const defaultFn = function() {
        return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];
      };
      defaultFn.$runBeforeSetters = !fn;
      this.default(defaultFn);
    }
  }
  SchemaArray.schemaName = "Array";
  SchemaArray.options = { castNonArrays: true };
  /*!
   * ignore
   */
  SchemaArray.defaultOptions = {};
  SchemaArray.set = SchemaType.set;
  SchemaArray.setters = [];
  SchemaArray.get = SchemaType.get;
  /*!
   * Inherits from SchemaType.
   */
  SchemaArray.prototype = Object.create(SchemaType.prototype);
  SchemaArray.prototype.constructor = SchemaArray;
  SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
  /*!
   * ignore
   */
  SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
  SchemaArray.checkRequired = SchemaType.checkRequired;
  /*!
   * Virtuals defined on this array itself.
   */
  SchemaArray.prototype.virtuals = null;
  SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
    return _checkRequired(value);
  };
  SchemaArray.prototype.enum = function() {
    let arr = this;
    while (true) {
      const instance = arr && arr.caster && arr.caster.instance;
      if (instance === "Array") {
        arr = arr.caster;
        continue;
      }
      if (instance !== "String" && instance !== "Number") {
        throw new Error("`enum` can only be set on an array of strings or numbers " + ", not " + instance);
      }
      break;
    }
    let enumArray = arguments;
    if (!Array.isArray(arguments) && utils.isObject(arguments)) {
      enumArray = utils.object.vals(enumArray);
    }
    arr.caster.enum.apply(arr.caster, enumArray);
    return this;
  };
  SchemaArray.prototype.applyGetters = function(value, scope) {
    if (scope != null && scope.$__ != null && scope.$populated(this.path)) {
      return value;
    }
    const ret = SchemaType.prototype.applyGetters.call(this, value, scope);
    return ret;
  };
  SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
    if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
      let depth = 0;
      let arr = this;
      while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        ++depth;
        arr = arr.casterConstructor;
      }
      if (value != null && value.length !== 0) {
        const valueDepth = arrayDepth(value);
        if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
          for (let i = valueDepth.max;i < depth; ++i) {
            value = [value];
          }
        }
      }
    }
    return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
  };
  SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
    MongooseArray || (MongooseArray = require_types().Array);
    let i;
    let l2;
    if (Array.isArray(value)) {
      const len = value.length;
      if (!len && doc) {
        const indexes = doc.schema.indexedPaths();
        const arrayPath = this.path;
        for (i = 0, l2 = indexes.length;i < l2; ++i) {
          const pathIndex = indexes[i][0][arrayPath];
          if (pathIndex === "2dsphere" || pathIndex === "2d") {
            return;
          }
        }
        const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
        if (arrayGeojsonPath != null) {
          for (i = 0, l2 = indexes.length;i < l2; ++i) {
            const pathIndex = indexes[i][0][arrayGeojsonPath];
            if (pathIndex === "2dsphere") {
              return;
            }
          }
        }
      }
      options = options || emptyOpts;
      let rawValue = utils.isMongooseArray(value) ? value.__array : value;
      let path = options.path || this.path;
      if (options.arrayPathIndex != null) {
        path += "." + options.arrayPathIndex;
      }
      value = MongooseArray(rawValue, path, doc, this);
      rawValue = value.__array;
      if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {
        return value;
      }
      const caster = this.caster;
      const isMongooseArray = caster.$isMongooseArray;
      if (caster && this.casterConstructor !== Mixed) {
        try {
          const len2 = rawValue.length;
          for (i = 0;i < len2; i++) {
            const opts = {};
            if (isMongooseArray) {
              if (options.arrayPath != null) {
                opts.arrayPathIndex = i;
              } else if (caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
            }
            if (options.hydratedPopulatedDocs) {
              opts.hydratedPopulatedDocs = options.hydratedPopulatedDocs;
            }
            rawValue[i] = caster.applySetters(rawValue[i], doc, init, undefined, opts);
          }
        } catch (e) {
          throw new CastError("[" + e.kind + "]", util3.inspect(value), this.path + "." + i, e, this);
        }
      }
      return value;
    }
    const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;
    if (init || castNonArraysOption) {
      if (!!doc && !!init) {
        doc.markModified(this.path);
      }
      return this.cast([value], doc, init);
    }
    throw new CastError("Array", util3.inspect(value), this.path, null, this);
  };
  /*!
   * ignore
   */
  SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
    MongooseArray || (MongooseArray = require_types().Array);
    if (Array.isArray(value)) {
      let i;
      const rawValue = value.__array ? value.__array : value;
      const len = rawValue.length;
      const caster = this.caster;
      if (caster && this.casterConstructor !== Mixed) {
        try {
          for (i = 0;i < len; i++) {
            const opts = {};
            if (caster.$isMongooseArray && caster._arrayParentPath != null) {
              opts.arrayPathIndex = i;
            }
            rawValue[i] = caster.cast(rawValue[i], doc, false, undefined, opts);
          }
        } catch (e) {
          throw new CastError("[" + e.kind + "]", util3.inspect(value), this.path + "." + i, e, this);
        }
      }
      return value;
    }
    throw new CastError("Array", util3.inspect(value), this.path, null, this);
  };
  SchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;
  /*!
   * ignore
   */
  SchemaArray.prototype.discriminator = function(...args) {
    let arr = this;
    while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
      arr = arr.casterConstructor;
      if (arr == null || typeof arr === "function") {
        throw new MongooseError("You can only add an embedded discriminator on " + "a document array, " + this.path + " is a plain array");
      }
    }
    return arr.discriminator(...args);
  };
  /*!
   * ignore
   */
  SchemaArray.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    return schematype;
  };
  SchemaArray.prototype._castForQuery = function(val, context) {
    let Constructor2 = this.casterConstructor;
    if (val && Constructor2.discriminators && Constructor2.schema && Constructor2.schema.options && Constructor2.schema.options.discriminatorKey) {
      if (typeof val[Constructor2.schema.options.discriminatorKey] === "string" && Constructor2.discriminators[val[Constructor2.schema.options.discriminatorKey]]) {
        Constructor2 = Constructor2.discriminators[val[Constructor2.schema.options.discriminatorKey]];
      } else {
        const constructorByValue = getDiscriminatorByValue(Constructor2.discriminators, val[Constructor2.schema.options.discriminatorKey]);
        if (constructorByValue) {
          Constructor2 = constructorByValue;
        }
      }
    }
    const proto = this.casterConstructor.prototype;
    const protoCastForQuery = proto && proto.castForQuery;
    const protoCast = proto && proto.cast;
    const constructorCastForQuery = Constructor2.castForQuery;
    const caster = this.caster;
    if (Array.isArray(val)) {
      this.setters.reverse().forEach((setter) => {
        val = setter.call(this, val, this);
      });
      val = val.map(function(v) {
        if (utils.isObject(v) && v.$elemMatch) {
          return v;
        }
        if (protoCastForQuery) {
          v = protoCastForQuery.call(caster, null, v, context);
          return v;
        } else if (protoCast) {
          v = protoCast.call(caster, v);
          return v;
        } else if (constructorCastForQuery) {
          v = constructorCastForQuery.call(caster, null, v, context);
          return v;
        }
        if (v != null) {
          v = new Constructor2(v);
          return v;
        }
        return v;
      });
    } else if (protoCastForQuery) {
      val = protoCastForQuery.call(caster, null, val, context);
    } else if (protoCast) {
      val = protoCast.call(caster, val);
    } else if (constructorCastForQuery) {
      val = constructorCastForQuery.call(caster, null, val, context);
    } else if (val != null) {
      val = new Constructor2(val);
    }
    return val;
  };
  SchemaArray.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional + " with Array.");
      }
      return handler.call(this, val, context);
    } else {
      return this._castForQuery(val, context);
    }
  };
  SchemaArray.prototype.virtual = function virtual(name, options) {
    if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
      return this.virtual(name.path, name.options);
    }
    options = new VirtualOptions(options);
    if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
      throw new MongooseError("Cannot set populate virtual as a property of an array");
    }
    const virtual = new VirtualType(options, name);
    if (this.virtuals === null) {
      this.virtuals = {};
    }
    this.virtuals[name] = virtual;
    return virtual;
  };
  function cast$all(val, context) {
    if (!Array.isArray(val)) {
      val = [val];
    }
    val = val.map((v) => {
      if (!utils.isObject(v)) {
        return v;
      }
      if (v.$elemMatch != null) {
        return { $elemMatch: cast2(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };
      }
      const o = {};
      o[this.path] = v;
      return cast2(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];
    }, this);
    return this.castForQuery(null, val, context);
  }
  function cast$elemMatch(val, context) {
    const keys = Object.keys(val);
    const numKeys = keys.length;
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const value = val[key];
      if (isOperator(key) && value != null) {
        val[key] = this.castForQuery(key, value, context);
      }
    }
    return val;
  }
  var handle = SchemaArray.prototype.$conditionalHandlers = {};
  handle.$all = cast$all;
  handle.$options = String;
  handle.$elemMatch = cast$elemMatch;
  handle.$geoIntersects = geospatial.cast$geoIntersects;
  handle.$or = createLogicalQueryOperatorHandler("$or");
  handle.$and = createLogicalQueryOperatorHandler("$and");
  handle.$nor = createLogicalQueryOperatorHandler("$nor");
  function createLogicalQueryOperatorHandler(op) {
    return function logicalQueryOperatorHandler(val, context) {
      if (!Array.isArray(val)) {
        throw new TypeError("conditional " + op + " requires an array");
      }
      const ret = [];
      for (const obj of val) {
        ret.push(cast2(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));
      }
      return ret;
    };
  }
  handle.$near = handle.$nearSphere = geospatial.cast$near;
  handle.$within = handle.$geoWithin = geospatial.cast$within;
  handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
  handle.$exists = $exists;
  handle.$type = $type;
  handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$not = handle.$regex = handle.$ne = SchemaArray.prototype._castForQuery;
  handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
  handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
  SchemaArray.prototype.toJSONSchema = function toJSONSchema(options) {
    const embeddedSchemaType = this.getEmbeddedSchemaType();
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return {
      ...createJSONSchemaTypeDefinition("array", "array", options?.useBsonType, isRequired),
      items: embeddedSchemaType.toJSONSchema(options)
    };
  };
  SchemaArray.prototype.autoEncryptionType = function autoEncryptionType() {
    return "array";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaArray;
});

// node_modules/mongoose/lib/cast/bigint.js
var require_bigint = __commonJS((exports, module) => {
  var { Long } = require_bson();
  var MAX_BIGINT = 9223372036854775807n;
  var MIN_BIGINT = -9223372036854775808n;
  var ERROR_MESSAGE = `Mongoose only supports BigInts between ${MIN_BIGINT} and ${MAX_BIGINT} because MongoDB does not support arbitrary precision integers`;
  module.exports = function castBigInt(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    if (typeof val === "bigint") {
      if (val > MAX_BIGINT || val < MIN_BIGINT) {
        throw new Error(ERROR_MESSAGE);
      }
      return val;
    }
    if (val instanceof Long) {
      return val.toBigInt();
    }
    if (typeof val === "string" || typeof val === "number") {
      val = BigInt(val);
      if (val > MAX_BIGINT || val < MIN_BIGINT) {
        throw new Error(ERROR_MESSAGE);
      }
      return val;
    }
    throw new Error(`Cannot convert value to BigInt: "${val}"`);
  };
});

// node_modules/mongoose/lib/schema/bigint.js
var require_bigint2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castBigInt = require_bigint();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  function SchemaBigInt(path, options) {
    SchemaType.call(this, path, options, "BigInt");
  }
  SchemaBigInt.schemaName = "BigInt";
  SchemaBigInt.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBigInt.prototype = Object.create(SchemaType.prototype);
  SchemaBigInt.prototype.constructor = SchemaBigInt;
  /*!
   * ignore
   */
  SchemaBigInt._cast = castBigInt;
  SchemaBigInt.set = SchemaType.set;
  SchemaBigInt.setters = [];
  SchemaBigInt.get = SchemaType.get;
  SchemaBigInt.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaBigInt._checkRequired = (v) => v != null;
  SchemaBigInt.checkRequired = SchemaType.checkRequired;
  SchemaBigInt.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaBigInt.prototype.cast = function(value) {
    let castBigInt2;
    if (typeof this._castFunction === "function") {
      castBigInt2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castBigInt2 = this.constructor.cast();
    } else {
      castBigInt2 = SchemaBigInt.cast();
    }
    try {
      return castBigInt2(value);
    } catch (error) {
      throw new CastError("BigInt", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  Object.defineProperty(SchemaBigInt.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  /*!
   * ignore
   */
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  SchemaBigInt.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
  };
  SchemaBigInt.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
      return v;
    }
    const castBigInt2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBigInt.cast();
    if (castBigInt2 == null) {
      return v;
    }
    return v;
  };
  SchemaBigInt.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "long", options?.useBsonType, isRequired);
  };
  SchemaBigInt.prototype.autoEncryptionType = function autoEncryptionType() {
    return "long";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBigInt;
});

// node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castBoolean = require_boolean();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  function SchemaBoolean(path, options) {
    SchemaType.call(this, path, options, "Boolean");
  }
  SchemaBoolean.schemaName = "Boolean";
  SchemaBoolean.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBoolean.prototype = Object.create(SchemaType.prototype);
  SchemaBoolean.prototype.constructor = SchemaBoolean;
  /*!
   * ignore
   */
  SchemaBoolean._cast = castBoolean;
  SchemaBoolean.set = SchemaType.set;
  SchemaBoolean.setters = [];
  SchemaBoolean.get = SchemaType.get;
  SchemaBoolean.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaBoolean._defaultCaster = (v) => {
    if (v != null && typeof v !== "boolean") {
      throw new Error;
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaBoolean._checkRequired = (v) => v === true || v === false;
  SchemaBoolean.checkRequired = SchemaType.checkRequired;
  SchemaBoolean.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  Object.defineProperty(SchemaBoolean, "convertToTrue", {
    get: () => castBoolean.convertToTrue,
    set: (v) => {
      castBoolean.convertToTrue = v;
    }
  });
  Object.defineProperty(SchemaBoolean, "convertToFalse", {
    get: () => castBoolean.convertToFalse,
    set: (v) => {
      castBoolean.convertToFalse = v;
    }
  });
  SchemaBoolean.prototype.cast = function(value) {
    let castBoolean2;
    if (typeof this._castFunction === "function") {
      castBoolean2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castBoolean2 = this.constructor.cast();
    } else {
      castBoolean2 = SchemaBoolean.cast();
    }
    try {
      return castBoolean2(value);
    } catch (error) {
      throw new CastError("Boolean", value, this.path, error, this);
    }
  };
  var $conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };
  Object.defineProperty(SchemaBoolean.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaBoolean.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
  };
  SchemaBoolean.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
      return v;
    }
    const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
    if (castBoolean2 == null) {
      return v;
    }
    if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
      return false;
    }
    if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
      return true;
    }
    return v;
  };
  SchemaBoolean.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("boolean", "bool", options?.useBsonType, isRequired);
  };
  SchemaBoolean.prototype.autoEncryptionType = function autoEncryptionType() {
    return "bool";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBoolean;
});

// node_modules/mongoose/lib/options/schemaBufferOptions.js
var require_schemaBufferOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaBufferOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
  /*!
   * ignore
   */
  module.exports = SchemaBufferOptions;
});

// node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseBuffer = require_buffer();
  var SchemaBufferOptions = require_schemaBufferOptions();
  var SchemaType = require_schemaType();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var handleBitwiseOperator = require_bitwise();
  var utils = require_utils3();
  var Binary = MongooseBuffer.Binary;
  var CastError = SchemaType.CastError;
  function SchemaBuffer(key, options) {
    SchemaType.call(this, key, options, "Buffer");
  }
  SchemaBuffer.schemaName = "Buffer";
  SchemaBuffer.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBuffer.prototype = Object.create(SchemaType.prototype);
  SchemaBuffer.prototype.constructor = SchemaBuffer;
  SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
  /*!
   * ignore
   */
  SchemaBuffer._checkRequired = (v) => !!(v && v.length);
  SchemaBuffer.set = SchemaType.set;
  SchemaBuffer.setters = [];
  SchemaBuffer.get = SchemaType.get;
  SchemaBuffer.checkRequired = SchemaType.checkRequired;
  SchemaBuffer.prototype.checkRequired = function(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    return this.constructor._checkRequired(value);
  };
  SchemaBuffer.prototype.cast = function(value, doc, init, prev, options) {
    let ret;
    if (SchemaType._isRef(this, value, doc, init)) {
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary) {
        ret = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret._subtype = value.sub_type;
        return ret;
      }
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init, options);
      }
    }
    if (value && value._id) {
      value = value._id;
    }
    if (value && value.isMongooseBuffer) {
      return value;
    }
    if (Buffer.isBuffer(value)) {
      if (!value || !value.isMongooseBuffer) {
        value = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          value._subtype = this.options.subtype;
        }
      }
      return value;
    }
    if (value instanceof Binary) {
      ret = new MongooseBuffer(value.value(true), [this.path, doc]);
      if (typeof value.sub_type !== "number") {
        throw new CastError("Buffer", value, this.path, null, this);
      }
      ret._subtype = value.sub_type;
      return ret;
    }
    if (value === null) {
      return value;
    }
    const type = typeof value;
    if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
      if (type === "number") {
        value = [value];
      }
      ret = new MongooseBuffer(value, [this.path, doc]);
      if (this.options.subtype != null) {
        ret._subtype = this.options.subtype;
      }
      return ret;
    }
    if (utils.isPOJO(value) && (value.$binary instanceof Binary || typeof value.$binary === "string")) {
      const buf = this.cast(Buffer.from(value.$binary, "base64"));
      if (value.$type != null) {
        buf._subtype = value.$type;
        return buf;
      }
    }
    throw new CastError("Buffer", value, this.path, null, this);
  };
  SchemaBuffer.prototype.subtype = function(subtype) {
    this.options.subtype = subtype;
    return this;
  };
  /*!
   * ignore
   */
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  Object.defineProperty(SchemaBuffer.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaBuffer.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional + " with Buffer.");
      }
      return handler.call(this, val);
    }
    let casted;
    try {
      casted = this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
    return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
  };
  SchemaBuffer.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "binData", options?.useBsonType, isRequired);
  };
  SchemaBuffer.prototype.autoEncryptionType = function autoEncryptionType() {
    return "binData";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBuffer;
});

// node_modules/mongoose/lib/options/schemaDateOptions.js
var require_schemaDateOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaDateOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
  Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
  Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
  /*!
   * ignore
   */
  module.exports = SchemaDateOptions;
});

// node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS((exports, module) => {
  var assert2 = __require("assert");
  module.exports = function castDate(value) {
    if (value == null || value === "") {
      return null;
    }
    if (value instanceof Date) {
      assert2.ok(!isNaN(value.valueOf()));
      return value;
    }
    let date2;
    assert2.ok(typeof value !== "boolean");
    if (value instanceof Number || typeof value === "number") {
      date2 = new Date(value);
    } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
      date2 = new Date(Number(value));
    } else if (typeof value.valueOf === "function") {
      date2 = new Date(value.valueOf());
    } else {
      date2 = new Date(value);
    }
    if (!isNaN(date2.valueOf())) {
      return date2;
    }
    assert2.ok(false);
  };
});

// node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS((exports, module) => {
  /*!
   * Module requirements.
   */
  var MongooseError = require_error2();
  var SchemaDateOptions = require_schemaDateOptions();
  var SchemaType = require_schemaType();
  var castDate = require_date();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var getConstructorName = require_getConstructorName();
  var utils = require_utils3();
  var CastError = SchemaType.CastError;
  function SchemaDate(key, options) {
    SchemaType.call(this, key, options, "Date");
  }
  SchemaDate.schemaName = "Date";
  SchemaDate.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDate.prototype = Object.create(SchemaType.prototype);
  SchemaDate.prototype.constructor = SchemaDate;
  SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
  /*!
   * ignore
   */
  SchemaDate._cast = castDate;
  SchemaDate.set = SchemaType.set;
  SchemaDate.setters = [];
  SchemaDate.get = SchemaType.get;
  SchemaDate.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDate._defaultCaster = (v) => {
    if (v != null && !(v instanceof Date)) {
      throw new Error;
    }
    return v;
  };
  SchemaDate.prototype.expires = function(when) {
    if (getConstructorName(this._index) !== "Object") {
      this._index = {};
    }
    this._index.expires = when;
    utils.expires(this._index);
    return this;
  };
  /*!
   * ignore
   */
  SchemaDate._checkRequired = (v) => v instanceof Date;
  SchemaDate.checkRequired = SchemaType.checkRequired;
  SchemaDate.prototype.checkRequired = function(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
    return _checkRequired(value);
  };
  SchemaDate.prototype.min = function(value, message) {
    if (this.minValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minValidator;
      }, this);
    }
    if (value) {
      let msg = message || MongooseError.messages.Date.min;
      if (typeof msg === "string") {
        msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
      }
      const _this = this;
      this.validators.push({
        validator: this.minValidator = function(val) {
          let _value = value;
          if (typeof value === "function" && value !== Date.now) {
            _value = _value.call(this);
          }
          const min = _value === Date.now ? _value() : _this.cast(_value);
          return val === null || val.valueOf() >= min.valueOf();
        },
        message: msg,
        type: "min",
        min: value
      });
    }
    return this;
  };
  SchemaDate.prototype.max = function(value, message) {
    if (this.maxValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxValidator;
      }, this);
    }
    if (value) {
      let msg = message || MongooseError.messages.Date.max;
      if (typeof msg === "string") {
        msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
      }
      const _this = this;
      this.validators.push({
        validator: this.maxValidator = function(val) {
          let _value = value;
          if (typeof _value === "function" && _value !== Date.now) {
            _value = _value.call(this);
          }
          const max2 = _value === Date.now ? _value() : _this.cast(_value);
          return val === null || val.valueOf() <= max2.valueOf();
        },
        message: msg,
        type: "max",
        max: value
      });
    }
    return this;
  };
  SchemaDate.prototype.cast = function(value) {
    let castDate2;
    if (typeof this._castFunction === "function") {
      castDate2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDate2 = this.constructor.cast();
    } else {
      castDate2 = SchemaDate.cast();
    }
    try {
      return castDate2(value);
    } catch (error) {
      throw new CastError("date", value, this.path, error, this);
    }
  };
  function handleSingle(val) {
    return this.cast(val);
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  Object.defineProperty(SchemaDate.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaDate.prototype.castForQuery = function($conditional, val, context) {
    if ($conditional == null) {
      try {
        return this.applySetters(val, context);
      } catch (err2) {
        if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
          err2.path = this.$fullPath;
        }
        throw err2;
      }
    }
    const handler = this.$conditionalHandlers[$conditional];
    if (!handler) {
      throw new Error("Can't use " + $conditional + " with Date.");
    }
    return handler.call(this, val);
  };
  SchemaDate.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "date", options?.useBsonType, isRequired);
  };
  SchemaDate.prototype.autoEncryptionType = function autoEncryptionType() {
    return "date";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDate;
});

// node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1282 = __commonJS((exports, module) => {
  var Decimal128Type = require_decimal128();
  var assert2 = __require("assert");
  module.exports = function castDecimal128(value) {
    if (value == null) {
      return value;
    }
    if (typeof value === "object" && typeof value.$numberDecimal === "string") {
      return Decimal128Type.fromString(value.$numberDecimal);
    }
    if (value instanceof Decimal128Type) {
      return value;
    }
    if (typeof value === "string") {
      return Decimal128Type.fromString(value);
    }
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      return new Decimal128Type(value);
    }
    if (typeof Uint8Array === "function" && value instanceof Uint8Array) {
      return new Decimal128Type(value);
    }
    if (typeof value === "number") {
      return Decimal128Type.fromString(String(value));
    }
    if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
      return Decimal128Type.fromString(value.valueOf());
    }
    assert2.ok(false);
  };
});

// node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1283 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schemaType();
  var CastError = SchemaType.CastError;
  var castDecimal128 = require_decimal1282();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var isBsonType = require_isBsonType();
  function SchemaDecimal128(key, options) {
    SchemaType.call(this, key, options, "Decimal128");
  }
  SchemaDecimal128.schemaName = "Decimal128";
  SchemaDecimal128.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDecimal128.prototype = Object.create(SchemaType.prototype);
  SchemaDecimal128.prototype.constructor = SchemaDecimal128;
  /*!
   * ignore
   */
  SchemaDecimal128._cast = castDecimal128;
  SchemaDecimal128.set = SchemaType.set;
  SchemaDecimal128.setters = [];
  SchemaDecimal128.get = SchemaType.get;
  SchemaDecimal128.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDecimal128._defaultCaster = (v) => {
    if (v != null && !isBsonType(v, "Decimal128")) {
      throw new Error;
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaDecimal128._checkRequired = (v) => isBsonType(v, "Decimal128");
  SchemaDecimal128.checkRequired = SchemaType.checkRequired;
  SchemaDecimal128.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDecimal128.checkRequired();
    return _checkRequired(value);
  };
  SchemaDecimal128.prototype.cast = function(value, doc, init, prev, options) {
    if (SchemaType._isRef(this, value, doc, init)) {
      if (isBsonType(value, "Decimal128")) {
        return value;
      }
      return this._castRef(value, doc, init, options);
    }
    let castDecimal1282;
    if (typeof this._castFunction === "function") {
      castDecimal1282 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDecimal1282 = this.constructor.cast();
    } else {
      castDecimal1282 = SchemaDecimal128.cast();
    }
    try {
      return castDecimal1282(value);
    } catch (error) {
      throw new CastError("Decimal128", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  function handleSingle(val) {
    return this.cast(val);
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  Object.defineProperty(SchemaDecimal128.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaDecimal128.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "decimal", options?.useBsonType, isRequired);
  };
  SchemaDecimal128.prototype.autoEncryptionType = function autoEncryptionType() {
    return "decimal";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDecimal128;
});

// node_modules/mongoose/lib/options/schemaSubdocumentOptions.js
var require_schemaSubdocumentOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaSubdocumentOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaSubdocumentOptions.prototype, "_id", opts);
  Object.defineProperty(SchemaSubdocumentOptions.prototype, "minimize", opts);
  module.exports = SchemaSubdocumentOptions;
});

// node_modules/mongoose/lib/helpers/each.js
var require_each = __commonJS((exports, module) => {
  module.exports = function each(arr, cb, done) {
    if (arr.length === 0) {
      return done();
    }
    let remaining = arr.length;
    let err2 = null;
    for (const v of arr) {
      cb(v, function(_err) {
        if (err2 != null) {
          return;
        }
        if (_err != null) {
          err2 = _err;
          return done(err2);
        }
        if (--remaining <= 0) {
          return done();
        }
      });
    }
  };
});

// node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS((exports, module) => {
  var each = require_each();
  /*!
   * ignore
   */
  module.exports = function saveSubdocs(schema) {
    const unshift = true;
    schema.s.hooks.pre("save", false, function saveSubdocsPreSave(next) {
      if (this.$isSubdocument) {
        next();
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs({ useCache: true });
      if (!subdocs.length) {
        next();
        return;
      }
      each(subdocs, function(subdoc, cb) {
        subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err2) {
          cb(err2);
        });
      }, function(error) {
        if (_this.$__.saveOptions) {
          _this.$__.saveOptions.__subdocs = null;
        }
        if (error) {
          return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            next(error2);
          });
        }
        next();
      });
    }, null, unshift);
    schema.s.hooks.post("save", async function saveSubdocsPostDeleteOne() {
      const removedSubdocs = this.$__.removedSubdocs;
      if (!removedSubdocs || !removedSubdocs.length) {
        return;
      }
      const promises = [];
      for (const subdoc of removedSubdocs) {
        promises.push(new Promise((resolve, reject) => {
          subdoc.$__schema.s.hooks.execPost("deleteOne", subdoc, [subdoc], function(err2) {
            if (err2) {
              return reject(err2);
            }
            resolve();
          });
        }));
      }
      this.$__.removedSubdocs = null;
      await Promise.all(promises);
    });
    schema.s.hooks.post("save", async function saveSubdocsPostSave() {
      if (this.$isSubdocument) {
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs({ useCache: true });
      if (!subdocs.length) {
        return;
      }
      const promises = [];
      for (const subdoc of subdocs) {
        promises.push(new Promise((resolve, reject) => {
          subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err2) {
            if (err2) {
              return reject(err2);
            }
            resolve();
          });
        }));
      }
      try {
        await Promise.all(promises);
      } catch (error) {
        await new Promise((resolve, reject) => {
          this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            if (error2) {
              return reject(error2);
            }
            resolve();
          });
        });
      }
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS((exports, module) => {
  var objectIdSymbol = require_symbols().objectIdSymbol;
  var utils = require_utils3();
  /*!
   * ignore
   */
  module.exports = function shardingPlugin(schema) {
    schema.post("init", function shardingPluginPostInit() {
      storeShard.call(this);
      return this;
    });
    schema.pre("save", function shardingPluginPreSave(next) {
      applyWhere.call(this);
      next();
    });
    schema.pre("remove", function shardingPluginPreRemove(next) {
      applyWhere.call(this);
      next();
    });
    schema.post("save", function shardingPluginPostSave() {
      storeShard.call(this);
    });
  };
  /*!
   * ignore
   */
  function applyWhere() {
    let paths;
    let len;
    if (this.$__.shardval) {
      paths = Object.keys(this.$__.shardval);
      len = paths.length;
      this.$where = this.$where || {};
      for (let i = 0;i < len; ++i) {
        this.$where[paths[i]] = this.$__.shardval[paths[i]];
      }
    }
  }
  /*!
   * ignore
   */
  module.exports.storeShard = storeShard;
  /*!
   * ignore
   */
  function storeShard() {
    const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
    if (!utils.isPOJO(key)) {
      return;
    }
    const orig = this.$__.shardval = {};
    const paths = Object.keys(key);
    const len = paths.length;
    let val;
    for (let i = 0;i < len; ++i) {
      val = this.$__getValue(paths[i]);
      if (val == null) {
        orig[paths[i]] = val;
      } else if (utils.isMongooseObject(val)) {
        orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
      } else if (val instanceof Date || val[objectIdSymbol]) {
        orig[paths[i]] = val;
      } else if (typeof val.valueOf === "function") {
        orig[paths[i]] = val.valueOf();
      } else {
        orig[paths[i]] = val;
      }
    }
  }
});

// node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS((exports, module) => {
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var utils = require_utils3();
  module.exports = function trackTransaction(schema) {
    schema.pre("save", function trackTransactionPreSave() {
      const session = this.$session();
      if (session == null) {
        return;
      }
      if (session.transaction == null || session[sessionNewDocuments] == null) {
        return;
      }
      if (!session[sessionNewDocuments].has(this)) {
        const initialState = {};
        if (this.isNew) {
          initialState.isNew = true;
        }
        if (this.$__schema.options.versionKey) {
          initialState.versionKey = this.get(this.$__schema.options.versionKey);
        }
        initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify")));
        initialState.atomics = _getAtomics(this);
        session[sessionNewDocuments].set(this, initialState);
      }
    });
  };
  function _getAtomics(doc, previous) {
    const pathToAtomics = new Map;
    previous = previous || new Map;
    const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
    for (const path of pathsToCheck) {
      const val = doc.$__getValue(path);
      if (val != null && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
        const existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
    const dirty = doc.$__dirty();
    for (const dirt of dirty) {
      const path = dirt.path;
      const val = dirt.value;
      if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
        const existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
    return pathToAtomics;
  }
  function mergeAtomics(destination, source) {
    destination = destination || {};
    if (source.$pullAll != null) {
      destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
    }
    if (source.$push != null) {
      destination.$push = destination.$push || {};
      destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
    }
    if (source.$addToSet != null) {
      destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
    }
    if (source.$set != null) {
      destination.$set = Array.isArray(source.$set) ? [...source.$set] : Object.assign({}, source.$set);
    }
    return destination;
  }
});

// node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function validateBeforeSave(schema) {
    const unshift = true;
    schema.pre("save", false, function validateBeforeSave(next, options) {
      const _this = this;
      if (this.$isSubdocument) {
        return next();
      }
      const hasValidateBeforeSaveOption = options && typeof options === "object" && "validateBeforeSave" in options;
      let shouldValidate;
      if (hasValidateBeforeSaveOption) {
        shouldValidate = !!options.validateBeforeSave;
      } else {
        shouldValidate = this.$__schema.options.validateBeforeSave;
      }
      if (shouldValidate) {
        const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
        const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options.validateModifiedOnly } : null;
        this.$validate(validateOptions).then(() => {
          this.$op = "save";
          next();
        }, (error) => {
          _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            _this.$op = "save";
            next(error2);
          });
        });
      } else {
        next();
      }
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/index.js
var require_plugins = __commonJS((exports) => {
  exports.saveSubdocs = require_saveSubdocs();
  exports.sharding = require_sharding();
  exports.trackTransaction = require_trackTransaction();
  exports.validateBeforeSave = require_validateBeforeSave();
});

// node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js
var require_applyBuiltinPlugins = __commonJS((exports, module) => {
  var builtinPlugins = require_plugins();
  module.exports = function applyBuiltinPlugins(schema) {
    for (const plugin of Object.values(builtinPlugins)) {
      plugin(schema, { deduplicate: true });
    }
    schema.plugins = Object.values(builtinPlugins).map((fn) => ({ fn, opts: { deduplicate: true } })).concat(schema.plugins);
  };
});

// node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js
var require_mergeDiscriminatorSchema = __commonJS((exports, module) => {
  var schemaMerge = require_merge();
  var specialProperties = require_specialProperties();
  var isBsonType = require_isBsonType();
  var ObjectId2 = require_objectid();
  var isObject2 = require_isObject();
  module.exports = function mergeDiscriminatorSchema(to, from, path, seen) {
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    path = path || "";
    seen = seen || new WeakSet;
    if (seen.has(from)) {
      return;
    }
    seen.add(from);
    while (i < len) {
      key = keys[i++];
      if (!path) {
        if (key === "discriminators" || key === "base" || key === "_applyDiscriminators" || key === "_userProvidedOptions" || key === "options" || key === "tree") {
          continue;
        }
      }
      if (path === "tree" && from != null && from.instanceOfSchema) {
        continue;
      }
      if (specialProperties.has(key)) {
        continue;
      }
      if (to[key] == null) {
        to[key] = from[key];
      } else if (isObject2(from[key])) {
        if (!isObject2(to[key])) {
          to[key] = {};
        }
        if (from[key] != null) {
          if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested || from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement) {
            continue;
          } else if (from[key].instanceOfSchema) {
            if (to[key].instanceOfSchema) {
              schemaMerge(to[key], from[key].clone(), true);
            } else {
              to[key] = from[key].clone();
            }
            continue;
          } else if (isBsonType(from[key], "ObjectId")) {
            to[key] = new ObjectId2(from[key]);
            continue;
          }
        }
        mergeDiscriminatorSchema(to[key], from[key], path ? path + "." + key : key, seen);
      }
    }
    if (from != null && from.instanceOfSchema) {
      to.tree = Object.assign({}, from.tree, to.tree);
    }
  };
});

// node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS((exports, module) => {
  var Mixed = require_mixed();
  var applyBuiltinPlugins = require_applyBuiltinPlugins();
  var clone2 = require_clone();
  var defineKey = require_compile().defineKey;
  var get = require_get();
  var utils = require_utils3();
  var mergeDiscriminatorSchema = require_mergeDiscriminatorSchema();
  var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
    toJSON: true,
    toObject: true,
    _id: true,
    id: true,
    virtuals: true,
    methods: true
  };
  function validateDiscriminatorSchemasForEncryption(parentSchema, childSchema) {
    if (parentSchema.encryptionType() == null && childSchema.encryptionType() == null)
      return;
    const allSharedNestedPaths = setIntersection(allNestedPaths(parentSchema), allNestedPaths(childSchema));
    for (const path of allSharedNestedPaths) {
      if (parentSchema._hasEncryptedField(path) && childSchema._hasEncryptedField(path)) {
        throw new Error(`encrypted fields cannot be declared on both the base schema and the child schema in a discriminator. path=${path}`);
      }
      if (parentSchema._hasEncryptedField(path) || childSchema._hasEncryptedField(path)) {
        throw new Error(`encrypted fields cannot have the same path as a non-encrypted field for discriminators. path=${path}`);
      }
    }
    function allNestedPaths(schema) {
      return [...Object.keys(schema.paths), ...Object.keys(schema.singleNestedPaths)];
    }
    function* setIntersection(i1, i2) {
      const s1 = new Set(i1);
      for (const item of i2) {
        if (s1.has(item)) {
          yield item;
        }
      }
    }
  }
  /*!
   * ignore
   */
  module.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {
    if (!(schema && schema.instanceOfSchema)) {
      throw new Error("You must pass a valid discriminator Schema");
    }
    mergeHooks = mergeHooks == null ? true : mergeHooks;
    if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
      throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
    }
    if (applyPlugins) {
      const applyPluginsToDiscriminators = get(model.base, "options.applyPluginsToDiscriminators", false) || !mergeHooks;
      model.base._applyPlugins(schema, {
        skipTopLevel: !applyPluginsToDiscriminators
      });
    } else if (!mergeHooks) {
      applyBuiltinPlugins(schema);
    }
    const key = model.schema.options.discriminatorKey;
    const existingPath = model.schema.path(key);
    if (existingPath != null) {
      if (!utils.hasUserDefinedProperty(existingPath.options, "select")) {
        existingPath.options.select = true;
      }
      existingPath.options.$skipDiscriminatorCheck = true;
    } else {
      const baseSchemaAddition = {};
      baseSchemaAddition[key] = {
        default: undefined,
        select: true,
        $skipDiscriminatorCheck: true
      };
      baseSchemaAddition[key][model.schema.options.typeKey] = String;
      model.schema.add(baseSchemaAddition);
      defineKey({
        prop: key,
        prototype: model.prototype,
        options: model.schema.options
      });
    }
    if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
      throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
    }
    let value = name;
    if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
      value = tiedValue;
    }
    validateDiscriminatorSchemasForEncryption(model.schema, schema);
    function merge(schema2, baseSchema) {
      schema2._baseSchema = baseSchema;
      if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
        schema2.remove("_id");
      }
      const baseSchemaPaths = Object.keys(baseSchema.paths);
      const conflictingPaths = [];
      for (const path of baseSchemaPaths) {
        if (schema2.nested[path]) {
          conflictingPaths.push(path);
          continue;
        }
        if (path.indexOf(".") === -1) {
          continue;
        }
        const sp = path.split(".").slice(0, -1);
        let cur = "";
        for (const piece of sp) {
          cur += (cur.length ? "." : "") + piece;
          if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
            conflictingPaths.push(path);
          }
        }
      }
      schema2.obj = { ...schema2.obj };
      mergeDiscriminatorSchema(schema2, baseSchema);
      schema2._gatherChildSchemas();
      for (const conflictingPath of conflictingPaths) {
        delete schema2.paths[conflictingPath];
      }
      schema2.childSchemas.forEach((obj2) => {
        obj2.model.prototype.$__setSchema(obj2.schema);
      });
      const obj = {};
      obj[key] = {
        default: value,
        select: true,
        set: function(newName) {
          if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
            return value;
          }
          throw new Error(`Can't set discriminator key "` + key + '"');
        },
        $skipDiscriminatorCheck: true
      };
      obj[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
      schema2.add(obj);
      schema2.discriminatorMapping = { key, value, isRoot: false };
      if (baseSchema.options.collection) {
        schema2.options.collection = baseSchema.options.collection;
      }
      const toJSON = schema2.options.toJSON;
      const toObject = schema2.options.toObject;
      const _id = schema2.options._id;
      const id = schema2.options.id;
      const keys = Object.keys(schema2.options);
      schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
      const userProvidedOptions = schema2._userProvidedOptions;
      for (const _key of keys) {
        if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
          if (_key in userProvidedOptions && !utils.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
            throw new Error("Can't customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
          }
        }
      }
      schema2.options = clone2(baseSchema.options);
      for (const _key of Object.keys(userProvidedOptions)) {
        schema2.options[_key] = userProvidedOptions[_key];
      }
      if (toJSON)
        schema2.options.toJSON = toJSON;
      if (toObject)
        schema2.options.toObject = toObject;
      if (typeof _id !== "undefined") {
        schema2.options._id = _id;
      }
      schema2.options.id = id;
      if (mergeHooks) {
        schema2.s.hooks = model.schema.s.hooks.merge(schema2.s.hooks);
      }
      if (applyPlugins) {
        schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
      }
      schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
      delete schema2._requiredpaths;
    }
    merge(schema, model.schema);
    if (!model.discriminators) {
      model.discriminators = {};
    }
    if (!model.schema.discriminatorMapping) {
      model.schema.discriminatorMapping = { key, value: null, isRoot: true };
    }
    if (!model.schema.discriminators) {
      model.schema.discriminators = {};
    }
    model.schema.discriminators[name] = schema;
    if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {
      throw new Error('Discriminator with name "' + name + '" already exists');
    }
    return schema;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS((exports, module) => {
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  module.exports = function getConstructor(Constructor2, value, defaultDiscriminatorValue) {
    const discriminatorKey = Constructor2.schema.options.discriminatorKey;
    let discriminatorValue = value != null && value[discriminatorKey];
    if (discriminatorValue == null) {
      discriminatorValue = defaultDiscriminatorValue;
    }
    if (Constructor2.discriminators && discriminatorValue != null) {
      if (Constructor2.discriminators[discriminatorValue]) {
        Constructor2 = Constructor2.discriminators[discriminatorValue];
      } else {
        const constructorByValue = getDiscriminatorByValue(Constructor2.discriminators, discriminatorValue);
        if (constructorByValue) {
          Constructor2 = constructorByValue;
        }
      }
    }
    return Constructor2;
  };
});

// node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS((exports, module) => {
  var addAutoId = require_addAutoId();
  module.exports = function handleIdOption(schema, options) {
    if (options == null || options._id == null) {
      return schema;
    }
    schema = schema.clone();
    if (!options._id) {
      schema.remove("_id");
      schema.options._id = false;
    } else if (!schema.paths["_id"]) {
      addAutoId(schema);
      schema.options._id = true;
    }
    return schema;
  };
});

// node_modules/mongoose/lib/error/invalidSchemaOption.js
var require_invalidSchemaOption = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class InvalidSchemaOptionError extends MongooseError {
    constructor(name, option) {
      const msg = `Cannot create use schema for property "${name}" because the schema has the ${option} option enabled.`;
      super(msg);
    }
  }
  Object.defineProperty(InvalidSchemaOptionError.prototype, "name", {
    value: "InvalidSchemaOptionError"
  });
  /*!
   * exports
   */
  module.exports = InvalidSchemaOptionError;
});

// node_modules/mongoose/lib/schema/subdocument.js
var require_subdocument2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var EventEmitter = __require("events").EventEmitter;
  var ObjectExpectedError = require_objectExpected();
  var SchemaSubdocumentOptions = require_schemaSubdocumentOptions();
  var SchemaType = require_schemaType();
  var applyDefaults = require_applyDefaults();
  var $exists = require_exists();
  var castToNumber = require_helpers().castToNumber;
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var discriminator = require_discriminator();
  var geospatial = require_geospatial();
  var getConstructor = require_getConstructor();
  var handleIdOption = require_handleIdOption();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isExclusive = require_isExclusive();
  var utils = require_utils3();
  var InvalidSchemaOptionError = require_invalidSchemaOption();
  var SubdocumentType;
  module.exports = SchemaSubdocument;
  function SchemaSubdocument(schema, path, options) {
    if (schema.options.timeseries) {
      throw new InvalidSchemaOptionError(path, "timeseries");
    }
    const schemaTypeIdOption = SchemaSubdocument.defaultOptions && SchemaSubdocument.defaultOptions._id;
    if (schemaTypeIdOption != null) {
      options = options || {};
      options._id = schemaTypeIdOption;
    }
    schema = handleIdOption(schema, options);
    this.caster = _createConstructor(schema, null, options);
    this.caster.path = path;
    this.caster.prototype.$basePath = path;
    this.schema = schema;
    this.$isSingleNested = true;
    this.base = schema.base;
    SchemaType.call(this, path, options, "Embedded");
  }
  /*!
   * ignore
   */
  SchemaSubdocument.prototype = Object.create(SchemaType.prototype);
  SchemaSubdocument.prototype.constructor = SchemaSubdocument;
  SchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;
  /*!
   * ignore
   */
  function _createConstructor(schema, baseClass, options) {
    SubdocumentType || (SubdocumentType = require_subdocument());
    const _embedded = function SingleNested(value, path, parent) {
      this.$__parent = parent;
      SubdocumentType.apply(this, arguments);
      if (parent == null) {
        return;
      }
      this.$session(parent.$session());
    };
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;
    _embedded.prototype = Object.create(proto);
    _embedded.prototype.$__setSchema(schema);
    _embedded.prototype.constructor = _embedded;
    _embedded.prototype.$__schemaTypeOptions = options;
    _embedded.$__required = options?.required;
    _embedded.base = schema.base;
    _embedded.schema = schema;
    _embedded.$isSingleNested = true;
    _embedded.events = new EventEmitter;
    _embedded.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    for (const i in schema.methods) {
      _embedded.prototype[i] = schema.methods[i];
    }
    for (const i in schema.statics) {
      _embedded[i] = schema.statics[i];
    }
    for (const i in EventEmitter.prototype) {
      _embedded[i] = EventEmitter.prototype[i];
    }
    return _embedded;
  }
  /*!
   * ignore
   */
  var $conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };
  $conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {
    return { $geometry: this.castForQuery(null, val.$geometry, context) };
  };
  /*!
   * ignore
   */
  $conditionalHandlers.$near = $conditionalHandlers.$nearSphere = geospatial.cast$near;
  $conditionalHandlers.$within = $conditionalHandlers.$geoWithin = geospatial.cast$within;
  $conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
  $conditionalHandlers.$minDistance = castToNumber;
  $conditionalHandlers.$maxDistance = castToNumber;
  $conditionalHandlers.$exists = $exists;
  Object.defineProperty(SchemaSubdocument.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {
    if (val && val.$isSingleNested && val.parent === doc) {
      return val;
    }
    if (val != null && (typeof val !== "object" || Array.isArray(val))) {
      throw new ObjectExpectedError(this.path, val);
    }
    const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);
    const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);
    const Constructor2 = getConstructor(this.caster, val, defaultDiscriminatorValue);
    let subdoc;
    const parentSelected = doc && doc.$__ && doc.$__.selected;
    const path = this.path;
    const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {
      if (key.startsWith(path + ".")) {
        obj = obj || {};
        obj[key.substring(path.length + 1)] = parentSelected[key];
      }
      return obj;
    }, null);
    if (init) {
      subdoc = new Constructor2(undefined, selected, doc, false, { defaults: false });
      delete subdoc.$__.defaults;
      subdoc.$init(val);
      const exclude = isExclusive(selected);
      applyDefaults(subdoc, selected, exclude);
    } else {
      options = Object.assign({}, options, { priorDoc: priorVal });
      if (Object.keys(val).length === 0) {
        return new Constructor2({}, selected, doc, undefined, options);
      }
      return new Constructor2(val, selected, doc, undefined, options);
    }
    return subdoc;
  };
  SchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional);
      }
      return handler.call(this, val);
    }
    if (val == null) {
      return val;
    }
    const Constructor2 = getConstructor(this.caster, val);
    if (val instanceof Constructor2) {
      return val;
    }
    if (this.options.runSetters) {
      val = this._applySetters(val, context);
    }
    const overrideStrict = options != null && options.strict != null ? options.strict : undefined;
    try {
      val = new Constructor2(val, overrideStrict);
    } catch (error) {
      if (!(error instanceof CastError)) {
        throw new CastError("Embedded", val, this.path, error, this);
      }
      throw error;
    }
    return val;
  };
  SchemaSubdocument.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor2 = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor2)) {
      value = new Constructor2(value, null, scope != null && scope.$__ != null ? scope : null);
    }
    if (options && options.skipSchemaValidators) {
      if (!value) {
        return fn(null);
      }
      return value.validate().then(() => fn(null), (err2) => fn(err2));
    }
    SchemaType.prototype.doValidate.call(this, value, function(error) {
      if (error) {
        return fn(error);
      }
      if (!value) {
        return fn(null);
      }
      value.validate().then(() => fn(null), (err2) => fn(err2));
    }, scope, options);
  };
  SchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {
    if (!options || !options.skipSchemaValidators) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
      if (schemaTypeError) {
        return schemaTypeError;
      }
    }
    if (!value) {
      return;
    }
    return value.validateSync();
  };
  SchemaSubdocument.prototype.discriminator = function(name, schema, options) {
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone2 = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone2) {
      schema = schema.clone();
    }
    schema = discriminator(this.caster, name, schema, value, null, null, options.overwriteExisting);
    this.caster.discriminators[name] = _createConstructor(schema, this.caster);
    return this.caster.discriminators[name];
  };
  /*!
   * ignore
   */
  SchemaSubdocument.defaultOptions = {};
  SchemaSubdocument.set = SchemaType.set;
  SchemaSubdocument.setters = [];
  SchemaSubdocument.get = SchemaType.get;
  /*!
   * ignore
   */
  SchemaSubdocument.prototype.toJSON = function toJSON() {
    return { path: this.path, options: this.options };
  };
  /*!
   * ignore
   */
  SchemaSubdocument.prototype.clone = function() {
    const schematype = new this.constructor(this.schema, this.path, { ...this.options, _skipApplyDiscriminators: true });
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
    schematype._appliedDiscriminators = this._appliedDiscriminators;
    return schematype;
  };
  SchemaSubdocument.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return {
      ...this.schema.toJSONSchema(options),
      ...createJSONSchemaTypeDefinition("object", "object", options?.useBsonType, isRequired)
    };
  };
});

// node_modules/mongoose/lib/schema/documentArrayElement.js
var require_documentArrayElement = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var SchemaType = require_schemaType();
  var SchemaSubdocument = require_subdocument2();
  var getConstructor = require_getConstructor();
  function SchemaDocumentArrayElement(path, options) {
    this.$parentSchemaType = options && options.$parentSchemaType;
    if (!this.$parentSchemaType) {
      throw new MongooseError("Cannot create DocumentArrayElement schematype without a parent");
    }
    delete options.$parentSchemaType;
    SchemaType.call(this, path, options, "DocumentArrayElement");
    this.$isMongooseDocumentArrayElement = true;
  }
  SchemaDocumentArrayElement.schemaName = "DocumentArrayElement";
  SchemaDocumentArrayElement.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);
  SchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;
  SchemaDocumentArrayElement.prototype.cast = function(...args) {
    return this.$parentSchemaType.cast(...args)[0];
  };
  SchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor2 = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor2)) {
      value = new Constructor2(value, scope, null, null, options && options.index != null ? options.index : null);
    }
    return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);
  };
  SchemaDocumentArrayElement.prototype.clone = function() {
    this.options.$parentSchemaType = this.$parentSchemaType;
    const ret = SchemaType.prototype.clone.apply(this, arguments);
    delete this.options.$parentSchemaType;
    ret.caster = this.caster;
    ret.schema = this.schema;
    return ret;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDocumentArrayElement;
});

// node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js
var require_schemaDocumentArrayOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaDocumentArrayOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
  Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
  /*!
   * ignore
   */
  module.exports = SchemaDocumentArrayOptions;
});

// node_modules/mongoose/lib/schema/documentArray.js
var require_documentArray2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var DocumentArrayElement = require_documentArrayElement();
  var EventEmitter = __require("events").EventEmitter;
  var SchemaArray = require_array2();
  var SchemaDocumentArrayOptions = require_schemaDocumentArrayOptions();
  var SchemaType = require_schemaType();
  var cast2 = require_cast2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var discriminator = require_discriminator();
  var handleIdOption = require_handleIdOption();
  var handleSpreadDoc = require_handleSpreadDoc();
  var isOperator = require_isOperator();
  var utils = require_utils3();
  var getConstructor = require_getConstructor();
  var InvalidSchemaOptionError = require_invalidSchemaOption();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var MongooseDocumentArray;
  var Subdocument;
  function SchemaDocumentArray(key, schema, options, schemaOptions) {
    if (schema.options && schema.options.timeseries) {
      throw new InvalidSchemaOptionError(key, "timeseries");
    }
    const schemaTypeIdOption = SchemaDocumentArray.defaultOptions && SchemaDocumentArray.defaultOptions._id;
    if (schemaTypeIdOption != null) {
      schemaOptions = schemaOptions || {};
      schemaOptions._id = schemaTypeIdOption;
    }
    if (schemaOptions != null && schemaOptions._id != null) {
      schema = handleIdOption(schema, schemaOptions);
    } else if (options != null && options._id != null) {
      schema = handleIdOption(schema, options);
    }
    const EmbeddedDocument = _createConstructor(schema, options);
    EmbeddedDocument.prototype.$basePath = key;
    SchemaArray.call(this, key, EmbeddedDocument, options);
    this.schema = schema;
    this.schemaOptions = schemaOptions || {};
    this.$isMongooseDocumentArray = true;
    this.Constructor = EmbeddedDocument;
    EmbeddedDocument.base = schema.base;
    const fn = this.defaultValue;
    if (!("defaultValue" in this) || fn != null) {
      this.default(function() {
        let arr = fn.call(this);
        if (arr != null && !Array.isArray(arr)) {
          arr = [arr];
        }
        return arr;
      });
    }
    const $parentSchemaType = this;
    this.$embeddedSchemaType = new DocumentArrayElement(key + ".$", {
      ...schemaOptions || {},
      $parentSchemaType
    });
    this.$embeddedSchemaType.caster = this.Constructor;
    this.$embeddedSchemaType.schema = this.schema;
  }
  SchemaDocumentArray.schemaName = "DocumentArray";
  SchemaDocumentArray.options = { castNonArrays: true };
  /*!
   * Inherits from SchemaArray.
   */
  SchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);
  SchemaDocumentArray.prototype.constructor = SchemaDocumentArray;
  SchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
  Object.defineProperty(SchemaDocumentArray.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: { ...SchemaArray.prototype.$conditionalHandlers }
  });
  /*!
   * ignore
   */
  function _createConstructor(schema, options, baseClass) {
    Subdocument || (Subdocument = require_arraySubdocument());
    function EmbeddedDocument() {
      Subdocument.apply(this, arguments);
      if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {
        return;
      }
      this.$session(this.__parentArray.getArrayParent().$session());
    }
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
    EmbeddedDocument.prototype = Object.create(proto);
    EmbeddedDocument.prototype.$__setSchema(schema);
    EmbeddedDocument.schema = schema;
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    EmbeddedDocument.$isArraySubdocument = true;
    EmbeddedDocument.events = new EventEmitter;
    EmbeddedDocument.base = schema.base;
    for (const i in schema.methods) {
      EmbeddedDocument.prototype[i] = schema.methods[i];
    }
    for (const i in schema.statics) {
      EmbeddedDocument[i] = schema.statics[i];
    }
    for (const i in EventEmitter.prototype) {
      EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.options = options;
    return EmbeddedDocument;
  }
  SchemaDocumentArray.prototype.discriminator = function(name, schema, options) {
    if (typeof name === "function") {
      name = utils.getFunctionName(name);
    }
    options = options || {};
    const tiedValue = utils.isPOJO(options) ? options.value : options;
    const clone2 = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone2) {
      schema = schema.clone();
    }
    schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);
    const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
    EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
    try {
      Object.defineProperty(EmbeddedDocument, "name", {
        value: name
      });
    } catch (error) {
    }
    this.casterConstructor.discriminators[name] = EmbeddedDocument;
    return this.casterConstructor.discriminators[name];
  };
  SchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {
    MongooseDocumentArray || (MongooseDocumentArray = require_documentArray());
    const _this = this;
    try {
      SchemaType.prototype.doValidate.call(this, array, cb, scope);
    } catch (err2) {
      return fn(err2);
    }
    function cb(err2) {
      if (err2) {
        return fn(err2);
      }
      let count = array && array.length;
      let error;
      if (!count) {
        return fn();
      }
      if (options && options.updateValidator) {
        return fn();
      }
      if (!utils.isMongooseDocumentArray(array)) {
        array = new MongooseDocumentArray(array, _this.path, scope);
      }
      function callback(err3) {
        if (err3 != null) {
          error = err3;
        }
        --count || fn(error);
      }
      for (let i = 0, len = count;i < len; ++i) {
        let doc = array[i];
        if (doc == null) {
          --count || fn(error);
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor2 = getConstructor(_this.casterConstructor, array[i]);
          doc = array[i] = new Constructor2(doc, array, undefined, undefined, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
          --count || fn(error);
          continue;
        }
        doc.$__validate(null, options, callback);
      }
    }
  };
  SchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {
    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
    if (schemaTypeError != null) {
      return schemaTypeError;
    }
    const count = array && array.length;
    let resultError = null;
    if (!count) {
      return;
    }
    for (let i = 0, len = count;i < len; ++i) {
      let doc = array[i];
      if (!doc) {
        continue;
      }
      if (!(doc instanceof Subdocument)) {
        const Constructor2 = getConstructor(this.casterConstructor, array[i]);
        doc = array[i] = new Constructor2(doc, array, undefined, undefined, i);
      }
      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
        continue;
      }
      const subdocValidateError = doc.validateSync(options);
      if (subdocValidateError && resultError == null) {
        resultError = subdocValidateError;
      }
    }
    return resultError;
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.getDefault = function(scope, init, options) {
    let ret = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
    if (ret == null) {
      return ret;
    }
    if (options && options.skipCast) {
      return ret;
    }
    MongooseDocumentArray || (MongooseDocumentArray = require_documentArray());
    if (!Array.isArray(ret)) {
      ret = [ret];
    }
    ret = new MongooseDocumentArray(ret, this.path, scope);
    for (let i = 0;i < ret.length; ++i) {
      const Constructor2 = getConstructor(this.casterConstructor, ret[i]);
      const _subdoc = new Constructor2({}, ret, undefined, undefined, i);
      _subdoc.$init(ret[i]);
      _subdoc.isNew = true;
      Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
      _subdoc.$__.activePaths.init = {};
      ret[i] = _subdoc;
    }
    return ret;
  };
  var _toObjectOptions = Object.freeze({ transform: false, virtuals: false });
  var initDocumentOptions = Object.freeze({ skipId: false, willInit: true });
  SchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {
    MongooseDocumentArray || (MongooseDocumentArray = require_documentArray());
    if (value != null && value[arrayPathSymbol] != null && value === prev) {
      return value;
    }
    let selected;
    let subdoc;
    options = options || {};
    const path = options.path || this.path;
    if (!Array.isArray(value)) {
      if (!init && !SchemaDocumentArray.options.castNonArrays) {
        throw new CastError("DocumentArray", value, this.path, null, this);
      }
      if (!!doc && init) {
        doc.markModified(path);
      }
      return this.cast([value], doc, init, prev, options);
    }
    if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {
      value = new MongooseDocumentArray(value, path, doc, this);
    }
    if (prev != null) {
      value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
    }
    if (options.arrayPathIndex != null) {
      value[arrayPathSymbol] = path + "." + options.arrayPathIndex;
    }
    const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;
    const len = rawArray.length;
    for (let i = 0;i < len; ++i) {
      if (!rawArray[i]) {
        continue;
      }
      const Constructor2 = getConstructor(this.casterConstructor, rawArray[i]);
      const spreadDoc = handleSpreadDoc(rawArray[i], true);
      if (rawArray[i] !== spreadDoc) {
        rawArray[i] = spreadDoc;
      }
      if (rawArray[i] instanceof Subdocument) {
        if (rawArray[i][documentArrayParent] !== doc) {
          if (init) {
            const subdoc2 = new Constructor2(null, value, initDocumentOptions, selected, i);
            rawArray[i] = subdoc2.$init(rawArray[i]);
          } else {
            const subdoc2 = new Constructor2(rawArray[i], value, undefined, undefined, i);
            rawArray[i] = subdoc2;
          }
        }
        if (rawArray[i].__index == null) {
          rawArray[i].$setIndex(i);
        }
      } else if (rawArray[i] != null) {
        if (init) {
          if (doc) {
            selected || (selected = scopePaths(this, doc.$__.selected, init));
          } else {
            selected = true;
          }
          subdoc = new Constructor2(null, value, initDocumentOptions, selected, i);
          rawArray[i] = subdoc.$init(rawArray[i]);
        } else {
          if (prev && typeof prev.id === "function") {
            subdoc = prev.id(rawArray[i]._id);
          }
          if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {
            subdoc.set(rawArray[i]);
            rawArray[i] = subdoc;
          } else {
            try {
              subdoc = new Constructor2(rawArray[i], value, undefined, undefined, i);
              rawArray[i] = subdoc;
            } catch (error) {
              throw new CastError("embedded", rawArray[i], value[arrayPathSymbol], error, this);
            }
          }
        }
      }
    }
    return value;
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);
    schematype._appliedDiscriminators = this._appliedDiscriminators;
    return schematype;
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.applyGetters = function(value, scope) {
    return SchemaType.prototype.applyGetters.call(this, value, scope);
  };
  function scopePaths(array, fields, init) {
    if (!(init && fields)) {
      return;
    }
    const path = array.path + ".";
    const keys = Object.keys(fields);
    let i = keys.length;
    const selected = {};
    let hasKeys;
    let key;
    let sub;
    while (i--) {
      key = keys[i];
      if (key.startsWith(path)) {
        sub = key.substring(path.length);
        if (sub === "$") {
          continue;
        }
        if (sub.startsWith("$.")) {
          sub = sub.substring(2);
        }
        hasKeys || (hasKeys = true);
        selected[sub] = fields[key];
      }
    }
    return hasKeys && selected || undefined;
  }
  /*!
   * ignore
   */
  SchemaDocumentArray.defaultOptions = {};
  SchemaDocumentArray.set = SchemaType.set;
  SchemaDocumentArray.setters = [];
  SchemaDocumentArray.get = SchemaType.get;
  /*!
   * Handle casting $elemMatch operators
   */
  SchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;
  function cast$elemMatch(val, context) {
    const keys = Object.keys(val);
    const numKeys = keys.length;
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const value = val[key];
      if (isOperator(key) && value != null) {
        val[key] = this.castForQuery(key, value, context);
      }
    }
    const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;
    const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
    if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
      return cast2(discriminators[val[discriminatorKey]], val, null, this && this.$$context);
    }
    const schema = this.casterConstructor.schema ?? context.schema;
    return cast2(schema, val, null, this && this.$$context);
  }
  SchemaDocumentArray.prototype.toJSONSchema = function toJSONSchema(options) {
    const itemsTypeDefinition = createJSONSchemaTypeDefinition("object", "object", options?.useBsonType, false);
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return {
      ...createJSONSchemaTypeDefinition("array", "array", options?.useBsonType, isRequired),
      items: { ...itemsTypeDefinition, ...this.schema.toJSONSchema(options) }
    };
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDocumentArray;
});

// node_modules/mongoose/lib/options/schemaMapOptions.js
var require_schemaMapOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaMapOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
  module.exports = SchemaMapOptions;
});

// node_modules/mongoose/lib/schema/map.js
var require_map2 = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var MongooseMap = require_map();
  var SchemaMapOptions = require_schemaMapOptions();
  var SchemaType = require_schemaType();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  /*!
   * ignore
   */

  class SchemaMap extends SchemaType {
    constructor(key, options) {
      super(key, options, "Map");
      this.$isSchemaMap = true;
    }
    set(option, value) {
      return SchemaType.set(option, value);
    }
    cast(val, doc, init, prev, options) {
      if (val instanceof MongooseMap) {
        return val;
      }
      const path = options?.path ?? this.path;
      if (init) {
        const map3 = new MongooseMap({}, path, doc, this.$__schemaType);
        if (val instanceof global.Map) {
          for (const key of val.keys()) {
            let _val = val.get(key);
            if (_val == null) {
              _val = map3.$__schemaType._castNullish(_val);
            } else {
              _val = map3.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
            }
            map3.$init(key, _val);
          }
        } else {
          for (const key of Object.keys(val)) {
            let _val = val[key];
            if (_val == null) {
              _val = map3.$__schemaType._castNullish(_val);
            } else {
              _val = map3.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
            }
            map3.$init(key, _val);
          }
        }
        return map3;
      }
      return new MongooseMap(val, path, doc, this.$__schemaType);
    }
    clone() {
      const schematype = super.clone();
      if (this.$__schemaType != null) {
        schematype.$__schemaType = this.$__schemaType.clone();
      }
      return schematype;
    }
    getEmbeddedSchemaType() {
      return this.$__schemaType;
    }
    toJSONSchema(options) {
      const useBsonType = options?.useBsonType;
      const embeddedSchemaType = this.getEmbeddedSchemaType();
      const isRequired = this.options.required && typeof this.options.required !== "function";
      const result = createJSONSchemaTypeDefinition("object", "object", useBsonType, isRequired);
      result.additionalProperties = embeddedSchemaType.toJSONSchema(options);
      return result;
    }
    autoEncryptionType() {
      return "object";
    }
  }
  SchemaMap.schemaName = "Map";
  SchemaMap.prototype.OptionsConstructor = SchemaMapOptions;
  SchemaMap.defaultOptions = {};
  module.exports = SchemaMap;
});

// node_modules/mongoose/lib/options/schemaObjectIdOptions.js
var require_schemaObjectIdOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaObjectIdOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
  Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaObjectIdOptions;
});

// node_modules/mongoose/lib/schema/objectId.js
var require_objectId = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var SchemaObjectIdOptions = require_schemaObjectIdOptions();
  var SchemaType = require_schemaType();
  var castObjectId = require_objectid2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var getConstructorName = require_getConstructorName();
  var oid = require_objectid();
  var isBsonType = require_isBsonType();
  var utils = require_utils3();
  var CastError = SchemaType.CastError;
  var Document;
  function SchemaObjectId(key, options) {
    const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
    const suppressWarning = options && options.suppressWarning;
    if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
      utils.warn("mongoose: To create a new ObjectId please try " + "`Mongoose.Types.ObjectId` instead of using " + "`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if " + "you're trying to create a hex char path in your schema.");
    }
    SchemaType.call(this, key, options, "ObjectId");
  }
  SchemaObjectId.schemaName = "ObjectId";
  SchemaObjectId.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaObjectId.prototype = Object.create(SchemaType.prototype);
  SchemaObjectId.prototype.constructor = SchemaObjectId;
  SchemaObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;
  SchemaObjectId.get = SchemaType.get;
  SchemaObjectId.set = SchemaType.set;
  SchemaObjectId.setters = [];
  SchemaObjectId.prototype.auto = function(turnOn) {
    if (turnOn) {
      this.default(defaultId);
      this.set(resetId);
    }
    return this;
  };
  /*!
   * ignore
   */
  SchemaObjectId._checkRequired = (v) => isBsonType(v, "ObjectId");
  /*!
   * ignore
   */
  SchemaObjectId._cast = castObjectId;
  SchemaObjectId.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaObjectId._defaultCaster = (v) => {
    if (!isBsonType(v, "ObjectId")) {
      throw new Error(v + " is not an instance of ObjectId");
    }
    return v;
  };
  SchemaObjectId.checkRequired = SchemaType.checkRequired;
  SchemaObjectId.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaObjectId.checkRequired();
    return _checkRequired(value);
  };
  SchemaObjectId.prototype.cast = function(value, doc, init, prev, options) {
    if (!isBsonType(value, "ObjectId") && SchemaType._isRef(this, value, doc, init)) {
      if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
        return new oid(value.toHexString());
      }
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init, options);
      }
    }
    let castObjectId2;
    if (typeof this._castFunction === "function") {
      castObjectId2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castObjectId2 = this.constructor.cast();
    } else {
      castObjectId2 = SchemaObjectId.cast();
    }
    try {
      return castObjectId2(value);
    } catch (error) {
      throw new CastError("ObjectId", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  function handleSingle(val) {
    return this.cast(val);
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  Object.defineProperty(SchemaObjectId.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  /*!
   * ignore
   */
  function defaultId() {
    return new oid;
  }
  defaultId.$runBeforeSetters = true;
  function resetId(v) {
    Document || (Document = require_document2());
    if (this instanceof Document) {
      if (v === undefined) {
        const _v = new oid;
        return _v;
      }
    }
    return v;
  }
  SchemaObjectId.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function" || this.path === "_id";
    return createJSONSchemaTypeDefinition("string", "objectId", options?.useBsonType, isRequired);
  };
  SchemaObjectId.prototype.autoEncryptionType = function autoEncryptionType() {
    return "objectId";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaObjectId;
});

// node_modules/mongoose/lib/options/schemaStringOptions.js
var require_schemaStringOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaStringOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaStringOptions;
});

// node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schemaType();
  var MongooseError = require_error2();
  var SchemaStringOptions = require_schemaStringOptions();
  var castString = require_string();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var utils = require_utils3();
  var isBsonType = require_isBsonType();
  var CastError = SchemaType.CastError;
  function SchemaString(key, options) {
    this.enumValues = [];
    this.regExp = null;
    SchemaType.call(this, key, options, "String");
  }
  SchemaString.schemaName = "String";
  SchemaString.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaString.prototype = Object.create(SchemaType.prototype);
  SchemaString.prototype.constructor = SchemaString;
  Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: SchemaStringOptions
  });
  /*!
   * ignore
   */
  SchemaString._cast = castString;
  SchemaString.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaString._defaultCaster = (v) => {
    if (v != null && typeof v !== "string") {
      throw new Error;
    }
    return v;
  };
  SchemaString.get = SchemaType.get;
  SchemaString.set = SchemaType.set;
  SchemaString.setters = [];
  /*!
   * ignore
   */
  SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
  SchemaString.checkRequired = SchemaType.checkRequired;
  SchemaString.prototype.enum = function() {
    if (this.enumValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.enumValidator;
      }, this);
      this.enumValidator = false;
    }
    if (arguments[0] === undefined || arguments[0] === false) {
      return this;
    }
    let values;
    let errorMessage;
    if (utils.isObject(arguments[0])) {
      if (Array.isArray(arguments[0].values)) {
        values = arguments[0].values;
        errorMessage = arguments[0].message;
      } else {
        values = utils.object.vals(arguments[0]);
        errorMessage = MongooseError.messages.String.enum;
      }
    } else {
      values = arguments;
      errorMessage = MongooseError.messages.String.enum;
    }
    for (const value of values) {
      if (value !== undefined) {
        this.enumValues.push(this.cast(value));
      }
    }
    const vals = this.enumValues;
    this.enumValidator = function(v) {
      return v == null || ~vals.indexOf(v);
    };
    this.validators.push({
      validator: this.enumValidator,
      message: errorMessage,
      type: "enum",
      enumValues: vals
    });
    return this;
  };
  SchemaString.prototype.lowercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.toLowerCase();
      }
      return v;
    });
  };
  SchemaString.prototype.uppercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.toUpperCase();
      }
      return v;
    });
  };
  SchemaString.prototype.trim = function(shouldTrim) {
    if (arguments.length > 0 && !shouldTrim) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.trim();
      }
      return v;
    });
  };
  SchemaString.prototype.minlength = function(value, message) {
    if (this.minlengthValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minlengthValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.String.minlength;
      msg = msg.replace(/{MINLENGTH}/, value);
      this.validators.push({
        validator: this.minlengthValidator = function(v) {
          return v === null || v.length >= value;
        },
        message: msg,
        type: "minlength",
        minlength: value
      });
    }
    return this;
  };
  SchemaString.prototype.minLength = SchemaString.prototype.minlength;
  SchemaString.prototype.maxlength = function(value, message) {
    if (this.maxlengthValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxlengthValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.String.maxlength;
      msg = msg.replace(/{MAXLENGTH}/, value);
      this.validators.push({
        validator: this.maxlengthValidator = function(v) {
          return v === null || v.length <= value;
        },
        message: msg,
        type: "maxlength",
        maxlength: value
      });
    }
    return this;
  };
  SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
  SchemaString.prototype.match = function match(regExp, message) {
    const msg = message || MongooseError.messages.String.match;
    const matchValidator = function(v) {
      if (!regExp) {
        return false;
      }
      regExp.lastIndex = 0;
      const ret = v != null && v !== "" ? regExp.test(v) : true;
      return ret;
    };
    this.validators.push({
      validator: matchValidator,
      message: msg,
      type: "regexp",
      regexp: regExp
    });
    return this;
  };
  SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
    return _checkRequired(value);
  };
  SchemaString.prototype.cast = function(value, doc, init, prev, options) {
    if (typeof value !== "string" && SchemaType._isRef(this, value, doc, init)) {
      return this._castRef(value, doc, init, options);
    }
    let castString2;
    if (typeof this._castFunction === "function") {
      castString2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castString2 = this.constructor.cast();
    } else {
      castString2 = SchemaString.cast();
    }
    try {
      return castString2(value);
    } catch (error) {
      throw new CastError("string", value, this.path, null, this);
    }
  };
  /*!
   * ignore
   */
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  /*!
   * ignore
   */
  function handleArray(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m2) {
      return _this.castForQuery(null, m2, context);
    });
  }
  /*!
   * ignore
   */
  function handleSingleNoSetters(val) {
    if (val == null) {
      return this._castNullish(val);
    }
    return this.cast(val, this);
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $options: handleSingleNoSetters,
    $regex: function handle$regex(val) {
      if (Object.prototype.toString.call(val) === "[object RegExp]") {
        return val;
      }
      return handleSingleNoSetters.call(this, val);
    },
    $not: handleSingle
  };
  Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaString.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional + " with String.");
      }
      return handler.call(this, val, context);
    }
    if (Object.prototype.toString.call(val) === "[object RegExp]" || isBsonType(val, "BSONRegExp")) {
      return val;
    }
    try {
      return this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
  };
  SchemaString.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "string", options?.useBsonType, isRequired);
  };
  SchemaString.prototype.autoEncryptionType = function autoEncryptionType() {
    return "string";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaString;
});

// node_modules/mongoose/lib/cast/uuid.js
var require_uuid2 = __commonJS((exports, module) => {
  var MongooseBuffer = require_buffer();
  var UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;
  var Binary = MongooseBuffer.Binary;
  module.exports = function castUUID(value) {
    if (value == null) {
      return value;
    }
    function newBuffer(initbuff) {
      const buff = new MongooseBuffer(initbuff);
      buff._subtype = 4;
      return buff;
    }
    if (typeof value === "string") {
      if (UUID_FORMAT.test(value)) {
        return stringToBinary(value);
      } else {
        throw new Error(`"${value}" is not a valid UUID string`);
      }
    }
    if (Buffer.isBuffer(value)) {
      return newBuffer(value);
    }
    if (value instanceof Binary) {
      return newBuffer(value.value(true));
    }
    if (value.toString && value.toString !== Object.prototype.toString) {
      if (UUID_FORMAT.test(value.toString())) {
        return stringToBinary(value.toString());
      }
    }
    throw new Error(`"${value}" cannot be casted to a UUID`);
  };
  module.exports.UUID_FORMAT = UUID_FORMAT;
  function hex2buffer(hex) {
    const buff = hex != null && Buffer.from(hex, "hex");
    return buff;
  }
  function stringToBinary(uuidStr) {
    if (typeof uuidStr !== "string")
      uuidStr = "";
    const hex = uuidStr.replace(/[{}-]/g, "");
    const bytes = hex2buffer(hex);
    const buff = new MongooseBuffer(bytes);
    buff._subtype = 4;
    return buff;
  }
});

// node_modules/mongoose/lib/schema/uuid.js
var require_uuid3 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseBuffer = require_buffer();
  var SchemaType = require_schemaType();
  var CastError = SchemaType.CastError;
  var castUUID = require_uuid2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var utils = require_utils3();
  var handleBitwiseOperator = require_bitwise();
  var UUID_FORMAT = castUUID.UUID_FORMAT;
  var Binary = MongooseBuffer.Binary;
  function binaryToString(uuidBin) {
    let hex;
    if (typeof uuidBin !== "string" && uuidBin != null) {
      hex = uuidBin.toString("hex");
      const uuidStr = hex.substring(0, 8) + "-" + hex.substring(8, 8 + 4) + "-" + hex.substring(12, 12 + 4) + "-" + hex.substring(16, 16 + 4) + "-" + hex.substring(20, 20 + 12);
      return uuidStr;
    }
    return uuidBin;
  }
  function SchemaUUID(key, options) {
    SchemaType.call(this, key, options, "UUID");
    this.getters.push(function(value) {
      if (value != null && value.$__ != null) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        return binaryToString(value);
      } else if (value instanceof Binary) {
        return binaryToString(value.buffer);
      } else if (utils.isPOJO(value) && value.type === "Buffer" && Array.isArray(value.data)) {
        return binaryToString(Buffer.from(value.data));
      }
      return value;
    });
  }
  SchemaUUID.schemaName = "UUID";
  SchemaUUID.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaUUID.prototype = Object.create(SchemaType.prototype);
  SchemaUUID.prototype.constructor = SchemaUUID;
  /*!
   * ignore
   */
  SchemaUUID._cast = castUUID;
  SchemaUUID.get = SchemaType.get;
  SchemaUUID.set = SchemaType.set;
  SchemaUUID.setters = [];
  SchemaUUID.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaUUID._checkRequired = (v) => v != null;
  SchemaUUID.checkRequired = SchemaType.checkRequired;
  SchemaUUID.prototype.checkRequired = function checkRequired(value) {
    if (Buffer.isBuffer(value)) {
      value = binaryToString(value);
    }
    return value != null && UUID_FORMAT.test(value);
  };
  SchemaUUID.prototype.cast = function(value, doc, init, prev, options) {
    if (utils.isNonBuiltinObject(value) && SchemaType._isRef(this, value, doc, init)) {
      return this._castRef(value, doc, init, options);
    }
    let castFn;
    if (typeof this._castFunction === "function") {
      castFn = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castFn = this.constructor.cast();
    } else {
      castFn = SchemaUUID.cast();
    }
    try {
      return castFn(value);
    } catch (error) {
      throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  function handleSingle(val) {
    return this.cast(val);
  }
  /*!
   * ignore
   */
  function handleArray(val) {
    return val.map((m2) => {
      return this.cast(m2);
    });
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $in: handleArray,
    $lt: handleSingle,
    $lte: handleSingle,
    $ne: handleSingle,
    $nin: handleArray
  };
  Object.defineProperty(SchemaUUID.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaUUID.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler)
        throw new Error("Can't use " + $conditional + " with UUID.");
      return handler.call(this, val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
  };
  SchemaUUID.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "binData", options?.useBsonType, isRequired);
  };
  SchemaUUID.prototype.autoEncryptionType = function autoEncryptionType() {
    return "binData";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaUUID;
});

// node_modules/mongoose/lib/cast/double.js
var require_double2 = __commonJS((exports, module) => {
  var assert2 = __require("assert");
  var BSON = require_bson();
  var isBsonType = require_isBsonType();
  module.exports = function castDouble(val) {
    if (val == null || val === "") {
      return null;
    }
    let coercedVal;
    if (isBsonType(val, "Long")) {
      coercedVal = val.toNumber();
    } else if (typeof val === "string") {
      try {
        coercedVal = BSON.Double.fromString(val);
        return coercedVal;
      } catch {
        assert2.ok(false);
      }
    } else if (typeof val === "object") {
      const tempVal = val.valueOf() ?? val.toString();
      if (typeof tempVal === "string") {
        try {
          coercedVal = BSON.Double.fromString(val);
          return coercedVal;
        } catch {
          assert2.ok(false);
        }
      } else {
        coercedVal = Number(tempVal);
      }
    } else {
      coercedVal = Number(val);
    }
    return new BSON.Double(coercedVal);
  };
});

// node_modules/mongoose/lib/schema/double.js
var require_double3 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castDouble = require_double2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  function SchemaDouble(path, options) {
    SchemaType.call(this, path, options, "Double");
  }
  SchemaDouble.schemaName = "Double";
  SchemaDouble.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDouble.prototype = Object.create(SchemaType.prototype);
  SchemaDouble.prototype.constructor = SchemaDouble;
  /*!
   * ignore
   */
  SchemaDouble._cast = castDouble;
  SchemaDouble.set = SchemaType.set;
  SchemaDouble.setters = [];
  SchemaDouble.get = SchemaType.get;
  /*!
   * ignore
   */
  SchemaDouble._defaultCaster = (v) => {
    if (v != null) {
      if (v._bsontype !== "Double") {
        throw new Error;
      }
    }
    return v;
  };
  SchemaDouble.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDouble._checkRequired = (v) => v != null;
  SchemaDouble.checkRequired = SchemaType.checkRequired;
  SchemaDouble.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaDouble.prototype.cast = function(value) {
    let castDouble2;
    if (typeof this._castFunction === "function") {
      castDouble2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDouble2 = this.constructor.cast();
    } else {
      castDouble2 = SchemaDouble.cast();
    }
    try {
      return castDouble2(value);
    } catch (error) {
      throw new CastError("Double", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  function handleSingle(val) {
    return this.cast(val);
  }
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  Object.defineProperty(SchemaDouble.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  SchemaDouble.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("number", "double", options?.useBsonType, isRequired);
  };
  SchemaDouble.prototype.autoEncryptionType = function autoEncryptionType() {
    return "double";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDouble;
});

// node_modules/mongoose/lib/cast/int32.js
var require_int32 = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  var assert2 = __require("assert");
  module.exports = function castInt32(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    const coercedVal = isBsonType(val, "Long") ? val.toNumber() : Number(val);
    const INT32_MAX = 2147483647;
    const INT32_MIN = -2147483648;
    if (coercedVal === (coercedVal | 0) && coercedVal >= INT32_MIN && coercedVal <= INT32_MAX) {
      return coercedVal;
    }
    assert2.ok(false);
  };
});

// node_modules/mongoose/lib/schema/int32.js
var require_int322 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castInt32 = require_int32();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var handleBitwiseOperator = require_bitwise();
  function SchemaInt32(path, options) {
    SchemaType.call(this, path, options, "Int32");
  }
  SchemaInt32.schemaName = "Int32";
  SchemaInt32.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaInt32.prototype = Object.create(SchemaType.prototype);
  SchemaInt32.prototype.constructor = SchemaInt32;
  /*!
   * ignore
   */
  SchemaInt32._cast = castInt32;
  SchemaInt32.set = SchemaType.set;
  SchemaInt32.setters = [];
  SchemaInt32.get = SchemaType.get;
  /*!
   * ignore
   */
  SchemaInt32._defaultCaster = (v) => {
    const INT32_MAX = 2147483647;
    const INT32_MIN = -2147483648;
    if (v != null) {
      if (typeof v !== "number" || v !== (v | 0) || v < INT32_MIN || v > INT32_MAX) {
        throw new Error;
      }
    }
    return v;
  };
  SchemaInt32.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaInt32._checkRequired = (v) => v != null;
  SchemaInt32.checkRequired = SchemaType.checkRequired;
  SchemaInt32.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaInt32.prototype.cast = function(value) {
    let castInt322;
    if (typeof this._castFunction === "function") {
      castInt322 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castInt322 = this.constructor.cast();
    } else {
      castInt322 = SchemaInt32.cast();
    }
    try {
      return castInt322(value);
    } catch (error) {
      throw new CastError("Int32", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator
  };
  Object.defineProperty(SchemaInt32.prototype, "$conditionalHandlers", {
    enumerable: false,
    value: $conditionalHandlers
  });
  /*!
   * ignore
   */
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  SchemaInt32.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err2) {
      if (err2 instanceof CastError && err2.path === this.path && this.$fullPath != null) {
        err2.path = this.$fullPath;
      }
      throw err2;
    }
  };
  SchemaInt32.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("number", "int", options?.useBsonType, isRequired);
  };
  SchemaInt32.prototype.autoEncryptionType = function autoEncryptionType() {
    return "int";
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaInt32;
});

// node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Array = require_array2();
  exports.BigInt = require_bigint2();
  exports.Boolean = require_boolean2();
  exports.Buffer = require_buffer2();
  exports.Date = require_date2();
  exports.Decimal128 = exports.Decimal = require_decimal1283();
  exports.DocumentArray = require_documentArray2();
  exports.Map = require_map2();
  exports.Mixed = require_mixed();
  exports.Number = require_number2();
  exports.ObjectId = require_objectId();
  exports.String = require_string2();
  exports.Subdocument = require_subdocument2();
  exports.UUID = require_uuid3();
  exports.Double = require_double3();
  exports.Int32 = require_int322();
  exports.Oid = exports.ObjectId;
  exports.Object = exports.Mixed;
  exports.Bool = exports.Boolean;
  exports.ObjectID = exports.ObjectId;
});

// node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EventEmitter = __require("events").EventEmitter;
  var Kareem = require_kareem();
  var MongooseError = require_mongooseError();
  var SchemaType = require_schemaType();
  var SchemaTypeOptions = require_schemaTypeOptions();
  var VirtualOptions = require_virtualOptions();
  var VirtualType = require_virtualType();
  var addAutoId = require_addAutoId();
  var clone2 = require_clone();
  var get = require_get();
  var getConstructorName = require_getConstructorName();
  var getIndexes = require_getIndexes();
  var handleReadPreferenceAliases = require_handleReadPreferenceAliases();
  var idGetter = require_idGetter();
  var isIndexSpecEqual = require_isIndexSpecEqual();
  var merge = require_merge();
  var mpath = require_mpath();
  var setPopulatedVirtualValue = require_setPopulatedVirtualValue();
  var setupTimestamps = require_setupTimestamps();
  var utils = require_utils3();
  var validateRef = require_validateRef();
  var hasNumericSubpathRegex = /\.\d+(\.|$)/;
  var MongooseTypes;
  var queryHooks = require_constants3().queryMiddlewareFunctions;
  var documentHooks = require_applyHooks().middlewareFunctions;
  var hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set);
  var isPOJO = utils.isPOJO;
  var id = 0;
  var numberRE = /^\d+$/;
  function Schema(obj, options) {
    if (!(this instanceof Schema)) {
      return new Schema(obj, options);
    }
    this.obj = obj;
    this.paths = {};
    this.aliases = {};
    this.subpaths = {};
    this.virtuals = {};
    this.singleNestedPaths = {};
    this.nested = {};
    this.inherits = {};
    this.callQueue = [];
    this._indexes = [];
    this._searchIndexes = [];
    this.methods = options && options.methods || {};
    this.methodOptions = {};
    this.statics = options && options.statics || {};
    this.tree = {};
    this.query = options && options.query || {};
    this.childSchemas = [];
    this.plugins = [];
    this.$id = ++id;
    this.mapPaths = [];
    this.encryptedFields = {};
    this.s = {
      hooks: new Kareem
    };
    this.options = this.defaultOptions(options);
    if (Array.isArray(obj)) {
      for (const definition of obj) {
        this.add(definition);
      }
    } else if (obj) {
      this.add(obj);
    }
    if (options && options.virtuals) {
      const virtuals = options.virtuals;
      const pathNames = Object.keys(virtuals);
      for (const pathName of pathNames) {
        const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;
        const virtual = this.virtual(pathName, pathOptions);
        if (virtuals[pathName].get) {
          virtual.get(virtuals[pathName].get);
        }
        if (virtuals[pathName].set) {
          virtual.set(virtuals[pathName].set);
        }
      }
    }
    const _idSubDoc = obj && obj._id && utils.isObject(obj._id);
    const auto_id = !this.paths["_id"] && this.options._id && !_idSubDoc;
    if (auto_id) {
      addAutoId(this);
    }
    this.setupTimestamp(this.options.timestamps);
  }
  function aliasFields(schema, paths) {
    for (const path of Object.keys(paths)) {
      let alias = null;
      if (paths[path] != null) {
        alias = paths[path];
      } else {
        const options = get(schema.paths[path], "options");
        if (options == null) {
          continue;
        }
        alias = options.alias;
      }
      if (!alias) {
        continue;
      }
      const prop = schema.paths[path].path;
      if (Array.isArray(alias)) {
        for (const a12 of alias) {
          if (typeof a12 !== "string") {
            throw new Error("Invalid value for alias option on " + prop + ", got " + a12);
          }
          schema.aliases[a12] = prop;
          schema.virtual(a12).get(function(p) {
            return function() {
              if (typeof this.get === "function") {
                return this.get(p);
              }
              return this[p];
            };
          }(prop)).set(function(p) {
            return function(v) {
              return this.$set(p, v);
            };
          }(prop));
        }
        continue;
      }
      if (typeof alias !== "string") {
        throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
      }
      schema.aliases[alias] = prop;
      schema.virtual(alias).get(function(p) {
        return function() {
          if (typeof this.get === "function") {
            return this.get(p);
          }
          return this[p];
        };
      }(prop)).set(function(p) {
        return function(v) {
          return this.$set(p, v);
        };
      }(prop));
    }
  }
  /*!
   * Inherit from EventEmitter.
   */
  Schema.prototype = Object.create(EventEmitter.prototype);
  Schema.prototype.constructor = Schema;
  Schema.prototype.instanceOfSchema = true;
  /*!
   * ignore
   */
  Object.defineProperty(Schema.prototype, "$schemaType", {
    configurable: false,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(Schema.prototype, "childSchemas", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Schema.prototype, "virtuals", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Schema.prototype.obj;
  Schema.prototype.paths;
  Schema.prototype.tree;
  Schema.prototype.clone = function() {
    const s = this._clone();
    s.on("init", (v) => this.emit("init", v));
    return s;
  };
  /*!
   * ignore
   */
  Schema.prototype._clone = function _clone(Constructor2) {
    Constructor2 = Constructor2 || (this.base == null ? Schema : this.base.Schema);
    const s = new Constructor2({}, this._userProvidedOptions);
    s.base = this.base;
    s.obj = this.obj;
    s.options = clone2(this.options);
    s.callQueue = this.callQueue.map(function(f) {
      return f;
    });
    s.methods = clone2(this.methods);
    s.methodOptions = clone2(this.methodOptions);
    s.statics = clone2(this.statics);
    s.query = clone2(this.query);
    s.plugins = Array.prototype.slice.call(this.plugins);
    s._indexes = clone2(this._indexes);
    s._searchIndexes = clone2(this._searchIndexes);
    s.s.hooks = this.s.hooks.clone();
    s.tree = clone2(this.tree);
    s.paths = Object.fromEntries(Object.entries(this.paths).map(([key, value]) => [key, value.clone()]));
    s.nested = clone2(this.nested);
    s.subpaths = clone2(this.subpaths);
    for (const schemaType of Object.values(s.paths)) {
      if (schemaType.$isSingleNested) {
        const path = schemaType.path;
        for (const key of Object.keys(schemaType.schema.paths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          s.singleNestedPaths[path + "." + key] = "nested";
        }
      }
    }
    s._gatherChildSchemas();
    s.virtuals = clone2(this.virtuals);
    s.$globalPluginsApplied = this.$globalPluginsApplied;
    s.$isRootDiscriminator = this.$isRootDiscriminator;
    s.$implicitlyCreated = this.$implicitlyCreated;
    s.$id = ++id;
    s.$originalSchemaId = this.$id;
    s.mapPaths = [].concat(this.mapPaths);
    if (this.discriminatorMapping != null) {
      s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
    }
    if (this.discriminators != null) {
      s.discriminators = Object.assign({}, this.discriminators);
    }
    if (this._applyDiscriminators != null) {
      s._applyDiscriminators = new Map(this._applyDiscriminators);
    }
    s.aliases = Object.assign({}, this.aliases);
    s.encryptedFields = clone2(this.encryptedFields);
    return s;
  };
  Schema.prototype.pick = function(paths, options) {
    const newSchema = new Schema({}, options || this.options);
    if (!Array.isArray(paths)) {
      throw new MongooseError("Schema#pick() only accepts an array argument, " + 'got "' + typeof paths + '"');
    }
    for (const path of paths) {
      if (this._hasEncryptedField(path)) {
        const encrypt = this.encryptedFields[path];
        const schemaType = this.path(path);
        newSchema.add({
          [path]: {
            encrypt,
            [this.options.typeKey]: schemaType
          }
        });
      } else if (this.nested[path]) {
        newSchema.add({ [path]: get(this.tree, path) });
      } else {
        const schematype = this.path(path);
        if (schematype == null) {
          throw new MongooseError("Path `" + path + "` is not in the schema");
        }
        newSchema.add({ [path]: schematype });
      }
    }
    if (!this._hasEncryptedFields()) {
      newSchema.options.encryptionType = null;
    }
    return newSchema;
  };
  Schema.prototype.omit = function(paths, options) {
    const newSchema = new Schema(this, options || this.options);
    if (!Array.isArray(paths)) {
      throw new MongooseError("Schema#omit() only accepts an array argument, " + 'got "' + typeof paths + '"');
    }
    newSchema.remove(paths);
    for (const nested in newSchema.singleNestedPaths) {
      if (paths.includes(nested)) {
        delete newSchema.singleNestedPaths[nested];
      }
    }
    return newSchema;
  };
  Schema.prototype.defaultOptions = function(options) {
    this._userProvidedOptions = options == null ? {} : clone2(options);
    const baseOptions = this.base && this.base.options || {};
    const strict = "strict" in baseOptions ? baseOptions.strict : true;
    const strictQuery = "strictQuery" in baseOptions ? baseOptions.strictQuery : false;
    const id2 = "id" in baseOptions ? baseOptions.id : true;
    options = {
      strict,
      strictQuery,
      bufferCommands: true,
      capped: false,
      versionKey: "__v",
      optimisticConcurrency: false,
      minimize: true,
      autoIndex: null,
      discriminatorKey: "__t",
      shardKey: null,
      read: null,
      validateBeforeSave: true,
      validateModifiedOnly: false,
      _id: true,
      id: id2,
      typeKey: "type",
      ...options
    };
    if (options.versionKey && typeof options.versionKey !== "string") {
      throw new MongooseError("`versionKey` must be falsy or string, got `" + typeof options.versionKey + "`");
    }
    if (typeof options.read === "string") {
      options.read = handleReadPreferenceAliases(options.read);
    } else if (Array.isArray(options.read) && typeof options.read[0] === "string") {
      options.read = {
        mode: handleReadPreferenceAliases(options.read[0]),
        tags: options.read[1]
      };
    }
    if (options.optimisticConcurrency && !options.versionKey) {
      throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
    }
    return options;
  };
  Schema.prototype.discriminator = function(name, schema, options) {
    this._applyDiscriminators = this._applyDiscriminators || new Map;
    this._applyDiscriminators.set(name, { schema, options });
    return this;
  };
  /*!
   * Get this schema's default toObject/toJSON options, including Mongoose global
   * options.
   */
  Schema.prototype._defaultToObjectOptions = function(json) {
    const path = json ? "toJSON" : "toObject";
    if (this._defaultToObjectOptionsMap && this._defaultToObjectOptionsMap[path]) {
      return this._defaultToObjectOptionsMap[path];
    }
    const baseOptions = this.base && this.base.options && this.base.options[path] || {};
    const schemaOptions = this.options[path] || {};
    const defaultOptions = Object.assign({}, baseOptions, schemaOptions);
    this._defaultToObjectOptionsMap = this._defaultToObjectOptionsMap || {};
    this._defaultToObjectOptionsMap[path] = defaultOptions;
    return defaultOptions;
  };
  Schema.prototype.encryptionType = function encryptionType(encryptionType) {
    if (arguments.length === 0) {
      return this.options.encryptionType;
    }
    if (!(typeof encryptionType === "string" || encryptionType === null)) {
      throw new Error("invalid `encryptionType`: ${encryptionType}");
    }
    this.options.encryptionType = encryptionType;
  };
  Schema.prototype.add = function add(obj, prefix) {
    if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {
      merge(this, obj);
      return this;
    }
    if (obj._id === false && prefix == null) {
      this.options._id = false;
    }
    prefix = prefix || "";
    if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
      return this;
    }
    const keys = Object.keys(obj);
    const typeKey = this.options.typeKey;
    for (const key of keys) {
      if (utils.specialProperties.has(key)) {
        continue;
      }
      const fullPath = prefix + key;
      const val = obj[key];
      if (val == null) {
        throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + val + '"');
      }
      if (key === "_id" && val === false) {
        continue;
      }
      let isMongooseTypeString = false;
      if (typeof val === "string") {
        const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
        const upperVal = val.charAt(0).toUpperCase() + val.substring(1);
        isMongooseTypeString = MongooseTypes2[upperVal] != null;
      }
      if (key !== "_id" && (typeof val !== "object" && typeof val !== "function" && !isMongooseTypeString || val == null)) {
        throw new TypeError(`Invalid schema configuration: \`${val}\` is not ` + `a valid type at path \`${key}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
      }
      if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === "VirtualType") {
        this.virtual(val);
        continue;
      }
      if (Array.isArray(val) && val.length === 1 && val[0] == null) {
        throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + val[0] + '"');
      }
      if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {
        if (prefix) {
          this.nested[prefix.substring(0, prefix.length - 1)] = true;
        }
        this.path(prefix + key, val);
        if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {
          const schemaType = this.path(prefix + key);
          for (const key2 in val[0].discriminators) {
            schemaType.discriminator(key2, val[0].discriminators[key2]);
          }
        }
      } else if (Object.keys(val).length < 1) {
        if (prefix) {
          this.nested[prefix.substring(0, prefix.length - 1)] = true;
        }
        this.path(fullPath, val);
      } else if (!val[typeKey] || typeKey === "type" && isPOJO(val.type) && val.type.type) {
        this.nested[fullPath] = true;
        this.add(val, fullPath + ".");
      } else {
        const _typeDef = val[typeKey];
        if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          const childSchemaOptions = {};
          if (this._userProvidedOptions.typeKey) {
            childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;
          }
          if (this._userProvidedOptions.strict != null) {
            childSchemaOptions.strict = this._userProvidedOptions.strict;
          }
          if (this._userProvidedOptions.toObject != null) {
            childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ["transform"]);
          }
          if (this._userProvidedOptions.toJSON != null) {
            childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ["transform"]);
          }
          const _schema = new Schema(_typeDef, childSchemaOptions);
          _schema.$implicitlyCreated = true;
          const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });
          this.path(prefix + key, schemaWrappedPath);
        } else {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, val);
          if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {
            const schemaType = this.path(prefix + key);
            for (const key2 in val.discriminators) {
              schemaType.discriminator(key2, val.discriminators[key2]);
            }
          }
        }
      }
      if (val.instanceOfSchema && val.encryptionType() != null) {
        if (this.encryptionType() != val.encryptionType()) {
          throw new Error("encryptionType of a nested schema must match the encryption type of the parent schema.");
        }
        for (const [encryptedField, encryptedFieldConfig] of Object.entries(val.encryptedFields)) {
          const path = fullPath + "." + encryptedField;
          this._addEncryptedField(path, encryptedFieldConfig);
        }
      } else if (typeof val === "object" && "encrypt" in val) {
        const { encrypt } = val;
        if (this.encryptionType() == null) {
          throw new Error("encryptionType must be provided");
        }
        this._addEncryptedField(fullPath, encrypt);
      } else {
        this._removeEncryptedField(fullPath);
      }
    }
    const aliasObj = Object.fromEntries(Object.entries(obj).map(([key]) => [prefix + key, null]));
    aliasFields(this, aliasObj);
    return this;
  };
  Schema.prototype._addEncryptedField = function _addEncryptedField(path, fieldConfig) {
    const type = this.path(path).autoEncryptionType();
    if (type == null) {
      throw new Error(`Invalid BSON type for FLE field: '${path}'`);
    }
    this.encryptedFields[path] = clone2(fieldConfig);
  };
  Schema.prototype._removeEncryptedField = function _removeEncryptedField(path) {
    delete this.encryptedFields[path];
  };
  Schema.prototype._hasEncryptedFields = function _hasEncryptedFields() {
    return Object.keys(this.encryptedFields).length > 0;
  };
  Schema.prototype._hasEncryptedField = function _hasEncryptedField(path) {
    return path in this.encryptedFields;
  };
  Schema.prototype._buildEncryptedFields = function() {
    const fields = Object.entries(this.encryptedFields).map(([path, config]) => {
      const bsonType = this.path(path).autoEncryptionType();
      return { path, bsonType, ...config };
    });
    return { fields };
  };
  Schema.prototype._buildSchemaMap = function() {
    function buildNestedPath(path, object, value) {
      let i = 0, component = path[i];
      for (;i < path.length - 1; ++i, component = path[i]) {
        object[component] = object[component] == null ? {
          bsonType: "object",
          properties: {}
        } : object[component];
        object = object[component].properties;
      }
      object[component] = value;
    }
    const schemaMapPropertyReducer = (accum, [path, propertyConfig]) => {
      const bsonType = this.path(path).autoEncryptionType();
      const pathComponents = path.split(".");
      const configuration = { encrypt: { ...propertyConfig, bsonType } };
      buildNestedPath(pathComponents, accum, configuration);
      return accum;
    };
    const properties = Object.entries(this.encryptedFields).reduce(schemaMapPropertyReducer, {});
    return {
      bsonType: "object",
      properties
    };
  };
  Schema.prototype.alias = function alias(path, alias) {
    aliasFields(this, { [path]: alias });
    return this;
  };
  Schema.prototype.removeIndex = function removeIndex(index) {
    if (arguments.length > 1) {
      throw new Error("removeIndex() takes only 1 argument");
    }
    if (typeof index !== "object" && typeof index !== "string") {
      throw new Error("removeIndex() may only take either an object or a string as an argument");
    }
    if (typeof index === "object") {
      for (let i = this._indexes.length - 1;i >= 0; --i) {
        if (isIndexSpecEqual(this._indexes[i][0], index)) {
          this._indexes.splice(i, 1);
        }
      }
    } else {
      for (let i = this._indexes.length - 1;i >= 0; --i) {
        if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {
          this._indexes.splice(i, 1);
        }
      }
    }
    return this;
  };
  Schema.prototype.clearIndexes = function clearIndexes() {
    this._indexes.length = 0;
    return this;
  };
  Schema.prototype.searchIndex = function searchIndex(description) {
    this._searchIndexes.push(description);
    return this;
  };
  Schema.reserved = Object.create(null);
  Schema.prototype.reserved = Schema.reserved;
  var reserved = Schema.reserved;
  reserved["prototype"] = reserved.emit = reserved.listeners = reserved.removeListener = reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
  reserved.collection = 1;
  Schema.prototype.path = function(path, obj) {
    if (obj === undefined) {
      if (this.paths[path] != null) {
        return this.paths[path];
      }
      const cleanPath = _pathToPositionalSyntax(path);
      let schematype = _getPath(this, path, cleanPath);
      if (schematype != null) {
        return schematype;
      }
      const mapPath = getMapPath(this, path);
      if (mapPath != null) {
        return mapPath;
      }
      schematype = this.hasMixedParent(cleanPath);
      if (schematype != null) {
        return schematype;
      }
      return hasNumericSubpathRegex.test(path) ? getPositionalPath(this, path, cleanPath) : undefined;
    }
    const firstPieceOfPath = path.split(".")[0];
    if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {
      const errorMessage = `\`${firstPieceOfPath}\` is a reserved schema pathname and may break some functionality. ` + "You are allowed to use it, but use at your own risk. " + "To disable this warning pass `suppressReservedKeysWarning` as a schema option.";
      utils.warn(errorMessage);
    }
    if (typeof obj === "object" && utils.hasUserDefinedProperty(obj, "ref")) {
      validateRef(obj.ref, path);
    }
    const subpaths = path.split(/\./);
    const last = subpaths.pop();
    let branch = this.tree;
    let fullPath = "";
    for (const sub of subpaths) {
      if (utils.specialProperties.has(sub)) {
        throw new Error("Cannot set special property `" + sub + "` on a schema");
      }
      fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
      if (!branch[sub]) {
        this.nested[fullPath] = true;
        branch[sub] = {};
      }
      if (typeof branch[sub] !== "object") {
        const msg = "Cannot set nested path `" + path + "`. " + "Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
        throw new Error(msg);
      }
      branch = branch[sub];
    }
    branch[last] = clone2(obj);
    this.paths[path] = this.interpretAsType(path, obj, this.options);
    const schemaType = this.paths[path];
    this.childSchemas = this.childSchemas.filter((childSchema) => childSchema.path !== path);
    if (schemaType.$isSchemaMap) {
      const mapPath = path + ".$*";
      this.paths[mapPath] = schemaType.$__schemaType;
      this.mapPaths.push(this.paths[mapPath]);
      if (schemaType.$__schemaType.$isSingleNested) {
        this.childSchemas.push({
          schema: schemaType.$__schemaType.schema,
          model: schemaType.$__schemaType.caster,
          path
        });
      }
    }
    if (schemaType.$isSingleNested) {
      for (const key of Object.keys(schemaType.schema.paths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
      }
      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
      }
      for (const key of Object.keys(schemaType.schema.subpaths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
      }
      for (const key of Object.keys(schemaType.schema.nested)) {
        this.singleNestedPaths[path + "." + key] = "nested";
      }
      Object.defineProperty(schemaType.schema, "base", {
        configurable: true,
        enumerable: false,
        writable: false,
        value: this.base
      });
      schemaType.caster.base = this.base;
      this.childSchemas.push({
        schema: schemaType.schema,
        model: schemaType.caster,
        path
      });
    } else if (schemaType.$isMongooseDocumentArray) {
      Object.defineProperty(schemaType.schema, "base", {
        configurable: true,
        enumerable: false,
        writable: false,
        value: this.base
      });
      schemaType.casterConstructor.base = this.base;
      this.childSchemas.push({
        schema: schemaType.schema,
        model: schemaType.casterConstructor,
        path
      });
    }
    if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
      let arrayPath = path;
      let _schemaType = schemaType;
      const toAdd = [];
      while (_schemaType.$isMongooseArray) {
        arrayPath = arrayPath + ".$";
        if (_schemaType.$isMongooseDocumentArray) {
          _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
          _schemaType.$embeddedSchemaType._arrayParentPath = path;
          _schemaType = _schemaType.$embeddedSchemaType;
        } else {
          _schemaType.caster._arrayPath = arrayPath;
          _schemaType.caster._arrayParentPath = path;
          _schemaType = _schemaType.caster;
        }
        this.subpaths[arrayPath] = _schemaType;
      }
      for (const _schemaType2 of toAdd) {
        this.subpaths[_schemaType2.path] = _schemaType2;
      }
    }
    if (schemaType.$isMongooseDocumentArray) {
      for (const key of Object.keys(schemaType.schema.paths)) {
        const _schemaType = schemaType.schema.paths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
      for (const key of Object.keys(schemaType.schema.subpaths)) {
        const _schemaType = schemaType.schema.subpaths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
        const _schemaType = schemaType.schema.singleNestedPaths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
    }
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype._gatherChildSchemas = function _gatherChildSchemas() {
    const childSchemas = [];
    for (const path of Object.keys(this.paths)) {
      if (typeof path !== "string") {
        continue;
      }
      const schematype = this.paths[path];
      if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
        childSchemas.push({
          schema: schematype.schema,
          model: schematype.caster,
          path
        });
      } else if (schematype.$isSchemaMap && schematype.$__schemaType.$isSingleNested) {
        childSchemas.push({
          schema: schematype.$__schemaType.schema,
          model: schematype.$__schemaType.caster,
          path
        });
      }
    }
    this.childSchemas = childSchemas;
    return childSchemas;
  };
  /*!
   * ignore
   */
  function _getPath(schema, path, cleanPath) {
    if (schema.paths.hasOwnProperty(path)) {
      return schema.paths[path];
    }
    if (schema.subpaths.hasOwnProperty(cleanPath)) {
      const subpath = schema.subpaths[cleanPath];
      if (subpath === "nested") {
        return;
      }
      return subpath;
    }
    if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
      const singleNestedPath = schema.singleNestedPaths[cleanPath];
      if (singleNestedPath === "nested") {
        return;
      }
      return singleNestedPath;
    }
    return null;
  }
  /*!
   * ignore
   */
  function _pathToPositionalSyntax(path) {
    if (!/\.\d+/.test(path)) {
      return path;
    }
    return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
  }
  /*!
   * ignore
   */
  function getMapPath(schema, path) {
    if (schema.mapPaths.length === 0) {
      return null;
    }
    for (const val of schema.mapPaths) {
      const cleanPath = val.path.replace(/\.\$\*/g, "");
      if (path === cleanPath || path.startsWith(cleanPath + ".") && path.slice(cleanPath.length + 1).indexOf(".") === -1) {
        return val;
      } else if (val.schema && path.startsWith(cleanPath + ".")) {
        let remnant = path.slice(cleanPath.length + 1);
        remnant = remnant.slice(remnant.indexOf(".") + 1);
        return val.schema.paths[remnant];
      } else if (val.$isSchemaMap && path.startsWith(cleanPath + ".")) {
        let remnant = path.slice(cleanPath.length + 1);
        remnant = remnant.slice(remnant.indexOf(".") + 1);
        const presplitPath = val.$__schemaType._presplitPath;
        if (remnant.indexOf(".") === -1 && presplitPath[presplitPath.length - 1] === "$*") {
          return val.$__schemaType;
        } else if (remnant.indexOf(".") !== -1 && val.$__schemaType.schema && presplitPath[presplitPath.length - 1] === "$*") {
          return val.$__schemaType.schema.path(remnant.slice(remnant.indexOf(".") + 1));
        }
      }
    }
    return null;
  }
  Object.defineProperty(Schema.prototype, "base", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: null
  });
  Schema.prototype.interpretAsType = function(path, obj, options) {
    if (obj instanceof SchemaType) {
      if (obj.path === path) {
        return obj;
      }
      const clone3 = obj.clone();
      clone3.path = path;
      return clone3;
    }
    const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
    const Types = this.base != null ? this.base.Types : require_types();
    if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
      const constructorName = utils.getFunctionName(obj.constructor);
      if (constructorName !== "Object") {
        const oldObj = obj;
        obj = {};
        obj[options.typeKey] = oldObj;
      }
    }
    let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== "type" || !obj.type.type) ? obj[options.typeKey] : {};
    if (type instanceof SchemaType) {
      if (type.path === path) {
        return type;
      }
      const clone3 = type.clone();
      clone3.path = path;
      return clone3;
    }
    let name;
    if (utils.isPOJO(type) || type === "mixed") {
      return new MongooseTypes2.Mixed(path, obj);
    }
    if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
      let cast2 = type === Array || type === "array" ? obj.cast || obj.of : type[0];
      if (cast2 && cast2.instanceOfSchema) {
        if (!(cast2 instanceof Schema)) {
          if (this.options._isMerging) {
            cast2 = new Schema(cast2);
          } else {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. " + "Please make sure you're using the same version " + "of Mongoose everywhere with `npm list mongoose`. If you are still " + "getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
          }
        }
        return new MongooseTypes2.DocumentArray(path, cast2, obj);
      }
      if (cast2 && cast2[options.typeKey] && cast2[options.typeKey].instanceOfSchema) {
        if (!(cast2[options.typeKey] instanceof Schema)) {
          if (this.options._isMerging) {
            cast2[options.typeKey] = new Schema(cast2[options.typeKey]);
          } else {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. " + "Please make sure you're using the same version " + "of Mongoose everywhere with `npm list mongoose`. If you are still " + "getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
          }
        }
        return new MongooseTypes2.DocumentArray(path, cast2[options.typeKey], obj, cast2);
      }
      if (typeof cast2 !== "undefined") {
        if (Array.isArray(cast2) || cast2.type === Array || cast2.type == "Array") {
          if (cast2 && cast2.type == "Array") {
            cast2.type = Array;
          }
          return new MongooseTypes2.Array(path, this.interpretAsType(path, cast2, options), obj);
        }
      }
      const castFromTypeKey = cast2 != null && cast2[options.typeKey] && (options.typeKey !== "type" || !cast2.type.type) ? cast2[options.typeKey] : cast2;
      if (typeof cast2 === "string") {
        cast2 = MongooseTypes2[cast2.charAt(0).toUpperCase() + cast2.substring(1)];
      } else if (utils.isPOJO(castFromTypeKey)) {
        if (Object.keys(castFromTypeKey).length) {
          const childSchemaOptions = { minimize: options.minimize };
          if (options.typeKey) {
            childSchemaOptions.typeKey = options.typeKey;
          }
          if (options.hasOwnProperty("strict")) {
            childSchemaOptions.strict = options.strict;
          }
          if (options.hasOwnProperty("strictQuery")) {
            childSchemaOptions.strictQuery = options.strictQuery;
          }
          if (options.hasOwnProperty("toObject")) {
            childSchemaOptions.toObject = utils.omit(options.toObject, ["transform"]);
          }
          if (options.hasOwnProperty("toJSON")) {
            childSchemaOptions.toJSON = utils.omit(options.toJSON, ["transform"]);
          }
          if (this._userProvidedOptions.hasOwnProperty("_id")) {
            childSchemaOptions._id = this._userProvidedOptions._id;
          } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {
            childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;
          }
          const childSchema = new Schema(castFromTypeKey, childSchemaOptions);
          childSchema.$implicitlyCreated = true;
          return new MongooseTypes2.DocumentArray(path, childSchema, obj);
        } else {
          return new MongooseTypes2.Array(path, MongooseTypes2.Mixed, obj);
        }
      }
      if (cast2) {
        type = cast2[options.typeKey] && (options.typeKey !== "type" || !cast2.type.type) ? cast2[options.typeKey] : cast2;
        if (Array.isArray(type)) {
          return new MongooseTypes2.Array(path, this.interpretAsType(path, type, options), obj);
        }
        name = typeof type === "string" ? type : type.schemaName || utils.getFunctionName(type);
        if (name === "ClockDate") {
          name = "Date";
        }
        if (name === undefined) {
          throw new TypeError("Invalid schema configuration: " + `Could not determine the embedded type for array \`${path}\`. ` + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
        }
        if (!MongooseTypes2.hasOwnProperty(name)) {
          throw new TypeError("Invalid schema configuration: " + `\`${name}\` is not a valid type within the array \`${path}\`.` + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
        }
      }
      return new MongooseTypes2.Array(path, cast2 || MongooseTypes2.Mixed, obj, options);
    }
    if (type && type.instanceOfSchema) {
      return new MongooseTypes2.Subdocument(type, path, obj);
    }
    if (Buffer.isBuffer(type)) {
      name = "Buffer";
    } else if (typeof type === "function" || typeof type === "object") {
      name = type.schemaName || utils.getFunctionName(type);
    } else if (type === Types.ObjectId) {
      name = "ObjectId";
    } else if (type === Types.Decimal128) {
      name = "Decimal128";
    } else {
      name = type == null ? "" + type : type.toString();
    }
    if (name) {
      name = name.charAt(0).toUpperCase() + name.substring(1);
    }
    if (name === "ObjectID") {
      name = "ObjectId";
    }
    if (name === "ClockDate") {
      name = "Date";
    }
    if (name === undefined) {
      throw new TypeError(`Invalid schema configuration: \`${path}\` schematype definition is ` + "invalid. See " + "https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
    }
    if (MongooseTypes2[name] == null) {
      throw new TypeError(`Invalid schema configuration: \`${name}\` is not ` + `a valid type at path \`${path}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
    }
    const schemaType = new MongooseTypes2[name](path, obj);
    if (schemaType.$isSchemaMap) {
      createMapNestedSchemaType(this, schemaType, path, obj, options);
    }
    return schemaType;
  };
  /*!
   * ignore
   */
  function createMapNestedSchemaType(schema, schemaType, path, obj, options) {
    const mapPath = path + ".$*";
    let _mapType = { type: {} };
    if (utils.hasUserDefinedProperty(obj, "of")) {
      const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);
      if (isInlineSchema) {
        _mapType = { [schema.options.typeKey]: new Schema(obj.of) };
      } else if (utils.isPOJO(obj.of)) {
        _mapType = Object.assign({}, obj.of);
      } else {
        _mapType = { [schema.options.typeKey]: obj.of };
      }
      if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {
        const subdocumentSchema = _mapType[schema.options.typeKey];
        subdocumentSchema.eachPath((subpath, type) => {
          if (type.options.select === true || type.options.select === false) {
            throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + path + "." + subpath + '"');
          }
        });
      }
      if (utils.hasUserDefinedProperty(obj, "ref")) {
        _mapType.ref = obj.ref;
      }
    }
    schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);
  }
  Schema.prototype.eachPath = function(fn) {
    const keys = Object.keys(this.paths);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      fn(keys[i], this.paths[keys[i]]);
    }
    return this;
  };
  Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
    if (this._requiredpaths && !invalidate) {
      return this._requiredpaths;
    }
    const paths = Object.keys(this.paths);
    let i = paths.length;
    const ret = [];
    while (i--) {
      const path = paths[i];
      if (this.paths[path].isRequired) {
        ret.push(path);
      }
    }
    this._requiredpaths = ret;
    return this._requiredpaths;
  };
  Schema.prototype.indexedPaths = function indexedPaths() {
    if (this._indexedpaths) {
      return this._indexedpaths;
    }
    this._indexedpaths = this.indexes();
    return this._indexedpaths;
  };
  Schema.prototype.pathType = function(path) {
    if (this.paths.hasOwnProperty(path)) {
      return "real";
    }
    if (this.virtuals.hasOwnProperty(path)) {
      return "virtual";
    }
    if (this.nested.hasOwnProperty(path)) {
      return "nested";
    }
    const cleanPath = _pathToPositionalSyntax(path);
    if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
      return "real";
    }
    const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
    if (singleNestedPath) {
      return singleNestedPath === "nested" ? "nested" : "real";
    }
    const mapPath = getMapPath(this, path);
    if (mapPath != null) {
      return "real";
    }
    if (/\.\d+\.|\.\d+$/.test(path)) {
      return getPositionalPathType(this, path, cleanPath);
    }
    return "adhocOrUndefined";
  };
  Schema.prototype.hasMixedParent = function(path) {
    const subpaths = path.split(/\./g);
    path = "";
    for (let i = 0;i < subpaths.length; ++i) {
      path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
      if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
        return this.paths[path];
      }
    }
    return null;
  };
  Schema.prototype.setupTimestamp = function(timestamps) {
    return setupTimestamps(this, timestamps);
  };
  function getPositionalPathType(self2, path, cleanPath) {
    const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
    if (subpaths.length < 2) {
      return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
    }
    let val = self2.path(subpaths[0]);
    let isNested = false;
    if (!val) {
      return "adhocOrUndefined";
    }
    const last = subpaths.length - 1;
    for (let i = 1;i < subpaths.length; ++i) {
      isNested = false;
      const subpath = subpaths[i];
      if (i === last && val && !/\D/.test(subpath)) {
        if (val.$isMongooseDocumentArray) {
          val = val.$embeddedSchemaType;
        } else if (val instanceof MongooseTypes.Array) {
          val = val.caster;
        } else {
          val = undefined;
        }
        break;
      }
      if (!/\D/.test(subpath)) {
        if (val instanceof MongooseTypes.Array && i !== last) {
          val = val.caster;
        }
        continue;
      }
      if (!(val && val.schema)) {
        val = undefined;
        break;
      }
      const type = val.schema.pathType(subpath);
      isNested = type === "nested";
      val = val.schema.path(subpath);
    }
    self2.subpaths[cleanPath] = val;
    if (val) {
      return "real";
    }
    if (isNested) {
      return "nested";
    }
    return "adhocOrUndefined";
  }
  /*!
   * ignore
   */
  function getPositionalPath(self2, path, cleanPath) {
    getPositionalPathType(self2, path, cleanPath);
    return self2.subpaths[cleanPath];
  }
  Schema.prototype.queue = function(name, args) {
    this.callQueue.push([name, args]);
    return this;
  };
  Schema.prototype.pre = function(name) {
    if (name instanceof RegExp) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const fn of hookNames) {
        if (name.test(fn)) {
          this.pre.apply(this, [fn].concat(remainingArgs));
        }
      }
      return this;
    }
    if (Array.isArray(name)) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const el of name) {
        this.pre.apply(this, [el].concat(remainingArgs));
      }
      return this;
    }
    this.s.hooks.pre.apply(this.s.hooks, arguments);
    return this;
  };
  Schema.prototype.post = function(name) {
    if (name instanceof RegExp) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const fn of hookNames) {
        if (name.test(fn)) {
          this.post.apply(this, [fn].concat(remainingArgs));
        }
      }
      return this;
    }
    if (Array.isArray(name)) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const el of name) {
        this.post.apply(this, [el].concat(remainingArgs));
      }
      return this;
    }
    this.s.hooks.post.apply(this.s.hooks, arguments);
    return this;
  };
  Schema.prototype.plugin = function(fn, opts) {
    if (typeof fn !== "function") {
      throw new Error("First param to `schema.plugin()` must be a function, " + 'got "' + typeof fn + '"');
    }
    if (opts && opts.deduplicate) {
      for (const plugin of this.plugins) {
        if (plugin.fn === fn) {
          return this;
        }
      }
    }
    this.plugins.push({ fn, opts });
    fn(this, opts);
    return this;
  };
  Schema.prototype.method = function(name, fn, options) {
    if (typeof name !== "string") {
      for (const i in name) {
        this.methods[i] = name[i];
        this.methodOptions[i] = clone2(options);
      }
    } else {
      this.methods[name] = fn;
      this.methodOptions[name] = clone2(options);
    }
    return this;
  };
  Schema.prototype.static = function(name, fn) {
    if (typeof name !== "string") {
      for (const i in name) {
        this.statics[i] = name[i];
      }
    } else {
      this.statics[name] = fn;
    }
    return this;
  };
  Schema.prototype.index = function(fields, options) {
    fields || (fields = {});
    options || (options = {});
    if (options.expires) {
      utils.expires(options);
    }
    for (const key in fields) {
      if (this.aliases[key]) {
        fields = utils.renameObjKey(fields, key, this.aliases[key]);
      }
    }
    for (const field of Object.keys(fields)) {
      if (fields[field] === "ascending" || fields[field] === "asc") {
        fields[field] = 1;
      } else if (fields[field] === "descending" || fields[field] === "desc") {
        fields[field] = -1;
      }
    }
    for (const existingIndex of this.indexes()) {
      if (options.name == null && existingIndex[1].name == null && isIndexSpecEqual(existingIndex[0], fields)) {
        utils.warn(`Duplicate schema index on ${JSON.stringify(fields)} found. This is often due to declaring an index using both "index: true" and "schema.index()". Please remove the duplicate index definition.`);
      }
    }
    this._indexes.push([fields, options]);
    return this;
  };
  Schema.prototype.set = function(key, value, tags) {
    if (arguments.length === 1) {
      return this.options[key];
    }
    switch (key) {
      case "read":
        if (typeof value === "string") {
          this.options[key] = { mode: handleReadPreferenceAliases(value), tags };
        } else if (Array.isArray(value) && typeof value[0] === "string") {
          this.options[key] = {
            mode: handleReadPreferenceAliases(value[0]),
            tags: value[1]
          };
        } else {
          this.options[key] = value;
        }
        this._userProvidedOptions[key] = this.options[key];
        break;
      case "timestamps":
        this.setupTimestamp(value);
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        break;
      case "_id":
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        if (value && !this.paths["_id"]) {
          addAutoId(this);
        } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
          this.remove("_id");
        }
        break;
      default:
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        break;
    }
    if (key === "strict") {
      _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });
    }
    if (key === "strictQuery") {
      _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });
    }
    if (key === "toObject") {
      value = { ...value };
      delete value.transform;
      _propagateOptionsToImplicitlyCreatedSchemas(this, { toObject: value });
    }
    if (key === "toJSON") {
      value = { ...value };
      delete value.transform;
      _propagateOptionsToImplicitlyCreatedSchemas(this, { toJSON: value });
    }
    return this;
  };
  /*!
   * Recursively set options on implicitly created schemas
   */
  function _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {
    for (const { schema } of baseSchema.childSchemas) {
      if (!schema.$implicitlyCreated) {
        continue;
      }
      Object.assign(schema.options, options);
      _propagateOptionsToImplicitlyCreatedSchemas(schema, options);
    }
  }
  Schema.prototype.get = function(key) {
    return this.options[key];
  };
  var indexTypes = "2d 2dsphere hashed text".split(" ");
  Object.defineProperty(Schema, "indexTypes", {
    get: function() {
      return indexTypes;
    },
    set: function() {
      throw new Error("Cannot overwrite Schema.indexTypes");
    }
  });
  Schema.prototype.indexes = function() {
    return getIndexes(this);
  };
  Schema.prototype.virtual = function(name, options) {
    if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
      return this.virtual(name.path, name.options);
    }
    options = new VirtualOptions(options);
    if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
      if (options.localField == null) {
        throw new Error("Reference virtuals require `localField` option");
      }
      if (options.foreignField == null) {
        throw new Error("Reference virtuals require `foreignField` option");
      }
      const virtual = this.virtual(name);
      virtual.options = options;
      this.pre("init", function virtualPreInit(obj, opts) {
        if (mpath.has(name, obj)) {
          const _v = mpath.get(name, obj);
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options.justOne || options.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
          }
          if (opts?.hydratedPopulatedDocs && !options.count) {
            const modelNames = virtual._getModelNamesForPopulate(this);
            const populatedVal = this.$$populatedVirtuals[name];
            if (!Array.isArray(populatedVal) && !populatedVal.$__ && modelNames?.length === 1) {
              const PopulateModel = this.db.model(modelNames[0]);
              this.$$populatedVirtuals[name] = PopulateModel.hydrate(populatedVal);
            } else if (Array.isArray(populatedVal) && modelNames?.length === 1) {
              const PopulateModel = this.db.model(modelNames[0]);
              for (let i = 0;i < populatedVal.length; ++i) {
                if (!populatedVal[i].$__) {
                  populatedVal[i] = PopulateModel.hydrate(populatedVal[i], null, { hydratedPopulatedDocs: true });
                }
              }
              const foreignField = options.foreignField;
              this.$populated(name, populatedVal.map((doc) => doc == null ? doc : doc.get(typeof foreignField === "function" ? foreignField.call(doc, doc) : foreignField)), { populateModelSymbol: PopulateModel });
            }
          }
          mpath.unset(name, obj);
        }
      });
      virtual.set(function(v) {
        if (!this.$$populatedVirtuals) {
          this.$$populatedVirtuals = {};
        }
        return setPopulatedVirtualValue(this.$$populatedVirtuals, name, v, options);
      });
      if (typeof options.get === "function") {
        virtual.get(options.get);
      }
      const parts2 = name.split(".");
      let cur = parts2[0];
      for (let i = 0;i < parts2.length - 1; ++i) {
        if (this.paths[cur] == null) {
          continue;
        }
        if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {
          const remnant = parts2.slice(i + 1).join(".");
          this.paths[cur].schema.virtual(remnant, options);
          break;
        } else if (this.paths[cur].$isSchemaMap) {
          const remnant = parts2.slice(i + 2).join(".");
          this.paths[cur].$__schemaType.schema.virtual(remnant, options);
          break;
        }
        cur += "." + parts2[i + 1];
      }
      return virtual;
    }
    const virtuals = this.virtuals;
    const parts = name.split(".");
    if (this.pathType(name) === "real") {
      throw new Error('Virtual path "' + name + '"' + " conflicts with a real path in the schema");
    }
    virtuals[name] = parts.reduce(function(mem, part, i) {
      mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
      return mem[part];
    }, this.tree);
    if (options && options.applyToArray && parts.length > 1) {
      const path = this.path(parts.slice(0, -1).join("."));
      if (path && path.$isMongooseArray) {
        return path.virtual(parts[parts.length - 1], options);
      } else {
        throw new MongooseError(`Path "${path}" is not an array`);
      }
    }
    return virtuals[name];
  };
  Schema.prototype.virtualpath = function(name) {
    return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
  };
  Schema.prototype.remove = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (Array.isArray(path)) {
      path.forEach(function(name) {
        if (this.path(name) == null && !this.nested[name]) {
          return;
        }
        if (this.nested[name]) {
          const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
          for (const path2 of allKeys) {
            if (path2.startsWith(name + ".")) {
              delete this.paths[path2];
              delete this.nested[path2];
              _deletePath(this, path2);
            }
          }
          delete this.nested[name];
          _deletePath(this, name);
          return;
        }
        delete this.paths[name];
        _deletePath(this, name);
        this._removeEncryptedField(name);
      }, this);
    }
    return this;
  };
  /*!
   * ignore
   */
  function _deletePath(schema, name) {
    const pieces = name.split(".");
    const last = pieces.pop();
    let branch = schema.tree;
    for (const piece of pieces) {
      branch = branch[piece];
    }
    delete branch[last];
  }
  Schema.prototype.removeVirtual = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (Array.isArray(path)) {
      for (const virtual of path) {
        if (this.virtuals[virtual] == null) {
          throw new MongooseError(`Attempting to remove virtual "${virtual}" that does not exist.`);
        }
      }
      for (const virtual of path) {
        delete this.paths[virtual];
        delete this.virtuals[virtual];
        if (virtual.indexOf(".") !== -1) {
          mpath.unset(virtual, this.tree);
        } else {
          delete this.tree[virtual];
        }
      }
    }
    return this;
  };
  Schema.prototype.loadClass = function(model, virtualsOnly) {
    if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype") || model.prototype.hasOwnProperty("$isMongooseDocumentPrototype")) {
      return this;
    }
    this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
    if (!virtualsOnly) {
      Object.getOwnPropertyNames(model).forEach(function(name) {
        if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
          return;
        }
        const prop = Object.getOwnPropertyDescriptor(model, name);
        if (prop.hasOwnProperty("value")) {
          this.static(name, prop.value);
        }
      }, this);
    }
    Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
      if (name.match(/^(constructor)$/)) {
        return;
      }
      const method = Object.getOwnPropertyDescriptor(model.prototype, name);
      if (!virtualsOnly) {
        if (typeof method.value === "function") {
          this.method(name, method.value);
        }
      }
      if (typeof method.get === "function") {
        if (this.virtuals[name]) {
          this.virtuals[name].getters = [];
        }
        this.virtual(name).get(method.get);
      }
      if (typeof method.set === "function") {
        if (this.virtuals[name]) {
          this.virtuals[name].setters = [];
        }
        this.virtual(name).set(method.set);
      }
    }, this);
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype._getSchema = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    const resultPath = [];
    if (pathschema) {
      pathschema.$fullPath = path;
      return pathschema;
    }
    function search(parts2, schema) {
      let p = parts2.length + 1;
      let foundschema;
      let trypath;
      while (p--) {
        trypath = parts2.slice(0, p).join(".");
        foundschema = schema.path(trypath);
        if (foundschema) {
          resultPath.push(trypath);
          if (foundschema.caster) {
            if (foundschema.caster instanceof MongooseTypes.Mixed) {
              foundschema.caster.$fullPath = resultPath.join(".");
              return foundschema.caster;
            }
            if (p !== parts2.length) {
              if (p + 1 === parts2.length && foundschema.$embeddedSchemaType && (parts2[p] === "$" || isArrayFilter(parts2[p]))) {
                return foundschema.$embeddedSchemaType;
              }
              if (foundschema.schema) {
                let ret;
                if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                  if (p + 1 === parts2.length) {
                    return foundschema.$embeddedSchemaType;
                  }
                  ret = search(parts2.slice(p + 1), foundschema.schema);
                  if (ret) {
                    ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                  }
                  return ret;
                }
                ret = search(parts2.slice(p), foundschema.schema);
                if (ret) {
                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                }
                return ret;
              }
            }
          } else if (foundschema.$isSchemaMap) {
            if (p >= parts2.length) {
              return foundschema;
            }
            if (p + 1 >= parts2.length) {
              return foundschema.$__schemaType;
            }
            if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {
              return foundschema.$__schemaType;
            }
            if (foundschema.$__schemaType.schema != null) {
              const ret = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
              return ret;
            }
          }
          foundschema.$fullPath = resultPath.join(".");
          return foundschema;
        }
      }
    }
    const parts = path.split(".");
    for (let i = 0;i < parts.length; ++i) {
      if (parts[i] === "$" || isArrayFilter(parts[i])) {
        parts[i] = "0";
      }
      if (numberRE.test(parts[i])) {
        parts[i] = "$";
      }
    }
    return search(parts, _this);
  };
  /*!
   * ignore
   */
  Schema.prototype._getPathType = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    if (pathschema) {
      return "real";
    }
    function search(parts, schema) {
      let p = parts.length + 1, foundschema, trypath;
      while (p--) {
        trypath = parts.slice(0, p).join(".");
        foundschema = schema.path(trypath);
        if (foundschema) {
          if (foundschema.caster) {
            if (foundschema.caster instanceof MongooseTypes.Mixed) {
              return { schema: foundschema, pathType: "mixed" };
            }
            if (p !== parts.length && foundschema.schema) {
              if (parts[p] === "$" || isArrayFilter(parts[p])) {
                if (p === parts.length - 1) {
                  return { schema: foundschema, pathType: "nested" };
                }
                return search(parts.slice(p + 1), foundschema.schema);
              }
              return search(parts.slice(p), foundschema.schema);
            }
            return {
              schema: foundschema,
              pathType: foundschema.$isSingleNested ? "nested" : "array"
            };
          }
          return { schema: foundschema, pathType: "real" };
        } else if (p === parts.length && schema.nested[trypath]) {
          return { schema, pathType: "nested" };
        }
      }
      return { schema: foundschema || schema, pathType: "undefined" };
    }
    return search(path.split("."), _this);
  };
  Schema.prototype._transformDuplicateKeyError = function _transformDuplicateKeyError(error) {
    if (!this._duplicateKeyErrorMessagesByPath) {
      return error;
    }
    if (error.code !== 11000 && error.code !== 11001) {
      return error;
    }
    if (error.keyPattern != null) {
      const keyPattern = error.keyPattern;
      const keys = Object.keys(keyPattern);
      if (keys.length !== 1) {
        return error;
      }
      const firstKey = keys[0];
      if (!this._duplicateKeyErrorMessagesByPath.hasOwnProperty(firstKey)) {
        return error;
      }
      return new MongooseError(this._duplicateKeyErrorMessagesByPath[firstKey], { cause: error });
    }
    return error;
  };
  /*!
   * ignore
   */
  function isArrayFilter(piece) {
    return piece.startsWith("$[") && piece.endsWith("]");
  }
  Schema.prototype._preCompile = function _preCompile() {
    this.plugin(idGetter, { deduplicate: true });
  };
  Schema.prototype.toJSONSchema = function toJSONSchema(options) {
    const useBsonType = options?.useBsonType ?? false;
    const result = useBsonType ? { required: [], properties: {} } : { type: "object", required: [], properties: {} };
    for (const path of Object.keys(this.paths)) {
      const schemaType = this.paths[path];
      if (schemaType._presplitPath.indexOf("$*") !== -1) {
        continue;
      }
      const isNested = schemaType._presplitPath.length > 1;
      let jsonSchemaForPath = result;
      if (isNested) {
        for (let i = 0;i < schemaType._presplitPath.length - 1; ++i) {
          const subpath = schemaType._presplitPath[i];
          if (jsonSchemaForPath.properties[subpath] == null) {
            jsonSchemaForPath.properties[subpath] = useBsonType ? {
              bsonType: ["object", "null"],
              properties: {}
            } : {
              type: ["object", "null"],
              properties: {}
            };
          }
          jsonSchemaForPath = jsonSchemaForPath.properties[subpath];
        }
      }
      const lastSubpath = schemaType._presplitPath[schemaType._presplitPath.length - 1];
      let isRequired = false;
      if (path === "_id") {
        if (!jsonSchemaForPath.required) {
          jsonSchemaForPath.required = [];
        }
        jsonSchemaForPath.required.push("_id");
        isRequired = true;
      } else if (schemaType.options.required && typeof schemaType.options.required !== "function") {
        if (!jsonSchemaForPath.required) {
          jsonSchemaForPath.required = [];
        }
        jsonSchemaForPath.required.push(lastSubpath);
        isRequired = true;
      }
      jsonSchemaForPath.properties[lastSubpath] = schemaType.toJSONSchema(options);
      if (schemaType.options.enum) {
        jsonSchemaForPath.properties[lastSubpath].enum = isRequired ? schemaType.options.enum : [...schemaType.options.enum, null];
      }
    }
    if (result.required.length === 0) {
      delete result.required;
    }
    return result;
  };
  /*!
   * Module exports.
   */
  module.exports = exports = Schema;
  Schema.Types = MongooseTypes = require_schema();
  /*!
   * ignore
   */
  exports.ObjectId = MongooseTypes.ObjectId;
});

// node_modules/mongoose/lib/error/bulkWriteError.js
var require_bulkWriteError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class MongooseBulkWriteError extends MongooseError {
    constructor(validationErrors, results, rawResult, operation) {
      let preview = validationErrors.map((e) => e.message).join(", ");
      if (preview.length > 200) {
        preview = preview.slice(0, 200) + "...";
      }
      super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);
      this.validationErrors = validationErrors;
      this.results = results;
      this.rawResult = rawResult;
      this.operation = operation;
    }
  }
  Object.defineProperty(MongooseBulkWriteError.prototype, "name", {
    value: "MongooseBulkWriteError"
  });
  /*!
   * exports
   */
  module.exports = MongooseBulkWriteError;
});

// node_modules/mongoose/lib/error/syncIndexes.js
var require_syncIndexes = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class SyncIndexesError extends MongooseError {
    constructor(message, errorsMap) {
      super(message);
      this.errors = errorsMap;
    }
  }
  Object.defineProperty(SyncIndexesError.prototype, "name", {
    value: "SyncIndexesError"
  });
  module.exports = SyncIndexesError;
});

// node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS((exports, module) => {
  module.exports = function applyPlugins(schema, plugins, options, cacheKey) {
    if (schema[cacheKey]) {
      return;
    }
    schema[cacheKey] = true;
    if (!options || !options.skipTopLevel) {
      let pluginTags = null;
      for (const plugin of plugins) {
        const tags = plugin[1] == null ? null : plugin[1].tags;
        if (!Array.isArray(tags)) {
          schema.plugin(plugin[0], plugin[1]);
          continue;
        }
        pluginTags = pluginTags || new Set(schema.options.pluginTags || []);
        if (!tags.find((tag) => pluginTags.has(tag))) {
          continue;
        }
        schema.plugin(plugin[0], plugin[1]);
      }
    }
    options = Object.assign({}, options);
    delete options.skipTopLevel;
    if (options.applyPluginsToChildSchemas !== false) {
      for (const path of Object.keys(schema.paths)) {
        const type = schema.paths[path];
        if (type.schema != null) {
          applyPlugins(type.schema, plugins, options, cacheKey);
          type.caster.prototype.$__setSchema(type.schema);
        }
      }
    }
    const discriminators = schema.discriminators;
    if (discriminators == null) {
      return;
    }
    const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
    const keys = Object.keys(discriminators);
    for (const discriminatorKey of keys) {
      const discriminatorSchema = discriminators[discriminatorKey];
      applyPlugins(discriminatorSchema, plugins, { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);
    }
  };
});

// node_modules/mongoose/lib/driver.js
var require_driver = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var driver = null;
  exports.get = function() {
    return driver;
  };
  exports.set = function(v) {
    driver = v;
  };
});

// node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS((exports, module) => {
  function getDefaultBulkwriteResult() {
    return {
      ok: 1,
      nInserted: 0,
      nUpserted: 0,
      nMatched: 0,
      nModified: 0,
      nRemoved: 0,
      upserted: [],
      writeErrors: [],
      insertedIds: [],
      writeConcernErrors: []
    };
  }
  module.exports = getDefaultBulkwriteResult;
});

// node_modules/mongoose/lib/error/createCollectionsError.js
var require_createCollectionsError = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();

  class CreateCollectionsError extends MongooseError {
    constructor(message, errorsMap) {
      super(message);
      this.errors = errorsMap;
    }
  }
  Object.defineProperty(CreateCollectionsError.prototype, "name", {
    value: "CreateCollectionsError"
  });
  module.exports = CreateCollectionsError;
});

// node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS((exports, module) => {
  var _modifiedPaths = require_common4().modifiedPaths;
  module.exports = function modifiedPaths(update) {
    const keys = Object.keys(update);
    const res = {};
    const withoutDollarKeys = {};
    for (const key of keys) {
      if (key.startsWith("$")) {
        _modifiedPaths(update[key], "", res);
        continue;
      }
      withoutDollarKeys[key] = update[key];
    }
    _modifiedPaths(withoutDollarKeys, "", res);
    return res;
  };
});

// node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS((exports, module) => {
  var modifiedPaths = require_modifiedPaths();
  module.exports = function updatedPathsByArrayFilter(update) {
    if (update == null) {
      return {};
    }
    const updatedPaths = modifiedPaths(update);
    return Object.keys(updatedPaths).reduce((cur, path) => {
      const matches = path.match(/\$\[[^\]]+\]/g);
      if (matches == null) {
        return cur;
      }
      for (const match of matches) {
        const firstMatch = path.indexOf(match);
        if (firstMatch !== path.lastIndexOf(match)) {
          throw new Error(`Path '${path}' contains the same array filter multiple times`);
        }
        cur[match.substring(2, match.length - 1)] = path.substring(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
      }
      return cur;
    }, {});
  };
});

// node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS((exports, module) => {
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
  module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
    const parts = path.indexOf(".") === -1 ? [path] : path.split(".");
    let schematype = null;
    let type = "adhocOrUndefined";
    filter = filter || {};
    update = update || {};
    const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    let startIndex = 0;
    for (let i = 0;i < parts.length; ++i) {
      const originalSubpath = parts.slice(startIndex, i + 1).join(".");
      const subpath = cleanPositionalOperators(originalSubpath);
      schematype = schema.path(subpath);
      if (schematype == null) {
        continue;
      }
      type = schema.pathType(subpath);
      if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
        const key = get(schematype, "schema.options.discriminatorKey");
        const discriminatorValuePath = subpath + "." + key;
        const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
        let discriminatorKey = null;
        if (discriminatorValuePath in filter) {
          discriminatorKey = filter[discriminatorValuePath];
        }
        if (discriminatorFilterPath in filter) {
          discriminatorKey = filter[discriminatorFilterPath];
        }
        const wrapperPath = subpath.replace(/\.\d+$/, "");
        if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
          discriminatorKey = filter[wrapperPath].$elemMatch[key];
        }
        const discriminatorKeyUpdatePath = originalSubpath + "." + key;
        if (discriminatorKeyUpdatePath in update) {
          discriminatorKey = update[discriminatorKeyUpdatePath];
        }
        if (discriminatorValuePath in update) {
          discriminatorKey = update[discriminatorValuePath];
        }
        for (const filterKey of Object.keys(updatedPathsByFilter)) {
          const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
          const arrayFilterKey = filterKey + "." + key;
          if (schemaKey === discriminatorFilterPath) {
            const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
            if (filter2 != null) {
              discriminatorKey = filter2[arrayFilterKey];
            }
          }
        }
        if (discriminatorKey == null) {
          continue;
        }
        const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);
        const discriminatorSchema = discriminator && discriminator.schema;
        if (discriminatorSchema == null) {
          continue;
        }
        const rest = parts.slice(i + 1).join(".");
        schematype = discriminatorSchema.path(rest);
        schema = discriminatorSchema;
        startIndex = i + 1;
        if (schematype != null) {
          type = discriminatorSchema._getPathType(rest);
          break;
        }
      }
    }
    return { type, schematype };
  };
});

// node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS((exports, module) => {
  var StrictModeError = require_strict();
  module.exports = function handleImmutable(schematype, strict, obj, key, fullPath, options, ctx) {
    if (schematype == null || !schematype.options || !schematype.options.immutable) {
      return false;
    }
    let immutable = schematype.options.immutable;
    if (typeof immutable === "function") {
      immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
      return false;
    }
    if (options && options.overwriteImmutable) {
      return false;
    }
    if (strict === false) {
      return false;
    }
    if (strict === "throw") {
      throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);
    }
    delete obj[key];
    return true;
  };
});

// node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS((exports, module) => {
  var get = require_get();
  module.exports = function moveImmutableProperties(schema, update, ctx) {
    if (update == null) {
      return;
    }
    const keys = Object.keys(update);
    for (const key of keys) {
      const isDollarKey = key.startsWith("$");
      if (key === "$set") {
        const updatedPaths = Object.keys(update[key]);
        for (const path of updatedPaths) {
          _walkUpdatePath(schema, update[key], path, update, ctx);
        }
      } else if (!isDollarKey) {
        _walkUpdatePath(schema, update, key, update, ctx);
      }
    }
  };
  function _walkUpdatePath(schema, op, path, update, ctx) {
    const schematype = schema.path(path);
    if (schematype == null) {
      return;
    }
    let immutable = get(schematype, "options.immutable", null);
    if (immutable == null) {
      return;
    }
    if (typeof immutable === "function") {
      immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
      return;
    }
    update.$setOnInsert = update.$setOnInsert || {};
    update.$setOnInsert[path] = op[path];
    delete op[path];
  }
});

// node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS((exports, module) => {
  var specialProperties = require_specialProperties();
  module.exports = function setDottedPath(obj, path, val) {
    if (path.indexOf(".") === -1) {
      if (specialProperties.has(path)) {
        return;
      }
      obj[path] = val;
      return;
    }
    const parts = path.split(".");
    const last = parts.pop();
    let cur = obj;
    for (const part of parts) {
      if (specialProperties.has(part)) {
        continue;
      }
      if (cur[part] == null) {
        cur[part] = {};
      }
      cur = cur[part];
    }
    if (!specialProperties.has(last)) {
      cur[last] = val;
    }
  };
});

// node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS((exports, module) => {
  var CastError = require_cast();
  var MongooseError = require_mongooseError();
  var SchemaString = require_string2();
  var StrictModeError = require_strict();
  var ValidationError2 = require_validation();
  var castNumber = require_number();
  var cast2 = require_cast2();
  var getConstructorName = require_getConstructorName();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
  var handleImmutable = require_handleImmutable2();
  var moveImmutableProperties = require_moveImmutableProperties();
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var setDottedPath = require_setDottedPath();
  var utils = require_utils3();
  var { internalToObjectOptions } = require_options();
  var mongodbUpdateOperators = new Set([
    "$currentDate",
    "$inc",
    "$min",
    "$max",
    "$mul",
    "$rename",
    "$set",
    "$setOnInsert",
    "$unset",
    "$addToSet",
    "$pop",
    "$pull",
    "$push",
    "$pullAll",
    "$bit"
  ]);
  module.exports = function castUpdate(schema, obj, options, context, filter) {
    if (obj == null) {
      return;
    }
    options = options || {};
    if (Array.isArray(obj)) {
      const len = obj.length;
      for (let i2 = 0;i2 < len; ++i2) {
        const ops2 = Object.keys(obj[i2]);
        for (const op of ops2) {
          obj[i2][op] = castPipelineOperator(op, obj[i2][op]);
        }
      }
      return obj;
    }
    if (schema != null && filter != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
      const discriminatorValue = filter[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    } else if (schema != null && options.overwriteDiscriminatorKey && utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) && schema.discriminators != null) {
      const discriminatorValue = obj[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    } else if (schema != null && options.overwriteDiscriminatorKey && obj.$set != null && utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) && schema.discriminators != null) {
      const discriminatorValue = obj.$set[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    }
    if (options.upsert) {
      moveImmutableProperties(schema, obj, context);
    }
    const ops = Object.keys(obj);
    let i = ops.length;
    const ret = {};
    let val;
    let hasDollarKey = false;
    filter = filter || {};
    while (i--) {
      const op = ops[i];
      if (!mongodbUpdateOperators.has(op)) {
        if (!ret.$set) {
          if (obj.$set) {
            ret.$set = obj.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = obj[op];
        ops.splice(i, 1);
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = obj[op];
        }
      } else {
        ret[op] = obj[op];
      }
    }
    i = ops.length;
    while (i--) {
      const op = ops[i];
      val = ret[op];
      hasDollarKey = hasDollarKey || op.startsWith("$");
      if (val != null && val.$__) {
        val = val.toObject(internalToObjectOptions);
        ret[op] = val;
      }
      if (val && typeof val === "object" && !Buffer.isBuffer(val) && mongodbUpdateOperators.has(op)) {
        walkUpdatePath(schema, val, op, options, context, filter);
      } else {
        const msg = "Invalid atomic update value for " + op + ". " + "Expected an object, received " + typeof val;
        throw new Error(msg);
      }
      if (op.startsWith("$") && utils.isEmptyObject(val)) {
        delete ret[op];
      }
    }
    if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {
      return { $setOnInsert: { ...filter } };
    }
    return ret;
  };
  /*!
   * ignore
   */
  function castPipelineOperator(op, val) {
    if (op === "$unset") {
      if (typeof val !== "string" && (!Array.isArray(val) || val.find((v) => typeof v !== "string"))) {
        throw new MongooseError("Invalid $unset in pipeline, must be " + " a string or an array of strings");
      }
      return val;
    }
    if (op === "$project") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid $project in pipeline, must be an object");
      }
      return val;
    }
    if (op === "$addFields" || op === "$set") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
      }
      return val;
    } else if (op === "$replaceRoot" || op === "$replaceWith") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
      }
      return val;
    }
    throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
  }
  function walkUpdatePath(schema, obj, op, options, context, filter, pref) {
    const strict = options.strict;
    const prefix = pref ? pref + "." : "";
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys = false;
    let schematype;
    let key;
    let val;
    let aggregatedError = null;
    const strictMode = strict != null ? strict : schema.options.strict;
    while (i--) {
      key = keys[i];
      val = obj[key];
      if (op === "$pull") {
        schematype = schema._getSchema(prefix + key);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
          }
        }
        if (schematype != null && schematype.schema != null) {
          obj[key] = cast2(schematype.schema, obj[key], options, context);
          hasKeys = true;
          continue;
        }
      }
      const discriminatorKey = prefix ? prefix + key : key;
      if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {
        if (strictMode === "throw") {
          const err2 = new Error(`Can't modify discriminator key "` + discriminatorKey + '" on discriminator model');
          aggregatedError = _appendError(err2, context, discriminatorKey, aggregatedError);
          continue;
        } else if (strictMode) {
          delete obj[key];
          continue;
        }
      }
      if (getConstructorName(val) === "Object") {
        schematype = schema._getSchema(prefix + key);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
          }
        }
        if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {
          continue;
        }
        if (schematype && schematype.caster && op in castOps) {
          if ("$each" in val) {
            hasKeys = true;
            try {
              obj[key] = {
                $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
              };
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
            if (val.$slice != null) {
              obj[key].$slice = val.$slice | 0;
            }
            if (val.$sort) {
              obj[key].$sort = val.$sort;
            }
            if (val.$position != null) {
              obj[key].$position = castNumber(val.$position);
            }
          } else {
            if (schematype != null && schematype.$isSingleNested) {
              const _strict = strict == null ? schematype.schema.options.strict : strict;
              try {
                obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
            } else {
              try {
                obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
            }
            if (obj[key] === undefined) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          }
        } else if (op === "$currentDate" || op in castOps && schematype) {
          try {
            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        } else if (op === "$rename") {
          const schematype2 = new SchemaString(`${prefix}${key}.$rename`);
          try {
            obj[key] = castUpdateVal(schematype2, val, op, key, context, prefix + key);
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        } else {
          const pathToCheck = prefix + key;
          const v = schema._getPathType(pathToCheck);
          let _strict = strict;
          if (v && v.schema && _strict == null) {
            _strict = v.schema.options.strict;
          }
          if (v.pathType === "undefined") {
            if (_strict === "throw") {
              throw new StrictModeError(pathToCheck);
            } else if (_strict) {
              delete obj[key];
              continue;
            }
          }
          hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
        }
      } else {
        const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
        schematype = schema._getSchema(checkPath);
        if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {
          continue;
        }
        let pathDetails = schema._getPathType(checkPath);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
            pathDetails = _res.type;
          }
        }
        let isStrict = strict;
        if (pathDetails && pathDetails.schema && strict == null) {
          isStrict = pathDetails.schema.options.strict;
        }
        const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
        if (skip) {
          if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
            throw new StrictModeError(prefix + key);
          } else {
            delete obj[key];
          }
        } else {
          if (op === "$rename") {
            if (obj[key] == null) {
              throw new CastError("String", obj[key], `${prefix}${key}.$rename`);
            }
            const schematype2 = new SchemaString(`${prefix}${key}.$rename`);
            obj[key] = schematype2.castForQuery(null, obj[key], context);
            continue;
          }
          try {
            if (prefix.length === 0 || key.indexOf(".") === -1) {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } else if (isStrict !== false || schematype != null) {
              setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
              delete obj[key];
            }
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
            if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {
              obj[key] = { $each: obj[key] };
            }
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        }
      }
    }
    if (aggregatedError != null) {
      throw aggregatedError;
    }
    return hasKeys;
  }
  /*!
   * ignore
   */
  function _appendError(error, query, key, aggregatedError) {
    if (typeof query !== "object" || !query.options.multipleCastError) {
      throw error;
    }
    aggregatedError = aggregatedError || new ValidationError2;
    aggregatedError.addError(key, error);
    return aggregatedError;
  }
  var numberOps = {
    $pop: 1,
    $inc: 1
  };
  var noCastOps = {
    $unset: 1
  };
  var castOps = {
    $push: 1,
    $addToSet: 1,
    $set: 1,
    $setOnInsert: 1
  };
  /*!
   * ignore
   */
  var overwriteOps = {
    $set: 1,
    $setOnInsert: 1
  };
  function castUpdateVal(schema, val, op, $conditional, context, path) {
    if (!schema) {
      if (op in numberOps) {
        try {
          return castNumber(val);
        } catch (err2) {
          throw new CastError("number", val, path);
        }
      }
      return val;
    }
    const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));
    if (cond && !overwriteOps[op]) {
      let schemaArrayDepth = 0;
      let cur = schema;
      while (cur.$isMongooseArray) {
        ++schemaArrayDepth;
        cur = cur.caster;
      }
      let arrayDepth = 0;
      let _val = val;
      while (Array.isArray(_val)) {
        ++arrayDepth;
        _val = _val[0];
      }
      const additionalNesting = schemaArrayDepth - arrayDepth;
      while (arrayDepth < schemaArrayDepth) {
        val = [val];
        ++arrayDepth;
      }
      let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
      for (let i = 0;i < additionalNesting; ++i) {
        tmp = tmp[0];
      }
      return tmp;
    }
    if (op in noCastOps) {
      return val;
    }
    if (op in numberOps) {
      if (val == null) {
        throw new CastError("number", val, schema.path);
      }
      if (op === "$inc") {
        return schema.castForQuery(null, val, context);
      }
      try {
        return castNumber(val);
      } catch (error) {
        throw new CastError("number", val, schema.path);
      }
    }
    if (op === "$currentDate") {
      if (typeof val === "object") {
        return { $type: val.$type };
      }
      return Boolean(val);
    }
    if (mongodbUpdateOperators.has($conditional)) {
      return schema.castForQuery($conditional, val, context);
    }
    if (overwriteOps[op]) {
      const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/);
      const applySetters = schema[schemaMixedSymbol] != null;
      if (skipQueryCastForUpdate || applySetters) {
        return schema.applySetters(val, context);
      }
      return schema.castForQuery(null, val, context);
    }
    return schema.castForQuery(null, val, context);
  }
});

// node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js
var require_decorateUpdateWithVersionKey = __commonJS((exports, module) => {
  var modifiedPaths = require_modifiedPaths();
  module.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {
    if (!versionKey || !(options && options.upsert || false)) {
      return;
    }
    const updatedPaths = modifiedPaths(update);
    if (!updatedPaths[versionKey]) {
      if (options.overwrite) {
        update[versionKey] = 0;
      } else {
        if (!update.$setOnInsert) {
          update.$setOnInsert = {};
        }
        update.$setOnInsert[versionKey] = 0;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS((exports, module) => {
  var modifiedPaths = require_common4().modifiedPaths;
  var get = require_get();
  module.exports = function(filter, schema, castedDoc, options) {
    options = options || {};
    const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
    if (!options.upsert || shouldSetDefaultsOnInsert === false) {
      return castedDoc;
    }
    const keys = Object.keys(castedDoc || {});
    const updatedKeys = {};
    const updatedValues = {};
    const numKeys = keys.length;
    const modified = {};
    let hasDollarUpdate = false;
    for (let i = 0;i < numKeys; ++i) {
      if (keys[i].startsWith("$")) {
        modifiedPaths(castedDoc[keys[i]], "", modified);
        hasDollarUpdate = true;
      }
    }
    if (!hasDollarUpdate) {
      modifiedPaths(castedDoc, "", modified);
    }
    const paths = Object.keys(filter);
    const numPaths = paths.length;
    for (let i = 0;i < numPaths; ++i) {
      const path = paths[i];
      const condition = filter[path];
      if (condition && typeof condition === "object") {
        const conditionKeys = Object.keys(condition);
        const numConditionKeys = conditionKeys.length;
        let hasDollarKey = false;
        for (let j = 0;j < numConditionKeys; ++j) {
          if (conditionKeys[j].startsWith("$")) {
            hasDollarKey = true;
            break;
          }
        }
        if (hasDollarKey) {
          continue;
        }
      }
      updatedKeys[path] = true;
      modified[path] = true;
    }
    if (options && options.overwrite && !hasDollarUpdate) {
      return castedDoc;
    }
    schema.eachPath(function(path, schemaType) {
      if (schemaType.path === "_id" && schemaType.options.auto) {
        return;
      }
      const def = schemaType.getDefault(null, true);
      if (isModified(modified, path)) {
        return;
      }
      if (typeof def === "undefined") {
        return;
      }
      if (schemaType.splitPath().includes("$*")) {
        return;
      }
      castedDoc = castedDoc || {};
      castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
      if (get(castedDoc, path) == null) {
        castedDoc.$setOnInsert[path] = def;
      }
      updatedValues[path] = def;
    });
    return castedDoc;
  };
  function isModified(modified, path) {
    if (modified[path]) {
      return true;
    }
    const sp = path.split(".");
    let cur = sp[0];
    for (let i = 1;i < sp.length; ++i) {
      if (modified[cur]) {
        return true;
      }
      cur += "." + sp[i];
    }
    const modifiedKeys = Object.keys(modified);
    if (modifiedKeys.length) {
      const parentPath = path + ".";
      for (const modifiedPath of modifiedKeys) {
        if (modifiedPath.slice(0, path.length + 1) === parentPath) {
          return true;
        }
      }
    }
    return false;
  }
});

// node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var applyTimestampsToChildren = require_applyTimestampsToChildren();
  var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
  var cast2 = require_cast2();
  var castUpdate = require_castUpdate();
  var clone2 = require_clone();
  var decorateUpdateWithVersionKey = require_decorateUpdateWithVersionKey();
  var { inspect } = __require("util");
  var setDefaultsOnInsert = require_setDefaultsOnInsert();
  module.exports = function castBulkWrite(originalModel, op, options) {
    const now = originalModel.base.now();
    if (op["insertOne"]) {
      return (callback) => module.exports.castInsertOne(originalModel, op["insertOne"], options).then(() => callback(null), (err2) => callback(err2));
    } else if (op["updateOne"]) {
      return (callback) => {
        try {
          module.exports.castUpdateOne(originalModel, op["updateOne"], options, now);
          callback(null);
        } catch (err2) {
          callback(err2);
        }
      };
    } else if (op["updateMany"]) {
      return (callback) => {
        try {
          module.exports.castUpdateMany(originalModel, op["updateMany"], options, now);
          callback(null);
        } catch (err2) {
          callback(err2);
        }
      };
    } else if (op["replaceOne"]) {
      return (callback) => {
        module.exports.castReplaceOne(originalModel, op["replaceOne"], options).then(() => callback(null), (err2) => callback(err2));
      };
    } else if (op["deleteOne"]) {
      return (callback) => {
        try {
          module.exports.castDeleteOne(originalModel, op["deleteOne"]);
          callback(null);
        } catch (err2) {
          callback(err2);
        }
      };
    } else if (op["deleteMany"]) {
      return (callback) => {
        try {
          module.exports.castDeleteMany(originalModel, op["deleteMany"]);
          callback(null);
        } catch (err2) {
          callback(err2);
        }
      };
    } else {
      return (callback) => {
        const error = new MongooseError(`Invalid op passed to \`bulkWrite()\`: ${inspect(op)}`);
        callback(error, null);
      };
    }
  };
  module.exports.castInsertOne = async function castInsertOne(originalModel, insertOne, options) {
    const model = decideModelByObject(originalModel, insertOne["document"]);
    const doc = new model(insertOne["document"]);
    if (model.schema.options.timestamps && getTimestampsOpt(insertOne, options)) {
      doc.initializeTimestamps();
    }
    if (options.session != null) {
      doc.$session(options.session);
    }
    const versionKey = model?.schema?.options?.versionKey;
    if (versionKey && doc[versionKey] == null) {
      doc[versionKey] = 0;
    }
    insertOne["document"] = doc;
    if (options.skipValidation || insertOne.skipValidation) {
      return insertOne;
    }
    await insertOne["document"].$validate();
    return insertOne;
  };
  module.exports.castUpdateOne = function castUpdateOne(originalModel, updateOne, options, now) {
    if (!updateOne["filter"]) {
      throw new Error("Must provide a filter object.");
    }
    if (!updateOne["update"]) {
      throw new Error("Must provide an update object.");
    }
    const model = decideModelByObject(originalModel, updateOne["filter"]);
    const schema = model.schema;
    const strict = options.strict != null ? options.strict : model.schema.options.strict;
    const update = clone2(updateOne["update"]);
    _addDiscriminatorToObject(schema, updateOne["filter"]);
    const doInitTimestamps = getTimestampsOpt(updateOne, options);
    if (model.schema.$timestamps != null && doInitTimestamps) {
      const createdAt = model.schema.$timestamps.createdAt;
      const updatedAt = model.schema.$timestamps.updatedAt;
      applyTimestampsToUpdate(now, createdAt, updatedAt, update, {});
    }
    if (doInitTimestamps) {
      applyTimestampsToChildren(now, update, model.schema);
    }
    const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;
    const shouldSetDefaultsOnInsert = updateOne.setDefaultsOnInsert == null ? globalSetDefaultsOnInsert : updateOne.setDefaultsOnInsert;
    if (shouldSetDefaultsOnInsert !== false) {
      setDefaultsOnInsert(updateOne["filter"], model.schema, update, {
        setDefaultsOnInsert: true,
        upsert: updateOne.upsert
      });
    }
    decorateUpdateWithVersionKey(update, updateOne, model.schema.options.versionKey);
    updateOne["filter"] = cast2(model.schema, updateOne["filter"], {
      strict,
      upsert: updateOne.upsert
    });
    updateOne["update"] = castUpdate(model.schema, update, {
      strict,
      upsert: updateOne.upsert,
      arrayFilters: updateOne.arrayFilters,
      overwriteDiscriminatorKey: updateOne.overwriteDiscriminatorKey
    }, model, updateOne["filter"]);
    return updateOne;
  };
  module.exports.castUpdateMany = function castUpdateMany(originalModel, updateMany, options, now) {
    if (!updateMany["filter"]) {
      throw new Error("Must provide a filter object.");
    }
    if (!updateMany["update"]) {
      throw new Error("Must provide an update object.");
    }
    const model = decideModelByObject(originalModel, updateMany["filter"]);
    const schema = model.schema;
    const strict = options.strict != null ? options.strict : model.schema.options.strict;
    const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;
    const shouldSetDefaultsOnInsert = updateMany.setDefaultsOnInsert == null ? globalSetDefaultsOnInsert : updateMany.setDefaultsOnInsert;
    if (shouldSetDefaultsOnInsert !== false) {
      setDefaultsOnInsert(updateMany["filter"], model.schema, updateMany["update"], {
        setDefaultsOnInsert: true,
        upsert: updateMany.upsert
      });
    }
    const doInitTimestamps = getTimestampsOpt(updateMany, options);
    if (model.schema.$timestamps != null && doInitTimestamps) {
      const createdAt = model.schema.$timestamps.createdAt;
      const updatedAt = model.schema.$timestamps.updatedAt;
      applyTimestampsToUpdate(now, createdAt, updatedAt, updateMany["update"], {});
    }
    if (doInitTimestamps) {
      applyTimestampsToChildren(now, updateMany["update"], model.schema);
    }
    _addDiscriminatorToObject(schema, updateMany["filter"]);
    decorateUpdateWithVersionKey(updateMany["update"], updateMany, model.schema.options.versionKey);
    updateMany["filter"] = cast2(model.schema, updateMany["filter"], {
      strict,
      upsert: updateMany.upsert
    });
    updateMany["update"] = castUpdate(model.schema, updateMany["update"], {
      strict,
      upsert: updateMany.upsert,
      arrayFilters: updateMany.arrayFilters,
      overwriteDiscriminatorKey: updateMany.overwriteDiscriminatorKey
    }, model, updateMany["filter"]);
  };
  module.exports.castReplaceOne = async function castReplaceOne(originalModel, replaceOne, options) {
    const model = decideModelByObject(originalModel, replaceOne["filter"]);
    const schema = model.schema;
    const strict = options.strict != null ? options.strict : model.schema.options.strict;
    _addDiscriminatorToObject(schema, replaceOne["filter"]);
    replaceOne["filter"] = cast2(model.schema, replaceOne["filter"], {
      strict,
      upsert: replaceOne.upsert
    });
    const doc = new model(replaceOne["replacement"], strict, true);
    if (model.schema.options.timestamps && getTimestampsOpt(replaceOne, options)) {
      doc.initializeTimestamps();
    }
    if (options.session != null) {
      doc.$session(options.session);
    }
    const versionKey = model?.schema?.options?.versionKey;
    if (versionKey && doc[versionKey] == null) {
      doc[versionKey] = 0;
    }
    replaceOne["replacement"] = doc;
    if (options.skipValidation || replaceOne.skipValidation) {
      replaceOne["replacement"] = replaceOne["replacement"].toBSON();
      return;
    }
    await replaceOne["replacement"].$validate();
    replaceOne["replacement"] = replaceOne["replacement"].toBSON();
  };
  module.exports.castDeleteOne = function castDeleteOne(originalModel, deleteOne) {
    const model = decideModelByObject(originalModel, deleteOne["filter"]);
    const schema = model.schema;
    _addDiscriminatorToObject(schema, deleteOne["filter"]);
    deleteOne["filter"] = cast2(model.schema, deleteOne["filter"]);
  };
  module.exports.castDeleteMany = function castDeleteMany(originalModel, deleteMany) {
    const model = decideModelByObject(originalModel, deleteMany["filter"]);
    const schema = model.schema;
    _addDiscriminatorToObject(schema, deleteMany["filter"]);
    deleteMany["filter"] = cast2(model.schema, deleteMany["filter"]);
  };
  module.exports.cast = {
    insertOne: module.exports.castInsertOne,
    updateOne: module.exports.castUpdateOne,
    updateMany: module.exports.castUpdateMany,
    replaceOne: module.exports.castReplaceOne,
    deleteOne: module.exports.castDeleteOne,
    deleteMany: module.exports.castDeleteMany
  };
  function _addDiscriminatorToObject(schema, obj) {
    if (schema == null) {
      return;
    }
    if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
      obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
  }
  function decideModelByObject(model, object) {
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (object != null && object.hasOwnProperty(discriminatorKey)) {
      model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
    }
    return model;
  }
  function getTimestampsOpt(opCommand, options) {
    const opLevelOpt = opCommand.timestamps;
    const bulkLevelOpt = options.timestamps;
    if (opLevelOpt != null) {
      return opLevelOpt;
    } else if (bulkLevelOpt != null) {
      return bulkLevelOpt;
    }
    return true;
  }
});

// node_modules/mongoose/lib/helpers/model/decorateBulkWriteResult.js
var require_decorateBulkWriteResult = __commonJS((exports, module) => {
  module.exports = function decorateBulkWriteResult(resultOrError, validationErrors, results) {
    resultOrError.mongoose = resultOrError.mongoose || {};
    resultOrError.mongoose.validationErrors = validationErrors;
    resultOrError.mongoose.results = results;
    return resultOrError;
  };
});

// node_modules/mongoose/lib/connection.js
var require_connection2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var ChangeStream = require_changeStream();
  var EventEmitter = __require("events").EventEmitter;
  var Schema = require_schema2();
  var STATES = require_connectionState();
  var MongooseBulkWriteError = require_bulkWriteError();
  var MongooseError = require_error2();
  var ServerSelectionError = require_serverSelection();
  var SyncIndexesError = require_syncIndexes();
  var applyPlugins = require_applyPlugins();
  var clone2 = require_clone();
  var driver = require_driver();
  var get = require_get();
  var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
  var immediate = require_immediate();
  var utils = require_utils3();
  var CreateCollectionsError = require_createCollectionsError();
  var castBulkWrite = require_castBulkWrite();
  var { modelSymbol } = require_symbols();
  var isPromise = require_isPromise();
  var decorateBulkWriteResult = require_decorateBulkWriteResult();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var noPasswordAuthMechanisms = [
    "MONGODB-X509"
  ];
  function Connection(base) {
    this.base = base;
    this.collections = {};
    this.models = {};
    this.config = {};
    this.replica = false;
    this.options = null;
    this.otherDbs = [];
    this.relatedDbs = {};
    this.states = STATES;
    this._readyState = STATES.disconnected;
    this._closeCalled = false;
    this._hasOpened = false;
    this.plugins = [];
    if (typeof base === "undefined" || !base.connections.length) {
      this.id = 0;
    } else {
      this.id = base.nextConnectionId;
    }
    this._queue = [];
  }
  /*!
   * Inherit from EventEmitter
   */
  Object.setPrototypeOf(Connection.prototype, EventEmitter.prototype);
  Object.defineProperty(Connection.prototype, "readyState", {
    get: function() {
      if (this._readyState === STATES.connected && this._lastHeartbeatAt != null && this.client?.topology?.s?.description?.type !== "LoadBalanced" && typeof this.client?.topology?.s?.description?.heartbeatFrequencyMS === "number" && Date.now() - this._lastHeartbeatAt >= this.client.topology.s.description.heartbeatFrequencyMS * 2) {
        return STATES.disconnected;
      }
      return this._readyState;
    },
    set: function(val) {
      if (!(val in STATES)) {
        throw new Error("Invalid connection state: " + val);
      }
      if (this._readyState !== val) {
        this._readyState = val;
        for (const db of this.otherDbs) {
          db.readyState = val;
        }
        if (STATES.connected === val) {
          this._hasOpened = true;
        }
        this.emit(STATES[val]);
      }
    }
  });
  Connection.prototype.get = function getOption(key) {
    if (this.config.hasOwnProperty(key)) {
      return this.config[key];
    }
    return get(this.options, key);
  };
  Connection.prototype.set = function setOption(key, val) {
    if (this.config.hasOwnProperty(key)) {
      this.config[key] = val;
      return val;
    }
    this.options = this.options || {};
    this.options[key] = val;
    return val;
  };
  Connection.prototype.collections;
  Connection.prototype.name;
  Connection.prototype.models;
  Connection.prototype.id;
  Object.defineProperty(Connection.prototype, "plugins", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "host", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "port", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "user", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "pass", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Connection.prototype.db;
  Connection.prototype.client;
  Connection.prototype.config;
  Connection.prototype.createCollection = async function createCollection(collection, options) {
    if (typeof options === "function" || arguments.length >= 3 && typeof arguments[2] === "function") {
      throw new MongooseError("Connection.prototype.createCollection() no longer accepts a callback");
    }
    await this._waitForConnect();
    return this.db.createCollection(collection, options);
  };
  Connection.prototype.bulkWrite = async function bulkWrite(ops, options) {
    await this._waitForConnect();
    options = options || {};
    const ordered = options.ordered == null ? true : options.ordered;
    const asyncLocalStorage = this.base.transactionAsyncLocalStorage?.getStore();
    if ((!options || !options.hasOwnProperty("session")) && asyncLocalStorage?.session != null) {
      options = { ...options, session: asyncLocalStorage.session };
    }
    const now = this.base.now();
    let res = null;
    if (ordered) {
      const opsToSend = [];
      for (const op of ops) {
        if (typeof op.model !== "string" && !op.model?.[modelSymbol]) {
          throw new MongooseError("Must specify model in Connection.prototype.bulkWrite() operations");
        }
        const Model = op.model[modelSymbol] ? op.model : this.model(op.model);
        if (op.name == null) {
          throw new MongooseError("Must specify operation name in Connection.prototype.bulkWrite()");
        }
        if (!castBulkWrite.cast.hasOwnProperty(op.name)) {
          throw new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);
        }
        await castBulkWrite.cast[op.name](Model, op, options, now);
        opsToSend.push({ ...op, namespace: Model.namespace() });
      }
      res = await this.client.bulkWrite(opsToSend, options);
    } else {
      const validOps = [];
      const validOpIndexes = [];
      let validationErrors = [];
      const asyncValidations = [];
      const results = [];
      for (let i = 0;i < ops.length; ++i) {
        const op = ops[i];
        if (typeof op.model !== "string" && !op.model?.[modelSymbol]) {
          const error2 = new MongooseError("Must specify model in Connection.prototype.bulkWrite() operations");
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        let Model;
        try {
          Model = op.model[modelSymbol] ? op.model : this.model(op.model);
        } catch (error2) {
          validationErrors.push({ index: i, error: error2 });
          continue;
        }
        if (op.name == null) {
          const error2 = new MongooseError("Must specify operation name in Connection.prototype.bulkWrite()");
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        if (!castBulkWrite.cast.hasOwnProperty(op.name)) {
          const error2 = new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        let maybePromise = null;
        try {
          maybePromise = castBulkWrite.cast[op.name](Model, op, options, now);
        } catch (error2) {
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        if (isPromise(maybePromise)) {
          asyncValidations.push(maybePromise.then(() => {
            validOps.push({ ...op, namespace: Model.namespace() });
            validOpIndexes.push(i);
          }, (error2) => {
            validationErrors.push({ index: i, error: error2 });
            results[i] = error2;
          }));
        } else {
          validOps.push({ ...op, namespace: Model.namespace() });
          validOpIndexes.push(i);
        }
      }
      if (asyncValidations.length > 0) {
        await Promise.all(asyncValidations);
      }
      validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map((v) => v.error);
      if (validOps.length === 0) {
        if (options.throwOnValidationError && validationErrors.length) {
          throw new MongooseBulkWriteError(validationErrors, results, res2, "bulkWrite");
        }
        const BulkWriteResult = this.base.driver.get().BulkWriteResult;
        const res2 = new BulkWriteResult(getDefaultBulkwriteResult(), false);
        return decorateBulkWriteResult(res2, validationErrors, results);
      }
      let error;
      [res, error] = await this.client.bulkWrite(validOps, options).then((res2) => [res2, null]).catch((err2) => [null, err2]);
      for (let i = 0;i < validOpIndexes.length; ++i) {
        results[validOpIndexes[i]] = null;
      }
      if (error) {
        if (validationErrors.length > 0) {
          decorateBulkWriteResult(error, validationErrors, results);
          error.mongoose = error.mongoose || {};
          error.mongoose.validationErrors = validationErrors;
        }
      }
      if (validationErrors.length > 0) {
        if (options.throwOnValidationError) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        } else {
          decorateBulkWriteResult(res, validationErrors, results);
        }
      }
    }
    return res;
  };
  Connection.prototype.createCollections = async function createCollections(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)) {
      try {
        result[model.modelName] = await model.createCollection({});
      } catch (err2) {
        if (!continueOnError) {
          errorsMap[model.modelName] = err2;
          break;
        } else {
          result[model.modelName] = err2;
        }
      }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
      const message = Object.entries(errorsMap).map(([modelName, err2]) => `${modelName}: ${err2.message}`).join(", ");
      const createCollectionsError = new CreateCollectionsError(message, errorsMap);
      throw createCollectionsError;
    }
    return result;
  };
  Connection.prototype.withSession = async function withSession(executor) {
    if (arguments.length === 0) {
      throw new Error("Please provide an executor function");
    }
    return await this.client.withSession(executor);
  };
  Connection.prototype.startSession = async function startSession(options) {
    if (arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.startSession() no longer accepts a callback");
    }
    await this._waitForConnect();
    const session = this.client.startSession(options);
    return session;
  };
  Connection.prototype.transaction = function transaction(fn, options) {
    return this.startSession().then((session) => {
      session[sessionNewDocuments] = new Map;
      return session.withTransaction(() => _wrapUserTransaction(fn, session, this.base), options).then((res) => {
        delete session[sessionNewDocuments];
        return res;
      }).catch((err2) => {
        delete session[sessionNewDocuments];
        throw err2;
      }).finally(() => {
        session.endSession().catch(() => {
        });
      });
    });
  };
  /*!
   * Reset document state in between transaction retries re: gh-13698
   */
  async function _wrapUserTransaction(fn, session, mongoose) {
    try {
      const res = mongoose.transactionAsyncLocalStorage == null ? await fn(session) : await new Promise((resolve) => {
        mongoose.transactionAsyncLocalStorage.run({ session }, () => resolve(fn(session)));
      });
      return res;
    } catch (err2) {
      _resetSessionDocuments(session);
      throw err2;
    }
  }
  /*!
   * If transaction was aborted, we need to reset newly inserted documents' `isNew`.
   */
  function _resetSessionDocuments(session) {
    for (const doc of session[sessionNewDocuments].keys()) {
      const state = session[sessionNewDocuments].get(doc);
      if (state.hasOwnProperty("isNew")) {
        doc.$isNew = state.isNew;
      }
      if (state.hasOwnProperty("versionKey")) {
        doc.set(doc.schema.options.versionKey, state.versionKey);
      }
      if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {
        doc.$__.activePaths.states.modify = {};
      }
      for (const path of state.modifiedPaths) {
        const currentState = doc.$__.activePaths.paths[path];
        if (currentState != null) {
          delete doc.$__.activePaths[currentState][path];
        }
        doc.$__.activePaths.paths[path] = "modify";
        doc.$__.activePaths.states.modify[path] = true;
      }
      for (const path of state.atomics.keys()) {
        const val = doc.$__getValue(path);
        if (val == null) {
          continue;
        }
        val[arrayAtomicsSymbol] = state.atomics.get(path);
      }
    }
  }
  Connection.prototype.dropCollection = async function dropCollection(collection) {
    if (arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.dropCollection() no longer accepts a callback");
    }
    await this._waitForConnect();
    return this.db.dropCollection(collection);
  };
  Connection.prototype._waitForConnect = async function _waitForConnect(noTimeout) {
    if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
      const bufferTimeoutMS = this._getBufferTimeoutMS();
      let timeout = null;
      let timedOut = false;
      const queueElement = {};
      const waitForConnectPromise = new Promise((resolve) => {
        queueElement.fn = resolve;
        this._queue.push(queueElement);
      });
      if (noTimeout) {
        await waitForConnectPromise;
      } else {
        await Promise.race([
          waitForConnectPromise,
          new Promise((resolve) => {
            timeout = setTimeout(() => {
              timedOut = true;
              resolve();
            }, bufferTimeoutMS);
          })
        ]);
      }
      if (timedOut) {
        const index = this._queue.indexOf(queueElement);
        if (index !== -1) {
          this._queue.splice(index, 1);
        }
        const message = "Connection operation buffering timed out after " + bufferTimeoutMS + "ms";
        throw new MongooseError(message);
      } else if (timeout != null) {
        clearTimeout(timeout);
      }
    }
  };
  /*!
   * Get the default buffer timeout for this connection
   */
  Connection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
    if (this.config.bufferTimeoutMS != null) {
      return this.config.bufferTimeoutMS;
    }
    if (this.base != null && this.base.get("bufferTimeoutMS") != null) {
      return this.base.get("bufferTimeoutMS");
    }
    return 1e4;
  };
  Connection.prototype.listCollections = async function listCollections() {
    await this._waitForConnect();
    const cursor = this.db.listCollections();
    return await cursor.toArray();
  };
  Connection.prototype.listDatabases = async function listDatabases() {
    throw new MongooseError("listDatabases() not implemented by driver");
  };
  Connection.prototype.dropDatabase = async function dropDatabase() {
    if (arguments.length >= 1 && typeof arguments[0] === "function") {
      throw new MongooseError("Connection.prototype.dropDatabase() no longer accepts a callback");
    }
    await this._waitForConnect();
    for (const model of Object.values(this.models)) {
      delete model.$init;
    }
    return this.db.dropDatabase();
  };
  /*!
   * ignore
   */
  Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    if (this.config.bufferCommands != null) {
      return this.config.bufferCommands;
    }
    if (this.base.get("bufferCommands") != null) {
      return this.base.get("bufferCommands");
    }
    return true;
  };
  Connection.prototype.error = function error(err2, callback) {
    if (callback) {
      callback(err2);
      return null;
    }
    if (this.listeners("error").length > 0) {
      this.emit("error", err2);
    }
    return Promise.reject(err2);
  };
  Connection.prototype.onOpen = function() {
    this.readyState = STATES.connected;
    for (const d of this._queue) {
      d.fn.apply(d.ctx, d.args);
    }
    this._queue = [];
    for (const i in this.collections) {
      if (utils.object.hasOwnProperty(this.collections, i)) {
        this.collections[i].onOpen();
      }
    }
    this.emit("open");
  };
  Connection.prototype.openUri = async function openUri(uri2, options) {
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
      if (this._connectionString === uri2) {
        return this;
      }
    }
    this._closeCalled = false;
    let _fireAndForget = false;
    if (options && "_fireAndForget" in options) {
      _fireAndForget = options._fireAndForget;
      delete options._fireAndForget;
    }
    try {
      _validateArgs.apply(arguments);
    } catch (err2) {
      if (_fireAndForget) {
        throw err2;
      }
      this.$initialConnection = Promise.reject(err2);
      throw err2;
    }
    this.$initialConnection = this.createClient(uri2, options).then(() => this).catch((err2) => {
      this.readyState = STATES.disconnected;
      if (this.listeners("error").length > 0) {
        immediate(() => this.emit("error", err2));
      }
      throw err2;
    });
    for (const model of Object.values(this.models)) {
      model.init().catch(function $modelInitNoop() {
      });
    }
    if (_fireAndForget) {
      return this;
    }
    try {
      await this.$initialConnection;
    } catch (err2) {
      throw _handleConnectionErrors(err2);
    }
    return this;
  };
  Connection.prototype.on = function on(event, callback) {
    if (event === "error" && this.$initialConnection) {
      this.$initialConnection.catch(() => {
      });
    }
    return EventEmitter.prototype.on.call(this, event, callback);
  };
  Connection.prototype.once = function on(event, callback) {
    if (event === "error" && this.$initialConnection) {
      this.$initialConnection.catch(() => {
      });
    }
    return EventEmitter.prototype.once.call(this, event, callback);
  };
  /*!
   * ignore
   */
  function _validateArgs(uri2, options, callback) {
    if (typeof options === "function" && callback == null) {
      throw new MongooseError("Connection.prototype.openUri() no longer accepts a callback");
    } else if (typeof callback === "function") {
      throw new MongooseError("Connection.prototype.openUri() no longer accepts a callback");
    }
  }
  /*!
   * ignore
   */
  function _handleConnectionErrors(err2) {
    if (err2?.name === "MongoServerSelectionError") {
      const originalError = err2;
      err2 = new ServerSelectionError;
      err2.assimilateError(originalError);
    }
    return err2;
  }
  Connection.prototype.destroy = async function destroy(force) {
    if (typeof force === "function" || arguments.length === 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.destroy() no longer accepts a callback");
    }
    if (force != null && typeof force === "object") {
      this.$wasForceClosed = !!force.force;
    } else {
      this.$wasForceClosed = !!force;
    }
    return this._close(force, true);
  };
  Connection.prototype.close = async function close(force) {
    if (typeof force === "function" || arguments.length === 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.close() no longer accepts a callback");
    }
    if (force != null && typeof force === "object") {
      this.$wasForceClosed = !!force.force;
    } else {
      this.$wasForceClosed = !!force;
    }
    if (this._lastHeartbeatAt != null) {
      this._lastHeartbeatAt = null;
    }
    for (const model of Object.values(this.models)) {
      delete model.$init;
    }
    return this._close(force, false);
  };
  Connection.prototype._close = async function _close(force, destroy) {
    const _this = this;
    const closeCalled = this._closeCalled;
    this._closeCalled = true;
    this._destroyCalled = destroy;
    if (this.client != null) {
      this.client._closeCalled = true;
      this.client._destroyCalled = destroy;
    }
    const conn = this;
    switch (this.readyState) {
      case STATES.disconnected:
        if (destroy && this.base.connections.indexOf(conn) !== -1) {
          this.base.connections.splice(this.base.connections.indexOf(conn), 1);
        }
        if (!closeCalled) {
          await this.doClose(force);
          this.onClose(force);
        }
        break;
      case STATES.connected:
        this.readyState = STATES.disconnecting;
        await this.doClose(force);
        if (destroy && _this.base.connections.indexOf(conn) !== -1) {
          this.base.connections.splice(this.base.connections.indexOf(conn), 1);
        }
        this.onClose(force);
        break;
      case STATES.connecting:
        return new Promise((resolve, reject) => {
          const _rerunClose = () => {
            this.removeListener("open", _rerunClose);
            this.removeListener("error", _rerunClose);
            if (destroy) {
              this.destroy(force).then(resolve, reject);
            } else {
              this.close(force).then(resolve, reject);
            }
          };
          this.once("open", _rerunClose);
          this.once("error", _rerunClose);
        });
      case STATES.disconnecting:
        return new Promise((resolve) => {
          this.once("close", () => {
            if (destroy && this.base.connections.indexOf(conn) !== -1) {
              this.base.connections.splice(this.base.connections.indexOf(conn), 1);
            }
            resolve();
          });
        });
    }
    return this;
  };
  Connection.prototype.doClose = function doClose() {
    throw new Error("Connection#doClose unimplemented by driver");
  };
  Connection.prototype.onClose = function onClose(force) {
    this.readyState = STATES.disconnected;
    for (const i in this.collections) {
      if (utils.object.hasOwnProperty(this.collections, i)) {
        this.collections[i].onClose(force);
      }
    }
    this.emit("close", force);
    const wasForceClosed = typeof force === "object" && force !== null ? force.force : force;
    for (const db of this.otherDbs) {
      this._destroyCalled ? db.destroy({ force: wasForceClosed, skipCloseClient: true }) : db.close({ force: wasForceClosed, skipCloseClient: true });
    }
  };
  Connection.prototype.collection = function(name, options) {
    const defaultOptions = {
      autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
      autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate,
      autoSearchIndex: this.config.autoSearchIndex != null ? this.config.autoSearchIndex : this.base.options.autoSearchIndex
    };
    options = Object.assign({}, defaultOptions, options ? clone2(options) : {});
    options.$wasForceClosed = this.$wasForceClosed;
    const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;
    if (!(name in this.collections)) {
      this.collections[name] = new Collection(name, this, options);
    }
    return this.collections[name];
  };
  Connection.prototype.plugin = function(fn, opts) {
    this.plugins.push([fn, opts]);
    return this;
  };
  Connection.prototype.model = function model(name, schema, collection, options) {
    if (!(this instanceof Connection)) {
      throw new MongooseError("`connection.model()` should not be run with " + "`new`. If you are doing `new db.model(foo)(bar)`, use " + "`db.model(foo)(bar)` instead");
    }
    let fn;
    if (typeof name === "function") {
      fn = name;
      name = fn.name;
    }
    if (typeof schema === "string") {
      collection = schema;
      schema = false;
    }
    if (utils.isObject(schema)) {
      if (!schema.instanceOfSchema) {
        schema = new Schema(schema);
      } else if (!(schema instanceof this.base.Schema)) {
        schema = schema._clone(this.base.Schema);
      }
    }
    if (schema && !schema.instanceOfSchema) {
      throw new Error("The 2nd parameter to `mongoose.model()` should be a " + "schema or a POJO");
    }
    const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
    const opts = Object.assign(defaultOptions, options, { connection: this });
    if (this.models[name] && !collection && opts.overwriteModels !== true) {
      if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
        throw new MongooseError.OverwriteModelError(name);
      }
      return this.models[name];
    }
    let model;
    if (schema && schema.instanceOfSchema) {
      applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
      model = this.base._model(fn || name, schema, collection, opts);
      if (!this.models[name]) {
        this.models[name] = model;
      }
      model.init().catch(function $modelInitNoop() {
      });
      return model;
    }
    if (this.models[name] && collection) {
      model = this.models[name];
      schema = model.prototype.schema;
      const sub = model.__subclass(this, schema, collection);
      return sub;
    }
    if (arguments.length === 1) {
      model = this.models[name];
      if (!model) {
        throw new MongooseError.MissingSchemaError(name);
      }
      return model;
    }
    if (!model) {
      throw new MongooseError.MissingSchemaError(name);
    }
    if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
      if (!this.models[name]) {
        this.models[name] = model;
      }
      return model;
    }
    this.models[name] = model.__subclass(this, schema, collection);
    return this.models[name];
  };
  Connection.prototype.deleteModel = function deleteModel(name) {
    if (typeof name === "string") {
      const model = this.model(name);
      if (model == null) {
        return this;
      }
      const collectionName = model.collection.name;
      delete this.models[name];
      delete this.collections[collectionName];
      this.emit("deleteModel", model);
    } else if (name instanceof RegExp) {
      const pattern = name;
      const names = this.modelNames();
      for (const name2 of names) {
        if (pattern.test(name2)) {
          this.deleteModel(name2);
        }
      }
    } else {
      throw new Error("First parameter to `deleteModel()` must be a string " + 'or regexp, got "' + name + '"');
    }
    return this;
  };
  Connection.prototype.watch = function watch(pipeline2, options) {
    const changeStreamThunk = (cb) => {
      immediate(() => {
        if (this.readyState === STATES.connecting) {
          this.once("open", function() {
            const driverChangeStream = this.db.watch(pipeline2, options);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.db.watch(pipeline2, options);
          cb(null, driverChangeStream);
        }
      });
    };
    const changeStream = new ChangeStream(changeStreamThunk, pipeline2, options);
    return changeStream;
  };
  Connection.prototype.asPromise = async function asPromise() {
    try {
      await this.$initialConnection;
      return this;
    } catch (err2) {
      throw _handleConnectionErrors(err2);
    }
  };
  Connection.prototype.modelNames = function modelNames() {
    return Object.keys(this.models);
  };
  Connection.prototype.shouldAuthenticate = function shouldAuthenticate() {
    return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
  };
  Connection.prototype.authMechanismDoesNotRequirePassword = function authMechanismDoesNotRequirePassword() {
    if (this.options && this.options.auth) {
      return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
    }
    return true;
  };
  Connection.prototype.optionsProvideAuthenticationData = function optionsProvideAuthenticationData(options) {
    return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
  };
  Connection.prototype.getClient = function getClient() {
    return this.client;
  };
  Connection.prototype.setClient = function setClient() {
    throw new MongooseError("Connection#setClient not implemented by driver");
  };
  /*!
   * Called internally by `openUri()` to create a MongoClient instance.
   */
  Connection.prototype.createClient = function createClient() {
    throw new MongooseError("Connection#createClient not implemented by driver");
  };
  Connection.prototype.syncIndexes = async function syncIndexes(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)) {
      try {
        result[model.modelName] = await model.syncIndexes(options);
      } catch (err2) {
        if (!continueOnError) {
          errorsMap[model.modelName] = err2;
          break;
        } else {
          result[model.modelName] = err2;
        }
      }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
      const message = Object.entries(errorsMap).map(([modelName, err2]) => `${modelName}: ${err2.message}`).join(", ");
      const syncIndexesError = new SyncIndexesError(message, errorsMap);
      throw syncIndexesError;
    }
    return result;
  };
  /*!
   * Module exports.
   */
  Connection.STATES = STATES;
  module.exports = Connection;
});

// node_modules/mongoose/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "mongoose",
    description: "Mongoose MongoDB ODM",
    version: "8.17.0",
    author: "Guillermo Rauch <guillermo@learnboost.com>",
    keywords: [
      "mongodb",
      "document",
      "model",
      "schema",
      "database",
      "odm",
      "data",
      "datastore",
      "query",
      "nosql",
      "orm",
      "db"
    ],
    type: "commonjs",
    license: "MIT",
    dependencies: {
      bson: "^6.10.4",
      kareem: "2.6.3",
      mongodb: "~6.18.0",
      mpath: "0.9.0",
      mquery: "5.0.0",
      ms: "2.1.3",
      sift: "17.1.3"
    },
    devDependencies: {
      "@babel/core": "7.27.7",
      "@babel/preset-env": "7.27.2",
      "@mongodb-js/mongodb-downloader": "^0.4.2",
      "@typescript-eslint/eslint-plugin": "^8.19.1",
      "@typescript-eslint/parser": "^8.19.1",
      acquit: "1.4.0",
      "acquit-ignore": "0.2.1",
      "acquit-require": "0.1.1",
      ajv: "8.17.1",
      "assert-browserify": "2.0.0",
      "babel-loader": "8.2.5",
      "broken-link-checker": "^0.7.8",
      buffer: "^5.6.0",
      cheerio: "1.1.0",
      "crypto-browserify": "3.12.1",
      dox: "1.0.0",
      eslint: "8.57.1",
      "eslint-plugin-markdown": "^5.1.0",
      "eslint-plugin-mocha-no-only": "1.2.0",
      express: "^4.19.2",
      "fs-extra": "~11.3.0",
      "highlight.js": "11.11.1",
      "lodash.isequal": "4.5.0",
      "lodash.isequalwith": "4.4.0",
      "markdownlint-cli2": "^0.18.1",
      marked: "15.0.12",
      mkdirp: "^3.0.1",
      mocha: "11.7.1",
      moment: "2.30.1",
      "mongodb-memory-server": "10.1.4",
      "mongodb-runner": "^5.8.2",
      ncp: "^2.0.0",
      nyc: "15.1.0",
      pug: "3.0.3",
      q: "1.5.1",
      sinon: "21.0.0",
      "stream-browserify": "3.0.0",
      tsd: "0.32.0",
      typescript: "5.8.3",
      uuid: "11.1.0",
      webpack: "5.99.9"
    },
    directories: {
      lib: "./lib/mongoose"
    },
    scripts: {
      "docs:clean": "npm run docs:clean:stable",
      "docs:clean:stable": "rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:clean:5x": "rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:clean:6x": "rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:copy:tmp": "mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/",
      "docs:copy:tmp:5x": "rimraf ./docs/5.x && ncp ./tmp ./docs/5.x",
      "docs:copy:tmp:6x": "rimraf ./docs/6.x && ncp ./tmp ./docs/6.x",
      "docs:generate": "node ./scripts/website.js",
      "docs:generate:sponsorData": "node ./scripts/loadSponsorData.js",
      "docs:test": "npm run docs:generate",
      "docs:view": "node ./scripts/static.js",
      "docs:prepare:publish:stable": "git checkout gh-pages && git merge master && npm run docs:generate",
      "docs:prepare:publish:5x": "git checkout 5.x && git merge 5.x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && git checkout gh-pages && npm run docs:copy:tmp:5x",
      "docs:prepare:publish:6x": "git checkout 6.x && git merge 6.x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && mv ./docs/6.x ./tmp && git checkout gh-pages && npm run docs:copy:tmp:6x",
      "docs:prepare:publish:7x": "env DOCS_DEPLOY=true npm run docs:generate && git checkout gh-pages && rimraf ./docs/7.x && mv ./tmp ./docs/7.x",
      "docs:check-links": "blc http://127.0.0.1:8089 -ro",
      lint: "eslint .",
      "lint-js": "eslint . --ext .js --ext .cjs",
      "lint-ts": "eslint . --ext .ts",
      "lint-md": 'markdownlint-cli2 "**/*.md" "#node_modules" "#benchmarks"',
      "build-browser": "(rm ./dist/* || true) && node ./scripts/build-browser.js",
      prepublishOnly: "npm run build-browser",
      release: "git pull && git push origin master --tags && npm publish",
      "release-5x": "git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x",
      "release-6x": "git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x",
      mongo: "node ./tools/repl.js",
      "publish-7x": "npm publish --tag 7x",
      "create-separate-require-instance": "rm -rf ./node_modules/mongoose-separate-require-instance && node ./scripts/create-tarball && tar -xzf mongoose.tgz -C ./node_modules && mv ./node_modules/package ./node_modules/mongoose-separate-require-instance",
      test: "mocha --exit ./test/*.test.js",
      "test-deno": "deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.mjs",
      "test-rs": "START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js",
      "test-tsd": "node ./test/types/check-types-filename && tsd",
      "setup-test-encryption": "node scripts/setup-encryption-tests.js",
      "test-encryption": "mocha --exit ./test/encryption/*.test.js",
      tdd: "mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}",
      "test-coverage": "nyc --reporter=html --reporter=text npm test",
      "ts-benchmark": "cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"
    },
    main: "./index.js",
    types: "./types/index.d.ts",
    engines: {
      node: ">=16.20.1"
    },
    bugs: {
      url: "https://github.com/Automattic/mongoose/issues/new"
    },
    repository: {
      type: "git",
      url: "git://github.com/Automattic/mongoose.git"
    },
    homepage: "https://mongoosejs.com",
    browser: "./dist/browser.umd.js",
    config: {
      mongodbMemoryServer: {
        disablePostinstall: true
      }
    },
    funding: {
      type: "opencollective",
      url: "https://opencollective.com/mongoose"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        esModuleInterop: false,
        strict: true,
        allowSyntheticDefaultImports: true,
        strictPropertyInitialization: false,
        noImplicitAny: false,
        strictNullChecks: true,
        module: "commonjs",
        target: "ES2017"
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/processConnectionOptions.js
var require_processConnectionOptions = __commonJS((exports, module) => {
  var clone2 = require_clone();
  var MongooseError = require_error2();
  function processConnectionOptions(uri2, options) {
    const opts = options ? options : {};
    const readPreference = opts.readPreference ? opts.readPreference : getUriReadPreference(uri2);
    const clonedOpts = clone2(opts);
    const resolvedOpts = readPreference && readPreference !== "primary" && readPreference !== "primaryPreferred" ? resolveOptsConflicts(readPreference, clonedOpts) : clonedOpts;
    return resolvedOpts;
  }
  function resolveOptsConflicts(pref, opts) {
    if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {
      throwReadPreferenceError();
    } else {
      return defaultIndexOptsToFalse(opts);
    }
  }
  function setsIndexOptions(opts) {
    const configIdx = opts.config && opts.config.autoIndex;
    const { autoCreate, autoIndex } = opts;
    return !!(configIdx || autoCreate || autoIndex);
  }
  function setsSecondaryRead(prefString) {
    return !!(prefString === "secondary" || prefString === "secondaryPreferred");
  }
  function getUriReadPreference(connectionString) {
    const exp = /(?:&|\?)readPreference=(\w+)(?:&|$)/;
    const match = exp.exec(connectionString);
    return match ? match[1] : null;
  }
  function defaultIndexOptsToFalse(opts) {
    opts.config = { autoIndex: false };
    opts.autoCreate = false;
    opts.autoIndex = false;
    return opts;
  }
  function throwReadPreferenceError() {
    throw new MongooseError("MongoDB prohibits index creation on connections that read from " + 'non-primary replicas.  Connections that set "readPreference" to "secondary" or ' + '"secondaryPreferred" may not opt-in to the following connection options: ' + "autoCreate, autoIndex");
  }
  module.exports = processConnectionOptions;
});

// node_modules/mongoose/lib/helpers/timers.js
var require_timers = __commonJS((exports) => {
  exports.setTimeout = setTimeout;
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection3 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseConnection = require_connection2();
  var MongooseError = require_error2();
  var STATES = require_connectionState();
  var mongodb = require_lib3();
  var pkg = require_package2();
  var processConnectionOptions = require_processConnectionOptions();
  var setTimeout2 = require_timers().setTimeout;
  var utils = require_utils3();
  var Schema = require_schema2();
  function NativeConnection() {
    MongooseConnection.apply(this, arguments);
    this._listening = false;
    this._lastHeartbeatAt = null;
  }
  NativeConnection.STATES = STATES;
  /*!
   * Inherits from Connection.
   */
  Object.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);
  NativeConnection.prototype.useDb = function(name, options) {
    options = options || {};
    if (options.useCache && this.relatedDbs[name]) {
      return this.relatedDbs[name];
    }
    const newConn = new this.constructor;
    newConn.name = name;
    newConn.base = this.base;
    newConn.collections = {};
    newConn.models = {};
    newConn.replica = this.replica;
    newConn.config = Object.assign({}, this.config, newConn.config);
    newConn.name = this.name;
    newConn.options = this.options;
    newConn._readyState = this._readyState;
    newConn._closeCalled = this._closeCalled;
    newConn._hasOpened = this._hasOpened;
    newConn._listening = false;
    newConn._parent = this;
    newConn.host = this.host;
    newConn.port = this.port;
    newConn.user = this.user;
    newConn.pass = this.pass;
    const _this = this;
    newConn.client = _this.client;
    if (this.db && this._readyState === STATES.connected) {
      wireup();
    } else {
      this._queue.push({ fn: wireup });
    }
    function wireup() {
      newConn.client = _this.client;
      const _opts = {};
      if (options.hasOwnProperty("noListener")) {
        _opts.noListener = options.noListener;
      }
      newConn.db = _this.client.db(name, _opts);
      newConn._lastHeartbeatAt = _this._lastHeartbeatAt;
      newConn.onOpen();
    }
    newConn.name = name;
    if (options.noListener !== true) {
      this.otherDbs.push(newConn);
    }
    newConn.otherDbs.push(this);
    if (options && options.useCache) {
      this.relatedDbs[newConn.name] = newConn;
      newConn.relatedDbs = this.relatedDbs;
    }
    return newConn;
  };
  NativeConnection.prototype.aggregate = function aggregate(pipeline2, options) {
    return new this.base.Aggregate(null, this).append(pipeline2).option(options ?? {});
  };
  NativeConnection.prototype.removeDb = function removeDb(name) {
    const dbs = this.otherDbs.filter((db) => db.name === name);
    if (!dbs.length) {
      throw new MongooseError(`No connections to database "${name}" found`);
    }
    for (const db of dbs) {
      db._closeCalled = true;
      db._destroyCalled = true;
      db._readyState = STATES.disconnected;
      db.$wasForceClosed = true;
    }
    delete this.relatedDbs[name];
    this.otherDbs = this.otherDbs.filter((db) => db.name !== name);
  };
  NativeConnection.prototype.doClose = async function doClose(force) {
    if (this.client == null) {
      return this;
    }
    let skipCloseClient = false;
    if (force != null && typeof force === "object") {
      skipCloseClient = force.skipCloseClient;
      force = force.force;
    }
    if (skipCloseClient) {
      return this;
    }
    await this.client.close(force);
    await new Promise((resolve) => setTimeout2(resolve, 1));
    return this;
  };
  NativeConnection.prototype.listDatabases = async function listDatabases() {
    await this._waitForConnect();
    return await this.db.admin().listDatabases();
  };
  /*!
   * ignore
   */
  NativeConnection.prototype.createClient = async function createClient(uri2, options) {
    if (typeof uri2 !== "string") {
      throw new MongooseError("The `uri` parameter to `openUri()` must be a " + `string, got "${typeof uri2}". Make sure the first parameter to ` + "`mongoose.connect()` or `mongoose.createConnection()` is a string.");
    }
    if (this._destroyCalled) {
      throw new MongooseError("Connection has been closed and destroyed, and cannot be used for re-opening the connection. " + "Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.");
    }
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
      if (this._connectionString !== uri2) {
        throw new MongooseError("Can't call `openUri()` on an active connection with " + "different connection strings. Make sure you aren't calling `mongoose.connect()` " + "multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
      }
    }
    options = processConnectionOptions(uri2, options);
    if (options) {
      const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
      if (autoIndex != null) {
        this.config.autoIndex = autoIndex !== false;
        delete options.config;
        delete options.autoIndex;
      }
      if ("autoCreate" in options) {
        this.config.autoCreate = !!options.autoCreate;
        delete options.autoCreate;
      }
      if ("sanitizeFilter" in options) {
        this.config.sanitizeFilter = options.sanitizeFilter;
        delete options.sanitizeFilter;
      }
      if ("autoSearchIndex" in options) {
        this.config.autoSearchIndex = options.autoSearchIndex;
        delete options.autoSearchIndex;
      }
      if ("bufferTimeoutMS" in options) {
        this.config.bufferTimeoutMS = options.bufferTimeoutMS;
        delete options.bufferTimeoutMS;
      }
      if (options.user || options.pass) {
        options.auth = options.auth || {};
        options.auth.username = options.user;
        options.auth.password = options.pass;
        this.user = options.user;
        this.pass = options.pass;
      }
      delete options.user;
      delete options.pass;
      if (options.bufferCommands != null) {
        this.config.bufferCommands = options.bufferCommands;
        delete options.bufferCommands;
      }
    } else {
      options = {};
    }
    this._connectionOptions = options;
    const dbName = options.dbName;
    if (dbName != null) {
      this.$dbName = dbName;
    }
    delete options.dbName;
    if (!utils.hasUserDefinedProperty(options, "driverInfo")) {
      options.driverInfo = {
        name: "Mongoose",
        version: pkg.version
      };
    }
    const { schemaMap, encryptedFieldsMap } = this._buildEncryptionSchemas();
    if ((Object.keys(schemaMap).length > 0 || Object.keys(encryptedFieldsMap).length) && !options.autoEncryption) {
      throw new Error("Must provide `autoEncryption` when connecting with encrypted schemas.");
    }
    if (Object.keys(schemaMap).length > 0) {
      options.autoEncryption.schemaMap = schemaMap;
    }
    if (Object.keys(encryptedFieldsMap).length > 0) {
      options.autoEncryption.encryptedFieldsMap = encryptedFieldsMap;
    }
    this.readyState = STATES.connecting;
    this._connectionString = uri2;
    let client;
    try {
      client = new mongodb.MongoClient(uri2, options);
    } catch (error) {
      this.readyState = STATES.disconnected;
      throw error;
    }
    this.client = client;
    client.setMaxListeners(0);
    await client.connect();
    _setClient(this, client, options, dbName);
    for (const db of this.otherDbs) {
      _setClient(db, client, {}, db.name);
    }
    return this;
  };
  NativeConnection.prototype._buildEncryptionSchemas = function() {
    const qeMappings = {};
    const csfleMappings = {};
    const encryptedModels = Object.values(this.models).filter((model) => model.schema._hasEncryptedFields());
    for (const model of encryptedModels) {
      const { schema, collection: { collectionName } } = model;
      const namespace = `${this.$dbName}.${collectionName}`;
      const mappings = schema.encryptionType() === "csfle" ? csfleMappings : qeMappings;
      mappings[namespace] ??= new Schema({}, { encryptionType: schema.encryptionType() });
      const isNonRootDiscriminator = schema.discriminatorMapping && !schema.discriminatorMapping.isRoot;
      if (isNonRootDiscriminator) {
        const rootSchema = schema._baseSchema;
        schema.eachPath((pathname) => {
          if (rootSchema.path(pathname))
            return;
          if (!mappings[namespace]._hasEncryptedField(pathname))
            return;
          throw new Error(`Cannot have duplicate keys in discriminators with encryption. key=${pathname}`);
        });
      }
      mappings[namespace].add(schema);
    }
    const schemaMap = Object.fromEntries(Object.entries(csfleMappings).map(([namespace, schema]) => [namespace, schema._buildSchemaMap()]));
    const encryptedFieldsMap = Object.fromEntries(Object.entries(qeMappings).map(([namespace, schema]) => [namespace, schema._buildEncryptedFields()]));
    return {
      schemaMap,
      encryptedFieldsMap
    };
  };
  /*!
   * ignore
   */
  NativeConnection.prototype.setClient = function setClient(client) {
    if (!(client instanceof mongodb.MongoClient)) {
      throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
    }
    if (this.readyState !== STATES.disconnected) {
      throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
    }
    if (client.topology == null) {
      throw new MongooseError("Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.");
    }
    this._connectionString = client.s.url;
    _setClient(this, client, {}, client.s.options.dbName);
    for (const model of Object.values(this.models)) {
      model.init().catch(function $modelInitNoop() {
      });
    }
    return this;
  };
  /*!
   * ignore
   */
  function _setClient(conn, client, options, dbName) {
    const db = dbName != null ? client.db(dbName) : client.db();
    conn.db = db;
    conn.client = client;
    conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || undefined;
    conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || undefined;
    conn.name = dbName != null ? dbName : db.databaseName;
    conn._closeCalled = client._closeCalled;
    const _handleReconnect = () => {
      if (conn.readyState !== STATES.connected) {
        conn.readyState = STATES.connected;
        conn.emit("reconnect");
        conn.emit("reconnected");
        conn.onOpen();
      }
    };
    const type = client && client.topology && client.topology.description && client.topology.description.type || "";
    if (type === "Single") {
      client.on("serverDescriptionChanged", (ev) => {
        const newDescription = ev.newDescription;
        if (newDescription.type === "Unknown") {
          conn.readyState = STATES.disconnected;
        } else {
          _handleReconnect();
        }
      });
    } else if (type.startsWith("ReplicaSet")) {
      client.on("topologyDescriptionChanged", (ev) => {
        const description = ev.newDescription;
        if (conn.readyState === STATES.connected && description.type !== "ReplicaSetWithPrimary") {
          conn.readyState = STATES.disconnected;
        } else if (conn.readyState === STATES.disconnected && description.type === "ReplicaSetWithPrimary") {
          _handleReconnect();
        }
      });
    }
    conn._lastHeartbeatAt = null;
    client.on("serverHeartbeatSucceeded", () => {
      conn._lastHeartbeatAt = Date.now();
    });
    if (options.monitorCommands) {
      client.on("commandStarted", (data) => conn.emit("commandStarted", data));
      client.on("commandFailed", (data) => conn.emit("commandFailed", data));
      client.on("commandSucceeded", (data) => conn.emit("commandSucceeded", data));
    }
    conn.onOpen();
    for (const i in conn.collections) {
      if (utils.object.hasOwnProperty(conn.collections, i)) {
        conn.collections[i].onOpen();
      }
    }
  }
  /*!
   * Module exports.
   */
  module.exports = NativeConnection;
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.BulkWriteResult = require_bulkWriteResult();
  exports.Collection = require_collection3();
  exports.Connection = require_connection3();
  exports.ClientEncryption = require_lib3().ClientEncryption;
});

// node_modules/mongoose/lib/validOptions.js
var require_validOptions = __commonJS((exports, module) => {
  /*!
   * Valid mongoose options
   */
  var VALID_OPTIONS = Object.freeze([
    "allowDiskUse",
    "applyPluginsToChildSchemas",
    "applyPluginsToDiscriminators",
    "autoCreate",
    "autoIndex",
    "autoSearchIndex",
    "bufferCommands",
    "bufferTimeoutMS",
    "cloneSchemas",
    "createInitialConnection",
    "debug",
    "forceRepopulate",
    "id",
    "timestamps.createdAt.immutable",
    "maxTimeMS",
    "objectIdGetter",
    "overwriteModels",
    "returnOriginal",
    "runValidators",
    "sanitizeFilter",
    "sanitizeProjection",
    "selectPopulatedPaths",
    "setDefaultsOnInsert",
    "skipOriginalStackTraces",
    "strict",
    "strictPopulate",
    "strictQuery",
    "toJSON",
    "toObject",
    "transactionAsyncLocalStorage",
    "translateAliases"
  ]);
  module.exports = VALID_OPTIONS;
});

// node_modules/mongoose/lib/error/eachAsyncMultiError.js
var require_eachAsyncMultiError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class EachAsyncMultiError extends MongooseError {
    constructor(errors2) {
      let preview = errors2.map((e) => e.message).join(", ");
      if (preview.length > 50) {
        preview = preview.slice(0, 50) + "...";
      }
      super(`eachAsync() finished with ${errors2.length} errors: ${preview}`);
      this.errors = errors2;
    }
  }
  Object.defineProperty(EachAsyncMultiError.prototype, "name", {
    value: "EachAsyncMultiError"
  });
  /*!
   * exports
   */
  module.exports = EachAsyncMultiError;
});

// node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EachAsyncMultiError = require_eachAsyncMultiError();
  var immediate = require_immediate();
  module.exports = async function eachAsync(next, fn, options) {
    const parallel = options.parallel || 1;
    const batchSize = options.batchSize;
    const signal = options.signal;
    const continueOnError = options.continueOnError;
    const aggregatedErrors = [];
    const enqueue = asyncQueue();
    let aborted = false;
    return new Promise((resolve, reject) => {
      if (signal != null) {
        if (signal.aborted) {
          return resolve(null);
        }
        signal.addEventListener("abort", () => {
          aborted = true;
          return resolve(null);
        }, { once: true });
      }
      if (batchSize != null) {
        if (typeof batchSize !== "number") {
          throw new TypeError("batchSize must be a number");
        } else if (!Number.isInteger(batchSize)) {
          throw new TypeError("batchSize must be an integer");
        } else if (batchSize < 1) {
          throw new TypeError("batchSize must be at least 1");
        }
      }
      iterate((err2, res) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve(res);
      });
    });
    function iterate(finalCallback) {
      let handleResultsInProgress = 0;
      let currentDocumentIndex = 0;
      let error = null;
      for (let i = 0;i < parallel; ++i) {
        enqueue(createFetch());
      }
      function createFetch() {
        let documentsBatch = [];
        let drained = false;
        return fetch;
        function fetch(done) {
          if (drained || aborted) {
            return done();
          } else if (error) {
            return done();
          }
          next(function(err2, doc) {
            if (error != null) {
              return done();
            }
            if (err2 != null) {
              if (err2.name === "MongoCursorExhaustedError") {
                doc = null;
              } else if (continueOnError) {
                aggregatedErrors.push(err2);
              } else {
                error = err2;
                finalCallback(err2);
                return done();
              }
            }
            if (doc == null) {
              drained = true;
              if (handleResultsInProgress <= 0) {
                const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                finalCallback(finalErr);
              } else if (batchSize && documentsBatch.length) {
                handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
              }
              return done();
            }
            ++handleResultsInProgress;
            immediate(() => done());
            if (batchSize) {
              documentsBatch.push(doc);
            }
            if (batchSize && documentsBatch.length !== batchSize) {
              immediate(() => enqueue(fetch));
              return;
            }
            const docsToProcess = batchSize ? documentsBatch : doc;
            function handleNextResultCallBack(err3) {
              if (batchSize) {
                handleResultsInProgress -= documentsBatch.length;
                documentsBatch = [];
              } else {
                --handleResultsInProgress;
              }
              if (err3 != null) {
                if (continueOnError) {
                  aggregatedErrors.push(err3);
                } else {
                  error = err3;
                  return finalCallback(err3);
                }
              }
              if ((drained || aborted) && handleResultsInProgress <= 0) {
                const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                return finalCallback(finalErr);
              }
              immediate(() => enqueue(fetch));
            }
            handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
          });
        }
      }
    }
    function handleNextResult(doc, i, callback) {
      let maybePromise;
      try {
        maybePromise = fn(doc, i);
      } catch (err2) {
        return callback(err2);
      }
      if (maybePromise && typeof maybePromise.then === "function") {
        maybePromise.then(function() {
          callback(null);
        }, function(error) {
          callback(error || new Error("`eachAsync()` promise rejected without error"));
        });
      } else {
        callback(null);
      }
    }
  };
  function asyncQueue() {
    const _queue = [];
    let inProgress = null;
    let id = 0;
    return function enqueue(fn) {
      if (inProgress === null && _queue.length === 0) {
        inProgress = id++;
        return fn(_step);
      }
      _queue.push(fn);
    };
    function _step() {
      if (_queue.length !== 0) {
        inProgress = id++;
        const fn = _queue.shift();
        fn(_step);
      } else {
        inProgress = null;
      }
    }
  }
  function createEachAsyncMultiError(aggregatedErrors) {
    if (aggregatedErrors.length === 0) {
      return null;
    }
    return new EachAsyncMultiError(aggregatedErrors);
  }
});

// node_modules/mongoose/lib/cursor/queryCursor.js
var require_queryCursor = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var Readable2 = __require("stream").Readable;
  var eachAsync = require_eachAsync();
  var helpers = require_queryHelpers();
  var kareem = require_kareem();
  var immediate = require_immediate();
  var { once } = __require("events");
  var util3 = __require("util");
  function QueryCursor(query) {
    Readable2.call(this, { autoDestroy: true, objectMode: true });
    this.cursor = null;
    this.skipped = false;
    this.query = query;
    this._closed = false;
    const model = query.model;
    this._mongooseOptions = {};
    this._transforms = [];
    this.model = model;
    this.options = {};
    model.hooks.execPre("find", query, (err2) => {
      if (err2 != null) {
        if (err2 instanceof kareem.skipWrappedFunction) {
          const resultValue = err2.args[0];
          if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {
            const err3 = new MongooseError("Cannot `skipMiddlewareFunction()` with a value when using " + '`.find().cursor()`, value must be nullish or empty array, got "' + util3.inspect(resultValue) + '".');
            this._markError(err3);
            this.listeners("error").length > 0 && this.emit("error", err3);
            return;
          }
          this.skipped = true;
          this.emit("cursor", null);
          return;
        }
        this._markError(err2);
        this.listeners("error").length > 0 && this.emit("error", err2);
        return;
      }
      Object.assign(this.options, query._optionsForExec());
      this._transforms = this._transforms.concat(query._transforms.slice());
      if (this.options.transform) {
        this._transforms.push(this.options.transform);
      }
      if (this.options.batchSize) {
        this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);
      }
      if (query._mongooseOptions._asyncIterator) {
        this._mongooseOptions._asyncIterator = true;
      }
      if (model.collection._shouldBufferCommands() && model.collection.buffer) {
        model.collection.queue.push([
          () => _getRawCursor(query, this)
        ]);
      } else {
        _getRawCursor(query, this);
      }
    });
  }
  util3.inherits(QueryCursor, Readable2);
  /*!
   * ignore
   */
  function _getRawCursor(query, queryCursor) {
    try {
      const cursor = query.model.collection.find(query._conditions, queryCursor.options);
      queryCursor.cursor = cursor;
      queryCursor.emit("cursor", cursor);
    } catch (err2) {
      queryCursor._markError(err2);
      queryCursor.listeners("error").length > 0 && queryCursor.emit("error", queryCursor._error);
    }
  }
  QueryCursor.prototype._read = function() {
    _next(this, (error, doc) => {
      if (error) {
        return this.emit("error", error);
      }
      if (!doc) {
        this.push(null);
        this.cursor.close(function(error2) {
          if (error2) {
            return this.emit("error", error2);
          }
        });
        return;
      }
      this.push(doc);
    });
  };
  QueryCursor.prototype.getDriverCursor = async function getDriverCursor() {
    if (this.cursor) {
      return this.cursor;
    }
    await once(this, "cursor");
    return this.cursor;
  };
  Object.defineProperty(QueryCursor.prototype, "map", {
    value: function(fn) {
      this._transforms.push(fn);
      return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
  });
  QueryCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
  };
  QueryCursor.prototype.close = async function close() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("QueryCursor.prototype.close() no longer accepts a callback");
    }
    try {
      await this.cursor.close();
      this._closed = true;
      this.emit("close");
    } catch (error) {
      this.listeners("error").length > 0 && this.emit("error", error);
      throw error;
    }
  };
  QueryCursor.prototype._destroy = function _destroy(_err, callback) {
    let waitForCursor = null;
    if (!this.cursor) {
      waitForCursor = new Promise((resolve) => {
        this.once("cursor", resolve);
      });
    } else {
      waitForCursor = Promise.resolve();
    }
    waitForCursor.then(() => {
      this.cursor.close();
    }).then(() => {
      this._closed = true;
      callback();
    }).catch((error) => {
      callback(error);
    });
    return this;
  };
  QueryCursor.prototype.rewind = function() {
    _waitForCursor(this, () => {
      this.cursor.rewind();
    });
    return this;
  };
  QueryCursor.prototype.next = async function next() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("QueryCursor.prototype.next() no longer accepts a callback");
    }
    if (this._closed) {
      throw new MongooseError("Cannot call `next()` on a closed cursor");
    }
    return new Promise((resolve, reject) => {
      _next(this, function(error, doc) {
        if (error) {
          return reject(error);
        }
        resolve(doc);
      });
    });
  };
  QueryCursor.prototype.eachAsync = function(fn, opts) {
    if (typeof arguments[2] === "function") {
      throw new MongooseError("QueryCursor.prototype.eachAsync() no longer accepts a callback");
    }
    if (typeof opts === "function") {
      opts = {};
    }
    opts = opts || {};
    return eachAsync((cb) => _next(this, cb), fn, opts);
  };
  QueryCursor.prototype.options;
  QueryCursor.prototype.addCursorFlag = function(flag, value) {
    _waitForCursor(this, () => {
      this.cursor.addCursorFlag(flag, value);
    });
    return this;
  };
  if (Symbol.asyncIterator != null) {
    QueryCursor.prototype[Symbol.asyncIterator] = function queryCursorAsyncIterator() {
      this._mongooseOptions._asyncIterator = true;
      return this;
    };
  }
  function _next(ctx, cb) {
    let callback = cb;
    callback = function(err2, doc) {
      if (err2) {
        return cb(err2);
      }
      if (doc === null) {
        if (ctx._mongooseOptions._asyncIterator) {
          return cb(null, { done: true });
        } else {
          return cb(null, null);
        }
      }
      if (ctx._transforms.length && doc !== null) {
        doc = ctx._transforms.reduce(function(doc2, fn) {
          return fn.call(ctx, doc2);
        }, doc);
      }
      if (ctx._mongooseOptions._asyncIterator) {
        return cb(null, { value: doc, done: false });
      }
      return cb(null, doc);
    };
    if (ctx._error) {
      return immediate(function() {
        callback(ctx._error);
      });
    }
    if (ctx.skipped) {
      return immediate(() => callback(null, null));
    }
    if (ctx.cursor) {
      if (ctx.query._mongooseOptions.populate && !ctx._pop) {
        ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);
        ctx._pop.__noPromise = true;
      }
      if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
        if (ctx._batchDocs && ctx._batchDocs.length) {
          return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
        } else if (ctx._batchExhausted) {
          return callback(null, null);
        } else {
          ctx._batchDocs = [];
          ctx.cursor.next().then((res) => {
            _onNext.call({ ctx, callback }, null, res);
          }, (err2) => {
            _onNext.call({ ctx, callback }, err2);
          });
          return;
        }
      } else {
        return ctx.cursor.next().then((doc) => {
          if (!doc) {
            callback(null, null);
            return;
          }
          if (!ctx.query._mongooseOptions.populate) {
            return _nextDoc(ctx, doc, null, callback);
          }
          _nextDoc(ctx, doc, ctx._pop, (err2, doc2) => {
            if (err2 != null) {
              return callback(err2);
            }
            ctx.query.model.populate(doc2, ctx._pop).then((doc3) => callback(null, doc3), (err3) => callback(err3));
          });
        }, (error) => {
          callback(error);
        });
      }
    } else {
      ctx.once("error", cb);
      ctx.once("cursor", function(cursor) {
        ctx.removeListener("error", cb);
        if (cursor == null) {
          if (ctx.skipped) {
            return cb(null, null);
          }
          return;
        }
        _next(ctx, cb);
      });
    }
  }
  /*!
   * ignore
   */
  function _onNext(error, doc) {
    if (error) {
      return this.callback(error);
    }
    if (!doc) {
      this.ctx._batchExhausted = true;
      return _populateBatch.call(this);
    }
    this.ctx._batchDocs.push(doc);
    if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
      immediate(() => this.ctx.cursor.next().then((res) => {
        _onNext.call(this, null, res);
      }, (err2) => {
        _onNext.call(this, err2);
      }));
    } else {
      _populateBatch.call(this);
    }
  }
  /*!
   * ignore
   */
  function _populateBatch() {
    if (!this.ctx._batchDocs.length) {
      return this.callback(null, null);
    }
    this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(() => {
      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);
    }, (err2) => {
      this.callback(err2);
    });
  }
  /*!
   * ignore
   */
  function _nextDoc(ctx, doc, pop, callback) {
    if (ctx.query._mongooseOptions.lean) {
      return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err2) => {
        if (err2 != null) {
          return callback(err2);
        }
        callback(null, doc);
      });
    }
    const { model, _fields, _userProvidedFields, options } = ctx.query;
    helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err2, doc2) => {
      if (err2 != null) {
        return callback(err2);
      }
      ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err3) => {
        if (err3 != null) {
          return callback(err3);
        }
        callback(null, doc2);
      });
    });
  }
  /*!
   * ignore
   */
  function _waitForCursor(ctx, cb) {
    if (ctx.cursor) {
      return cb();
    }
    ctx.once("cursor", function(cursor) {
      if (cursor == null) {
        return;
      }
      cb();
    });
  }
  module.exports = QueryCursor;
});

// node_modules/mongoose/lib/helpers/query/applyGlobalOption.js
var require_applyGlobalOption = __commonJS((exports, module) => {
  var utils = require_utils3();
  function applyGlobalMaxTimeMS(options, connectionOptions, baseOptions) {
    applyGlobalOption(options, connectionOptions, baseOptions, "maxTimeMS");
  }
  function applyGlobalDiskUse(options, connectionOptions, baseOptions) {
    applyGlobalOption(options, connectionOptions, baseOptions, "allowDiskUse");
  }
  module.exports = {
    applyGlobalMaxTimeMS,
    applyGlobalDiskUse
  };
  function applyGlobalOption(options, connectionOptions, baseOptions, optionName) {
    if (utils.hasUserDefinedProperty(options, optionName)) {
      return;
    }
    if (utils.hasUserDefinedProperty(connectionOptions, optionName)) {
      options[optionName] = connectionOptions[optionName];
    } else if (utils.hasUserDefinedProperty(baseOptions, optionName)) {
      options[optionName] = baseOptions[optionName];
    }
  }
});

// node_modules/mongoose/lib/helpers/schema/applyReadConcern.js
var require_applyReadConcern = __commonJS((exports, module) => {
  module.exports = function applyReadConcern(schema, options) {
    if (options.readConcern !== undefined) {
      return;
    }
    if (options && options.session && options.session.transaction) {
      return;
    }
    const level = schema.options?.readConcern?.level;
    if (level != null) {
      options.readConcern = { level };
    }
  };
});

// node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS((exports, module) => {
  module.exports = function applyWriteConcern(schema, options) {
    if (options.writeConcern != null) {
      return;
    }
    if (options && options.session && options.session.transaction) {
      return;
    }
    const writeConcern = schema.options.writeConcern ?? {};
    if (Object.keys(writeConcern).length != 0) {
      options.writeConcern = {};
      if (!("w" in options) && writeConcern.w != null) {
        options.writeConcern.w = writeConcern.w;
      }
      if (!("j" in options) && writeConcern.j != null) {
        options.writeConcern.j = writeConcern.j;
      }
      if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
        options.writeConcern.wtimeout = writeConcern.wtimeout;
      }
    } else {
      if (!("w" in options) && writeConcern.w != null) {
        options.w = writeConcern.w;
      }
      if (!("j" in options) && writeConcern.j != null) {
        options.j = writeConcern.j;
      }
      if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
        options.wtimeout = writeConcern.wtimeout;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS((exports, module) => {
  var isOperator = require_isOperator();
  module.exports = function castFilterPath(ctx, schematype, val) {
    const any$conditionals = Object.keys(val).some(isOperator);
    if (!any$conditionals) {
      return schematype.castForQuery(null, val, ctx);
    }
    const ks = Object.keys(val);
    let k = ks.length;
    while (k--) {
      const $cond = ks[k];
      const nested = val[$cond];
      if ($cond === "$not") {
        if (nested && schematype && !schematype.caster) {
          const _keys = Object.keys(nested);
          if (_keys.length && isOperator(_keys[0])) {
            for (const key of Object.keys(nested)) {
              nested[key] = schematype.castForQuery(key, nested[key], ctx);
            }
          } else {
            val[$cond] = schematype.castForQuery($cond, nested, ctx);
          }
          continue;
        }
      } else {
        val[$cond] = schematype.castForQuery($cond, nested, ctx);
      }
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS((exports, module) => {
  var numberRE = /^\d+$/;
  module.exports = function getPath(schema, path, discriminatorValueMap) {
    let schematype = schema.path(path);
    if (schematype != null) {
      return schematype;
    }
    const pieces = path.split(".");
    let cur = "";
    let isArray = false;
    for (const piece of pieces) {
      if (isArray && numberRE.test(piece)) {
        continue;
      }
      cur = cur.length === 0 ? piece : cur + "." + piece;
      schematype = schema.path(cur);
      if (schematype != null && schematype.schema) {
        schema = schematype.schema;
        if (!isArray && schematype.$isMongooseDocumentArray) {
          isArray = true;
        }
        if (discriminatorValueMap && discriminatorValueMap[cur]) {
          schema = schema.discriminators[discriminatorValueMap[cur]] ?? schema;
        }
        cur = "";
      }
    }
    return schematype;
  };
});

// node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS((exports, module) => {
  var castFilterPath = require_castFilterPath();
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var getPath = require_getPath();
  var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
  module.exports = function castArrayFilters(query) {
    const arrayFilters = query.options.arrayFilters;
    const update = query.getUpdate();
    const schema = query.schema;
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    let strictQuery = schema.options.strict;
    if (query._mongooseOptions.strict != null) {
      strictQuery = query._mongooseOptions.strict;
    }
    if (query.model && query.model.base.options.strictQuery != null) {
      strictQuery = query.model.base.options.strictQuery;
    }
    if (schema._userProvidedOptions.strictQuery != null) {
      strictQuery = schema._userProvidedOptions.strictQuery;
    }
    if (query._mongooseOptions.strictQuery != null) {
      strictQuery = query._mongooseOptions.strictQuery;
    }
    _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);
  };
  function _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {
    if (!Array.isArray(arrayFilters)) {
      return;
    }
    const discriminatorValueMap = {};
    for (const filter of arrayFilters) {
      if (filter == null) {
        throw new Error(`Got null array filter in ${arrayFilters}`);
      }
      const keys = Object.keys(filter).filter((key) => filter[key] != null);
      if (keys.length === 0) {
        continue;
      }
      const firstKey = keys[0];
      if (firstKey === "$and" || firstKey === "$or") {
        for (const key of keys) {
          _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);
        }
        continue;
      }
      const dot = firstKey.indexOf(".");
      const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);
      if (updatedPathsByFilter[filterWildcardPath] == null) {
        continue;
      }
      const baseFilterPath = cleanPositionalOperators(updatedPathsByFilter[filterWildcardPath]);
      const baseSchematype = getPath(schema, baseFilterPath, discriminatorValueMap);
      let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;
      if (filterBaseSchema != null && filterBaseSchema.discriminators != null && filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]) {
        filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;
        discriminatorValueMap[baseFilterPath] = filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey];
      }
      for (const key of keys) {
        if (updatedPathsByFilter[key] === null) {
          continue;
        }
        if (Object.keys(updatedPathsByFilter).length === 0) {
          continue;
        }
        const dot2 = key.indexOf(".");
        let filterPathRelativeToBase = dot2 === -1 ? null : key.substring(dot2);
        let schematype;
        if (filterPathRelativeToBase == null || filterBaseSchema == null) {
          schematype = baseSchematype;
        } else {
          filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);
          schematype = getPath(filterBaseSchema, filterPathRelativeToBase, discriminatorValueMap);
        }
        if (schematype == null) {
          if (!strictQuery) {
            return;
          }
          const filterPath = filterPathRelativeToBase == null ? baseFilterPath + ".0" : baseFilterPath + ".0" + filterPathRelativeToBase;
          throw new Error(`Could not find path "${filterPath}" in schema`);
        }
        if (typeof filter[key] === "object") {
          filter[key] = castFilterPath(query, schematype, filter[key]);
        } else {
          filter[key] = schematype.castForQuery(null, filter[key]);
        }
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  var isPOJO = require_isPOJO();
  /*!
   * ignore
   */
  module.exports = function isInclusive(projection) {
    if (projection == null) {
      return false;
    }
    const props = Object.keys(projection);
    const numProps = props.length;
    if (numProps === 0) {
      return false;
    }
    for (let i = 0;i < numProps; ++i) {
      const prop = props[i];
      if (prop.startsWith("+")) {
        continue;
      }
      if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
        if (isPOJO(projection[prop])) {
          return isInclusive(projection[prop]);
        } else {
          return !!projection[prop];
        }
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/projection/isSubpath.js
var require_isSubpath = __commonJS((exports, module) => {
  module.exports = function isSubpath(path1, path2) {
    return path1 === path2 || path2.startsWith(path1 + ".");
  };
});

// node_modules/mquery/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  /*!
   * Module dependencies.
   */
  var specialProperties = ["__proto__", "constructor", "prototype"];
  var clone2 = exports.clone = function clone(obj, options) {
    if (obj === undefined || obj === null)
      return obj;
    if (Array.isArray(obj))
      return exports.cloneArray(obj, options);
    if (obj.constructor) {
      if (/ObjectI[dD]$/.test(obj.constructor.name)) {
        return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.id);
      }
      if (obj.constructor.name === "ReadPreference") {
        return new obj.constructor(obj.mode, clone(obj.tags, options));
      }
      if (obj._bsontype == "Binary" && obj.buffer && obj.value) {
        return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
      }
      if (obj.constructor.name === "Date" || obj.constructor.name === "Function")
        return new obj.constructor(+obj);
      if (obj.constructor.name === "RegExp")
        return new RegExp(obj);
      if (obj.constructor.name === "Buffer")
        return Buffer.from(obj);
    }
    if (isObject2(obj))
      return exports.cloneObject(obj, options);
    if (obj.valueOf)
      return obj.valueOf();
  };
  /*!
   * ignore
   */
  exports.cloneObject = function cloneObject(obj, options) {
    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;
    let hasKeys = false, val, k = "", i = 0;
    for (i = 0;i < len; ++i) {
      k = keys[i];
      if (specialProperties.indexOf(k) !== -1) {
        continue;
      }
      val = clone2(obj[k], options);
      if (!minimize || typeof val !== "undefined") {
        hasKeys || (hasKeys = true);
        ret[k] = val;
      }
    }
    return minimize ? hasKeys && ret : ret;
  };
  exports.cloneArray = function cloneArray(arr, options) {
    const ret = [], l2 = arr.length;
    let i = 0;
    for (;i < l2; i++)
      ret.push(clone2(arr[i], options));
    return ret;
  };
  exports.merge = function merge(to, from) {
    const keys = Object.keys(from);
    for (const key of keys) {
      if (specialProperties.indexOf(key) !== -1) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = from[key];
      } else {
        if (exports.isObject(from[key])) {
          merge(to[key], from[key]);
        } else {
          to[key] = from[key];
        }
      }
    }
  };
  exports.mergeClone = function mergeClone(to, from) {
    const keys = Object.keys(from);
    for (const key of keys) {
      if (specialProperties.indexOf(key) !== -1) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = clone2(from[key]);
      } else {
        if (exports.isObject(from[key])) {
          mergeClone(to[key], from[key]);
        } else {
          to[key] = clone2(from[key]);
        }
      }
    }
  };
  exports.readPref = function readPref(pref) {
    switch (pref) {
      case "p":
        pref = "primary";
        break;
      case "pp":
        pref = "primaryPreferred";
        break;
      case "s":
        pref = "secondary";
        break;
      case "sp":
        pref = "secondaryPreferred";
        break;
      case "n":
        pref = "nearest";
        break;
    }
    return pref;
  };
  exports.readConcern = function readConcern(concern) {
    if (typeof concern === "string") {
      switch (concern) {
        case "l":
          concern = "local";
          break;
        case "a":
          concern = "available";
          break;
        case "m":
          concern = "majority";
          break;
        case "lz":
          concern = "linearizable";
          break;
        case "s":
          concern = "snapshot";
          break;
      }
      concern = { level: concern };
    }
    return concern;
  };
  var _toString = Object.prototype.toString;
  exports.toString = function(arg) {
    return _toString.call(arg);
  };
  var isObject2 = exports.isObject = function(arg) {
    return exports.toString(arg) == "[object Object]";
  };
  exports.keys = Object.keys;
  exports.create = typeof Object.create == "function" ? Object.create : create2;
  function create2(proto) {
    if (arguments.length > 1) {
      throw new Error("Adding properties is not supported");
    }
    function F() {
    }
    F.prototype = proto;
    return new F;
  }
  exports.inherits = function(ctor, superCtor) {
    ctor.prototype = exports.create(superCtor.prototype);
    ctor.prototype.constructor = ctor;
  };
  exports.isArgumentsObject = function(v) {
    return Object.prototype.toString.call(v) === "[object Arguments]";
  };
});

// node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS((exports) => {
  var denied = exports;
  denied.distinct = function(self2) {
    if (self2._fields && Object.keys(self2._fields).length > 0) {
      return "field selection and slice";
    }
    const keys = Object.keys(denied.distinct);
    let err2;
    keys.every(function(option) {
      if (self2.options[option]) {
        err2 = option;
        return false;
      }
      return true;
    });
    return err2;
  };
  denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.hint = denied.distinct.tailable = true;
  denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
    const keys = Object.keys(denied.findOneAndUpdate);
    let err2;
    keys.every(function(option) {
      if (self2.options[option]) {
        err2 = option;
        return false;
      }
      return true;
    });
    return err2;
  };
  denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.tailable = true;
  denied.count = function(self2) {
    if (self2._fields && Object.keys(self2._fields).length > 0) {
      return "field selection and slice";
    }
    const keys = Object.keys(denied.count);
    let err2;
    keys.every(function(option) {
      if (self2.options[option]) {
        err2 = option;
        return false;
      }
      return true;
    });
    return err2;
  };
  denied.count.slice = denied.count.batchSize = denied.count.tailable = true;
});

// node_modules/mquery/lib/env.js
var require_env = __commonJS((exports, module) => {
  exports.isNode = typeof process != "undefined" && typeof module == "object" && typeof global == "object" && typeof Buffer == "function" && process.argv;
  exports.isMongo = !exports.isNode && typeof printjson == "function" && typeof ObjectId == "function" && typeof rs == "function" && typeof sh == "function";
  exports.isBrowser = !exports.isNode && !exports.isMongo && typeof window != "undefined";
  exports.type = exports.isNode ? "node" : exports.isMongo ? "mongo" : exports.isBrowser ? "browser" : "unknown";
});

// node_modules/mquery/lib/collection/collection.js
var require_collection4 = __commonJS((exports, module) => {
  var methods = [
    "find",
    "findOne",
    "updateMany",
    "updateOne",
    "replaceOne",
    "count",
    "distinct",
    "findOneAndDelete",
    "findOneAndUpdate",
    "aggregate",
    "findCursor",
    "deleteOne",
    "deleteMany"
  ];
  function Collection() {
  }
  for (let i = 0, len = methods.length;i < len; ++i) {
    const method = methods[i];
    Collection.prototype[method] = notImplemented(method);
  }
  module.exports = exports = Collection;
  Collection.methods = methods;
  function notImplemented(method) {
    return function() {
      throw new Error("collection." + method + " not implemented");
    };
  }
});

// node_modules/mquery/lib/collection/node.js
var require_node3 = __commonJS((exports, module) => {
  var Collection = require_collection4();

  class NodeCollection extends Collection {
    constructor(col) {
      super();
      this.collection = col;
      this.collectionName = col.collectionName;
    }
    async find(match, options) {
      const cursor = this.collection.find(match, options);
      return cursor.toArray();
    }
    async findOne(match, options) {
      return this.collection.findOne(match, options);
    }
    async count(match, options) {
      return this.collection.count(match, options);
    }
    async distinct(prop, match, options) {
      return this.collection.distinct(prop, match, options);
    }
    async updateMany(match, update, options) {
      return this.collection.updateMany(match, update, options);
    }
    async updateOne(match, update, options) {
      return this.collection.updateOne(match, update, options);
    }
    async replaceOne(match, update, options) {
      return this.collection.replaceOne(match, update, options);
    }
    async deleteOne(match, options) {
      return this.collection.deleteOne(match, options);
    }
    async deleteMany(match, options) {
      return this.collection.deleteMany(match, options);
    }
    async findOneAndDelete(match, options) {
      return this.collection.findOneAndDelete(match, options);
    }
    async findOneAndUpdate(match, update, options) {
      return this.collection.findOneAndUpdate(match, update, options);
    }
    findCursor(match, options) {
      return this.collection.find(match, options);
    }
  }
  module.exports = exports = NodeCollection;
});

// node_modules/mquery/lib/collection/index.js
var require_collection5 = __commonJS((exports, module) => {
  var env3 = require_env();
  if (env3.type == "unknown") {
    throw new Error("Unknown environment");
  }
  module.exports = env3.isNode ? require_node3() : env3.isMongo ? require_collection4() : require_collection4();
});

// node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS((exports, module) => {
  var assert2 = __require("assert");
  var util3 = __require("util");
  var utils = require_utils4();
  var debug2 = require_src()("mquery");
  function Query(criteria, options) {
    if (!(this instanceof Query))
      return new Query(criteria, options);
    const proto = this.constructor.prototype;
    this.op = proto.op || undefined;
    this.options = Object.assign({}, proto.options);
    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};
    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;
    this._updateDoc = proto._updateDoc ? utils.clone(proto._updateDoc) : undefined;
    this._path = proto._path || undefined;
    this._distinctDoc = proto._distinctDoc || undefined;
    this._collection = proto._collection || undefined;
    this._traceFunction = proto._traceFunction || undefined;
    if (options) {
      this.setOptions(options);
    }
    if (criteria) {
      this.find(criteria);
    }
  }
  var $withinCmd = "$geoWithin";
  Object.defineProperty(Query, "use$geoWithin", {
    get: function() {
      return $withinCmd == "$geoWithin";
    },
    set: function(v) {
      if (v === true) {
        $withinCmd = "$geoWithin";
      } else {
        $withinCmd = "$within";
      }
    }
  });
  Query.prototype.toConstructor = function toConstructor() {
    function CustomQuery(criteria, options) {
      if (!(this instanceof CustomQuery))
        return new CustomQuery(criteria, options);
      Query.call(this, criteria, options);
    }
    utils.inherits(CustomQuery, Query);
    const p = CustomQuery.prototype;
    p.options = {};
    p.setOptions(this.options);
    p.op = this.op;
    p._conditions = utils.clone(this._conditions);
    p._fields = utils.clone(this._fields);
    p._updateDoc = utils.clone(this._updateDoc);
    p._path = this._path;
    p._distinctDoc = this._distinctDoc;
    p._collection = this._collection;
    p._traceFunction = this._traceFunction;
    return CustomQuery;
  };
  Query.prototype.setOptions = function(options) {
    if (!(options && utils.isObject(options)))
      return this;
    const methods = utils.keys(options);
    let method;
    for (let i = 0;i < methods.length; ++i) {
      method = methods[i];
      if (typeof this[method] == "function") {
        const args = Array.isArray(options[method]) ? options[method] : [options[method]];
        this[method].apply(this, args);
      } else {
        this.options[method] = options[method];
      }
    }
    return this;
  };
  Query.prototype.collection = function collection(coll) {
    this._collection = new Query.Collection(coll);
    return this;
  };
  Query.prototype.collation = function(value) {
    this.options.collation = value;
    return this;
  };
  Query.prototype.$where = function(js) {
    this._conditions.$where = js;
    return this;
  };
  Query.prototype.where = function() {
    if (!arguments.length)
      return this;
    if (!this.op)
      this.op = "find";
    const type = typeof arguments[0];
    if (type == "string") {
      this._path = arguments[0];
      if (arguments.length === 2) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if (type == "object" && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw new TypeError("path must be a string or object");
  };
  Query.prototype.equals = function equals(val) {
    this._ensurePath("equals");
    const path = this._path;
    this._conditions[path] = val;
    return this;
  };
  Query.prototype.eq = function eq(val) {
    this._ensurePath("eq");
    const path = this._path;
    this._conditions[path] = val;
    return this;
  };
  Query.prototype.or = function or(array) {
    const or = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array))
      array = [array];
    or.push.apply(or, array);
    return this;
  };
  Query.prototype.nor = function nor(array) {
    const nor = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array))
      array = [array];
    nor.push.apply(nor, array);
    return this;
  };
  Query.prototype.and = function and(array) {
    const and = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array))
      array = [array];
    and.push.apply(and, array);
    return this;
  };
  /*!
   * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
   *
   *     Thing.where('type').nin(array)
   */
  "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
    Query.prototype[$conditional] = function() {
      let path, val;
      if (arguments.length === 1) {
        this._ensurePath($conditional);
        val = arguments[0];
        path = this._path;
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
      conds["$" + $conditional] = val;
      return this;
    };
  });
  Query.prototype.mod = function() {
    let val, path;
    if (arguments.length === 1) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = [arguments[0], arguments[1]];
      path = this._path;
    } else if (arguments.length === 3) {
      val = [arguments[1], arguments[2]];
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  Query.prototype.exists = function() {
    let path, val;
    if (arguments.length === 0) {
      this._ensurePath("exists");
      path = this._path;
      val = true;
    } else if (arguments.length === 1) {
      if (typeof arguments[0] === "boolean") {
        this._ensurePath("exists");
        path = this._path;
        val = arguments[0];
      } else {
        path = arguments[0];
        val = true;
      }
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
  };
  Query.prototype.elemMatch = function() {
    if (arguments[0] == null)
      throw new TypeError("Invalid argument");
    let fn, path, criteria;
    if (typeof arguments[0] === "function") {
      this._ensurePath("elemMatch");
      path = this._path;
      fn = arguments[0];
    } else if (utils.isObject(arguments[0])) {
      this._ensurePath("elemMatch");
      path = this._path;
      criteria = arguments[0];
    } else if (typeof arguments[1] === "function") {
      path = arguments[0];
      fn = arguments[1];
    } else if (arguments[1] && utils.isObject(arguments[1])) {
      path = arguments[0];
      criteria = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (fn) {
      criteria = new Query;
      fn(criteria);
      criteria = criteria._conditions;
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  Query.prototype.within = function within() {
    this._ensurePath("within");
    this._geoComparison = $withinCmd;
    if (arguments.length === 0) {
      return this;
    }
    if (arguments.length === 2) {
      return this.box.apply(this, arguments);
    } else if (2 < arguments.length) {
      return this.polygon.apply(this, arguments);
    }
    const area = arguments[0];
    if (!area)
      throw new TypeError("Invalid argument");
    if (area.center)
      return this.circle(area);
    if (area.box)
      return this.box.apply(this, area.box);
    if (area.polygon)
      return this.polygon.apply(this, area.polygon);
    if (area.type && area.coordinates)
      return this.geometry(area);
    throw new TypeError("Invalid argument");
  };
  Query.prototype.box = function() {
    let path, box;
    if (arguments.length === 3) {
      path = arguments[0];
      box = [arguments[1], arguments[2]];
    } else if (arguments.length === 2) {
      this._ensurePath("box");
      path = this._path;
      box = [arguments[0], arguments[1]];
    } else {
      throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = { $box: box };
    return this;
  };
  Query.prototype.polygon = function() {
    let val, path;
    if (typeof arguments[0] == "string") {
      val = Array.from(arguments);
      path = val.shift();
    } else {
      this._ensurePath("polygon");
      path = this._path;
      val = Array.from(arguments);
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = { $polygon: val };
    return this;
  };
  Query.prototype.circle = function() {
    let path, val;
    if (arguments.length === 1) {
      this._ensurePath("circle");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!(("radius" in val) && val.center))
      throw new Error("center and radius are required");
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$centerSphere" : "$center";
    const wKey = this._geoComparison || $withinCmd;
    conds[wKey] = {};
    conds[wKey][type] = [val.center, val.radius];
    if ("unique" in val)
      conds[wKey].$uniqueDocs = !!val.unique;
    return this;
  };
  Query.prototype.near = function near() {
    let path, val;
    this._geoComparison = "$near";
    if (arguments.length === 0) {
      return this;
    } else if (arguments.length === 1) {
      this._ensurePath("near");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!val.center) {
      throw new Error("center is required");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$nearSphere" : "$near";
    if (Array.isArray(val.center)) {
      conds[type] = val.center;
      const radius = "maxDistance" in val ? val.maxDistance : null;
      if (radius != null) {
        conds.$maxDistance = radius;
      }
      if (val.minDistance != null) {
        conds.$minDistance = val.minDistance;
      }
    } else {
      if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
        throw new Error(util3.format("Invalid GeoJSON specified for %s", type));
      }
      conds[type] = { $geometry: val.center };
      if ("maxDistance" in val) {
        conds[type]["$maxDistance"] = val.maxDistance;
      }
      if ("minDistance" in val) {
        conds[type]["$minDistance"] = val.minDistance;
      }
    }
    return this;
  };
  Query.prototype.intersects = function intersects() {
    this._ensurePath("intersects");
    this._geoComparison = "$geoIntersects";
    if (arguments.length === 0) {
      return this;
    }
    const area = arguments[0];
    if (area != null && area.type && area.coordinates)
      return this.geometry(area);
    throw new TypeError("Invalid argument");
  };
  Query.prototype.geometry = function geometry() {
    if (!(this._geoComparison == "$within" || this._geoComparison == "$geoWithin" || this._geoComparison == "$near" || this._geoComparison == "$geoIntersects")) {
      throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
    }
    let val, path;
    if (arguments.length === 1) {
      this._ensurePath("geometry");
      path = this._path;
      val = arguments[0];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!(val.type && Array.isArray(val.coordinates))) {
      throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison] = { $geometry: val };
    return this;
  };
  Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg)
      return this;
    if (arguments.length !== 1) {
      throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const type = typeof arg;
    let i, len;
    if ((type == "string" || utils.isArgumentsObject(arg)) && typeof arg.length == "number" || Array.isArray(arg)) {
      if (type == "string")
        arg = arg.split(/\s+/);
      for (i = 0, len = arg.length;i < len; ++i) {
        let field = arg[i];
        if (!field)
          continue;
        const include = field[0] == "-" ? 0 : 1;
        if (include === 0)
          field = field.substring(1);
        fields[field] = include;
      }
      return this;
    }
    if (utils.isObject(arg)) {
      const keys = utils.keys(arg);
      for (i = 0;i < keys.length; ++i) {
        fields[keys[i]] = arg[keys[i]];
      }
      return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
  };
  Query.prototype.slice = function() {
    if (arguments.length === 0)
      return this;
    this._validate("slice");
    let path, val;
    if (arguments.length === 1) {
      const arg = arguments[0];
      if (typeof arg === "object" && !Array.isArray(arg)) {
        const keys = Object.keys(arg);
        const numKeys = keys.length;
        for (let i = 0;i < numKeys; ++i) {
          this.slice(keys[i], arg[keys[i]]);
        }
        return this;
      }
      this._ensurePath("slice");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        this._ensurePath("slice");
        path = this._path;
        val = [arguments[0], arguments[1]];
      } else {
        path = arguments[0];
        val = arguments[1];
      }
    } else if (arguments.length === 3) {
      path = arguments[0];
      val = [arguments[1], arguments[2]];
    }
    const myFields = this._fields || (this._fields = {});
    myFields[path] = { $slice: val };
    return this;
  };
  Query.prototype.sort = function(arg) {
    if (!arg)
      return this;
    let i, len, field;
    this._validate("sort");
    const type = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (i = 0;i < arg.length; ++i) {
        if (!Array.isArray(arg[i])) {
          throw new Error("Invalid sort() argument, must be array of arrays");
        }
        _pushArr(this.options, arg[i][0], arg[i][1]);
      }
      return this;
    }
    if (arguments.length === 1 && type == "string") {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (i = 0;i < len; ++i) {
        field = arg[i];
        if (!field)
          continue;
        const ascend = field[0] == "-" ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if (utils.isObject(arg)) {
      const keys = utils.keys(arg);
      for (i = 0;i < keys.length; ++i) {
        field = keys[i];
        push(this.options, field, arg[field]);
      }
      return this;
    }
    if (typeof Map !== "undefined" && arg instanceof Map) {
      _pushMap(this.options, arg);
      return this;
    }
    throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
  };
  /*!
   * @ignore
   */
  var _validSortValue = {
    1: 1,
    "-1": -1,
    asc: 1,
    ascending: 1,
    desc: -1,
    descending: -1
  };
  function push(opts, field, value) {
    if (Array.isArray(opts.sort)) {
      throw new TypeError("Can't mix sort syntaxes. Use either array or object:" + "\n- `.sort([['field', 1], ['test', -1]])`" + "\n- `.sort({ field: 1, test: -1 })`");
    }
    let s;
    if (value && value.$meta) {
      s = opts.sort || (opts.sort = {});
      s[field] = { $meta: value.$meta };
      return;
    }
    s = opts.sort || (opts.sort = {});
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val)
      throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
    s[field] = val;
  }
  function _pushArr(opts, field, value) {
    opts.sort = opts.sort || [];
    if (!Array.isArray(opts.sort)) {
      throw new TypeError("Can't mix sort syntaxes. Use either array or object:" + "\n- `.sort([['field', 1], ['test', -1]])`" + "\n- `.sort({ field: 1, test: -1 })`");
    }
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val)
      throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
    opts.sort.push([field, val]);
  }
  function _pushMap(opts, map3) {
    opts.sort = opts.sort || new Map;
    if (!(opts.sort instanceof Map)) {
      throw new TypeError("Can't mix sort syntaxes. Use either array or " + "object or map consistently");
    }
    map3.forEach(function(value, key) {
      let val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
      opts.sort.set(key, val);
    });
  }
  /*!
   * limit, skip, batchSize, comment
   *
   * Sets these associated options.
   *
   *     query.comment('feed query');
   */
  ["limit", "skip", "batchSize", "comment"].forEach(function(method) {
    Query.prototype[method] = function(v) {
      this._validate(method);
      this.options[method] = v;
      return this;
    };
  });
  Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
    this._validate("maxTime");
    this.options.maxTimeMS = ms;
    return this;
  };
  Query.prototype.hint = function() {
    if (arguments.length === 0)
      return this;
    this._validate("hint");
    const arg = arguments[0];
    if (utils.isObject(arg)) {
      const hint = this.options.hint || (this.options.hint = {});
      for (const k in arg) {
        hint[k] = arg[k];
      }
      return this;
    }
    if (typeof arg === "string") {
      this.options.hint = arg;
      return this;
    }
    throw new TypeError("Invalid hint. " + arg);
  };
  Query.prototype.j = function j(val) {
    this.options.j = val;
    return this;
  };
  Query.prototype.slaveOk = function(v) {
    this.options.slaveOk = arguments.length ? !!v : true;
    return this;
  };
  Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
      console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
      Query.prototype.read.deprecationWarningIssued = true;
    }
    this.options.readPreference = utils.readPref(pref);
    return this;
  };
  Query.prototype.readConcern = Query.prototype.r = function(level) {
    this.options.readConcern = utils.readConcern(level);
    return this;
  };
  Query.prototype.tailable = function() {
    this._validate("tailable");
    this.options.tailable = arguments.length ? !!arguments[0] : true;
    return this;
  };
  Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
    if (typeof concern === "object") {
      if (typeof concern.j !== "undefined")
        this.options.j = concern.j;
      if (typeof concern.w !== "undefined")
        this.options.w = concern.w;
      if (typeof concern.wtimeout !== "undefined")
        this.options.wtimeout = concern.wtimeout;
    } else {
      this.options.w = concern === "m" ? "majority" : concern;
    }
    return this;
  };
  Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
    this.options.wtimeout = ms;
    return this;
  };
  Query.prototype.merge = function(source) {
    if (!source)
      return this;
    if (!Query.canMerge(source))
      throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
    if (source instanceof Query) {
      if (source._conditions) {
        utils.merge(this._conditions, source._conditions);
      }
      if (source._fields) {
        this._fields || (this._fields = {});
        utils.merge(this._fields, source._fields);
      }
      if (source.options) {
        this.options || (this.options = {});
        utils.merge(this.options, source.options);
      }
      if (source._updateDoc) {
        this._updateDoc || (this._updateDoc = {});
        utils.mergeClone(this._updateDoc, source._updateDoc);
      }
      if (source._distinctDoc) {
        this._distinctDoc = source._distinctDoc;
      }
      return this;
    }
    utils.merge(this._conditions, source);
    return this;
  };
  Query.prototype.find = function(criteria) {
    this.op = "find";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._find = async function _find() {
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug2("_find", this._collection.collectionName, conds, options);
    return this._collection.find(conds, options);
  };
  Query.prototype.cursor = function cursor(criteria) {
    if (this.op) {
      if (this.op !== "find") {
        throw new TypeError(".cursor only support .find method");
      }
    } else {
      this.find(criteria);
    }
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug2("findCursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
  };
  Query.prototype.findOne = function(criteria) {
    this.op = "findOne";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._findOne = async function _findOne() {
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug2("findOne", this._collection.collectionName, conds, options);
    return this._collection.findOne(conds, options);
  };
  Query.prototype.count = function(criteria) {
    this.op = "count";
    this._validate();
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._count = async function _count() {
    const conds = this._conditions, options = this._optionsForExec();
    debug2("count", this._collection.collectionName, conds, options);
    return this._collection.count(conds, options);
  };
  Query.prototype.distinct = function(criteria, field) {
    this.op = "distinct";
    this._validate();
    if (!field && typeof criteria === "string") {
      field = criteria;
      criteria = undefined;
    }
    if (typeof field == "string") {
      this._distinctDoc = field;
    }
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._distinct = async function _distinct() {
    if (!this._distinctDoc) {
      throw new Error("No value for `distinct` has been declared");
    }
    const conds = this._conditions, options = this._optionsForExec();
    debug2("distinct", this._collection.collectionName, conds, options);
    return this._collection.distinct(this._distinctDoc, conds, options);
  };
  Query.prototype.updateMany = function updateMany(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    return _update(this, "updateMany", criteria, doc, options);
  };
  Query.prototype._updateMany = async function() {
    return _updateExec(this, "updateMany");
  };
  Query.prototype.updateOne = function updateOne(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    return _update(this, "updateOne", criteria, doc, options);
  };
  Query.prototype._updateOne = async function() {
    return _updateExec(this, "updateOne");
  };
  Query.prototype.replaceOne = function replaceOne(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    this.setOptions({ overwrite: true });
    return _update(this, "replaceOne", criteria, doc, options);
  };
  Query.prototype._replaceOne = async function() {
    return _updateExec(this, "replaceOne");
  };
  /*!
   * Internal helper for updateMany, updateOne
   */
  function _update(query, op, criteria, doc, options) {
    query.op = op;
    if (Query.canMerge(criteria)) {
      query.merge(criteria);
    }
    if (doc) {
      query._mergeUpdate(doc);
    }
    if (utils.isObject(options)) {
      query.setOptions(options);
    }
    return query;
  }
  async function _updateExec(query, op) {
    const options = query._optionsForExec();
    const criteria = query._conditions;
    const doc = query._updateForExec();
    debug2("update", query._collection.collectionName, criteria, doc, options);
    return query._collection[op](criteria, doc, options);
  }
  Query.prototype.deleteOne = function(criteria) {
    this.op = "deleteOne";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._deleteOne = async function() {
    const options = this._optionsForExec();
    delete options.justOne;
    const conds = this._conditions;
    debug2("deleteOne", this._collection.collectionName, conds, options);
    return this._collection.deleteOne(conds, options);
  };
  Query.prototype.deleteMany = function(criteria) {
    this.op = "deleteMany";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._deleteMany = async function() {
    const options = this._optionsForExec();
    delete options.justOne;
    const conds = this._conditions;
    debug2("deleteOne", this._collection.collectionName, conds, options);
    return this._collection.deleteMany(conds, options);
  };
  Query.prototype.findOneAndUpdate = function(criteria, doc, options) {
    this.op = "findOneAndUpdate";
    this._validate();
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    if (doc) {
      this._mergeUpdate(doc);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndUpdate = async function() {
    const conds = this._conditions;
    const update = this._updateForExec();
    const options = this._optionsForExec();
    return this._collection.findOneAndUpdate(conds, update, options);
  };
  Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {
    this.op = "findOneAndRemove";
    this._validate();
    if (Query.canMerge(conditions)) {
      this.merge(conditions);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndRemove = async function() {
    const options = this._optionsForExec();
    const conds = this._conditions;
    return this._collection.findOneAndDelete(conds, options);
  };
  Query.prototype.setTraceFunction = function(traceFunction) {
    this._traceFunction = traceFunction;
    return this;
  };
  Query.prototype.exec = async function exec(op) {
    if (typeof op === "string") {
      this.op = op;
    }
    assert2.ok(this.op, "Missing query type: (find, etc)");
    const fnName = "_" + this.op;
    if (typeof this[fnName] !== "function") {
      throw new TypeError(`this[${fnName}] is not a function`);
    }
    return this[fnName]();
  };
  Query.prototype.then = async function(res, rej) {
    return this.exec().then(res, rej);
  };
  Query.prototype.cursor = function() {
    if (this.op != "find")
      throw new Error("cursor() is only available for find");
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug2("cursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
  };
  Query.prototype.selected = function selected() {
    return !!(this._fields && Object.keys(this._fields).length > 0);
  };
  Query.prototype.selectedInclusively = function selectedInclusively() {
    if (!this._fields)
      return false;
    const keys = Object.keys(this._fields);
    if (keys.length === 0)
      return false;
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (this._fields[key] === 0)
        return false;
      if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
        return false;
      }
    }
    return true;
  };
  Query.prototype.selectedExclusively = function selectedExclusively() {
    if (!this._fields)
      return false;
    const keys = Object.keys(this._fields);
    if (keys.length === 0)
      return false;
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (this._fields[key] === 0)
        return true;
    }
    return false;
  };
  Query.prototype._mergeUpdate = function(doc) {
    if (!this._updateDoc)
      this._updateDoc = {};
    if (doc instanceof Query) {
      if (doc._updateDoc) {
        utils.mergeClone(this._updateDoc, doc._updateDoc);
      }
    } else {
      utils.mergeClone(this._updateDoc, doc);
    }
  };
  Query.prototype._optionsForExec = function() {
    const options = utils.clone(this.options);
    return options;
  };
  Query.prototype._fieldsForExec = function() {
    return utils.clone(this._fields);
  };
  Query.prototype._updateForExec = function() {
    const update = utils.clone(this._updateDoc);
    const ops = utils.keys(update);
    const ret = {};
    for (const op of ops) {
      if (this.options.overwrite) {
        ret[op] = update[op];
        continue;
      }
      if (op[0] !== "$") {
        if (!ret.$set) {
          if (update.$set) {
            ret.$set = update.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = update[op];
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = update[op];
        }
      } else {
        ret[op] = update[op];
      }
    }
    this._compiledUpdate = ret;
    return ret;
  };
  Query.prototype._ensurePath = function(method) {
    if (!this._path) {
      const msg = method + "() must be used after where() " + "when called with these arguments";
      throw new Error(msg);
    }
  };
  /*!
   * Permissions
   */
  Query.permissions = require_permissions();
  Query._isPermitted = function(a12, b) {
    const denied = Query.permissions[b];
    if (!denied)
      return true;
    return denied[a12] !== true;
  };
  Query.prototype._validate = function(action) {
    let fail;
    let validator;
    if (action === undefined) {
      validator = Query.permissions[this.op];
      if (typeof validator != "function")
        return true;
      fail = validator(this);
    } else if (!Query._isPermitted(action, this.op)) {
      fail = action;
    }
    if (fail) {
      throw new Error(fail + " cannot be used with " + this.op);
    }
  };
  Query.canMerge = function(conds) {
    return conds instanceof Query || utils.isObject(conds);
  };
  Query.setGlobalTraceFunction = function(traceFunction) {
    Query.traceFunction = traceFunction;
  };
  /*!
   * Exports.
   */
  Query.utils = utils;
  Query.env = require_env();
  Query.Collection = require_collection5();
  Query.BaseCollection = require_collection4();
  module.exports = exports = Query;
});

// node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS((exports, module) => {
  module.exports = function parseProjection(v, retainMinusPaths) {
    const type = typeof v;
    if (type === "string") {
      v = v.split(/\s+/);
    }
    if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
      return v;
    }
    const len = v.length;
    const ret = {};
    for (let i = 0;i < len; ++i) {
      let field = v[i];
      if (!field) {
        continue;
      }
      const include = field[0] == "-" ? 0 : 1;
      if (!retainMinusPaths && include === 0) {
        field = field.substring(1);
      }
      ret[field] = include;
    }
    return ret;
  };
});

// node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS((exports, module) => {
  module.exports = function removeUnusedArrayFilters(update, arrayFilters) {
    const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
    return arrayFilters.filter((obj) => {
      return _checkSingleFilterKey(obj, updateKeys);
    });
  };
  function _checkSingleFilterKey(arrayFilter, updateKeys) {
    const firstKey = Object.keys(arrayFilter)[0];
    if (firstKey === "$and" || firstKey === "$or") {
      if (!Array.isArray(arrayFilter[firstKey])) {
        return false;
      }
      return arrayFilter[firstKey].find((filter) => _checkSingleFilterKey(filter, updateKeys)) != null;
    }
    const firstDot = firstKey.indexOf(".");
    const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
    return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
  }
});

// node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function hasDollarKeys(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      if (keys[i][0] === "$") {
        return true;
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/query/sanitizeFilter.js
var require_sanitizeFilter = __commonJS((exports, module) => {
  var hasDollarKeys = require_hasDollarKeys();
  var { trustedSymbol } = require_trusted();
  module.exports = function sanitizeFilter(filter) {
    if (filter == null || typeof filter !== "object") {
      return filter;
    }
    if (Array.isArray(filter)) {
      for (const subfilter of filter) {
        sanitizeFilter(subfilter);
      }
      return filter;
    }
    const filterKeys = Object.keys(filter);
    for (const key of filterKeys) {
      const value = filter[key];
      if (value != null && value[trustedSymbol]) {
        continue;
      }
      if (key === "$and" || key === "$or") {
        sanitizeFilter(value);
        continue;
      }
      if (hasDollarKeys(value)) {
        const keys = Object.keys(value);
        if (keys.length === 1 && keys[0] === "$eq") {
          continue;
        }
        filter[key] = { $eq: filter[key] };
      }
    }
    return filter;
  };
});

// node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS((exports, module) => {
  module.exports = function sanitizeProjection(projection) {
    if (projection == null) {
      return;
    }
    const keys = Object.keys(projection);
    for (let i = 0;i < keys.length; ++i) {
      if (typeof projection[keys[i]] === "string") {
        projection[keys[i]] = 1;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS((exports, module) => {
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  /*!
   * ignore
   */
  module.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
    if (populateOptions == null) {
      return;
    }
    const paths = Object.keys(populateOptions);
    userProvidedFields = userProvidedFields || {};
    if (isInclusive(fields)) {
      for (const path of paths) {
        if (!isPathInFields(userProvidedFields, path)) {
          fields[path] = 1;
        } else if (userProvidedFields[path] === 0) {
          delete fields[path];
        }
        const refPath = populateOptions[path]?.refPath;
        if (typeof refPath === "string") {
          if (!isPathInFields(userProvidedFields, refPath)) {
            fields[refPath] = 1;
          } else if (userProvidedFields[refPath] === 0) {
            delete fields[refPath];
          }
        }
      }
    } else if (isExclusive(fields)) {
      for (const path of paths) {
        if (userProvidedFields[path] == null) {
          delete fields[path];
        }
        const refPath = populateOptions[path]?.refPath;
        if (typeof refPath === "string" && userProvidedFields[refPath] == null) {
          delete fields[refPath];
        }
      }
    }
  };
  /*!
   * ignore
   */
  function isPathInFields(userProvidedFields, path) {
    const pieces = path.split(".");
    const len = pieces.length;
    let cur = pieces[0];
    for (let i = 1;i < len; ++i) {
      if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
        return true;
      }
      cur += "." + pieces[i];
    }
    return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
  }
});

// node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var ValidationError2 = require_validation();
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var flatten = require_common4().flatten;
  var modifiedPaths = require_common4().modifiedPaths;
  module.exports = function(query, schema, castedDoc, options, callback) {
    const keys = Object.keys(castedDoc || {});
    let updatedKeys = {};
    let updatedValues = {};
    const isPull = {};
    const arrayAtomicUpdates = {};
    const numKeys = keys.length;
    let hasDollarUpdate = false;
    const modified = {};
    let currentUpdate;
    let key;
    let i;
    for (i = 0;i < numKeys; ++i) {
      if (keys[i].startsWith("$")) {
        hasDollarUpdate = true;
        if (keys[i] === "$push" || keys[i] === "$addToSet") {
          const _keys = Object.keys(castedDoc[keys[i]]);
          for (let ii = 0;ii < _keys.length; ++ii) {
            currentUpdate = castedDoc[keys[i]][_keys[ii]];
            if (currentUpdate && currentUpdate.$each) {
              arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
            } else {
              arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
            }
          }
          continue;
        }
        modifiedPaths(castedDoc[keys[i]], "", modified);
        const flat = flatten(castedDoc[keys[i]], null, null, schema);
        const paths = Object.keys(flat);
        const numPaths = paths.length;
        for (let j = 0;j < numPaths; ++j) {
          const updatedPath = cleanPositionalOperators(paths[j]);
          key = keys[i];
          if (updatedPath.includes("$")) {
            continue;
          }
          if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
            updatedValues[updatedPath] = flat[paths[j]];
            isPull[updatedPath] = key === "$pull" || key === "$pullAll";
          } else if (key === "$unset") {
            updatedValues[updatedPath] = undefined;
          }
          updatedKeys[updatedPath] = true;
        }
      }
    }
    if (!hasDollarUpdate) {
      modifiedPaths(castedDoc, "", modified);
      updatedValues = flatten(castedDoc, null, null, schema);
      updatedKeys = Object.keys(updatedValues);
    }
    const updates = Object.keys(updatedValues);
    const numUpdates = updates.length;
    const validatorsToExecute = [];
    const validationErrors = [];
    const alreadyValidated = [];
    const context = query;
    function iter(i2, v) {
      const schemaPath = schema._getSchema(updates[i2]);
      if (schemaPath == null) {
        return;
      }
      if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
        return;
      }
      if (v && Array.isArray(v.$in)) {
        v.$in.forEach((v2, i3) => {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(v2, function(err2) {
              if (err2) {
                err2.path = updates[i3] + ".$in." + i3;
                validationErrors.push(err2);
              }
              callback2(null);
            }, context, { updateValidator: true });
          });
        });
      } else {
        if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
          return;
        }
        if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
          alreadyValidated.push(updates[i2]);
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(v, function(err2) {
              if (err2) {
                if (err2.errors) {
                  for (const key2 of Object.keys(err2.errors)) {
                    const _err = err2.errors[key2];
                    _err.path = updates[i2] + "." + key2;
                    validationErrors.push(_err);
                  }
                } else {
                  err2.path = updates[i2];
                  validationErrors.push(err2);
                }
              }
              return callback2(null);
            }, context, { updateValidator: true });
          });
        } else {
          validatorsToExecute.push(function(callback2) {
            for (const path of alreadyValidated) {
              if (updates[i2].startsWith(path + ".")) {
                return callback2(null);
              }
            }
            if (schemaPath.$isSingleNested) {
              alreadyValidated.push(updates[i2]);
            }
            schemaPath.doValidate(v, function(err2) {
              if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err2 instanceof ValidationError2) {
                return callback2(null);
              }
              if (err2) {
                err2.path = updates[i2];
                validationErrors.push(err2);
              }
              callback2(null);
            }, context, { updateValidator: true });
          });
        }
      }
    }
    for (i = 0;i < numUpdates; ++i) {
      iter(i, updatedValues[updates[i]]);
    }
    const arrayUpdates = Object.keys(arrayAtomicUpdates);
    for (const arrayUpdate of arrayUpdates) {
      let schemaPath = schema._getSchema(arrayUpdate);
      if (schemaPath && schemaPath.$isMongooseDocumentArray) {
        validatorsToExecute.push(function(callback2) {
          schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback2), options && options.context === "query" ? query : null);
        });
      } else {
        schemaPath = schema._getSchema(arrayUpdate + ".0");
        for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback2), options && options.context === "query" ? query : null, { updateValidator: true });
          });
        }
      }
    }
    if (callback != null) {
      let numValidators = validatorsToExecute.length;
      if (numValidators === 0) {
        return _done(callback);
      }
      for (const validator of validatorsToExecute) {
        validator(function() {
          if (--numValidators <= 0) {
            _done(callback);
          }
        });
      }
      return;
    }
    return function(callback2) {
      let numValidators = validatorsToExecute.length;
      if (numValidators === 0) {
        return _done(callback2);
      }
      for (const validator of validatorsToExecute) {
        validator(function() {
          if (--numValidators <= 0) {
            _done(callback2);
          }
        });
      }
    };
    function _done(callback2) {
      if (validationErrors.length) {
        const err2 = new ValidationError2(null);
        for (const validationError of validationErrors) {
          err2.addError(validationError.path, validationError);
        }
        return callback2(err2);
      }
      callback2(null);
    }
    function getValidationCallback(arrayUpdate, validationErrors2, callback2) {
      return function(err2) {
        if (err2) {
          err2.path = arrayUpdate;
          validationErrors2.push(err2);
        }
        callback2(null);
      };
    }
  };
});

// node_modules/mongoose/lib/query.js
var require_query = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var DocumentNotFoundError = require_notFound();
  var Kareem = require_kareem();
  var MongooseError = require_mongooseError();
  var ObjectParameterError = require_objectParameter();
  var QueryCursor = require_queryCursor();
  var ValidationError2 = require_validation();
  var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
  var handleReadPreferenceAliases = require_handleReadPreferenceAliases();
  var applyReadConcern = require_applyReadConcern();
  var applyWriteConcern = require_applyWriteConcern();
  var cast2 = require_cast2();
  var castArrayFilters = require_castArrayFilters();
  var castNumber = require_number();
  var castUpdate = require_castUpdate();
  var clone2 = require_clone();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var helpers = require_queryHelpers();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  var isSubpath = require_isSubpath();
  var mpath = require_mpath();
  var mquery = require_mquery();
  var parseProjection = require_parseProjection();
  var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
  var sanitizeFilter = require_sanitizeFilter();
  var sanitizeProjection = require_sanitizeProjection();
  var selectPopulatedFields = require_selectPopulatedFields();
  var setDefaultsOnInsert = require_setDefaultsOnInsert();
  var specialProperties = require_specialProperties();
  var updateValidators = require_updateValidators();
  var util3 = __require("util");
  var utils = require_utils3();
  var queryMiddlewareFunctions = require_constants3().queryMiddlewareFunctions;
  var queryOptionMethods = new Set([
    "allowDiskUse",
    "batchSize",
    "collation",
    "comment",
    "explain",
    "hint",
    "j",
    "lean",
    "limit",
    "maxTimeMS",
    "populate",
    "projection",
    "read",
    "select",
    "skip",
    "slice",
    "sort",
    "tailable",
    "w",
    "writeConcern",
    "wtimeout"
  ]);
  var opToThunk = new Map([
    ["countDocuments", "_countDocuments"],
    ["distinct", "__distinct"],
    ["estimatedDocumentCount", "_estimatedDocumentCount"],
    ["find", "_find"],
    ["findOne", "_findOne"],
    ["findOneAndReplace", "_findOneAndReplace"],
    ["findOneAndUpdate", "_findOneAndUpdate"],
    ["replaceOne", "_replaceOne"],
    ["updateMany", "_updateMany"],
    ["updateOne", "_updateOne"],
    ["deleteMany", "_deleteMany"],
    ["deleteOne", "_deleteOne"],
    ["findOneAndDelete", "_findOneAndDelete"]
  ]);
  function Query(conditions, options, model, collection) {
    if (!this._mongooseOptions) {
      this._mongooseOptions = {};
    }
    options = options || {};
    this._transforms = [];
    this._hooks = new Kareem;
    this._executionStack = null;
    const keys = Object.keys(options);
    for (const key of keys) {
      this._mongooseOptions[key] = options[key];
    }
    if (collection) {
      this.mongooseCollection = collection;
    }
    if (model) {
      this.model = model;
      this.schema = model.schema;
    }
    if (this.model && this.model._mapreduce) {
      this.lean();
    }
    mquery.call(this, null, options);
    if (collection) {
      this.collection(collection);
    }
    if (conditions) {
      this.find(conditions);
    }
    this.options = this.options || {};
    this.$useProjection = true;
    const collation = this && this.schema && this.schema.options && this.schema.options.collation || null;
    if (collation != null) {
      this.options.collation = collation;
    }
  }
  function isEmptyFilter(obj) {
    if (obj == null)
      return true;
    if (typeof obj !== "object")
      return true;
    if (Object.keys(obj).length === 0)
      return true;
    for (const key of ["$and", "$or", "$nor"]) {
      if (Array.isArray(obj[key])) {
        if (obj[key].length === 0 || obj[key].every((item) => isEmptyFilter(item))) {
          return true;
        }
      }
    }
    return false;
  }
  function checkRequireFilter(filter, options) {
    if (options && options.requireFilter && isEmptyFilter(filter)) {
      throw new Error("Empty or invalid filter not allowed with requireFilter enabled");
    }
  }
  /*!
   * inherit mquery
   */
  Query.prototype = new mquery;
  Query.prototype.constructor = Query;
  Query.prototype.count = undefined;
  Query.prototype.findOneAndRemove = undefined;
  Query.base = mquery.prototype;
  /*!
   * Overwrite mquery's `_distinct`, because Mongoose uses that name
   * to store the field to apply distinct on.
   */
  Object.defineProperty(Query.prototype, "_distinct", {
    configurable: true,
    writable: true,
    enumerable: true,
    value: undefined
  });
  Query.use$geoWithin = mquery.use$geoWithin;
  Query.prototype.toConstructor = function toConstructor() {
    const model = this.model;
    const coll = this.mongooseCollection;
    const CustomQuery = function(criteria, options2) {
      if (!(this instanceof CustomQuery)) {
        return new CustomQuery(criteria, options2);
      }
      this._mongooseOptions = clone2(p._mongooseOptions);
      Query.call(this, criteria, options2 || null, model, coll);
    };
    util3.inherits(CustomQuery, model.Query);
    const p = CustomQuery.prototype;
    p.options = {};
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
      p.sort(options.sort);
      delete options.sort;
    }
    p.setOptions(options);
    p.op = this.op;
    p._validateOp();
    p._conditions = clone2(this._conditions);
    p._fields = clone2(this._fields);
    p._update = clone2(this._update, {
      flattenDecimals: false
    });
    p._path = this._path;
    p._distinct = this._distinct;
    p._collection = this._collection;
    p._mongooseOptions = this._mongooseOptions;
    return CustomQuery;
  };
  Query.prototype.clone = function() {
    const model = this.model;
    const collection = this.mongooseCollection;
    const q = new this.model.Query({}, {}, model, collection);
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
      q.sort(options.sort);
      delete options.sort;
    }
    q.setOptions(options);
    q.op = this.op;
    q._validateOp();
    q._conditions = clone2(this._conditions);
    q._fields = clone2(this._fields);
    q._update = clone2(this._update, {
      flattenDecimals: false
    });
    q._path = this._path;
    q._distinct = this._distinct;
    q._collection = this._collection;
    q._mongooseOptions = this._mongooseOptions;
    return q;
  };
  Query.prototype.slice = function() {
    if (arguments.length === 0) {
      return this;
    }
    this._validate("slice");
    let path;
    let val;
    if (arguments.length === 1) {
      const arg = arguments[0];
      if (typeof arg === "object" && !Array.isArray(arg)) {
        const keys = Object.keys(arg);
        const numKeys = keys.length;
        for (let i = 0;i < numKeys; ++i) {
          this.slice(keys[i], arg[keys[i]]);
        }
        return this;
      }
      this._ensurePath("slice");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        this._ensurePath("slice");
        path = this._path;
        val = [arguments[0], arguments[1]];
      } else {
        path = arguments[0];
        val = arguments[1];
      }
    } else if (arguments.length === 3) {
      path = arguments[0];
      val = [arguments[1], arguments[2]];
    }
    const p = {};
    p[path] = { $slice: val };
    this.select(p);
    return this;
  };
  /*!
   * ignore
   */
  var validOpsSet = new Set(queryMiddlewareFunctions);
  Query.prototype._validateOp = function() {
    if (this.op != null && !validOpsSet.has(this.op)) {
      this.error(new Error('Query has invalid `op`: "' + this.op + '"'));
    }
  };
  Query.prototype.mod = function() {
    let val;
    let path;
    if (arguments.length === 1) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = [arguments[0], arguments[1]];
      path = this._path;
    } else if (arguments.length === 3) {
      val = [arguments[1], arguments[2]];
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  Query.prototype.limit = function limit(v) {
    this._validate("limit");
    if (typeof v === "string") {
      try {
        v = castNumber(v);
      } catch (err2) {
        throw new CastError("Number", v, "limit");
      }
    }
    this.options.limit = v;
    return this;
  };
  Query.prototype.skip = function skip(v) {
    this._validate("skip");
    if (typeof v === "string") {
      try {
        v = castNumber(v);
      } catch (err2) {
        throw new CastError("Number", v, "skip");
      }
    }
    this.options.skip = v;
    return this;
  };
  Query.prototype.projection = function(arg) {
    if (arguments.length === 0) {
      return this._fields;
    }
    this._fields = {};
    this._userProvidedFields = {};
    this.select(arg);
    return this._fields;
  };
  Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg)
      return this;
    if (arguments.length !== 1) {
      throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
    let sanitizeProjection2 = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.db.options.sanitizeProjection;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.base.options.sanitizeProjection;
    } else {
      sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
    }
    function sanitizeValue(value) {
      return typeof value === "string" && sanitizeProjection2 ? value = 1 : value;
    }
    arg = parseProjection(arg, true);
    if (utils.isObject(arg)) {
      if (this.selectedInclusively()) {
        Object.entries(arg).forEach(([key, value]) => {
          if (value) {
            if (fields["-" + key] != null) {
              delete fields["-" + key];
            }
            fields[key] = userProvidedFields[key] = sanitizeValue(value);
          } else {
            Object.keys(userProvidedFields).forEach((field) => {
              if (isSubpath(key, field)) {
                delete fields[field];
                delete userProvidedFields[field];
              }
            });
          }
        });
      } else if (this.selectedExclusively()) {
        Object.entries(arg).forEach(([key, value]) => {
          if (!value) {
            if (fields["+" + key] != null) {
              delete fields["+" + key];
            }
            fields[key] = userProvidedFields[key] = sanitizeValue(value);
          } else {
            Object.keys(userProvidedFields).forEach((field) => {
              if (isSubpath(key, field)) {
                delete fields[field];
                delete userProvidedFields[field];
              }
            });
          }
        });
      } else {
        const keys = Object.keys(arg);
        for (let i = 0;i < keys.length; ++i) {
          const value = arg[keys[i]];
          const key = keys[i];
          fields[key] = sanitizeValue(value);
          userProvidedFields[key] = sanitizeValue(value);
        }
      }
      return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
  };
  Query.prototype.schemaLevelProjections = function schemaLevelProjections(value) {
    this._mongooseOptions.schemaLevelProjections = value;
    return this;
  };
  Query.prototype.sanitizeProjection = function sanitizeProjection(value) {
    this._mongooseOptions.sanitizeProjection = value;
    return this;
  };
  Query.prototype.read = function read(mode, tags) {
    if (typeof mode === "string") {
      mode = handleReadPreferenceAliases(mode);
      this.options.readPreference = { mode, tags };
    } else {
      this.options.readPreference = mode;
    }
    return this;
  };
  Query.prototype.toString = function toString() {
    if (this.op === "count" || this.op === "countDocuments" || this.op === "find" || this.op === "findOne" || this.op === "deleteMany" || this.op === "deleteOne" || this.op === "findOneAndDelete" || this.op === "remove") {
      return `${this.model.modelName}.${this.op}(${util3.inspect(this._conditions)})`;
    }
    if (this.op === "distinct") {
      return `${this.model.modelName}.distinct('${this._distinct}', ${util3.inspect(this._conditions)})`;
    }
    if (this.op === "findOneAndReplace" || this.op === "findOneAndUpdate" || this.op === "replaceOne" || this.op === "update" || this.op === "updateMany" || this.op === "updateOne") {
      return `${this.model.modelName}.${this.op}(${util3.inspect(this._conditions)}, ${util3.inspect(this._update)})`;
    }
    return `${this.model.modelName}.${this.op}()`;
  };
  Query.prototype.session = function session(v) {
    if (v == null) {
      delete this.options.session;
    }
    this.options.session = v;
    return this;
  };
  Query.prototype.writeConcern = function writeConcern(val) {
    if (val == null) {
      delete this.options.writeConcern;
      return this;
    }
    this.options.writeConcern = val;
    return this;
  };
  Query.prototype.w = function w(val) {
    if (val == null) {
      delete this.options.w;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.w = val;
    } else {
      this.options.w = val;
    }
    return this;
  };
  Query.prototype.j = function j(val) {
    if (val == null) {
      delete this.options.j;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.j = val;
    } else {
      this.options.j = val;
    }
    return this;
  };
  Query.prototype.wtimeout = function wtimeout(ms) {
    if (ms == null) {
      delete this.options.wtimeout;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.wtimeout = ms;
    } else {
      this.options.wtimeout = ms;
    }
    return this;
  };
  Query.prototype.getOptions = function() {
    return this.options;
  };
  Query.prototype.setOptions = function(options, overwrite) {
    if (overwrite) {
      this._mongooseOptions = options && clone2(options) || {};
      this.options = options || {};
      if ("populate" in options) {
        this.populate(this._mongooseOptions);
      }
      return this;
    }
    if (options == null) {
      return this;
    }
    if (typeof options !== "object") {
      throw new Error('Options must be an object, got "' + options + '"');
    }
    options = Object.assign({}, options);
    if (Array.isArray(options.populate)) {
      const populate = options.populate;
      delete options.populate;
      const _numPopulate = populate.length;
      for (let i = 0;i < _numPopulate; ++i) {
        this.populate(populate[i]);
      }
    }
    if ("setDefaultsOnInsert" in options) {
      this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
      delete options.setDefaultsOnInsert;
    }
    if ("overwriteDiscriminatorKey" in options) {
      this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
      delete options.overwriteDiscriminatorKey;
    }
    if ("overwriteImmutable" in options) {
      this._mongooseOptions.overwriteImmutable = options.overwriteImmutable;
      delete options.overwriteImmutable;
    }
    if ("sanitizeProjection" in options) {
      if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
        sanitizeProjection(this._fields);
      }
      this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
      delete options.sanitizeProjection;
    }
    if ("sanitizeFilter" in options) {
      this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;
      delete options.sanitizeFilter;
    }
    if ("timestamps" in options) {
      this._mongooseOptions.timestamps = options.timestamps;
      delete options.timestamps;
    }
    if ("defaults" in options) {
      this._mongooseOptions.defaults = options.defaults;
    }
    if ("translateAliases" in options) {
      this._mongooseOptions.translateAliases = options.translateAliases;
      delete options.translateAliases;
    }
    if ("schemaLevelProjections" in options) {
      this._mongooseOptions.schemaLevelProjections = options.schemaLevelProjections;
      delete options.schemaLevelProjections;
    }
    if (options.lean == null && this.schema && "lean" in this.schema.options) {
      this._mongooseOptions.lean = this.schema.options.lean;
    }
    if (typeof options.limit === "string") {
      try {
        options.limit = castNumber(options.limit);
      } catch (err2) {
        throw new CastError("Number", options.limit, "limit");
      }
    }
    if (typeof options.skip === "string") {
      try {
        options.skip = castNumber(options.skip);
      } catch (err2) {
        throw new CastError("Number", options.skip, "skip");
      }
    }
    for (const key of Object.keys(options)) {
      if (queryOptionMethods.has(key)) {
        const args = Array.isArray(options[key]) ? options[key] : [options[key]];
        this[key].apply(this, args);
      } else {
        this.options[key] = options[key];
      }
    }
    return this;
  };
  Query.prototype.explain = function explain(verbose) {
    if (arguments.length === 0) {
      this.options.explain = true;
    } else if (verbose === false) {
      delete this.options.explain;
    } else {
      this.options.explain = verbose;
    }
    return this;
  };
  Query.prototype.allowDiskUse = function(v) {
    if (arguments.length === 0) {
      this.options.allowDiskUse = true;
    } else if (v === false) {
      delete this.options.allowDiskUse;
    } else {
      this.options.allowDiskUse = v;
    }
    return this;
  };
  Query.prototype.maxTimeMS = function(ms) {
    this.options.maxTimeMS = ms;
    return this;
  };
  Query.prototype.getFilter = function() {
    return this._conditions;
  };
  Query.prototype.getQuery = function() {
    return this._conditions;
  };
  Query.prototype.setQuery = function(val) {
    this._conditions = val;
  };
  Query.prototype.getUpdate = function() {
    return this._update;
  };
  Query.prototype.setUpdate = function(val) {
    this._update = val;
  };
  Query.prototype._fieldsForExec = function() {
    if (this._fields == null) {
      return null;
    }
    if (Object.keys(this._fields).length === 0) {
      return null;
    }
    return clone2(this._fields);
  };
  Query.prototype._updateForExec = function() {
    const update = clone2(this._update, {
      transform: false,
      depopulate: true
    });
    const ops = Object.keys(update);
    let i = ops.length;
    const ret = {};
    while (i--) {
      const op = ops[i];
      if (op[0] !== "$") {
        if (!ret.$set) {
          if (update.$set) {
            ret.$set = update.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = update[op];
        ops.splice(i, 1);
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = update[op];
        }
      } else {
        ret[op] = update[op];
      }
    }
    return ret;
  };
  Query.prototype._optionsForExec = function(model) {
    const options = clone2(this.options);
    delete options.populate;
    model = model || this.model;
    if (!model) {
      return options;
    }
    applyReadConcern(model.schema, options);
    applyWriteConcern(model.schema, options);
    const asyncLocalStorage = this.model?.db?.base.transactionAsyncLocalStorage?.getStore();
    if (!this.options.hasOwnProperty("session") && asyncLocalStorage?.session != null) {
      options.session = asyncLocalStorage.session;
    }
    const readPreference = model && model.schema && model.schema.options && model.schema.options.read;
    if (!("readPreference" in options) && readPreference) {
      options.readPreference = readPreference;
    }
    if (options.upsert !== undefined) {
      options.upsert = !!options.upsert;
    }
    if (options.writeConcern) {
      if (options.j) {
        options.writeConcern.j = options.j;
        delete options.j;
      }
      if (options.w) {
        options.writeConcern.w = options.w;
        delete options.w;
      }
      if (options.wtimeout) {
        options.writeConcern.wtimeout = options.wtimeout;
        delete options.wtimeout;
      }
    }
    this._applyPaths();
    if (this._fields != null) {
      this._fields = this._castFields(this._fields);
      const projection = this._fieldsForExec();
      if (projection != null) {
        options.projection = projection;
      }
    }
    return options;
  };
  Query.prototype.lean = function(v) {
    this._mongooseOptions.lean = arguments.length ? v : true;
    return this;
  };
  Query.prototype.set = function(path, val) {
    if (typeof path === "object") {
      const keys = Object.keys(path);
      for (const key of keys) {
        this.set(key, path[key]);
      }
      return this;
    }
    this._update = this._update || {};
    if (path in this._update) {
      delete this._update[path];
    }
    this._update.$set = this._update.$set || {};
    this._update.$set[path] = val;
    return this;
  };
  Query.prototype.get = function get(path) {
    const update = this._update;
    if (update == null) {
      return;
    }
    const $set = update.$set;
    if ($set == null) {
      return update[path];
    }
    if (utils.hasUserDefinedProperty(update, path)) {
      return update[path];
    }
    if (utils.hasUserDefinedProperty($set, path)) {
      return $set[path];
    }
    return;
  };
  Query.prototype.error = function error(err2) {
    if (arguments.length === 0) {
      return this._error;
    }
    this._error = err2;
    return this;
  };
  Query.prototype._unsetCastError = function _unsetCastError() {
    if (this._error == null || !(this._error instanceof CastError)) {
      return;
    }
    return this.error(null);
  };
  Query.prototype.mongooseOptions = function(v) {
    if (arguments.length > 0) {
      this._mongooseOptions = v;
    }
    return this._mongooseOptions;
  };
  Query.prototype._castConditions = function() {
    let sanitizeFilterOpt = undefined;
    if (this.model?.db.options?.sanitizeFilter != null) {
      sanitizeFilterOpt = this.model.db.options.sanitizeFilter;
    } else if (this.model?.base.options?.sanitizeFilter != null) {
      sanitizeFilterOpt = this.model.base.options.sanitizeFilter;
    } else {
      sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;
    }
    if (sanitizeFilterOpt) {
      sanitizeFilter(this._conditions);
    }
    try {
      this.cast(this.model);
      this._unsetCastError();
    } catch (err2) {
      this.error(err2);
    }
  };
  /*!
   * ignore
   */
  function _castArrayFilters(query) {
    try {
      castArrayFilters(query);
    } catch (err2) {
      query.error(err2);
    }
  }
  Query.prototype._find = async function _find() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const mongooseOptions = this._mongooseOptions;
    const userProvidedFields = this._userProvidedFields || {};
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const completeManyOptions = {
      session: this && this.options && this.options.session || null,
      lean: mongooseOptions.lean || null
    };
    const options = this._optionsForExec();
    const filter = this._conditions;
    const fields = options.projection;
    const cursor = await this.mongooseCollection.find(filter, options);
    if (options.explain) {
      return cursor.explain();
    }
    let docs = await cursor.toArray();
    if (docs.length === 0) {
      return docs;
    }
    if (!mongooseOptions.populate) {
      const versionKey = this.schema.options.versionKey;
      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
        docs.forEach((doc) => {
          if (versionKey in doc) {
            delete doc[versionKey];
          }
        });
      }
      return mongooseOptions.lean ? _completeManyLean(this.model.schema, docs, null, completeManyOptions) : this._completeMany(docs, fields, userProvidedFields, completeManyOptions);
    }
    const pop = helpers.preparePopulationOptionsMQ(this, mongooseOptions);
    if (mongooseOptions.lean) {
      return this.model.populate(docs, pop);
    }
    docs = await this._completeMany(docs, fields, userProvidedFields, completeManyOptions);
    await this.model.populate(docs, pop);
    return docs;
  };
  Query.prototype.find = function(conditions) {
    if (typeof conditions === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.find() no longer accepts a callback");
    }
    this.op = "find";
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "find"));
    }
    return this;
  };
  Query.prototype.merge = function(source) {
    if (!source) {
      return this;
    }
    const opts = { overwrite: true };
    if (source instanceof Query) {
      if (source._conditions) {
        opts.omit = {};
        if (this._conditions && this._conditions.$and && source._conditions.$and) {
          opts.omit["$and"] = true;
          this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);
        }
        if (this._conditions && this._conditions.$or && source._conditions.$or) {
          opts.omit["$or"] = true;
          this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);
        }
        utils.merge(this._conditions, source._conditions, opts);
      }
      if (source._fields) {
        this._fields || (this._fields = {});
        utils.merge(this._fields, source._fields, opts);
      }
      if (source.options) {
        this.options || (this.options = {});
        utils.merge(this.options, source.options, opts);
      }
      if (source._update) {
        this._update || (this._update = {});
        utils.mergeClone(this._update, source._update);
      }
      if (source._distinct) {
        this._distinct = source._distinct;
      }
      utils.merge(this._mongooseOptions, source._mongooseOptions);
      return this;
    } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {
      utils.merge(this._conditions, { _id: source }, opts);
      return this;
    } else if (source && source.$__) {
      source = source.toObject(internalToObjectOptions);
    }
    opts.omit = {};
    if (Array.isArray(source.$and)) {
      opts.omit["$and"] = true;
      if (!this._conditions) {
        this._conditions = {};
      }
      this._conditions.$and = (this._conditions.$and || []).concat(source.$and.map((el) => utils.isPOJO(el) ? utils.merge({}, el) : el));
    }
    if (Array.isArray(source.$or)) {
      opts.omit["$or"] = true;
      if (!this._conditions) {
        this._conditions = {};
      }
      this._conditions.$or = (this._conditions.$or || []).concat(source.$or.map((el) => utils.isPOJO(el) ? utils.merge({}, el) : el));
    }
    utils.merge(this._conditions, source, opts);
    return this;
  };
  Query.prototype.collation = function(value) {
    if (this.options == null) {
      this.options = {};
    }
    this.options.collation = value;
    return this;
  };
  Query.prototype._completeOne = function(doc, res, projection, callback) {
    if (!doc && !this.options.includeResultMetadata) {
      return callback(null, null);
    }
    const model = this.model;
    const userProvidedFields = this._userProvidedFields || {};
    const mongooseOptions = this._mongooseOptions;
    const options = this.options;
    if (!options.lean && mongooseOptions.lean) {
      options.lean = mongooseOptions.lean;
    }
    if (options.explain) {
      return callback(null, doc);
    }
    if (!mongooseOptions.populate) {
      const versionKey = this.schema.options.versionKey;
      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
        if (versionKey in doc) {
          delete doc[versionKey];
        }
      }
      return mongooseOptions.lean ? _completeOneLean(model.schema, doc, null, res, options, callback) : completeOne(model, doc, res, options, projection, userProvidedFields, null, callback);
    }
    const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
    if (mongooseOptions.lean) {
      return model.populate(doc, pop).then((doc2) => {
        _completeOneLean(model.schema, doc2, null, res, options, callback);
      }, (error) => {
        callback(error);
      });
    }
    completeOne(model, doc, res, options, projection, userProvidedFields, [], (err2, doc2) => {
      if (err2 != null) {
        return callback(err2);
      }
      model.populate(doc2, pop).then((res2) => {
        callback(null, res2);
      }, (err3) => {
        callback(err3);
      });
    });
  };
  Query.prototype._completeMany = async function _completeMany(docs, fields, userProvidedFields, opts) {
    const model = this.model;
    return Promise.all(docs.map((doc) => new Promise((resolve, reject) => {
      const rawDoc = doc;
      doc = helpers.createModel(model, doc, fields, userProvidedFields);
      if (opts.session != null) {
        doc.$session(opts.session);
      }
      doc.$init(rawDoc, opts, (err2) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve(doc);
      });
    })));
  };
  Query.prototype._findOne = async function _findOne() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error()) {
      const err2 = this.error();
      throw err2;
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const options = this._optionsForExec();
    const doc = await this.mongooseCollection.findOne(this._conditions, options);
    return new Promise((resolve, reject) => {
      this._completeOne(doc, null, options.projection, (err2, res) => {
        if (err2) {
          return reject(err2);
        }
        resolve(res);
      });
    });
  };
  Query.prototype.findOne = function(conditions, projection, options) {
    if (typeof conditions === "function" || typeof projection === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.findOne() no longer accepts a callback");
    }
    this.op = "findOne";
    this._validateOp();
    if (options) {
      this.setOptions(options);
    }
    if (projection) {
      this.select(projection);
    }
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "findOne"));
    }
    return this;
  };
  Query.prototype._countDocuments = async function _countDocuments() {
    this._applyTranslateAliases();
    try {
      this.cast(this.model);
    } catch (err2) {
      this.error(err2);
    }
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const options = this._optionsForExec();
    const conds = this._conditions;
    return this.mongooseCollection.countDocuments(conds, options);
  };
  /*!
   * If `translateAliases` option is set, call `Model.translateAliases()`
   * on the following query properties: filter, projection, update, distinct.
   */
  Query.prototype._applyTranslateAliases = function _applyTranslateAliases() {
    let applyTranslateAliases = false;
    if ("translateAliases" in this._mongooseOptions) {
      applyTranslateAliases = this._mongooseOptions.translateAliases;
    } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {
      applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;
    } else if (this.model?.base?.options?.translateAliases != null) {
      applyTranslateAliases = this.model.base.options.translateAliases;
    }
    if (!applyTranslateAliases) {
      return;
    }
    if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {
      this.model.translateAliases(this._conditions, true);
      this.model.translateAliases(this._fields, true);
      this.model.translateAliases(this._update, true);
      if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {
        this._distinct = this.model.schema.aliases[this._distinct];
      }
    }
  };
  Query.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {
    if (this.error()) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this.mongooseCollection.estimatedDocumentCount(options);
  };
  Query.prototype.estimatedDocumentCount = function(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.estimatedDocumentCount() no longer accepts a callback");
    }
    this.op = "estimatedDocumentCount";
    this._validateOp();
    if (options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.countDocuments = function(conditions, options) {
    if (typeof conditions === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.countDocuments() no longer accepts a callback");
    }
    this.op = "countDocuments";
    this._validateOp();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
    }
    if (options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.__distinct = async function __distinct() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const options = this._optionsForExec();
    return this.mongooseCollection.distinct(this._distinct, this._conditions, options);
  };
  Query.prototype.distinct = function(field, conditions, options) {
    if (typeof field === "function" || typeof conditions === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.distinct() no longer accepts a callback");
    }
    this.op = "distinct";
    this._validateOp();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "distinct"));
    }
    if (field != null) {
      this._distinct = field;
    }
    if (options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.sort = function(arg, options) {
    if (arguments.length > 2) {
      throw new Error("sort() takes at most 2 arguments");
    }
    if (options != null && typeof options !== "object") {
      throw new Error("sort() options argument must be an object or nullish");
    }
    if (this.options.sort == null) {
      this.options.sort = {};
    }
    if (options && options.override) {
      this.options.sort = {};
    }
    const sort = this.options.sort;
    if (typeof arg === "string") {
      const properties = arg.indexOf(" ") === -1 ? [arg] : arg.split(" ");
      for (let property of properties) {
        const ascend = property[0] == "-" ? -1 : 1;
        if (ascend === -1) {
          property = property.slice(1);
        }
        if (specialProperties.has(property)) {
          continue;
        }
        sort[property] = ascend;
      }
    } else if (Array.isArray(arg)) {
      for (const pair of arg) {
        if (!Array.isArray(pair)) {
          throw new TypeError("Invalid sort() argument, must be array of arrays");
        }
        const key = "" + pair[0];
        if (specialProperties.has(key)) {
          continue;
        }
        sort[key] = _handleSortValue(pair[1], key);
      }
    } else if (typeof arg === "object" && arg != null && !(arg instanceof Map)) {
      for (const key of Object.keys(arg)) {
        if (specialProperties.has(key)) {
          continue;
        }
        sort[key] = _handleSortValue(arg[key], key);
      }
    } else if (arg instanceof Map) {
      for (let key of arg.keys()) {
        key = "" + key;
        if (specialProperties.has(key)) {
          continue;
        }
        sort[key] = _handleSortValue(arg.get(key), key);
      }
    } else if (arg != null) {
      throw new TypeError("Invalid sort() argument. Must be a string, object, array, or map.");
    }
    return this;
  };
  /*!
   * Convert sort values
   */
  function _handleSortValue(val, key) {
    if (val === 1 || val === "asc" || val === "ascending") {
      return 1;
    }
    if (val === -1 || val === "desc" || val === "descending") {
      return -1;
    }
    if (val?.$meta != null) {
      return { $meta: val.$meta };
    }
    throw new TypeError("Invalid sort value: { " + key + ": " + val + " }");
  }
  Query.prototype.deleteOne = function deleteOne(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.deleteOne() no longer accepts a callback");
    }
    this.op = "deleteOne";
    this.setOptions(options);
    if (mquery.canMerge(filter)) {
      this.merge(filter);
      prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
    }
    return this;
  };
  Query.prototype._deleteOne = async function _deleteOne() {
    this._applyTranslateAliases();
    this._castConditions();
    checkRequireFilter(this._conditions, this.options);
    if (this.error() != null) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this.mongooseCollection.deleteOne(this._conditions, options);
  };
  Query.prototype.deleteMany = function(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.deleteMany() no longer accepts a callback");
    }
    this.setOptions(options);
    this.op = "deleteMany";
    if (mquery.canMerge(filter)) {
      this.merge(filter);
      prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
    }
    return this;
  };
  Query.prototype._deleteMany = async function _deleteMany() {
    this._applyTranslateAliases();
    this._castConditions();
    checkRequireFilter(this._conditions, this.options);
    if (this.error() != null) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this.mongooseCollection.deleteMany(this._conditions, options);
  };
  function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
    if (options.includeResultMetadata && doc == null) {
      _init(null);
      return null;
    }
    helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);
    function _init(err2, casted) {
      if (err2) {
        return callback(err2);
      }
      if (options.includeResultMetadata) {
        if (doc && casted) {
          if (options.session != null) {
            casted.$session(options.session);
          }
          res.value = casted;
        } else {
          res.value = null;
        }
        return callback(null, res);
      }
      if (options.session != null) {
        casted.$session(options.session);
      }
      callback(null, casted);
    }
  }
  function prepareDiscriminatorCriteria(query) {
    if (!query || !query.model || !query.model.schema) {
      return;
    }
    const schema = query.model.schema;
    if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
      query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
  }
  Query.prototype.findOneAndUpdate = function(filter, doc, options) {
    if (typeof filter === "function" || typeof doc === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.findOneAndUpdate() no longer accepts a callback");
    }
    this.op = "findOneAndUpdate";
    this._validateOp();
    this._validate();
    switch (arguments.length) {
      case 2:
        options = undefined;
        break;
      case 1:
        doc = filter;
        filter = options = undefined;
        break;
    }
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "findOneAndUpdate"));
    }
    if (doc) {
      this._mergeUpdate(doc);
    }
    options = options ? clone2(options) : {};
    if (options.projection) {
      this.select(options.projection);
      delete options.projection;
    }
    if (options.fields) {
      this.select(options.fields);
      delete options.fields;
    }
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
      options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndUpdate = async function _findOneAndUpdate() {
    this._applyTranslateAliases();
    this._castConditions();
    checkRequireFilter(this._conditions, this.options);
    _castArrayFilters(this);
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    if ("strict" in this.options) {
      this._mongooseOptions.strict = this.options.strict;
    }
    const options = this._optionsForExec(this.model);
    convertNewToReturnDocument(options);
    this._update = this._castUpdate(this._update);
    const _opts = Object.assign({}, options, {
      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
    });
    this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    if (!this._update || Object.keys(this._update).length === 0) {
      if (options.upsert) {
        const $set = clone2(this._update);
        delete $set._id;
        this._update = { $set };
      } else {
        this._executionStack = null;
        const res2 = await this._findOne();
        return res2;
      }
    } else if (this._update instanceof Error) {
      throw this._update;
    } else {
      if (this._update.$set && Object.keys(this._update.$set).length === 0) {
        delete this._update.$set;
      }
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
      await this.validate(this._update, options, false);
    }
    if (this._update.toBSON) {
      this._update = this._update.toBSON();
    }
    let res = await this.mongooseCollection.findOneAndUpdate(this._conditions, this._update, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = !options.includeResultMetadata ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, options.projection, (err2, res2) => {
        if (err2) {
          return reject(err2);
        }
        resolve(res2);
      });
    });
  };
  Query.prototype.findOneAndDelete = function(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.findOneAndDelete() no longer accepts a callback");
    }
    this.op = "findOneAndDelete";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndDelete = async function _findOneAndDelete() {
    this._applyTranslateAliases();
    this._castConditions();
    checkRequireFilter(this._conditions, this.options);
    if (this.error() != null) {
      throw this.error();
    }
    const includeResultMetadata = this.options.includeResultMetadata;
    const filter = this._conditions;
    const options = this._optionsForExec(this.model);
    let res = await this.mongooseCollection.findOneAndDelete(filter, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = !includeResultMetadata ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, options.projection, (err2, res2) => {
        if (err2) {
          return reject(err2);
        }
        resolve(res2);
      });
    });
  };
  Query.prototype.findOneAndReplace = function(filter, replacement, options) {
    if (typeof filter === "function" || typeof replacement === "function" || typeof options === "function" || typeof arguments[4] === "function") {
      throw new MongooseError("Query.prototype.findOneAndReplace() no longer accepts a callback");
    }
    this.op = "findOneAndReplace";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "findOneAndReplace"));
    }
    if (replacement != null) {
      this._mergeUpdate(replacement);
    }
    options = options || {};
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
      options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndReplace = async function _findOneAndReplace() {
    this._applyTranslateAliases();
    this._castConditions();
    checkRequireFilter(this._conditions, this.options);
    if (this.error() != null) {
      throw this.error();
    }
    if ("strict" in this.options) {
      this._mongooseOptions.strict = this.options.strict;
      delete this.options.strict;
    }
    const filter = this._conditions;
    const options = this._optionsForExec();
    convertNewToReturnDocument(options);
    const includeResultMetadata = this.options.includeResultMetadata;
    const modelOpts = { skipId: true };
    if ("strict" in this._mongooseOptions) {
      modelOpts.strict = this._mongooseOptions.strict;
    }
    const runValidators = _getOption(this, "runValidators", false);
    try {
      const update = new this.model(this._update, null, modelOpts);
      if (runValidators) {
        await update.validate();
      } else if (update.$__.validationError) {
        throw update.$__.validationError;
      }
      this._update = update.toBSON();
    } catch (err2) {
      if (err2 instanceof ValidationError2) {
        throw err2;
      }
      const validationError = new ValidationError2;
      validationError.errors[err2.path] = err2;
      throw validationError;
    }
    let res = await this.mongooseCollection.findOneAndReplace(filter, this._update, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = !includeResultMetadata ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, options.projection, (err2, res2) => {
        if (err2) {
          return reject(err2);
        }
        resolve(res2);
      });
    });
  };
  Query.prototype.findById = function(id, projection, options) {
    return this.findOne({ _id: id }, projection, options);
  };
  Query.prototype.findByIdAndUpdate = function(id, update, options) {
    return this.findOneAndUpdate({ _id: id }, update, options);
  };
  Query.prototype.findByIdAndDelete = function(id, options) {
    return this.findOneAndDelete({ _id: id }, options);
  };
  function convertNewToReturnDocument(options) {
    if ("new" in options) {
      options.returnDocument = options["new"] ? "after" : "before";
      delete options["new"];
    }
    if ("returnOriginal" in options) {
      options.returnDocument = options["returnOriginal"] ? "before" : "after";
      delete options["returnOriginal"];
    }
    if (typeof options.returnDocument === "string") {
      options.returnOriginal = options.returnDocument === "before";
    }
  }
  function _getOption(query, option, def) {
    const opts = query._optionsForExec(query.model);
    if (option in opts) {
      return opts[option];
    }
    if (option in query.model.base.options) {
      return query.model.base.options[option];
    }
    return def;
  }
  /*!
   * ignore
   */
  function _completeOneLean(schema, doc, path, res, opts, callback) {
    if (opts.lean && typeof opts.lean.transform === "function") {
      opts.lean.transform(doc);
      for (let i = 0;i < schema.childSchemas.length; i++) {
        const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
        const _schema = schema.childSchemas[i].schema;
        const obj = mpath.get(childPath, doc);
        if (obj == null) {
          continue;
        }
        if (Array.isArray(obj)) {
          for (let i2 = 0;i2 < obj.length; i2++) {
            opts.lean.transform(obj[i2]);
          }
        } else {
          opts.lean.transform(obj);
        }
        _completeOneLean(_schema, obj, childPath, res, opts);
      }
      if (callback) {
        return callback(null, doc);
      } else {
        return;
      }
    }
    if (opts.includeResultMetadata) {
      return callback(null, res);
    }
    return callback(null, doc);
  }
  /*!
   * ignore
   */
  function _completeManyLean(schema, docs, path, opts) {
    if (opts.lean && typeof opts.lean.transform === "function") {
      for (const doc of docs) {
        opts.lean.transform(doc);
      }
      for (let i = 0;i < schema.childSchemas.length; i++) {
        const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
        const _schema = schema.childSchemas[i].schema;
        let doc = mpath.get(childPath, docs);
        if (doc == null) {
          continue;
        }
        doc = doc.flat();
        for (let i2 = 0;i2 < doc.length; i2++) {
          opts.lean.transform(doc[i2]);
        }
        _completeManyLean(_schema, doc, childPath, opts);
      }
    }
    return docs;
  }
  Query.prototype._mergeUpdate = function(doc) {
    if (!this._update) {
      this._update = Array.isArray(doc) ? [] : {};
    }
    if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
      return;
    }
    if (doc instanceof Query) {
      if (Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      if (doc._update) {
        utils.mergeClone(this._update, doc._update);
      }
    } else if (Array.isArray(doc)) {
      if (!Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      this._update = this._update.concat(doc);
    } else {
      if (Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      utils.mergeClone(this._update, doc);
    }
  };
  /*!
   * ignore
   */
  async function _updateThunk(op) {
    this._applyTranslateAliases();
    this._castConditions();
    checkRequireFilter(this._conditions, this.options);
    _castArrayFilters(this);
    if (this.error() != null) {
      throw this.error();
    }
    const castedQuery = this._conditions;
    const options = this._optionsForExec(this.model);
    this._update = clone2(this._update, options);
    const isOverwriting = op === "replaceOne";
    if (isOverwriting) {
      this._update = new this.model(this._update, null, true);
    } else {
      this._update = this._castUpdate(this._update);
      if (this._update == null || Object.keys(this._update).length === 0) {
        return { acknowledged: false };
      }
      const _opts = Object.assign({}, options, {
        setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
      });
      this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    }
    if (Array.isArray(options.arrayFilters)) {
      options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
      await this.validate(this._update, options, isOverwriting);
    }
    if (this._update.toBSON) {
      this._update = this._update.toBSON();
    }
    return this.mongooseCollection[op](castedQuery, this._update, options);
  }
  Query.prototype.validate = async function validate(castedDoc, options, isOverwriting) {
    if (typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.validate() no longer accepts a callback");
    }
    await _executePreHooks(this, "validate");
    if (isOverwriting) {
      await castedDoc.$validate();
    } else {
      await new Promise((resolve, reject) => {
        updateValidators(this, this.model.schema, castedDoc, options, (err2) => {
          if (err2 != null) {
            return reject(err2);
          }
          resolve();
        });
      });
    }
    await _executePostHooks(this, null, null, "validate");
  };
  Query.prototype._updateMany = async function _updateMany() {
    return _updateThunk.call(this, "updateMany");
  };
  Query.prototype._updateOne = async function _updateOne() {
    return _updateThunk.call(this, "updateOne");
  };
  Query.prototype._replaceOne = async function _replaceOne() {
    return _updateThunk.call(this, "replaceOne");
  };
  Query.prototype.updateMany = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    } else if (typeof doc === "function") {
      callback = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback = undefined;
    }
    return _update(this, "updateMany", conditions, doc, options, callback);
  };
  Query.prototype.updateOne = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    } else if (typeof doc === "function") {
      callback = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback = undefined;
    }
    return _update(this, "updateOne", conditions, doc, options, callback);
  };
  Query.prototype.replaceOne = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    } else if (typeof doc === "function") {
      callback = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback = undefined;
    }
    return _update(this, "replaceOne", conditions, doc, options, callback);
  };
  function _update(query, op, filter, doc, options, callback) {
    query.op = op;
    query._validateOp();
    doc = doc || {};
    if (options != null) {
      if ("strict" in options) {
        query._mongooseOptions.strict = options.strict;
      }
    }
    if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
      query.error(new ObjectParameterError(filter, "filter", op));
    } else {
      query.merge(filter);
    }
    if (utils.isObject(options)) {
      query.setOptions(options);
    }
    query._mergeUpdate(doc);
    if (callback) {
      query.exec(callback);
      return query;
    }
    return query;
  }
  Query.prototype.transform = function(fn) {
    this._transforms.push(fn);
    return this;
  };
  Query.prototype.orFail = function(err2) {
    this.transform((res) => {
      switch (this.op) {
        case "find":
          if (res.length === 0) {
            throw _orFailError(err2, this);
          }
          break;
        case "findOne":
          if (res == null) {
            throw _orFailError(err2, this);
          }
          break;
        case "replaceOne":
        case "updateMany":
        case "updateOne":
          if (res && res.matchedCount === 0) {
            throw _orFailError(err2, this);
          }
          break;
        case "findOneAndDelete":
        case "findOneAndUpdate":
        case "findOneAndReplace":
          if (this.options.includeResultMetadata && res != null && res.value == null) {
            throw _orFailError(err2, this);
          }
          if (!this.options.includeResultMetadata && res == null) {
            throw _orFailError(err2, this);
          }
          break;
        case "deleteMany":
        case "deleteOne":
          if (res.deletedCount === 0) {
            throw _orFailError(err2, this);
          }
          break;
        default:
          break;
      }
      return res;
    });
    return this;
  };
  function _orFailError(err2, query) {
    if (typeof err2 === "function") {
      err2 = err2.call(query);
    }
    if (err2 == null) {
      err2 = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
    }
    return err2;
  }
  Query.prototype.isPathSelectedInclusive = function(path) {
    return isPathSelectedInclusive(this._fields, path);
  };
  Query.prototype.exec = async function exec(op) {
    if (typeof op === "function" || arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.exec() no longer accepts a callback");
    }
    if (typeof op === "string") {
      this.op = op;
    }
    if (this.op == null) {
      throw new MongooseError("Query must have `op` before executing");
    }
    if (this.model == null) {
      throw new MongooseError("Query must have an associated model before executing");
    }
    const thunk = opToThunk.get(this.op);
    if (!thunk) {
      throw new MongooseError('Query has invalid `op`: "' + this.op + '"');
    }
    if (this.options && this.options.sort && typeof this.options.sort === "object" && this.options.sort.hasOwnProperty("")) {
      throw new Error('Invalid field "" passed to sort()');
    }
    if (this._executionStack != null) {
      let str = this.toString();
      if (str.length > 60) {
        str = str.slice(0, 60) + "...";
      }
      const err2 = new MongooseError("Query was already executed: " + str);
      if (!this.model.base.options.skipOriginalStackTraces) {
        err2.originalStack = this._executionStack;
      }
      throw err2;
    } else {
      this._executionStack = this.model.base.options.skipOriginalStackTraces ? true : new Error().stack;
    }
    let skipWrappedFunction = null;
    try {
      await _executePreExecHooks(this);
    } catch (err2) {
      if (err2 instanceof Kareem.skipWrappedFunction) {
        skipWrappedFunction = err2;
      } else {
        throw err2;
      }
    }
    let res;
    let error = null;
    try {
      await _executePreHooks(this);
      res = skipWrappedFunction ? skipWrappedFunction.args[0] : await this[thunk]();
      for (const fn of this._transforms) {
        res = fn(res);
      }
    } catch (err2) {
      if (err2 instanceof Kareem.skipWrappedFunction) {
        res = err2.args[0];
      } else {
        error = err2;
      }
      error = this.model.schema._transformDuplicateKeyError(error);
    }
    res = await _executePostHooks(this, res, error);
    await _executePostExecHooks(this);
    return res;
  };
  /*!
   * ignore
   */
  function _executePostExecHooks(query) {
    return new Promise((resolve, reject) => {
      query._hooks.execPost("exec", query, [], {}, (error) => {
        if (error) {
          return reject(error);
        }
        resolve();
      });
    });
  }
  /*!
   * ignore
   */
  function _executePostHooks(query, res, error, op) {
    if (query._queryMiddleware == null) {
      if (error != null) {
        throw error;
      }
      return res;
    }
    return new Promise((resolve, reject) => {
      const opts = error ? { error } : {};
      query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error2, res2) => {
        if (error2) {
          return reject(error2);
        }
        resolve(res2);
      });
    });
  }
  /*!
   * ignore
   */
  function _executePreExecHooks(query) {
    return new Promise((resolve, reject) => {
      query._hooks.execPre("exec", query, [], (error) => {
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  }
  /*!
   * ignore
   */
  function _executePreHooks(query, op) {
    if (query._queryMiddleware == null) {
      return;
    }
    return new Promise((resolve, reject) => {
      query._queryMiddleware.execPre(op || query.op, query, [], (error) => {
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  }
  Query.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
  };
  Query.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
  };
  Query.prototype.finally = function(onFinally) {
    return this.exec().finally(onFinally);
  };
  Query.prototype[Symbol.toStringTag] = function toString() {
    return `Query { ${this.op} }`;
  };
  Query.prototype.pre = function(fn) {
    this._hooks.pre("exec", fn);
    return this;
  };
  Query.prototype.post = function(fn) {
    this._hooks.post("exec", fn);
    return this;
  };
  Query.prototype._castUpdate = function _castUpdate(obj) {
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
    if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
      const _schema = Object.values(baseSchema.discriminators).find((discriminator) => discriminator.discriminatorMapping.value === obj[discriminatorKey]);
      if (_schema != null) {
        schema = _schema;
      }
    }
    let upsert;
    if ("upsert" in this.options) {
      upsert = this.options.upsert;
    }
    return castUpdate(schema, obj, {
      strict: this._mongooseOptions.strict,
      upsert,
      arrayFilters: this.options.arrayFilters,
      overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey,
      overwriteImmutable: this._mongooseOptions.overwriteImmutable
    }, this, this._conditions);
  };
  Query.prototype.populate = function() {
    const args = Array.from(arguments);
    if (!args.some(Boolean)) {
      return this;
    }
    const res = utils.populate.apply(null, args);
    if (this.options != null) {
      const readConcern = this.options.readConcern;
      const readPref = this.options.readPreference;
      for (const populateOptions of res) {
        if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.readConcern = readConcern;
        }
        if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.readPreference = readPref;
        }
      }
    }
    const opts = this._mongooseOptions;
    if (opts.lean != null) {
      const lean = opts.lean;
      for (const populateOptions of res) {
        if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.lean = lean;
        }
      }
    }
    if (!utils.isObject(opts.populate)) {
      opts.populate = {};
    }
    const pop = opts.populate;
    for (const populateOptions of res) {
      const path = populateOptions.path;
      if (pop[path] && pop[path].populate && populateOptions.populate) {
        populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
      }
      pop[populateOptions.path] = populateOptions;
    }
    return this;
  };
  Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
    const obj = this._mongooseOptions.populate || {};
    const ret = Object.keys(obj);
    for (const path of Object.keys(obj)) {
      const pop = obj[path];
      if (!Array.isArray(pop.populate)) {
        continue;
      }
      _getPopulatedPaths(ret, pop.populate, path + ".");
    }
    return ret;
  };
  /*!
   * ignore
   */
  function _getPopulatedPaths(list, arr, prefix) {
    for (const pop of arr) {
      list.push(prefix + pop.path);
      if (!Array.isArray(pop.populate)) {
        continue;
      }
      _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
    }
  }
  Query.prototype.cast = function(model, obj) {
    obj || (obj = this._conditions);
    model = model || this.model;
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
      model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
    }
    const opts = { upsert: this.options && this.options.upsert };
    if (this.options) {
      if ("strict" in this.options) {
        opts.strict = this.options.strict;
      }
      if ("strictQuery" in this.options) {
        opts.strictQuery = this.options.strictQuery;
      }
    }
    if ("sanitizeFilter" in this._mongooseOptions) {
      opts.sanitizeFilter = this._mongooseOptions.sanitizeFilter;
    }
    try {
      return cast2(model.schema, obj, opts, this);
    } catch (err2) {
      if (typeof err2.setModel === "function") {
        err2.setModel(model);
      }
      throw err2;
    }
  };
  Query.prototype._castFields = function _castFields(fields) {
    let selected, elemMatchKeys, keys, key, out;
    if (fields) {
      keys = Object.keys(fields);
      elemMatchKeys = [];
      for (let i = 0;i < keys.length; ++i) {
        key = keys[i];
        if (fields[key].$elemMatch) {
          selected || (selected = {});
          selected[key] = fields[key];
          elemMatchKeys.push(key);
        }
      }
    }
    if (selected) {
      try {
        out = this.cast(this.model, selected);
      } catch (err2) {
        return err2;
      }
      for (let i = 0;i < elemMatchKeys.length; ++i) {
        key = elemMatchKeys[i];
        fields[key] = out[key];
      }
    }
    return fields;
  };
  Query.prototype._applyPaths = function applyPaths() {
    if (!this.model) {
      return;
    }
    this._fields = this._fields || {};
    let sanitizeProjection2 = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.db.options.sanitizeProjection;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.base.options.sanitizeProjection;
    } else {
      sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
    }
    const schemaLevelProjections = this._mongooseOptions.schemaLevelProjections ?? true;
    if (schemaLevelProjections) {
      helpers.applyPaths(this._fields, this.model.schema, sanitizeProjection2);
    }
    let _selectPopulatedPaths = true;
    if ("selectPopulatedPaths" in this.model.base.options) {
      _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
    }
    if ("selectPopulatedPaths" in this.model.schema.options) {
      _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
    }
    if (_selectPopulatedPaths) {
      selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
    }
  };
  Query.prototype.cursor = function cursor(opts) {
    if (opts) {
      this.setOptions(opts);
    }
    try {
      this.cast(this.model);
    } catch (err2) {
      return new QueryCursor(this)._markError(err2);
    }
    return new QueryCursor(this);
  };
  Query.prototype.tailable = function(val, opts) {
    if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
      opts = val;
      val = true;
    }
    if (val === undefined) {
      val = true;
    }
    if (opts && typeof opts === "object") {
      for (const key of Object.keys(opts)) {
        if (key === "awaitData" || key === "awaitdata") {
          this.options["awaitData"] = !!opts[key];
        } else {
          this.options[key] = opts[key];
        }
      }
    }
    this.options.tailable = arguments.length ? !!val : true;
    return this;
  };
  Query.prototype.near = function() {
    const params = [];
    const sphere = this._mongooseOptions.nearSphere;
    if (arguments.length === 1) {
      if (Array.isArray(arguments[0])) {
        params.push({ center: arguments[0], spherical: sphere });
      } else if (typeof arguments[0] === "string") {
        params.push(arguments[0]);
      } else if (utils.isObject(arguments[0])) {
        if (typeof arguments[0].spherical !== "boolean") {
          arguments[0].spherical = sphere;
        }
        params.push(arguments[0]);
      } else {
        throw new TypeError("invalid argument");
      }
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
        params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
      } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
        params.push(arguments[0]);
        params.push({ center: arguments[1], spherical: sphere });
      } else if (typeof arguments[0] === "string" && utils.isObject(arguments[1])) {
        params.push(arguments[0]);
        if (typeof arguments[1].spherical !== "boolean") {
          arguments[1].spherical = sphere;
        }
        params.push(arguments[1]);
      } else {
        throw new TypeError("invalid argument");
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
        params.push(arguments[0]);
        params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
      } else {
        throw new TypeError("invalid argument");
      }
    } else {
      throw new TypeError("invalid argument");
    }
    return Query.base.near.apply(this, params);
  };
  Query.prototype.nearSphere = function() {
    this._mongooseOptions.nearSphere = true;
    this.near.apply(this, arguments);
    return this;
  };
  if (Symbol.asyncIterator != null) {
    Query.prototype[Symbol.asyncIterator] = function queryAsyncIterator() {
      this._mongooseOptions._asyncIterator = true;
      return this.cursor();
    };
  }
  Query.prototype.box = function(ll, ur) {
    if (!Array.isArray(ll) && utils.isObject(ll)) {
      ur = ll.ur;
      ll = ll.ll;
    }
    return Query.base.box.call(this, ll, ur);
  };
  Query.prototype.center = Query.base.circle;
  Query.prototype.centerSphere = function() {
    if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
      arguments[0].spherical = true;
    }
    if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
      arguments[1].spherical = true;
    }
    Query.base.circle.apply(this, arguments);
  };
  Query.prototype.selectedInclusively = function selectedInclusively() {
    return isInclusive(this._fields);
  };
  Query.prototype.selectedExclusively = function selectedExclusively() {
    return isExclusive(this._fields);
  };
  Query.prototype.model;
  /*!
   * Export
   */
  module.exports = Query;
});

// node_modules/mongoose/lib/cursor/aggregationCursor.js
var require_aggregationCursor = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var Readable2 = __require("stream").Readable;
  var eachAsync = require_eachAsync();
  var immediate = require_immediate();
  var kareem = require_kareem();
  var util3 = __require("util");
  function AggregationCursor(agg) {
    Readable2.call(this, { autoDestroy: true, objectMode: true });
    this.cursor = null;
    this.agg = agg;
    this._transforms = [];
    const connection = agg._connection;
    const model = agg._model;
    delete agg.options.cursor.useMongooseAggCursor;
    this._mongooseOptions = {};
    if (connection) {
      this.cursor = connection.db.aggregate(agg._pipeline, agg.options || {});
      setImmediate(() => this.emit("cursor", this.cursor));
    } else {
      _init(model, this, agg);
    }
  }
  util3.inherits(AggregationCursor, Readable2);
  /*!
   * ignore
   */
  function _init(model, c, agg) {
    if (!model.collection.buffer) {
      model.hooks.execPre("aggregate", agg, function(err2) {
        if (err2 != null) {
          _handlePreHookError(c, err2);
          return;
        }
        if (typeof agg.options?.cursor?.transform === "function") {
          c._transforms.push(agg.options.cursor.transform);
        }
        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
        c.emit("cursor", c.cursor);
      });
    } else {
      model.collection.emitter.once("queue", function() {
        model.hooks.execPre("aggregate", agg, function(err2) {
          if (err2 != null) {
            _handlePreHookError(c, err2);
            return;
          }
          if (typeof agg.options?.cursor?.transform === "function") {
            c._transforms.push(agg.options.cursor.transform);
          }
          c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      });
    }
  }
  function _handlePreHookError(queryCursor, err2) {
    if (err2 instanceof kareem.skipWrappedFunction) {
      const resultValue = err2.args[0];
      if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {
        const err3 = new MongooseError("Cannot `skipMiddlewareFunction()` with a value when using " + '`.aggregate().cursor()`, value must be nullish or empty array, got "' + util3.inspect(resultValue) + '".');
        queryCursor._markError(err3);
        queryCursor.listeners("error").length > 0 && queryCursor.emit("error", err3);
        return;
      }
      queryCursor.emit("cursor", null);
      return;
    }
    queryCursor._markError(err2);
    queryCursor.listeners("error").length > 0 && queryCursor.emit("error", err2);
  }
  AggregationCursor.prototype._read = function() {
    const _this = this;
    _next(this, function(error, doc) {
      if (error) {
        return _this.emit("error", error);
      }
      if (!doc) {
        _this.push(null);
        _this.cursor.close(function(error2) {
          if (error2) {
            return _this.emit("error", error2);
          }
        });
        return;
      }
      _this.push(doc);
    });
  };
  if (Symbol.asyncIterator != null) {
    const msg = "Mongoose does not support using async iterators with an " + "existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation";
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
      throw new MongooseError(msg);
    };
  }
  Object.defineProperty(AggregationCursor.prototype, "map", {
    value: function(fn) {
      this._transforms.push(fn);
      return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
  });
  AggregationCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
  };
  AggregationCursor.prototype.close = async function close() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("AggregationCursor.prototype.close() no longer accepts a callback");
    }
    try {
      await this.cursor.close();
    } catch (error) {
      this.listeners("error").length > 0 && this.emit("error", error);
      throw error;
    }
    this.emit("close");
  };
  AggregationCursor.prototype._destroy = function _destroy(_err, callback) {
    let waitForCursor = null;
    if (!this.cursor) {
      waitForCursor = new Promise((resolve) => {
        this.once("cursor", resolve);
      });
    } else {
      waitForCursor = Promise.resolve();
    }
    waitForCursor.then(() => this.cursor.close()).then(() => {
      this._closed = true;
      callback();
    }).catch((error) => {
      callback(error);
    });
    return this;
  };
  AggregationCursor.prototype.next = async function next() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("AggregationCursor.prototype.next() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      _next(this, (err2, res) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve(res);
      });
    });
  };
  AggregationCursor.prototype.eachAsync = function(fn, opts) {
    if (typeof arguments[2] === "function") {
      throw new MongooseError("AggregationCursor.prototype.eachAsync() no longer accepts a callback");
    }
    const _this = this;
    if (typeof opts === "function") {
      opts = {};
    }
    opts = opts || {};
    return eachAsync(function(cb) {
      return _next(_this, cb);
    }, fn, opts);
  };
  if (Symbol.asyncIterator != null) {
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
      return this.transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * ignore
   */
  AggregationCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
      this.map(_transformForAsyncIterator);
    }
    return this;
  };
  /*!
   * ignore
   */
  AggregationCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
      val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
  };
  /*!
   * ignore
   */
  function _transformForAsyncIterator(doc) {
    return doc == null ? { done: true } : { value: doc, done: false };
  }
  AggregationCursor.prototype.addCursorFlag = function(flag, value) {
    const _this = this;
    _waitForCursor(this, function() {
      _this.cursor.addCursorFlag(flag, value);
    });
    return this;
  };
  /*!
   * ignore
   */
  function _waitForCursor(ctx, cb) {
    if (ctx.cursor) {
      return cb();
    }
    ctx.once("cursor", function() {
      cb();
    });
  }
  function _next(ctx, cb) {
    let callback = cb;
    if (ctx._transforms.length) {
      callback = function(err2, doc) {
        if (err2 || doc === null && !ctx._mongooseOptions.transformNull) {
          return cb(err2, doc);
        }
        cb(err2, ctx._transforms.reduce(function(doc2, fn) {
          return fn(doc2);
        }, doc));
      };
    }
    if (ctx._error) {
      return immediate(function() {
        callback(ctx._error);
      });
    }
    if (ctx.cursor) {
      return ctx.cursor.next().then((doc) => {
        if (!doc) {
          return callback(null, null);
        }
        callback(null, doc);
      }, (err2) => callback(err2));
    } else {
      ctx.once("error", cb);
      ctx.once("cursor", function() {
        _next(ctx, cb);
      });
    }
  }
  module.exports = AggregationCursor;
});

// node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js
var require_prepareDiscriminatorPipeline = __commonJS((exports, module) => {
  module.exports = function prepareDiscriminatorPipeline(pipeline2, schema, prefix) {
    const discriminatorMapping = schema && schema.discriminatorMapping;
    prefix = prefix || "";
    if (discriminatorMapping && !discriminatorMapping.isRoot) {
      const originalPipeline = pipeline2;
      const filterKey = (prefix.length > 0 ? prefix + "." : prefix) + discriminatorMapping.key;
      const discriminatorValue = discriminatorMapping.value;
      if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {
        originalPipeline[0].$match[filterKey] = discriminatorValue;
      } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {
        originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
        originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;
      } else if (originalPipeline[0] != null && originalPipeline[0].$search) {
        if (originalPipeline[1] && originalPipeline[1].$match != null) {
          originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;
        } else {
          const match = {};
          match[filterKey] = discriminatorValue;
          originalPipeline.splice(1, 0, { $match: match });
        }
      } else {
        const match = {};
        match[filterKey] = discriminatorValue;
        originalPipeline.unshift({ $match: match });
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS((exports, module) => {
  module.exports = function stringifyFunctionOperators(pipeline2) {
    if (!Array.isArray(pipeline2)) {
      return;
    }
    for (const stage of pipeline2) {
      if (stage == null) {
        continue;
      }
      const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
      if (canHaveAccumulator != null) {
        for (const key of Object.keys(canHaveAccumulator)) {
          handleAccumulator(canHaveAccumulator[key]);
        }
      }
      const stageType = Object.keys(stage)[0];
      if (stageType && typeof stage[stageType] === "object") {
        const stageOptions = stage[stageType];
        for (const key of Object.keys(stageOptions)) {
          if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
            stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
          }
        }
      }
      if (stage.$facet != null) {
        for (const key of Object.keys(stage.$facet)) {
          stringifyFunctionOperators(stage.$facet[key]);
        }
      }
    }
  };
  function handleAccumulator(operator) {
    if (operator == null || operator.$accumulator == null) {
      return;
    }
    for (const key of ["init", "accumulate", "merge", "finalize"]) {
      if (typeof operator.$accumulator[key] === "function") {
        operator.$accumulator[key] = String(operator.$accumulator[key]);
      }
    }
  }
});

// node_modules/mongoose/lib/aggregate.js
var require_aggregate2 = __commonJS((exports, module) => {
  /*!
   * Module dependencies
   */
  var AggregationCursor = require_aggregationCursor();
  var MongooseError = require_mongooseError();
  var Query = require_query();
  var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
  var clone2 = require_clone();
  var getConstructorName = require_getConstructorName();
  var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
  var stringifyFunctionOperators = require_stringifyFunctionOperators();
  var utils = require_utils3();
  var { modelSymbol } = require_symbols();
  var read = Query.prototype.read;
  var readConcern = Query.prototype.readConcern;
  var validRedactStringValues = new Set(["$$DESCEND", "$$PRUNE", "$$KEEP"]);
  function Aggregate(pipeline2, modelOrConn) {
    this._pipeline = [];
    if (modelOrConn == null || modelOrConn[modelSymbol]) {
      this._model = modelOrConn;
    } else {
      this._connection = modelOrConn;
    }
    this.options = {};
    if (arguments.length === 1 && Array.isArray(pipeline2)) {
      this.append.apply(this, pipeline2);
    }
  }
  Aggregate.prototype.options;
  Aggregate.prototype._optionsForExec = function() {
    const options = this.options || {};
    const asyncLocalStorage = this.model()?.db?.base.transactionAsyncLocalStorage?.getStore();
    if (!options.hasOwnProperty("session") && asyncLocalStorage?.session != null) {
      options.session = asyncLocalStorage.session;
    }
    return options;
  };
  Aggregate.prototype.model = function(model) {
    if (arguments.length === 0) {
      return this._model;
    }
    this._model = model;
    if (model.schema != null) {
      if (this.options.readPreference == null && model.schema.options.read != null) {
        this.options.readPreference = model.schema.options.read;
      }
      if (this.options.collation == null && model.schema.options.collation != null) {
        this.options.collation = model.schema.options.collation;
      }
    }
    return model;
  };
  Aggregate.prototype.append = function() {
    const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [...arguments];
    if (!args.every(isOperator)) {
      throw new Error("Arguments must be aggregate pipeline operators");
    }
    this._pipeline = this._pipeline.concat(args);
    return this;
  };
  Aggregate.prototype.addFields = function(arg) {
    if (typeof arg !== "object" || arg === null || Array.isArray(arg)) {
      throw new Error("Invalid addFields() argument. Must be an object");
    }
    return this.append({ $addFields: Object.assign({}, arg) });
  };
  Aggregate.prototype.project = function(arg) {
    const fields = {};
    if (typeof arg === "object" && !Array.isArray(arg)) {
      Object.keys(arg).forEach(function(field) {
        fields[field] = arg[field];
      });
    } else if (arguments.length === 1 && typeof arg === "string") {
      arg.split(/\s+/).forEach(function(field) {
        if (!field) {
          return;
        }
        const include = field[0] === "-" ? 0 : 1;
        if (include === 0) {
          field = field.substring(1);
        }
        fields[field] = include;
      });
    } else {
      throw new Error("Invalid project() argument. Must be string or object");
    }
    return this.append({ $project: fields });
  };
  Aggregate.prototype.near = function(arg) {
    if (arg == null) {
      throw new MongooseError("Aggregate `near()` must be called with non-nullish argument");
    }
    if (arg.near == null) {
      throw new MongooseError("Aggregate `near()` argument must have a `near` property");
    }
    const coordinates = Array.isArray(arg.near) ? arg.near : arg.near.coordinates;
    if (typeof arg.near === "object" && (!Array.isArray(coordinates) || coordinates.length < 2 || coordinates.find((c) => typeof c !== "number"))) {
      throw new MongooseError(`Aggregate \`near()\` argument has invalid coordinates, got "${coordinates}"`);
    }
    const op = {};
    op.$geoNear = arg;
    return this.append(op);
  };
  /*!
   * define methods
   */
  "group match skip limit out densify fill".split(" ").forEach(function($operator) {
    Aggregate.prototype[$operator] = function(arg) {
      const op = {};
      op["$" + $operator] = arg;
      return this.append(op);
    };
  });
  Aggregate.prototype.unwind = function() {
    const args = [...arguments];
    const res = [];
    for (const arg of args) {
      if (arg && typeof arg === "object") {
        res.push({ $unwind: arg });
      } else if (typeof arg === "string") {
        res.push({
          $unwind: arg[0] === "$" ? arg : "$" + arg
        });
      } else {
        throw new Error('Invalid arg "' + arg + '" to unwind(), ' + "must be string or object");
      }
    }
    return this.append.apply(this, res);
  };
  Aggregate.prototype.replaceRoot = function(newRoot) {
    let ret;
    if (typeof newRoot === "string") {
      ret = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
    } else {
      ret = newRoot;
    }
    return this.append({
      $replaceRoot: {
        newRoot: ret
      }
    });
  };
  Aggregate.prototype.count = function(fieldName) {
    return this.append({ $count: fieldName });
  };
  Aggregate.prototype.sortByCount = function(arg) {
    if (arg && typeof arg === "object") {
      return this.append({ $sortByCount: arg });
    } else if (typeof arg === "string") {
      return this.append({
        $sortByCount: arg[0] === "$" ? arg : "$" + arg
      });
    } else {
      throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), ' + "must be string or object");
    }
  };
  Aggregate.prototype.lookup = function(options) {
    return this.append({ $lookup: options });
  };
  Aggregate.prototype.graphLookup = function(options) {
    const cloneOptions = {};
    if (options) {
      if (!utils.isObject(options)) {
        throw new TypeError("Invalid graphLookup() argument. Must be an object.");
      }
      utils.mergeClone(cloneOptions, options);
      const startWith = cloneOptions.startWith;
      if (startWith && typeof startWith === "string") {
        cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
      }
    }
    return this.append({ $graphLookup: cloneOptions });
  };
  Aggregate.prototype.sample = function(size) {
    return this.append({ $sample: { size } });
  };
  Aggregate.prototype.sort = function(arg) {
    const sort = {};
    if (getConstructorName(arg) === "Object") {
      const desc = ["desc", "descending", -1];
      Object.keys(arg).forEach(function(field) {
        if (arg[field] instanceof Object && arg[field].$meta) {
          sort[field] = arg[field];
          return;
        }
        sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
      });
    } else if (arguments.length === 1 && typeof arg === "string") {
      arg.split(/\s+/).forEach(function(field) {
        if (!field) {
          return;
        }
        const ascend = field[0] === "-" ? -1 : 1;
        if (ascend === -1) {
          field = field.substring(1);
        }
        sort[field] = ascend;
      });
    } else {
      throw new TypeError("Invalid sort() argument. Must be a string or object.");
    }
    return this.append({ $sort: sort });
  };
  Aggregate.prototype.unionWith = function(options) {
    return this.append({ $unionWith: options });
  };
  Aggregate.prototype.read = function(pref, tags) {
    read.call(this, pref, tags);
    return this;
  };
  Aggregate.prototype.readConcern = function(level) {
    readConcern.call(this, level);
    return this;
  };
  Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
    if (arguments.length === 3) {
      if (typeof thenExpr === "string" && !validRedactStringValues.has(thenExpr) || typeof elseExpr === "string" && !validRedactStringValues.has(elseExpr)) {
        throw new Error("If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP");
      }
      expression = {
        $cond: {
          if: expression,
          then: thenExpr,
          else: elseExpr
        }
      };
    } else if (arguments.length !== 1) {
      throw new TypeError("Invalid arguments");
    }
    return this.append({ $redact: expression });
  };
  Aggregate.prototype.explain = async function explain(verbosity) {
    if (typeof verbosity === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Aggregate.prototype.explain() no longer accepts a callback");
    }
    const model = this._model;
    if (!this._pipeline.length) {
      throw new Error("Aggregate has empty pipeline");
    }
    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
    await new Promise((resolve, reject) => {
      model.hooks.execPre("aggregate", this, (error) => {
        if (error) {
          const _opts2 = { error };
          return model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
            reject(error2);
          });
        } else {
          resolve();
        }
      });
    });
    const cursor = model.collection.aggregate(this._pipeline, this.options);
    if (verbosity == null) {
      verbosity = true;
    }
    let result = null;
    try {
      result = await cursor.explain(verbosity);
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts2 = { error };
        model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
          if (error2) {
            return reject(error2);
          }
          return resolve();
        });
      });
    }
    const _opts = { error: null };
    await new Promise((resolve, reject) => {
      model.hooks.execPost("aggregate", this, [result], _opts, (error) => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
    return result;
  };
  Aggregate.prototype.allowDiskUse = function(value) {
    this.options.allowDiskUse = value;
    return this;
  };
  Aggregate.prototype.hint = function(value) {
    this.options.hint = value;
    return this;
  };
  Aggregate.prototype.session = function(session) {
    if (session == null) {
      delete this.options.session;
    } else {
      this.options.session = session;
    }
    return this;
  };
  Aggregate.prototype.option = function(value) {
    for (const key in value) {
      this.options[key] = value[key];
    }
    return this;
  };
  Aggregate.prototype.cursor = function(options) {
    this._optionsForExec();
    this.options.cursor = options || {};
    return new AggregationCursor(this);
  };
  Aggregate.prototype.collation = function(collation) {
    this.options.collation = collation;
    return this;
  };
  Aggregate.prototype.facet = function(options) {
    return this.append({ $facet: options });
  };
  Aggregate.prototype.search = function(options) {
    return this.append({ $search: options });
  };
  Aggregate.prototype.pipeline = function() {
    return this._pipeline;
  };
  Aggregate.prototype.exec = async function exec() {
    if (!this._model && !this._connection) {
      throw new Error("Aggregate not bound to any Model");
    }
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Aggregate.prototype.exec() no longer accepts a callback");
    }
    if (this._connection) {
      if (!this._pipeline.length) {
        throw new MongooseError("Aggregate has empty pipeline");
      }
      this._optionsForExec();
      const cursor = await this._connection.client.db().aggregate(this._pipeline, this.options);
      return await cursor.toArray();
    }
    const model = this._model;
    const collection = this._model.collection;
    applyGlobalMaxTimeMS(this.options, model.db.options, model.base.options);
    applyGlobalDiskUse(this.options, model.db.options, model.base.options);
    this._optionsForExec();
    if (this.options && this.options.cursor) {
      return new AggregationCursor(this);
    }
    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
    stringifyFunctionOperators(this._pipeline);
    await new Promise((resolve, reject) => {
      model.hooks.execPre("aggregate", this, (error) => {
        if (error) {
          const _opts2 = { error };
          return model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
            reject(error2);
          });
        } else {
          resolve();
        }
      });
    });
    if (!this._pipeline.length) {
      throw new MongooseError("Aggregate has empty pipeline");
    }
    const options = clone2(this.options || {});
    let result;
    try {
      const cursor = await collection.aggregate(this._pipeline, options);
      result = await cursor.toArray();
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts2 = { error };
        model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
          if (error2) {
            return reject(error2);
          }
          resolve();
        });
      });
    }
    const _opts = { error: null };
    await new Promise((resolve, reject) => {
      model.hooks.execPost("aggregate", this, [result], _opts, (error) => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
    return result;
  };
  Aggregate.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
  };
  Aggregate.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
  };
  Aggregate.prototype.finally = function(onFinally) {
    return this.exec().finally(onFinally);
  };
  if (Symbol.asyncIterator != null) {
    Aggregate.prototype[Symbol.asyncIterator] = function() {
      return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * Helpers
   */
  function isOperator(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const k = Object.keys(obj);
    return k.length === 1 && k[0][0] === "$";
  }
  Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
  /*!
   * Exports
   */
  module.exports = Aggregate;
});

// node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS((exports, module) => {
  var clone2 = require_clone();

  class SaveOptions {
    constructor(obj) {
      if (obj == null) {
        return;
      }
      Object.assign(this, clone2(obj));
    }
  }
  SaveOptions.prototype.__subdocs = null;
  module.exports = SaveOptions;
});

// node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js
var require_applyDefaultsToPOJO = __commonJS((exports, module) => {
  module.exports = function applyDefaultsToPOJO(doc, schema) {
    const paths = Object.keys(schema.paths);
    const plen = paths.length;
    for (let i = 0;i < plen; ++i) {
      let curPath = "";
      const p = paths[i];
      const type = schema.paths[p];
      const path = type.splitPath();
      const len = path.length;
      let doc_ = doc;
      for (let j = 0;j < len; ++j) {
        if (doc_ == null) {
          break;
        }
        const piece = path[j];
        curPath += (!curPath.length ? "" : ".") + piece;
        if (j === len - 1) {
          if (typeof doc_[piece] !== "undefined") {
            if (type.$isSingleNested) {
              applyDefaultsToPOJO(doc_[piece], type.caster.schema);
            } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {
              doc_[piece].forEach((el) => applyDefaultsToPOJO(el, type.schema));
            }
            break;
          }
          const def = type.getDefault(doc, false, { skipCast: true });
          if (typeof def !== "undefined") {
            doc_[piece] = def;
            if (type.$isSingleNested) {
              applyDefaultsToPOJO(def, type.caster.schema);
            } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {
              def.forEach((el) => applyDefaultsToPOJO(el, type.schema));
            }
          }
        } else {
          if (doc_[piece] == null) {
            doc_[piece] = {};
          }
          doc_ = doc_[piece];
        }
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js
var require_applyEmbeddedDiscriminators = __commonJS((exports, module) => {
  module.exports = applyEmbeddedDiscriminators;
  function applyEmbeddedDiscriminators(schema, seen = new WeakSet, overwriteExisting = false) {
    if (seen.has(schema)) {
      return;
    }
    seen.add(schema);
    for (const path of Object.keys(schema.paths)) {
      const schemaType = schema.paths[path];
      if (!schemaType.schema) {
        continue;
      }
      applyEmbeddedDiscriminators(schemaType.schema, seen);
      if (!schemaType.schema._applyDiscriminators) {
        continue;
      }
      if (schemaType._appliedDiscriminators && !overwriteExisting) {
        continue;
      }
      for (const discriminatorKey of schemaType.schema._applyDiscriminators.keys()) {
        const {
          schema: discriminatorSchema,
          options
        } = schemaType.schema._applyDiscriminators.get(discriminatorKey);
        applyEmbeddedDiscriminators(discriminatorSchema, seen);
        schemaType.discriminator(discriminatorKey, discriminatorSchema, overwriteExisting ? { ...options, overwriteExisting: true } : options);
      }
      schemaType._appliedDiscriminators = true;
    }
  }
});

// node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS((exports, module) => {
  var get = require_get();
  var utils = require_utils3();
  module.exports = function applyMethods(model, schema) {
    const Model = require_model();
    function apply(method, schema2) {
      Object.defineProperty(model.prototype, method, {
        get: function() {
          const h = {};
          for (const k in schema2.methods[method]) {
            h[k] = schema2.methods[method][k].bind(this);
          }
          return h;
        },
        configurable: true
      });
    }
    for (const method of Object.keys(schema.methods)) {
      const fn = schema.methods[method];
      if (schema.tree.hasOwnProperty(method)) {
        throw new Error("You have a method and a property in your schema both " + 'named "' + method + '"');
      }
      if (typeof fn === "function" && Model.prototype[method] === fn) {
        delete schema.methods[method];
        continue;
      }
      if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
        utils.warn(`mongoose: the method name "${method}" is used by mongoose ` + "internally, overwriting it may cause bugs. If you're sure you know " + "what you're doing, you can suppress this error by using " + `\`schema.method('${method}', fn, { suppressWarning: true })\`.`);
      }
      if (typeof fn === "function") {
        model.prototype[method] = fn;
      } else {
        apply(method, schema);
      }
    }
    model.$appliedMethods = true;
    for (const key of Object.keys(schema.paths)) {
      const type = schema.paths[key];
      if (type.$isSingleNested && !type.caster.$appliedMethods) {
        applyMethods(type.caster, type.schema);
      }
      if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
        applyMethods(type.Constructor, type.schema);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/projection/applyProjection.js
var require_applyProjection = __commonJS((exports, module) => {
  var hasIncludedChildren = require_hasIncludedChildren();
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  var isPOJO = require_utils3().isPOJO;
  module.exports = function applyProjection(doc, projection, _hasIncludedChildren) {
    if (projection == null) {
      return doc;
    }
    if (doc == null) {
      return doc;
    }
    let exclude = null;
    if (isInclusive(projection)) {
      exclude = false;
    } else if (isExclusive(projection)) {
      exclude = true;
    }
    if (exclude == null) {
      return doc;
    } else if (exclude) {
      _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
      return applyExclusiveProjection(doc, projection, _hasIncludedChildren);
    } else {
      _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
      return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
    }
  };
  function applyExclusiveProjection(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
      return doc;
    }
    if (Array.isArray(doc)) {
      return doc.map((el) => applyExclusiveProjection(el, projection, hasIncludedChildren2, projectionLimb, prefix));
    }
    const ret = { ...doc };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)) {
      const fullPath = prefix ? prefix + "." + key : key;
      if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
        if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
          ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        } else {
          delete ret[key];
        }
      } else if (hasIncludedChildren2[fullPath]) {
        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
      }
    }
    return ret;
  }
  function applyInclusiveProjection(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
      return doc;
    }
    if (Array.isArray(doc)) {
      return doc.map((el) => applyInclusiveProjection(el, projection, hasIncludedChildren2, projectionLimb, prefix));
    }
    const ret = { ...doc };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)) {
      const fullPath = prefix ? prefix + "." + key : key;
      if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
        if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
          ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        }
        continue;
      } else if (hasIncludedChildren2[fullPath]) {
        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
      } else {
        delete ret[key];
      }
    }
    return ret;
  }
});

// node_modules/mongoose/lib/helpers/indexes/isTextIndex.js
var require_isTextIndex = __commonJS((exports, module) => {
  module.exports = function isTextIndex(indexKeys) {
    let isTextIndex = false;
    for (const key of Object.keys(indexKeys)) {
      if (indexKeys[key] === "text") {
        isTextIndex = true;
      }
    }
    return isTextIndex;
  };
});

// node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js
var require_applySchemaCollation = __commonJS((exports, module) => {
  var isTextIndex = require_isTextIndex();
  module.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {
    if (isTextIndex(indexKeys)) {
      return;
    }
    if (schemaOptions.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation")) {
      indexOptions.collation = schemaOptions.collation;
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS((exports, module) => {
  var promiseOrCallback = require_promiseOrCallback();
  var { queryMiddlewareFunctions, aggregateMiddlewareFunctions, modelMiddlewareFunctions, documentMiddlewareFunctions } = require_constants3();
  var middlewareFunctions = Array.from(new Set([
    ...queryMiddlewareFunctions,
    ...aggregateMiddlewareFunctions,
    ...modelMiddlewareFunctions,
    ...documentMiddlewareFunctions
  ]));
  module.exports = function applyStaticHooks(model, hooks, statics) {
    const kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1
    };
    model.$__insertMany = hooks.createWrapper("insertMany", model.$__insertMany, model, kareemOptions);
    hooks = hooks.filter((hook) => {
      if (middlewareFunctions.indexOf(hook.name) !== -1) {
        return !!hook.model;
      }
      return hook.model !== false;
    });
    for (const key of Object.keys(statics)) {
      if (hooks.hasHooks(key)) {
        const original = model[key];
        model[key] = function() {
          const numArgs = arguments.length;
          const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
          const cb = typeof lastArg === "function" ? lastArg : null;
          const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
          return promiseOrCallback(cb, (callback) => {
            hooks.execPre(key, model, args, function(err2) {
              if (err2 != null) {
                return callback(err2);
              }
              let postCalled = 0;
              const ret = original.apply(model, args.concat(post));
              if (ret != null && typeof ret.then === "function") {
                ret.then((res) => post(null, res), (err3) => post(err3));
              }
              function post(error, res) {
                if (postCalled++ > 0) {
                  return;
                }
                if (error != null) {
                  return callback(error);
                }
                hooks.execPost(key, model, [res], function(error2) {
                  if (error2 != null) {
                    return callback(error2);
                  }
                  callback(null, res);
                });
              }
            });
          }, model.events);
        };
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS((exports, module) => {
  module.exports = function applyStatics(model, schema) {
    for (const i in schema.statics) {
      model[i] = schema.statics[i];
    }
  };
});

// node_modules/mongoose/lib/helpers/document/applyTimestamps.js
var require_applyTimestamps = __commonJS((exports, module) => {
  var handleTimestampOption = require_handleTimestampOption();
  var mpath = require_mpath();
  module.exports = applyTimestamps;
  function applyTimestamps(schema, obj, options) {
    if (obj == null) {
      return obj;
    }
    applyTimestampsToChildren(schema, obj, options);
    return applyTimestampsToDoc(schema, obj, options);
  }
  function applyTimestampsToChildren(schema, res, options) {
    for (const childSchema of schema.childSchemas) {
      const _path = childSchema.model.path;
      const _schema = childSchema.schema;
      if (!_path) {
        continue;
      }
      const _obj = mpath.get(_path, res);
      if (_obj == null || Array.isArray(_obj) && _obj.flat(Infinity).length === 0) {
        continue;
      }
      applyTimestamps(_schema, _obj, options);
    }
  }
  function applyTimestampsToDoc(schema, obj, options) {
    if (obj == null || typeof obj !== "object") {
      return;
    }
    if (Array.isArray(obj)) {
      for (const el of obj) {
        applyTimestampsToDoc(schema, el, options);
      }
      return;
    }
    if (schema.discriminators && Object.keys(schema.discriminators).length > 0) {
      for (const discriminatorKey of Object.keys(schema.discriminators)) {
        const discriminator = schema.discriminators[discriminatorKey];
        const key = discriminator.discriminatorMapping.key;
        const value = discriminator.discriminatorMapping.value;
        if (obj[key] == value) {
          schema = discriminator;
          break;
        }
      }
    }
    const createdAt = handleTimestampOption(schema.options.timestamps, "createdAt");
    const updatedAt = handleTimestampOption(schema.options.timestamps, "updatedAt");
    const currentTime = options?.currentTime;
    let ts = null;
    if (currentTime != null) {
      ts = currentTime();
    } else if (schema.base?.now) {
      ts = schema.base.now();
    } else {
      ts = new Date;
    }
    if (createdAt && obj[createdAt] == null && !options?.isUpdate) {
      obj[createdAt] = ts;
    }
    if (updatedAt) {
      obj[updatedAt] = ts;
    }
  }
});

// node_modules/mongoose/lib/helpers/document/applyVirtuals.js
var require_applyVirtuals = __commonJS((exports, module) => {
  var mpath = require_mpath();
  module.exports = applyVirtuals;
  function applyVirtuals(schema, obj, virtuals) {
    if (obj == null) {
      return obj;
    }
    let virtualsForChildren = virtuals;
    let toApply = null;
    if (Array.isArray(virtuals)) {
      virtualsForChildren = [];
      toApply = [];
      for (const virtual of virtuals) {
        if (virtual.length === 1) {
          toApply.push(virtual[0]);
        } else {
          virtualsForChildren.push(virtual);
        }
      }
    }
    applyVirtualsToChildren(schema, obj, virtualsForChildren);
    return applyVirtualsToDoc(schema, obj, toApply);
  }
  function applyVirtualsToChildren(schema, res, virtuals) {
    let attachedVirtuals = false;
    for (const childSchema of schema.childSchemas) {
      const _path = childSchema.model.path;
      const _schema = childSchema.schema;
      if (!_path) {
        continue;
      }
      const _obj = mpath.get(_path, res);
      if (_obj == null || Array.isArray(_obj) && _obj.flat(Infinity).length === 0) {
        continue;
      }
      let virtualsForChild = null;
      if (Array.isArray(virtuals)) {
        virtualsForChild = [];
        for (const virtual of virtuals) {
          if (virtual[0] == _path) {
            virtualsForChild.push(virtual.slice(1));
          }
        }
        if (virtualsForChild.length === 0) {
          continue;
        }
      }
      applyVirtuals(_schema, _obj, virtualsForChild);
      attachedVirtuals = true;
    }
    if (virtuals && virtuals.length && !attachedVirtuals) {
      applyVirtualsToDoc(schema, res, virtuals);
    }
  }
  function applyVirtualsToDoc(schema, obj, virtuals) {
    if (obj == null || typeof obj !== "object") {
      return;
    }
    if (Array.isArray(obj)) {
      for (const el of obj) {
        applyVirtualsToDoc(schema, el, virtuals);
      }
      return;
    }
    if (schema.discriminators && Object.keys(schema.discriminators).length > 0) {
      for (const discriminatorKey of Object.keys(schema.discriminators)) {
        const discriminator = schema.discriminators[discriminatorKey];
        const key = discriminator.discriminatorMapping.key;
        const value = discriminator.discriminatorMapping.value;
        if (obj[key] == value) {
          schema = discriminator;
          break;
        }
      }
    }
    if (virtuals == null) {
      virtuals = Object.keys(schema.virtuals);
    }
    for (const virtual of virtuals) {
      if (schema.virtuals[virtual] == null) {
        continue;
      }
      const virtualType = schema.virtuals[virtual];
      const sp = Array.isArray(virtual) ? virtual : virtual.indexOf(".") === -1 ? [virtual] : virtual.split(".");
      let cur = obj;
      for (let i = 0;i < sp.length - 1; ++i) {
        cur[sp[i]] = sp[i] in cur ? cur[sp[i]] : {};
        cur = cur[sp[i]];
      }
      let val = virtualType.applyGetters(cur[sp[sp.length - 1]], obj);
      const isPopulateVirtual = virtualType.options && (virtualType.options.ref || virtualType.options.refPath);
      if (isPopulateVirtual && val === undefined) {
        if (virtualType.options.justOne) {
          val = null;
        } else {
          val = [];
        }
      }
      cur[sp[sp.length - 1]] = val;
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js
var require_skipPopulateValue = __commonJS((exports, module) => {
  module.exports = function SkipPopulateValue(val) {
    if (!(this instanceof SkipPopulateValue)) {
      return new SkipPopulateValue(val);
    }
    this.val = val;
    return this;
  };
});

// node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = new WeakMap;
});

// node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS((exports, module) => {
  var clone2 = require_clone();
  var leanPopulateMap = require_leanPopulateMap();
  var modelSymbol = require_symbols().modelSymbol;
  var utils = require_utils3();
  module.exports = assignRawDocsToIdStructure;
  var kHasArray = Symbol("mongoose#assignRawDocsToIdStructure#hasArray");
  function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {
    const newOrder = [];
    const sorting = options.isVirtual && options.justOne && rawIds.length > 1 ? false : options.sort && rawIds.length > 1;
    const nullIfNotFound = options.$nullIfNotFound;
    let doc;
    let sid;
    let id;
    if (utils.isMongooseArray(rawIds)) {
      rawIds = rawIds.__array;
    }
    let i = 0;
    const len = rawIds.length;
    if (sorting && recursed && options[kHasArray] === undefined) {
      options[kHasArray] = false;
      for (const key in resultOrder) {
        if (Array.isArray(resultOrder[key])) {
          options[kHasArray] = true;
          break;
        }
      }
    }
    for (i = 0;i < len; ++i) {
      id = rawIds[i];
      if (Array.isArray(id)) {
        assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
        newOrder.push(id);
        continue;
      }
      if (id === null && sorting === false) {
        newOrder.push(id);
        continue;
      }
      if (id?.constructor?.name === "Binary" && id.sub_type === 4 && typeof id.toUUID === "function") {
        sid = String(id.toUUID());
      } else if (id?.constructor?.name === "Buffer" && id._subtype === 4 && typeof id.toUUID === "function") {
        sid = String(id.toUUID());
      } else {
        sid = String(id);
      }
      doc = resultDocs[sid];
      if (options.clone && doc != null) {
        if (options.lean) {
          const _model = leanPopulateMap.get(doc);
          doc = clone2(doc);
          leanPopulateMap.set(doc, _model);
        } else {
          doc = doc.constructor.hydrate(doc._doc);
        }
      }
      if (recursed) {
        if (doc) {
          if (sorting) {
            const _resultOrder = resultOrder[sid];
            if (options[kHasArray]) {
              newOrder.push(doc);
            } else {
              newOrder[_resultOrder] = doc;
            }
          } else {
            newOrder.push(doc);
          }
        } else if (id != null && id[modelSymbol] != null) {
          newOrder.push(id);
        } else {
          newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
        }
      } else {
        newOrder[i] = doc || null;
      }
    }
    rawIds.length = 0;
    if (newOrder.length) {
      newOrder.forEach(function(doc2, i2) {
        rawIds[i2] = doc2;
      });
    }
  }
});

// node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS((exports, module) => {
  module.exports = getVirtual;
  /*!
   * ignore
   */
  function getVirtual(schema, name) {
    if (schema.virtuals[name]) {
      return { virtual: schema.virtuals[name], path: undefined };
    }
    const parts = name.split(".");
    let cur = "";
    let nestedSchemaPath = "";
    for (let i = 0;i < parts.length; ++i) {
      cur += (cur.length > 0 ? "." : "") + parts[i];
      if (schema.virtuals[cur]) {
        if (i === parts.length - 1) {
          return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
        }
        continue;
      }
      if (schema.nested[cur]) {
        continue;
      }
      if (schema.paths[cur] && schema.paths[cur].schema) {
        schema = schema.paths[cur].schema;
        const rest = parts.slice(i + 1).join(".");
        if (schema.virtuals[rest]) {
          if (i === parts.length - 2) {
            return {
              virtual: schema.virtuals[rest],
              nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
            };
          }
          continue;
        }
        if (i + 1 < parts.length && schema.discriminators) {
          for (const key of Object.keys(schema.discriminators)) {
            const res = getVirtual(schema.discriminators[key], rest);
            if (res != null) {
              const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
              return {
                virtual: res.virtual,
                nestedSchemaPath: _path
              };
            }
          }
        }
        nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
        cur = "";
        continue;
      } else if (schema.paths[cur]?.$isSchemaMap && schema.paths[cur].$__schemaType?.schema) {
        schema = schema.paths[cur].$__schemaType.schema;
        ++i;
        const rest = parts.slice(i + 1).join(".");
        if (schema.virtuals[rest]) {
          if (i === parts.length - 2) {
            return {
              virtual: schema.virtuals[rest],
              nestedSchemaPath: [nestedSchemaPath, cur, "$*"].filter((v) => !!v).join(".")
            };
          }
          continue;
        }
        if (i + 1 < parts.length && schema.discriminators) {
          for (const key of Object.keys(schema.discriminators)) {
            const res = getVirtual(schema.discriminators[key], rest);
            if (res != null) {
              const _path = [nestedSchemaPath, cur, res.nestedSchemaPath, "$*"].filter((v) => !!v).join(".");
              return {
                virtual: res.virtual,
                nestedSchemaPath: _path
              };
            }
          }
        }
        nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + "$*" + cur;
        cur = "";
      }
      if (schema.discriminators) {
        for (const discriminatorKey of Object.keys(schema.discriminators)) {
          const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
          if (virtualFromDiscriminator)
            return virtualFromDiscriminator;
        }
      }
      return null;
    }
  }
});

// node_modules/sift/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sift = {}));
  })(exports, function(exports2) {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }
    typeof SuppressedError === "function" && SuppressedError;
    var typeChecker = function(type) {
      var typeString = "[object " + type + "]";
      return function(value) {
        return getClassName(value) === typeString;
      };
    };
    var getClassName = function(value) {
      return Object.prototype.toString.call(value);
    };
    var comparable = function(value) {
      if (value instanceof Date) {
        return value.getTime();
      } else if (isArray(value)) {
        return value.map(comparable);
      } else if (value && typeof value.toJSON === "function") {
        return value.toJSON();
      }
      return value;
    };
    var coercePotentiallyNull = function(value) {
      return value == null ? null : value;
    };
    var isArray = typeChecker("Array");
    var isObject2 = typeChecker("Object");
    var isFunction = typeChecker("Function");
    var isProperty = function(item, key) {
      return item.hasOwnProperty(key) && !isFunction(item[key]);
    };
    var isVanillaObject = function(value) {
      return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
    };
    var equals = function(a12, b) {
      if (a12 == null && a12 == b) {
        return true;
      }
      if (a12 === b) {
        return true;
      }
      if (Object.prototype.toString.call(a12) !== Object.prototype.toString.call(b)) {
        return false;
      }
      if (isArray(a12)) {
        if (a12.length !== b.length) {
          return false;
        }
        for (var i = 0, length_1 = a12.length;i < length_1; i++) {
          if (!equals(a12[i], b[i]))
            return false;
        }
        return true;
      } else if (isObject2(a12)) {
        if (Object.keys(a12).length !== Object.keys(b).length) {
          return false;
        }
        for (var key in a12) {
          if (!equals(a12[key], b[key]))
            return false;
        }
        return true;
      }
      return false;
    };
    var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
      var currentKey = keyPath[depth];
      if (isArray(item) && isNaN(Number(currentKey)) && !isProperty(item, currentKey)) {
        for (var i = 0, length_1 = item.length;i < length_1; i++) {
          if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
            return false;
          }
        }
      }
      if (depth === keyPath.length || item == null) {
        return next(item, key, owner, depth === 0, depth === keyPath.length);
      }
      return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
    };
    var BaseOperation = function() {
      function BaseOperation2(params, owneryQuery, options, name) {
        this.params = params;
        this.owneryQuery = owneryQuery;
        this.options = options;
        this.name = name;
        this.init();
      }
      BaseOperation2.prototype.init = function() {
      };
      BaseOperation2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
      };
      return BaseOperation2;
    }();
    var GroupOperation = function(_super) {
      __extends(GroupOperation2, _super);
      function GroupOperation2(params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options) || this;
        _this.children = children;
        return _this;
      }
      GroupOperation2.prototype.reset = function() {
        this.keep = false;
        this.done = false;
        for (var i = 0, length_2 = this.children.length;i < length_2; i++) {
          this.children[i].reset();
        }
      };
      GroupOperation2.prototype.childrenNext = function(item, key, owner, root, leaf) {
        var done = true;
        var keep = true;
        for (var i = 0, length_3 = this.children.length;i < length_3; i++) {
          var childOperation = this.children[i];
          if (!childOperation.done) {
            childOperation.next(item, key, owner, root, leaf);
          }
          if (!childOperation.keep) {
            keep = false;
          }
          if (childOperation.done) {
            if (!childOperation.keep) {
              break;
            }
          } else {
            done = false;
          }
        }
        this.done = done;
        this.keep = keep;
      };
      return GroupOperation2;
    }(BaseOperation);
    var NamedGroupOperation = function(_super) {
      __extends(NamedGroupOperation2, _super);
      function NamedGroupOperation2(params, owneryQuery, options, children, name) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.name = name;
        return _this;
      }
      return NamedGroupOperation2;
    }(GroupOperation);
    var QueryOperation = function(_super) {
      __extends(QueryOperation2, _super);
      function QueryOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      QueryOperation2.prototype.next = function(item, key, parent, root) {
        this.childrenNext(item, key, parent, root);
      };
      return QueryOperation2;
    }(GroupOperation);
    var NestedOperation = function(_super) {
      __extends(NestedOperation2, _super);
      function NestedOperation2(keyPath, params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.keyPath = keyPath;
        _this.propop = true;
        _this._nextNestedValue = function(value, key, owner, root, leaf) {
          _this.childrenNext(value, key, owner, root, leaf);
          return !_this.done;
        };
        return _this;
      }
      NestedOperation2.prototype.next = function(item, key, parent) {
        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
      };
      return NestedOperation2;
    }(GroupOperation);
    var createTester = function(a12, compare) {
      if (a12 instanceof Function) {
        return a12;
      }
      if (a12 instanceof RegExp) {
        return function(b) {
          var result = typeof b === "string" && a12.test(b);
          a12.lastIndex = 0;
          return result;
        };
      }
      var comparableA = comparable(a12);
      return function(b) {
        return compare(comparableA, comparable(b));
      };
    };
    var EqualsOperation = function(_super) {
      __extends(EqualsOperation2, _super);
      function EqualsOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      EqualsOperation2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      EqualsOperation2.prototype.next = function(item, key, parent) {
        if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
          if (this._test(item, key, parent)) {
            this.done = true;
            this.keep = true;
          }
        }
      };
      return EqualsOperation2;
    }(BaseOperation);
    var createEqualsOperation = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    var numericalOperationCreator = function(createNumericalOperation) {
      return function(params, owneryQuery, options, name) {
        return createNumericalOperation(params, owneryQuery, options, name);
      };
    };
    var numericalOperation = function(createTester2) {
      return numericalOperationCreator(function(params, owneryQuery, options, name) {
        var typeofParams = typeof comparable(params);
        var test = createTester2(params);
        return new EqualsOperation(function(b) {
          var actualValue = coercePotentiallyNull(b);
          return typeof comparable(actualValue) === typeofParams && test(actualValue);
        }, owneryQuery, options, name);
      });
    };
    var createNamedOperation = function(name, params, parentQuery, options) {
      var operationCreator = options.operations[name];
      if (!operationCreator) {
        throwUnsupportedOperation(name);
      }
      return operationCreator(params, parentQuery, options, name);
    };
    var throwUnsupportedOperation = function(name) {
      throw new Error("Unsupported operation: ".concat(name));
    };
    var containsOperation = function(query, options) {
      for (var key in query) {
        if (options.operations.hasOwnProperty(key) || key.charAt(0) === "$")
          return true;
      }
      return false;
    };
    var createNestedOperation = function(keyPath, nestedQuery, parentKey, owneryQuery, options) {
      if (containsOperation(nestedQuery, options)) {
        var _a3 = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a3[0], nestedOperations = _a3[1];
        if (nestedOperations.length) {
          throw new Error("Property queries must contain only operations, or exact objects.");
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
      }
      return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
        new EqualsOperation(nestedQuery, owneryQuery, options)
      ]);
    };
    var createQueryOperation = function(query, owneryQuery, _a3) {
      if (owneryQuery === undefined) {
        owneryQuery = null;
      }
      var _b2 = _a3 === undefined ? {} : _a3, compare = _b2.compare, operations = _b2.operations;
      var options = {
        compare: compare || equals,
        operations: Object.assign({}, operations || {})
      };
      var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];
      var ops = [];
      if (selfOperations.length) {
        ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
      }
      ops.push.apply(ops, nestedOperations);
      if (ops.length === 1) {
        return ops[0];
      }
      return new QueryOperation(query, owneryQuery, options, ops);
    };
    var createQueryOperations = function(query, parentKey, options) {
      var selfOperations = [];
      var nestedOperations = [];
      if (!isVanillaObject(query)) {
        selfOperations.push(new EqualsOperation(query, query, options));
        return [selfOperations, nestedOperations];
      }
      for (var key in query) {
        if (options.operations.hasOwnProperty(key)) {
          var op = createNamedOperation(key, query[key], query, options);
          if (op) {
            if (!op.propop && parentKey && !options.operations[parentKey]) {
              throw new Error("Malformed query. ".concat(key, " cannot be matched against property."));
            }
          }
          if (op != null) {
            selfOperations.push(op);
          }
        } else if (key.charAt(0) === "$") {
          throwUnsupportedOperation(key);
        } else {
          nestedOperations.push(createNestedOperation(key.split("."), query[key], key, query, options));
        }
      }
      return [selfOperations, nestedOperations];
    };
    var createOperationTester = function(operation) {
      return function(item, key, owner) {
        operation.reset();
        operation.next(item, key, owner);
        return operation.keep;
      };
    };
    var createQueryTester = function(query, options) {
      if (options === undefined) {
        options = {};
      }
      return createOperationTester(createQueryOperation(query, null, options));
    };
    var $Ne = function(_super) {
      __extends($Ne2, _super);
      function $Ne2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Ne2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      $Ne2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.keep = true;
      };
      $Ne2.prototype.next = function(item) {
        if (this._test(item)) {
          this.done = true;
          this.keep = false;
        }
      };
      return $Ne2;
    }(BaseOperation);
    var $ElemMatch = function(_super) {
      __extends($ElemMatch2, _super);
      function $ElemMatch2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $ElemMatch2.prototype.init = function() {
        if (!this.params || typeof this.params !== "object") {
          throw new Error("Malformed query. $elemMatch must by an object.");
        }
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $ElemMatch2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $ElemMatch2.prototype.next = function(item) {
        if (isArray(item)) {
          for (var i = 0, length_1 = item.length;i < length_1; i++) {
            this._queryOperation.reset();
            var child = item[i];
            this._queryOperation.next(child, i, item, false);
            this.keep = this.keep || this._queryOperation.keep;
          }
          this.done = true;
        } else {
          this.done = false;
          this.keep = false;
        }
      };
      return $ElemMatch2;
    }(BaseOperation);
    var $Not = function(_super) {
      __extends($Not2, _super);
      function $Not2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Not2.prototype.init = function() {
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $Not2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $Not2.prototype.next = function(item, key, owner, root) {
        this._queryOperation.next(item, key, owner, root);
        this.done = this._queryOperation.done;
        this.keep = !this._queryOperation.keep;
      };
      return $Not2;
    }(BaseOperation);
    var $Size = function(_super) {
      __extends($Size2, _super);
      function $Size2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Size2.prototype.init = function() {
      };
      $Size2.prototype.next = function(item) {
        if (isArray(item) && item.length === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Size2;
    }(BaseOperation);
    var assertGroupNotEmpty = function(values) {
      if (values.length === 0) {
        throw new Error("$and/$or/$nor must be a nonempty array");
      }
    };
    var $Or = function(_super) {
      __extends($Or2, _super);
      function $Or2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = false;
        return _this;
      }
      $Or2.prototype.init = function() {
        var _this = this;
        assertGroupNotEmpty(this.params);
        this._ops = this.params.map(function(op) {
          return createQueryOperation(op, null, _this.options);
        });
      };
      $Or2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
        for (var i = 0, length_2 = this._ops.length;i < length_2; i++) {
          this._ops[i].reset();
        }
      };
      $Or2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_3 = this._ops.length;i < length_3; i++) {
          var op = this._ops[i];
          op.next(item, key, owner);
          if (op.keep) {
            done = true;
            success = op.keep;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $Or2;
    }(BaseOperation);
    var $Nor = function(_super) {
      __extends($Nor2, _super);
      function $Nor2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = false;
        return _this;
      }
      $Nor2.prototype.next = function(item, key, owner) {
        _super.prototype.next.call(this, item, key, owner);
        this.keep = !this.keep;
      };
      return $Nor2;
    }($Or);
    var $In = function(_super) {
      __extends($In2, _super);
      function $In2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $In2.prototype.init = function() {
        var _this = this;
        var params = Array.isArray(this.params) ? this.params : [this.params];
        this._testers = params.map(function(value) {
          if (containsOperation(value, _this.options)) {
            throw new Error("cannot nest $ under ".concat(_this.name.toLowerCase()));
          }
          return createTester(value, _this.options.compare);
        });
      };
      $In2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_4 = this._testers.length;i < length_4; i++) {
          var test = this._testers[i];
          if (test(item)) {
            done = true;
            success = true;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $In2;
    }(BaseOperation);
    var $Nin = function(_super) {
      __extends($Nin2, _super);
      function $Nin2(params, ownerQuery, options, name) {
        var _this = _super.call(this, params, ownerQuery, options, name) || this;
        _this.propop = true;
        _this._in = new $In(params, ownerQuery, options, name);
        return _this;
      }
      $Nin2.prototype.next = function(item, key, owner, root) {
        this._in.next(item, key, owner);
        if (isArray(owner) && !root) {
          if (this._in.keep) {
            this.keep = false;
            this.done = true;
          } else if (key == owner.length - 1) {
            this.keep = true;
            this.done = true;
          }
        } else {
          this.keep = !this._in.keep;
          this.done = true;
        }
      };
      $Nin2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._in.reset();
      };
      return $Nin2;
    }(BaseOperation);
    var $Exists = function(_super) {
      __extends($Exists2, _super);
      function $Exists2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Exists2.prototype.next = function(item, key, owner, root, leaf) {
        if (!leaf) {
          this.done = true;
          this.keep = !this.params;
        } else if (owner.hasOwnProperty(key) === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Exists2;
    }(BaseOperation);
    var $And = function(_super) {
      __extends($And2, _super);
      function $And2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
        _this.propop = false;
        assertGroupNotEmpty(params);
        return _this;
      }
      $And2.prototype.next = function(item, key, owner, root) {
        this.childrenNext(item, key, owner, root);
      };
      return $And2;
    }(NamedGroupOperation);
    var $All = function(_super) {
      __extends($All2, _super);
      function $All2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
        _this.propop = true;
        return _this;
      }
      $All2.prototype.next = function(item, key, owner, root) {
        this.childrenNext(item, key, owner, root);
      };
      return $All2;
    }(NamedGroupOperation);
    var $eq = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    var $ne = function(params, owneryQuery, options, name) {
      return new $Ne(params, owneryQuery, options, name);
    };
    var $or = function(params, owneryQuery, options, name) {
      return new $Or(params, owneryQuery, options, name);
    };
    var $nor = function(params, owneryQuery, options, name) {
      return new $Nor(params, owneryQuery, options, name);
    };
    var $elemMatch = function(params, owneryQuery, options, name) {
      return new $ElemMatch(params, owneryQuery, options, name);
    };
    var $nin = function(params, owneryQuery, options, name) {
      return new $Nin(params, owneryQuery, options, name);
    };
    var $in = function(params, owneryQuery, options, name) {
      return new $In(params, owneryQuery, options, name);
    };
    var $lt = numericalOperation(function(params) {
      return function(b) {
        return b != null && b < params;
      };
    });
    var $lte = numericalOperation(function(params) {
      return function(b) {
        return b === params || b <= params;
      };
    });
    var $gt = numericalOperation(function(params) {
      return function(b) {
        return b != null && b > params;
      };
    });
    var $gte = numericalOperation(function(params) {
      return function(b) {
        return b === params || b >= params;
      };
    });
    var $mod = function(_a3, owneryQuery, options) {
      var mod = _a3[0], equalsValue = _a3[1];
      return new EqualsOperation(function(b) {
        return comparable(b) % mod === equalsValue;
      }, owneryQuery, options);
    };
    var $exists = function(params, owneryQuery, options, name) {
      return new $Exists(params, owneryQuery, options, name);
    };
    var $regex = function(pattern, owneryQuery, options) {
      return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
    };
    var $not = function(params, owneryQuery, options, name) {
      return new $Not(params, owneryQuery, options, name);
    };
    var typeAliases2 = {
      number: function(v) {
        return typeof v === "number";
      },
      string: function(v) {
        return typeof v === "string";
      },
      bool: function(v) {
        return typeof v === "boolean";
      },
      array: function(v) {
        return Array.isArray(v);
      },
      null: function(v) {
        return v === null;
      },
      timestamp: function(v) {
        return v instanceof Date;
      }
    };
    var $type = function(clazz, owneryQuery, options) {
      return new EqualsOperation(function(b) {
        if (typeof clazz === "string") {
          if (!typeAliases2[clazz]) {
            throw new Error("Type alias does not exist");
          }
          return typeAliases2[clazz](b);
        }
        return b != null ? b instanceof clazz || b.constructor === clazz : false;
      }, owneryQuery, options);
    };
    var $and = function(params, ownerQuery, options, name) {
      return new $And(params, ownerQuery, options, name);
    };
    var $all = function(params, ownerQuery, options, name) {
      return new $All(params, ownerQuery, options, name);
    };
    var $size = function(params, ownerQuery, options) {
      return new $Size(params, ownerQuery, options, "$size");
    };
    var $options = function() {
      return null;
    };
    var $where = function(params, ownerQuery, options) {
      var test;
      if (isFunction(params)) {
        test = params;
      } else if (!process.env.CSP_ENABLED) {
        test = new Function("obj", "return " + params);
      } else {
        throw new Error('In CSP mode, sift does not support strings in "$where" condition');
      }
      return new EqualsOperation(function(b) {
        return test.bind(b)(b);
      }, ownerQuery, options);
    };
    var defaultOperations = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      $Size,
      $all,
      $and,
      $elemMatch,
      $eq,
      $exists,
      $gt,
      $gte,
      $in,
      $lt,
      $lte,
      $mod,
      $ne,
      $nin,
      $nor,
      $not,
      $options,
      $or,
      $regex,
      $size,
      $type,
      $where
    });
    var createDefaultQueryOperation = function(query, ownerQuery, _a3) {
      var _b2 = _a3 === undefined ? {} : _a3, compare = _b2.compare, operations = _b2.operations;
      return createQueryOperation(query, ownerQuery, {
        compare,
        operations: Object.assign({}, defaultOperations, operations || {})
      });
    };
    var createDefaultQueryTester = function(query, options) {
      if (options === undefined) {
        options = {};
      }
      var op = createDefaultQueryOperation(query, null, options);
      return createOperationTester(op);
    };
    exports2.$Size = $Size;
    exports2.$all = $all;
    exports2.$and = $and;
    exports2.$elemMatch = $elemMatch;
    exports2.$eq = $eq;
    exports2.$exists = $exists;
    exports2.$gt = $gt;
    exports2.$gte = $gte;
    exports2.$in = $in;
    exports2.$lt = $lt;
    exports2.$lte = $lte;
    exports2.$mod = $mod;
    exports2.$ne = $ne;
    exports2.$nin = $nin;
    exports2.$nor = $nor;
    exports2.$not = $not;
    exports2.$options = $options;
    exports2.$or = $or;
    exports2.$regex = $regex;
    exports2.$size = $size;
    exports2.$type = $type;
    exports2.$where = $where;
    exports2.EqualsOperation = EqualsOperation;
    exports2.createDefaultQueryOperation = createDefaultQueryOperation;
    exports2.createEqualsOperation = createEqualsOperation;
    exports2.createOperationTester = createOperationTester;
    exports2.createQueryOperation = createQueryOperation;
    exports2.createQueryTester = createQueryTester;
    exports2.default = createDefaultQueryTester;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/sift/index.js
var require_sift = __commonJS((exports, module) => {
  var lib = require_lib5();
  module.exports = lib.default;
  Object.assign(module.exports, lib);
});

// node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS((exports, module) => {
  var MongooseMap = require_map();
  var SkipPopulateValue = require_skipPopulateValue();
  var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
  var get = require_get();
  var getVirtual = require_getVirtual();
  var leanPopulateMap = require_leanPopulateMap();
  var lookupLocalFields = require_lookupLocalFields();
  var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
  var mpath = require_mpath();
  var sift = require_sift().default;
  var utils = require_utils3();
  var { populateModelSymbol } = require_symbols();
  module.exports = function assignVals(o) {
    const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
    const populateOptions = Object.assign({}, o.options, userOptions, {
      justOne: o.justOne,
      isVirtual: o.isVirtual
    });
    populateOptions.$nullIfNotFound = o.isVirtual;
    const populatedModel = o.populatedModel;
    const originalIds = [].concat(o.rawIds);
    o.allIds = [].concat(o.allIds);
    assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
    const docs = o.docs;
    const rawIds = o.rawIds;
    const options = o.options;
    const count = o.count && o.isVirtual;
    let i;
    let setValueIndex = 0;
    function setValue(val) {
      ++setValueIndex;
      if (count) {
        return val;
      }
      if (val instanceof SkipPopulateValue) {
        return val.val;
      }
      if (val === undefined) {
        return val;
      }
      const _allIds = o.allIds[i];
      if (o.path.endsWith(".$*")) {
        return valueFilter(val, options, populateOptions, _allIds);
      }
      if (o.justOne === true && Array.isArray(val)) {
        const ret = [];
        for (const doc of val) {
          const _docPopulatedModel = leanPopulateMap.get(doc);
          if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
            ret.push(doc);
          }
        }
        while (val.length > ret.length) {
          Array.prototype.pop.apply(val, []);
        }
        for (let i2 = 0;i2 < ret.length; ++i2) {
          val[i2] = ret[i2];
        }
        return valueFilter(val[0], options, populateOptions, _allIds);
      } else if (o.justOne === false && !Array.isArray(val)) {
        return valueFilter([val], options, populateOptions, _allIds);
      } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {
        return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);
      }
      return valueFilter(val, options, populateOptions, _allIds);
    }
    for (i = 0;i < docs.length; ++i) {
      setValueIndex = 0;
      const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
      const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
      if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
        continue;
      }
      let valueToSet;
      if (count) {
        valueToSet = numDocs(rawIds[i]);
      } else if (Array.isArray(o.match)) {
        valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter((v) => v == null || sift(o.match[i])(v)) : [rawIds[i]].filter((v) => v == null || sift(o.match[i])(v))[0];
      } else {
        valueToSet = rawIds[i];
      }
      const originalSchema = o.originalModel.schema;
      const isDoc = get(docs[i], "$__", null) != null;
      let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);
      isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
      if (!o.isVirtual && isMap) {
        const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
        valueToSet = valueToSet.reduce((cur2, v, i2) => {
          cur2.set(_keys[i2], v);
          return cur2;
        }, new Map);
      }
      if (isDoc && Array.isArray(valueToSet)) {
        for (const val of valueToSet) {
          if (val != null && val.$__ != null) {
            val.$__.parent = docs[i];
          }
        }
      } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
        valueToSet.$__.parent = docs[i];
      }
      if (o.isVirtual && isDoc) {
        docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
        if (Array.isArray(valueToSet)) {
          valueToSet = valueToSet.map((v) => v == null ? undefined : v);
        }
        mpath.set(_path, valueToSet, docs[i], function lookup(obj, part, val) {
          if (arguments.length >= 3) {
            obj[part] = val;
            return obj[part];
          }
          if (obj instanceof Map && part === "$*") {
            return [...obj.values()];
          }
          return obj[part];
        }, setValue, false);
        continue;
      }
      const parts = _path.split(".");
      let cur = docs[i];
      for (let j = 0;j < parts.length - 1; ++j) {
        if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
          break;
        }
        if (parts[j] === "$*") {
          break;
        }
        if (cur[parts[j]] == null) {
          const curPath = parts.slice(0, j + 1).join(".");
          const schematype = originalSchema._getSchema(curPath);
          if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
            break;
          }
          cur[parts[j]] = {};
        }
        cur = cur[parts[j]];
        if (typeof cur !== "object") {
          break;
        }
      }
      if (docs[i].$__) {
        o.allOptions.options[populateModelSymbol] = o.allOptions.model;
        docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);
        if (valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };
        }
        if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {
          valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);
        }
      }
      mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
      if (docs[i].$__) {
        markArraySubdocsPopulated(docs[i], [o.allOptions.options]);
      }
    }
  };
  function numDocs(v) {
    if (Array.isArray(v)) {
      if (v.some((el) => Array.isArray(el) || el === null)) {
        return v.map((el) => {
          if (el == null) {
            return 0;
          }
          if (Array.isArray(el)) {
            return el.filter((el2) => el2 != null).length;
          }
          return 1;
        });
      }
      return v.filter((el) => el != null).length;
    }
    return v == null ? 0 : 1;
  }
  function valueFilter(val, assignmentOpts, populateOptions, allIds) {
    const userSpecifiedTransform = typeof populateOptions.transform === "function";
    const transform2 = userSpecifiedTransform ? populateOptions.transform : (v) => v;
    if (Array.isArray(val)) {
      const ret = [];
      const numValues = val.length;
      for (let i2 = 0;i2 < numValues; ++i2) {
        let subdoc = val[i2];
        const _allIds = Array.isArray(allIds) ? allIds[i2] : allIds;
        if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
          continue;
        } else if (!populateOptions.retainNullValues && subdoc == null) {
          continue;
        } else if (userSpecifiedTransform) {
          subdoc = transform2(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
        }
        maybeRemoveId(subdoc, assignmentOpts);
        ret.push(subdoc);
        if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {
          break;
        }
      }
      const rLen = ret.length;
      while (val.length > rLen) {
        Array.prototype.pop.apply(val, []);
      }
      let i = 0;
      if (utils.isMongooseArray(val)) {
        for (i = 0;i < rLen; ++i) {
          val.set(i, ret[i], true);
        }
      } else {
        for (i = 0;i < rLen; ++i) {
          val[i] = ret[i];
        }
      }
      return val;
    }
    if (isPopulatedObject(val) || utils.isPOJO(val)) {
      maybeRemoveId(val, assignmentOpts);
      return transform2(val, allIds);
    }
    if (val instanceof Map) {
      return val;
    }
    if (populateOptions.justOne === false) {
      return [];
    }
    return val == null ? transform2(val, allIds) : transform2(null, allIds);
  }
  function maybeRemoveId(subdoc, assignmentOpts) {
    if (subdoc != null && assignmentOpts.excludeId) {
      if (typeof subdoc.$__setValue === "function") {
        delete subdoc._doc._id;
      } else {
        delete subdoc._id;
      }
    }
  }
  function isPopulatedObject(obj) {
    if (obj == null) {
      return false;
    }
    return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
  }
});

// node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS((exports, module) => {
  var SkipPopulateValue = require_skipPopulateValue();
  var parentPaths = require_parentPaths();
  var { trusted } = require_trusted();
  var hasDollarKeys = require_hasDollarKeys();
  module.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
    const match = _formatMatch(_match);
    if (_foreignField.size === 1) {
      const foreignField = Array.from(_foreignField)[0];
      const foreignSchemaType = model.schema.path(foreignField);
      if (foreignField !== "_id" || !match["_id"]) {
        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
        match[foreignField] = trusted({ $in: ids });
      } else if (foreignField === "_id" && match["_id"]) {
        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
      }
      const _parentPaths = parentPaths(foreignField);
      for (let i = 0;i < _parentPaths.length - 1; ++i) {
        const cur = _parentPaths[i];
        if (match[cur] != null && match[cur].$elemMatch != null) {
          match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });
          delete match[foreignField];
          break;
        }
      }
    } else {
      const $or = [];
      if (Array.isArray(match.$or)) {
        match.$and = [{ $or: match.$or }, { $or }];
        delete match.$or;
      } else {
        match.$or = $or;
      }
      for (const foreignField of _foreignField) {
        if (foreignField !== "_id" || !match["_id"]) {
          const foreignSchemaType = model.schema.path(foreignField);
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          $or.push({ [foreignField]: { $in: ids } });
        } else if (foreignField === "_id" && match["_id"]) {
          const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
          match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
        }
      }
    }
    return match;
  };
  function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
    ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
    if (!skipInvalidIds) {
      return ids;
    }
    return ids.filter((id) => {
      try {
        foreignSchemaType.cast(id);
        return true;
      } catch (err2) {
        return false;
      }
    });
  }
  function _formatMatch(match) {
    if (Array.isArray(match)) {
      if (match.length > 1) {
        return { $or: [].concat(match.map((m2) => Object.assign({}, m2))) };
      }
      return Object.assign({}, match[0]);
    }
    return Object.assign({}, match);
  }
});

// node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var Mixed = require_mixed();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var leanPopulateMap = require_leanPopulateMap();
  var mpath = require_mpath();
  var populateModelSymbol = require_symbols().populateModelSymbol;
  module.exports = function getSchemaTypes(model, schema, doc, path) {
    const pathschema = schema.path(path);
    const topLevelDoc = doc;
    if (pathschema) {
      return pathschema;
    }
    const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;
    if (discriminatorKey && model != null) {
      if (doc != null && doc[discriminatorKey] != null) {
        const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
        schema = discriminator ? discriminator.schema : schema;
      } else if (model.discriminators != null) {
        return Object.keys(model.discriminators).reduce((arr, name) => {
          const disc = model.discriminators[name];
          return arr.concat(getSchemaTypes(disc, disc.schema, null, path));
        }, []);
      }
    }
    function search(parts2, schema2, subdoc, nestedPath) {
      let p = parts2.length + 1;
      let foundschema;
      let trypath;
      while (p--) {
        trypath = parts2.slice(0, p).join(".");
        foundschema = schema2.path(trypath);
        if (foundschema == null) {
          continue;
        }
        if (foundschema.caster) {
          if (foundschema.caster instanceof Mixed) {
            return foundschema.caster;
          }
          let schemas = null;
          if (foundschema.schema != null && foundschema.schema.discriminators != null) {
            const discriminators = foundschema.schema.discriminators;
            const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
            const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
            schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
              const tiedValue = discriminators[discriminator].discriminatorMapping.value;
              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                cur.push(discriminators[discriminator]);
              }
              return cur;
            }, []);
          }
          if (p !== parts2.length && foundschema.schema) {
            let ret;
            if (parts2[p] === "$") {
              if (p + 1 === parts2.length) {
                return foundschema;
              }
              ret = search(parts2.slice(p + 1), schema2, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret) {
                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
              }
              return ret;
            }
            if (schemas != null && schemas.length > 0) {
              ret = [];
              for (const schema3 of schemas) {
                const _ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (_ret != null) {
                  _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                  if (_ret.$parentSchemaDocArray) {
                    ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;
                  }
                  ret.push(_ret);
                }
              }
              return ret;
            } else {
              ret = search(parts2.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret) {
                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
              }
              return ret;
            }
          } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
            let type = foundschema;
            while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
              type = type.casterConstructor;
            }
            const ret = search(parts2.slice(p), type.schema, null, nestedPath.concat(parts2.slice(0, p)));
            if (ret != null) {
              return ret;
            }
            if (type.schema.discriminators) {
              const discriminatorPaths = [];
              for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                const ret2 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2 != null) {
                  discriminatorPaths.push(ret2);
                }
              }
              if (discriminatorPaths.length > 0) {
                return discriminatorPaths;
              }
            }
          }
        } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {
          return foundschema.$__schemaType;
        }
        const fullPath = nestedPath.concat([trypath]).join(".");
        if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath, true) && p < parts2.length) {
          const model2 = topLevelDoc.$populated(fullPath, true).options[populateModelSymbol];
          if (model2 != null) {
            const ret = search(parts2.slice(p), model2.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
            return ret;
          }
        }
        const _val = get(topLevelDoc, trypath);
        if (_val != null) {
          const model2 = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
          const schema3 = model2 != null ? model2.schema : null;
          if (schema3 != null) {
            const ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
            if (ret != null) {
              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (schema3.$isSingleNested ? null : schema3);
              return ret;
            }
          }
        }
        return foundschema;
      }
    }
    const parts = path.split(".");
    for (let i = 0;i < parts.length; ++i) {
      if (parts[i] === "$") {
        parts[i] = "0";
      }
    }
    return search(parts, schema, doc, []);
  };
});

// node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS((exports, module) => {
  var MongooseError = require_error2();
  var SkipPopulateValue = require_skipPopulateValue();
  var clone2 = require_clone();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getConstructorName = require_getConstructorName();
  var getSchemaTypes = require_getSchemaTypes();
  var getVirtual = require_getVirtual();
  var lookupLocalFields = require_lookupLocalFields();
  var mpath = require_mpath();
  var modelNamesFromRefPath = require_modelNamesFromRefPath();
  var utils = require_utils3();
  var modelSymbol = require_symbols().modelSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var StrictPopulate = require_strictPopulate();
  module.exports = function getModelsMapForPopulate(model, docs, options) {
    let doc;
    const len = docs.length;
    const map3 = [];
    const modelNameFromQuery = options.model && options.model.modelName || options.model;
    let schema;
    let refPath;
    let modelNames;
    const available = {};
    const modelSchema = model.schema;
    if (options._localModel != null && options._localModel.schema.nested[options.path]) {
      return [];
    }
    const _virtualRes = getVirtual(model.schema, options.path);
    const virtual = _virtualRes == null ? null : _virtualRes.virtual;
    if (virtual != null) {
      return _virtualPopulate(model, docs, options, _virtualRes);
    }
    let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);
    allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
    const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;
    if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {
      return new StrictPopulate(options._fullPath || options.path);
    }
    for (let i = 0;i < len; i++) {
      doc = docs[i];
      let justOne = null;
      if (doc.$__ != null && doc.populated(options.path)) {
        const forceRepopulate = options.forceRepopulate != null ? options.forceRepopulate : doc.constructor.base.options.forceRepopulate;
        if (forceRepopulate === false) {
          continue;
        }
      }
      const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;
      schema = getSchemaTypes(model, docSchema, doc, options.path);
      if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
        continue;
      }
      const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;
      if (isUnderneathDocArray && get(options, "options.sort") != null) {
        return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
      }
      modelNames = null;
      let isRefPath = false;
      let normalizedRefPath = null;
      let schemaOptions = null;
      let modelNamesInOrder = null;
      if (schema != null && schema.instance === "Embedded") {
        if (schema.options.ref) {
          const data2 = {
            localField: options.path + "._id",
            foreignField: "_id",
            justOne: true
          };
          const res = _getModelNames(doc, schema, modelNameFromQuery, model);
          const unpopulatedValue = mpath.get(options.path, doc);
          const id2 = mpath.get("_id", unpopulatedValue);
          addModelNamesToMap(model, map3, available, res.modelNames, options, data2, id2, doc, schemaOptions, unpopulatedValue);
        }
        continue;
      }
      if (Array.isArray(schema)) {
        const schemasArray = schema;
        for (const _schema of schemasArray) {
          let _modelNames;
          let res;
          try {
            res = _getModelNames(doc, _schema, modelNameFromQuery, model);
            _modelNames = res.modelNames;
            isRefPath = isRefPath || res.isRefPath;
            normalizedRefPath = normalizedRefPath || res.refPath;
            justOne = res.justOne;
          } catch (error) {
            return error;
          }
          if (isRefPath && !res.isRefPath) {
            continue;
          }
          if (!_modelNames) {
            continue;
          }
          modelNames = modelNames || [];
          for (const modelName of _modelNames) {
            if (modelNames.indexOf(modelName) === -1) {
              modelNames.push(modelName);
            }
          }
        }
      } else {
        try {
          const res = _getModelNames(doc, schema, modelNameFromQuery, model);
          modelNames = res.modelNames;
          isRefPath = res.isRefPath;
          normalizedRefPath = normalizedRefPath || res.refPath;
          justOne = res.justOne;
          schemaOptions = get(schema, "options.populate", null);
          if (isRefPath) {
            modelNamesInOrder = modelNames;
            modelNames = Array.from(new Set(modelNames));
          }
        } catch (error) {
          return error;
        }
        if (!modelNames) {
          continue;
        }
      }
      const data = {};
      const localField = options.path;
      const foreignField = "_id";
      if ("justOne" in options && options.justOne !== undefined) {
        justOne = options.justOne;
      } else if (schema && !schema[schemaMixedSymbol]) {
        if (options.path.endsWith("." + schema.path) || options.path === schema.path) {
          justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
        }
      }
      if (!modelNames) {
        continue;
      }
      data.isVirtual = false;
      data.justOne = justOne;
      data.localField = localField;
      data.foreignField = foreignField;
      const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);
      const id = String(utils.getValue(foreignField, doc));
      options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
      let match = get(options, "match", null);
      const hasMatchFunction = typeof match === "function";
      if (hasMatchFunction) {
        match = match.call(doc, doc);
      }
      throwOn$where(match);
      data.match = match;
      data.hasMatchFunction = hasMatchFunction;
      data.isRefPath = isRefPath;
      data.modelNamesInOrder = modelNamesInOrder;
      if (isRefPath) {
        const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);
        modelNames = embeddedDiscriminatorModelNames || modelNames;
      }
      try {
        addModelNamesToMap(model, map3, available, modelNames, options, data, ret, doc, schemaOptions);
      } catch (err2) {
        return err2;
      }
    }
    return map3;
    function _getModelNames(doc2, schema2, modelNameFromQuery2, model2) {
      let modelNames2;
      let isRefPath = false;
      let justOne = null;
      const originalSchema = schema2;
      if (schema2 && schema2.instance === "Array") {
        schema2 = schema2.caster;
      }
      if (schema2 && schema2.$isSchemaMap) {
        schema2 = schema2.$__schemaType;
      }
      const ref = schema2 && schema2.options && schema2.options.ref;
      refPath = schema2 && schema2.options && schema2.options.refPath;
      if (schema2 != null && schema2[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery2) {
        return { modelNames: null };
      }
      if (modelNameFromQuery2) {
        modelNames2 = [modelNameFromQuery2];
      } else if (refPath != null) {
        if (typeof refPath === "function") {
          const subdocPath = options.path.slice(0, options.path.length - schema2.path.length - 1);
          const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
          modelNames2 = new Set;
          for (const subdoc of subdocsBeingPopulated) {
            refPath = refPath.call(subdoc, subdoc, options.path);
            modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
          }
          modelNames2 = Array.from(modelNames2);
        } else {
          modelNames2 = modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection);
        }
        isRefPath = true;
      } else {
        let ref2;
        let refPath2;
        let schemaForCurrentDoc;
        let discriminatorValue;
        let modelForCurrentDoc = model2;
        const discriminatorKey = model2.schema.options.discriminatorKey;
        if (!schema2 && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc2))) {
          const discriminatorModel = getDiscriminatorByValue(model2.discriminators, discriminatorValue) || model2;
          if (discriminatorModel != null) {
            modelForCurrentDoc = discriminatorModel;
          } else {
            try {
              modelForCurrentDoc = _getModelFromConn(model2.db, discriminatorValue);
            } catch (error) {
              return error;
            }
          }
          schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
          if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
            schemaForCurrentDoc = schemaForCurrentDoc.caster;
          }
        } else {
          schemaForCurrentDoc = schema2;
        }
        if (originalSchema && originalSchema.path.endsWith(".$*")) {
          justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;
        } else if (schemaForCurrentDoc != null) {
          justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
        }
        if ((ref2 = get(schemaForCurrentDoc, "options.ref")) != null) {
          if (schemaForCurrentDoc != null && typeof ref2 === "function" && options.path.endsWith("." + schemaForCurrentDoc.path)) {
            modelNames2 = new Set;
            const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            for (const subdoc of subdocsBeingPopulated) {
              modelNames2.add(handleRefFunction(ref2, subdoc));
            }
            if (subdocsBeingPopulated.length === 0) {
              modelNames2 = [handleRefFunction(ref2, doc2)];
            } else {
              modelNames2 = Array.from(modelNames2);
            }
          } else {
            ref2 = handleRefFunction(ref2, doc2);
            modelNames2 = [ref2];
          }
        } else if ((schemaForCurrentDoc = get(schema2, "options.refPath")) != null) {
          isRefPath = true;
          if (typeof refPath2 === "function") {
            const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            modelNames2 = new Set;
            for (const subdoc of subdocsBeingPopulated) {
              refPath2 = refPath2.call(subdoc, subdoc, options.path);
              modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
            }
            modelNames2 = Array.from(modelNames2);
          } else {
            modelNames2 = modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection);
          }
        }
      }
      if (!modelNames2) {
        if (options._localModel == null) {
          modelNames2 = [model2.modelName];
        } else {
          return { modelNames: modelNames2, justOne, isRefPath, refPath };
        }
      }
      if (!Array.isArray(modelNames2)) {
        modelNames2 = [modelNames2];
      }
      return { modelNames: modelNames2, justOne, isRefPath, refPath };
    }
  };
  /*!
   * ignore
   */
  function _virtualPopulate(model, docs, options, _virtualRes) {
    const map3 = [];
    const available = {};
    const virtual = _virtualRes.virtual;
    for (const doc of docs) {
      let modelNames = null;
      const data = {};
      let localField;
      const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
      if (typeof options.localField === "string") {
        localField = options.localField;
      } else if (typeof virtual.options.localField === "function") {
        localField = virtualPrefix + virtual.options.localField.call(doc, doc);
      } else if (Array.isArray(virtual.options.localField)) {
        localField = virtual.options.localField.map((field) => virtualPrefix + field);
      } else {
        localField = virtualPrefix + virtual.options.localField;
      }
      data.count = virtual.options.count;
      if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
        options.skip = virtual.options.skip;
      }
      if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
        options.limit = virtual.options.limit;
      }
      if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
        options.perDocumentLimit = virtual.options.perDocumentLimit;
      }
      let foreignField = virtual.options.foreignField;
      if (!localField || !foreignField) {
        return new MongooseError(`Cannot populate virtual \`${options.path}\` on model \`${model.modelName}\`, because options \`localField\` and / or \`foreignField\` are missing`);
      }
      if (typeof localField === "function") {
        localField = localField.call(doc, doc);
      }
      if (typeof foreignField === "function") {
        foreignField = foreignField.call(doc, doc);
      }
      data.isRefPath = false;
      let justOne = null;
      if ("justOne" in options && options.justOne !== undefined) {
        justOne = options.justOne;
      }
      modelNames = virtual._getModelNamesForPopulate(doc);
      if (virtual.options.refPath) {
        justOne = !!virtual.options.justOne;
        data.isRefPath = true;
      } else if (virtual.options.ref) {
        justOne = !!virtual.options.justOne;
      }
      data.isVirtual = true;
      data.virtual = virtual;
      data.justOne = justOne;
      const baseMatch = get(data, "virtual.options.match", null) || get(data, "virtual.options.options.match", null);
      let match = get(options, "match", null) || baseMatch;
      let hasMatchFunction = typeof match === "function";
      if (hasMatchFunction) {
        match = match.call(doc, doc, data.virtual);
      }
      if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
        match = Object.assign({}, match);
        for (let i = 1;i < localField.length; ++i) {
          match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);
          hasMatchFunction = true;
        }
        localField = localField[0];
        foreignField = foreignField[0];
      }
      data.localField = localField;
      data.foreignField = foreignField;
      data.match = match;
      data.hasMatchFunction = hasMatchFunction;
      throwOn$where(match);
      const ret = _getLocalFieldValues(doc, localField, model, options, virtual);
      try {
        addModelNamesToMap(model, map3, available, modelNames, options, data, ret, doc);
      } catch (err2) {
        return err2;
      }
    }
    return map3;
  }
  /*!
   * ignore
   */
  function addModelNamesToMap(model, map3, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {
    const connection = options.connection != null ? options.connection : model.db;
    unpopulatedValue = unpopulatedValue === undefined ? ret : unpopulatedValue;
    if (Array.isArray(unpopulatedValue)) {
      unpopulatedValue = utils.cloneArrays(unpopulatedValue);
    }
    if (modelNames == null) {
      return;
    }
    const flatModelNames = utils.array.flatten(modelNames);
    let k = flatModelNames.length;
    while (k--) {
      let modelName = flatModelNames[k];
      if (modelName == null) {
        continue;
      }
      let Model;
      if (options.model && options.model[modelSymbol]) {
        Model = options.model;
      } else if (modelName[modelSymbol]) {
        Model = modelName;
        modelName = Model.modelName;
      } else {
        try {
          Model = _getModelFromConn(connection, modelName);
        } catch (err2) {
          if (ret !== undefined) {
            throw err2;
          }
          Model = null;
        }
      }
      let ids = ret;
      const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;
      if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {
        ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);
      }
      const perDocumentLimit = options.perDocumentLimit == null ? get(options, "options.perDocumentLimit", null) : options.perDocumentLimit;
      if (!available[modelName] || perDocumentLimit != null) {
        const currentOptions = {
          model: Model
        };
        if (data.isVirtual && get(data.virtual, "options.options")) {
          currentOptions.options = clone2(data.virtual.options.options);
        } else if (schemaOptions != null) {
          currentOptions.options = Object.assign({}, schemaOptions);
        }
        utils.merge(currentOptions, options);
        options[populateModelSymbol] = Model;
        currentOptions[populateModelSymbol] = Model;
        available[modelName] = {
          model: Model,
          options: currentOptions,
          match: data.hasMatchFunction ? [data.match] : data.match,
          docs: [doc],
          ids: [ids],
          allIds: [ret],
          unpopulatedValues: [unpopulatedValue],
          localField: new Set([data.localField]),
          foreignField: new Set([data.foreignField]),
          justOne: data.justOne,
          isVirtual: data.isVirtual,
          virtual: data.virtual,
          count: data.count,
          [populateModelSymbol]: Model
        };
        map3.push(available[modelName]);
      } else {
        available[modelName].localField.add(data.localField);
        available[modelName].foreignField.add(data.foreignField);
        available[modelName].docs.push(doc);
        available[modelName].ids.push(ids);
        available[modelName].allIds.push(ret);
        available[modelName].unpopulatedValues.push(unpopulatedValue);
        if (data.hasMatchFunction) {
          available[modelName].match.push(data.match);
        }
      }
    }
  }
  function _getModelFromConn(conn, modelName) {
    if (conn.models[modelName] == null && conn._parent != null) {
      return _getModelFromConn(conn._parent, modelName);
    }
    return conn.model(modelName);
  }
  function matchIdsToRefPaths(ids, refPaths, refPathToFind) {
    if (!Array.isArray(refPaths)) {
      return refPaths === refPathToFind ? Array.isArray(ids) ? utils.array.flatten(ids) : [ids] : [];
    }
    if (Array.isArray(ids) && Array.isArray(refPaths)) {
      return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));
    }
    return [];
  }
  /*!
   * ignore
   */
  function handleRefFunction(ref, doc) {
    if (typeof ref === "function" && !ref[modelSymbol]) {
      return ref.call(doc, doc);
    }
    return ref;
  }
  /*!
   * ignore
   */
  function _getLocalFieldValues(doc, localField, model, options, virtual, schema) {
    const localFieldPathType = model.schema._getPathType(localField);
    const localFieldPath = localFieldPathType === "real" ? model.schema.path(localField) : localFieldPathType.schema;
    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
    localField = localFieldPath != null && localFieldPath.instance === "Embedded" ? localField + "._id" : localField;
    const _populateOptions = get(options, "options", {});
    const getters = "getters" in _populateOptions ? _populateOptions.getters : get(virtual, "options.getters", false);
    if (localFieldGetters.length !== 0 && getters) {
      const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
      const localFieldValue = utils.getValue(localField, doc);
      if (Array.isArray(localFieldValue)) {
        const localFieldHydratedValue = utils.getValue(localField.split(".").slice(0, -1), hydratedDoc);
        return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
      } else {
        return localFieldPath.applyGetters(localFieldValue, hydratedDoc);
      }
    } else {
      return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
    }
  }
  function convertTo_id(val, schema) {
    if (val != null && val.$__ != null) {
      return val._doc._id;
    }
    if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
      return val._id;
    }
    if (Array.isArray(val)) {
      const rawVal = val.__array != null ? val.__array : val;
      for (let i = 0;i < rawVal.length; ++i) {
        if (rawVal[i] != null && rawVal[i].$__ != null) {
          rawVal[i] = rawVal[i]._doc._id;
        }
      }
      if (utils.isMongooseArray(val) && val.$schema()) {
        return val.$schema()._castForPopulate(val, val.$parent());
      }
      return [].concat(val);
    }
    if (getConstructorName(val) === "Object" && (schema == null || schema[schemaMixedSymbol] == null)) {
      const ret = [];
      for (const key of Object.keys(val)) {
        ret.push(val[key]);
      }
      return ret;
    }
    if (val instanceof Map) {
      return Array.from(val.values());
    }
    return val;
  }
  /*!
   * ignore
   */
  function _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {
    if (!data.isRefPath || normalizedRefPath == null) {
      return;
    }
    const pieces = normalizedRefPath.split(".");
    let cur = "";
    let modelNames = undefined;
    for (let i = 0;i < pieces.length; ++i) {
      const piece = pieces[i];
      cur = cur + (cur.length === 0 ? "" : ".") + piece;
      const schematype = modelSchema.path(cur);
      if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {
        const subdocs = utils.getValue(cur, doc);
        const remnant = options.path.substring(cur.length + 1);
        const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
        modelNames = [];
        for (const subdoc of subdocs) {
          const discriminatorName = utils.getValue(discriminatorKey, subdoc);
          const discriminator = schematype.caster.discriminators[discriminatorName];
          const discriminatorSchema = discriminator && discriminator.schema;
          if (discriminatorSchema == null) {
            continue;
          }
          const _path = discriminatorSchema.path(remnant);
          if (_path == null || _path.options.refPath == null) {
            const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);
            ret.forEach((v, i2) => {
              if (v === docValue) {
                ret[i2] = SkipPopulateValue(v);
              }
            });
            continue;
          }
          const modelName = utils.getValue(pieces.slice(i + 1).join("."), subdoc);
          modelNames.push(modelName);
        }
      }
    }
    return modelNames;
  }
  function throwOn$where(match) {
    if (match == null) {
      return;
    }
    if (typeof match !== "object") {
      return;
    }
    for (const key of Object.keys(match)) {
      if (key === "$where") {
        throw new MongooseError("Cannot use $where filter with populate() match");
      }
      if (match[key] != null && typeof match[key] === "object") {
        throwOn$where(match[key]);
      }
    }
  }
});

// node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS((exports, module) => {
  var get = require_get();
  module.exports = function isDefaultIdIndex(index) {
    if (Array.isArray(index)) {
      const keys = Object.keys(index[0]);
      return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
    }
    if (typeof index !== "object") {
      return false;
    }
    const key = get(index, "key", {});
    return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
  };
});

// node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS((exports, module) => {
  var get = require_get();
  var utils = require_utils3();
  module.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {
    if (dbIndex.textIndexVersion != null) {
      delete dbIndex.key._fts;
      delete dbIndex.key._ftsx;
      const weights = { ...dbIndex.weights, ...dbIndex.key };
      if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {
        return false;
      }
      for (const prop of Object.keys(weights)) {
        if (!(prop in schemaIndexKeysObject)) {
          return false;
        }
        const weight = weights[prop];
        if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
          return false;
        }
      }
      if (options["default_language"] !== dbIndex["default_language"]) {
        return dbIndex["default_language"] === "english" && options["default_language"] == null;
      }
      return true;
    }
    const optionKeys = [
      "unique",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "collation"
    ];
    for (const key of optionKeys) {
      if (!(key in options) && !(key in dbIndex)) {
        continue;
      }
      if (key === "collation") {
        if (options[key] == null || dbIndex[key] == null) {
          return options[key] == null && dbIndex[key] == null;
        }
        const definedKeys = Object.keys(options.collation);
        const schemaCollation = options.collation;
        const dbCollation = dbIndex.collation;
        for (const opt of definedKeys) {
          if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
            return false;
          }
        }
      } else if (!utils.deepEqual(options[key], dbIndex[key])) {
        return false;
      }
    }
    const schemaIndexKeys = Object.keys(schemaIndexKeysObject);
    const dbIndexKeys = Object.keys(dbIndex.key);
    if (schemaIndexKeys.length !== dbIndexKeys.length) {
      return false;
    }
    for (let i = 0;i < schemaIndexKeys.length; ++i) {
      if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
        return false;
      }
      if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/indexes/isTimeseriesIndex.js
var require_isTimeseriesIndex = __commonJS((exports, module) => {
  module.exports = function isTimeseriesIndex(dbIndex, schemaOptions) {
    if (schemaOptions.timeseries == null) {
      return false;
    }
    const { timeField, metaField } = schemaOptions.timeseries;
    if (typeof timeField !== "string" || typeof metaField !== "string") {
      return false;
    }
    return Object.keys(dbIndex.key).length === 2 && dbIndex.key[timeField] === 1 && dbIndex.key[metaField] === 1;
  };
});

// node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js
var require_getRelatedIndexes = __commonJS((exports, module) => {
  var hasDollarKeys = require_hasDollarKeys();
  function getRelatedSchemaIndexes(model, schemaIndexes) {
    return getRelatedIndexes({
      baseModelName: model.baseModelName,
      discriminatorMapping: model.schema.discriminatorMapping,
      indexes: schemaIndexes,
      indexesType: "schema"
    });
  }
  function getRelatedDBIndexes(model, dbIndexes) {
    return getRelatedIndexes({
      baseModelName: model.baseModelName,
      discriminatorMapping: model.schema.discriminatorMapping,
      indexes: dbIndexes,
      indexesType: "db"
    });
  }
  module.exports = {
    getRelatedSchemaIndexes,
    getRelatedDBIndexes
  };
  function getRelatedIndexes({
    baseModelName,
    discriminatorMapping,
    indexes,
    indexesType
  }) {
    const discriminatorKey = discriminatorMapping && discriminatorMapping.key;
    const discriminatorValue = discriminatorMapping && discriminatorMapping.value;
    if (!discriminatorKey) {
      return indexes;
    }
    const isChildDiscriminatorModel = Boolean(baseModelName);
    if (isChildDiscriminatorModel) {
      return indexes.filter((index) => {
        const partialFilterExpression = getPartialFilterExpression(index, indexesType);
        return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;
      });
    }
    return indexes.filter((index) => {
      const partialFilterExpression = getPartialFilterExpression(index, indexesType);
      return !partialFilterExpression || !partialFilterExpression[discriminatorKey] || hasDollarKeys(partialFilterExpression[discriminatorKey]) && !("$eq" in partialFilterExpression[discriminatorKey]);
    });
  }
  function getPartialFilterExpression(index, indexesType) {
    if (indexesType === "schema") {
      const options = index[1];
      return options && options.partialFilterExpression;
    }
    return index.partialFilterExpression;
  }
});

// node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS((exports, module) => {
  module.exports = parallelLimit;
  /*!
   * ignore
   */
  function parallelLimit(fns, limit, callback) {
    let numInProgress = 0;
    let numFinished = 0;
    let error = null;
    if (limit <= 0) {
      throw new Error("Limit must be positive");
    }
    if (fns.length === 0) {
      return callback(null, []);
    }
    for (let i = 0;i < fns.length && i < limit; ++i) {
      _start();
    }
    function _start() {
      fns[numFinished + numInProgress](_done(numFinished + numInProgress));
      ++numInProgress;
    }
    const results = [];
    function _done(index) {
      return (err2, res) => {
        --numInProgress;
        ++numFinished;
        if (error != null) {
          return;
        }
        if (err2 != null) {
          error = err2;
          return callback(error);
        }
        results[index] = res;
        if (numFinished === fns.length) {
          return callback(null, results);
        } else if (numFinished + numInProgress < fns.length) {
          _start();
        }
      };
    }
  }
});

// node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js
var require_pushNestedArrayPaths = __commonJS((exports, module) => {
  module.exports = function pushNestedArrayPaths(paths, nestedArray, path) {
    if (nestedArray == null) {
      return;
    }
    for (let i = 0;i < nestedArray.length; ++i) {
      if (Array.isArray(nestedArray[i])) {
        pushNestedArrayPaths(paths, nestedArray[i], path + "." + i);
      } else {
        paths.push(path + "." + i);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS((exports, module) => {
  var get = require_get();
  var mpath = require_mpath();
  var parseProjection = require_parseProjection();
  /*!
   * ignore
   */
  module.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
    const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
    if (projection == null) {
      return;
    }
    for (const foreignField of foreignFields) {
      if (!projection.hasOwnProperty("-" + foreignField)) {
        continue;
      }
      for (const val of docs) {
        if (val.$__ != null) {
          mpath.unset(foreignField, val._doc);
        } else {
          mpath.unset(foreignField, val);
        }
      }
    }
  };
});

// node_modules/mongoose/lib/model.js
var require_model = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var Aggregate = require_aggregate2();
  var ChangeStream = require_changeStream();
  var Document = require_document2();
  var DocumentNotFoundError = require_notFound();
  var EventEmitter = __require("events").EventEmitter;
  var Kareem = require_kareem();
  var MongooseBulkWriteError = require_bulkWriteError();
  var MongooseError = require_error2();
  var ObjectParameterError = require_objectParameter();
  var OverwriteModelError = require_overwriteModel();
  var Query = require_query();
  var SaveOptions = require_saveOptions();
  var Schema = require_schema2();
  var ValidationError2 = require_validation();
  var VersionError = require_version();
  var ParallelSaveError = require_parallelSave();
  var applyDefaultsHelper = require_applyDefaults();
  var applyDefaultsToPOJO = require_applyDefaultsToPOJO();
  var applyEmbeddedDiscriminators = require_applyEmbeddedDiscriminators();
  var applyHooks = require_applyHooks();
  var applyMethods = require_applyMethods();
  var applyProjection = require_applyProjection();
  var applyReadConcern = require_applyReadConcern();
  var applySchemaCollation = require_applySchemaCollation();
  var applyStaticHooks = require_applyStaticHooks();
  var applyStatics = require_applyStatics();
  var applyTimestampsHelper = require_applyTimestamps();
  var applyWriteConcern = require_applyWriteConcern();
  var applyVirtualsHelper = require_applyVirtuals();
  var assignVals = require_assignVals();
  var castBulkWrite = require_castBulkWrite();
  var clone2 = require_clone();
  var createPopulateQueryFilter = require_createPopulateQueryFilter();
  var decorateUpdateWithVersionKey = require_decorateUpdateWithVersionKey();
  var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  var discriminator = require_discriminator();
  var each = require_each();
  var get = require_get();
  var getConstructorName = require_getConstructorName();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getModelsMapForPopulate = require_getModelsMapForPopulate();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isDefaultIdIndex = require_isDefaultIdIndex();
  var isIndexEqual = require_isIndexEqual();
  var isTimeseriesIndex = require_isTimeseriesIndex();
  var {
    getRelatedDBIndexes,
    getRelatedSchemaIndexes
  } = require_getRelatedIndexes();
  var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  var leanPopulateMap = require_leanPopulateMap();
  var parallelLimit = require_parallelLimit();
  var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
  var pushNestedArrayPaths = require_pushNestedArrayPaths();
  var removeDeselectedForeignField = require_removeDeselectedForeignField();
  var setDottedPath = require_setDottedPath();
  var util3 = __require("util");
  var utils = require_utils3();
  var minimize = require_minimize();
  var MongooseBulkSaveIncompleteError = require_bulkSaveIncompleteError();
  var ObjectExpectedError = require_objectExpected();
  var decorateBulkWriteResult = require_decorateBulkWriteResult();
  var modelCollectionSymbol = Symbol("mongoose#Model#collection");
  var modelDbSymbol = Symbol("mongoose#Model#db");
  var modelSymbol = require_symbols().modelSymbol;
  var subclassedSymbol = Symbol("mongoose#Model#subclassed");
  var { VERSION_INC, VERSION_WHERE, VERSION_ALL } = Document;
  var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
    bson: true
  });
  function Model(doc, fields, skipId) {
    if (fields instanceof Schema) {
      throw new TypeError("2nd argument to `Model` constructor must be a POJO or string, " + "**not** a schema. Make sure you're calling `mongoose.model()`, not " + "`mongoose.Model()`.");
    }
    if (typeof doc === "string") {
      throw new TypeError("First argument to `Model` constructor must be an object, " + "**not** a string. Make sure you're calling `mongoose.model()`, not " + "`mongoose.Model()`.");
    }
    Document.call(this, doc, fields, skipId);
  }
  Object.setPrototypeOf(Model.prototype, Document.prototype);
  Model.prototype.$isMongooseModelPrototype = true;
  Model.prototype.db;
  Model.useConnection = function useConnection(connection) {
    if (!connection) {
      throw new Error("Please provide a connection.");
    }
    if (this.db) {
      delete this.db.models[this.modelName];
      delete this.prototype.db;
      delete this.prototype[modelDbSymbol];
      delete this.prototype.collection;
      delete this.prototype.$collection;
      delete this.prototype[modelCollectionSymbol];
    }
    this.db = connection;
    const collection = connection.collection(this.modelName, connection.options);
    this.prototype.collection = collection;
    this.prototype.$collection = collection;
    this.prototype[modelCollectionSymbol] = collection;
    this.prototype.db = connection;
    this.prototype[modelDbSymbol] = connection;
    this.collection = collection;
    this.$__collection = collection;
    connection.models[this.modelName] = this;
    return this;
  };
  Model.prototype.collection;
  Model.prototype.$__collection;
  Model.prototype.modelName;
  Model.prototype.$where;
  Model.prototype.baseModelName;
  Model.events;
  Model._middleware;
  /*!
   * ignore
   */
  function _applyCustomWhere(doc, where) {
    if (doc.$where == null) {
      return;
    }
    for (const key of Object.keys(doc.$where)) {
      where[key] = doc.$where[key];
    }
  }
  /*!
   * ignore
   */
  Model.prototype.$__handleSave = function(options, callback) {
    const saveOptions = {};
    applyWriteConcern(this.$__schema, options);
    if (typeof options.writeConcern !== "undefined") {
      saveOptions.writeConcern = {};
      if ("w" in options.writeConcern) {
        saveOptions.writeConcern.w = options.writeConcern.w;
      }
      if ("j" in options.writeConcern) {
        saveOptions.writeConcern.j = options.writeConcern.j;
      }
      if ("wtimeout" in options.writeConcern) {
        saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
      }
    } else {
      if ("w" in options) {
        saveOptions.w = options.w;
      }
      if ("j" in options) {
        saveOptions.j = options.j;
      }
      if ("wtimeout" in options) {
        saveOptions.wtimeout = options.wtimeout;
      }
    }
    if ("checkKeys" in options) {
      saveOptions.checkKeys = options.checkKeys;
    }
    const session = this.$session();
    const asyncLocalStorage = this[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();
    if (session != null) {
      saveOptions.session = session;
    } else if (!options.hasOwnProperty("session") && asyncLocalStorage?.session != null) {
      saveOptions.session = asyncLocalStorage.session;
    }
    if (this.$isNew) {
      const obj = this.toObject(saveToObjectOptions);
      if ((obj || {})._id === undefined) {
        immediate(function() {
          callback(new MongooseError("document must have an _id before saving"));
        });
        return;
      }
      this.$__version(true, obj);
      this[modelCollectionSymbol].insertOne(obj, saveOptions).then((ret) => callback(null, ret), (err2) => {
        _setIsNew(this, true);
        callback(err2, null);
      });
      this.$__reset();
      _setIsNew(this, false);
      this.$__.inserting = true;
      return;
    }
    this.$__.inserting = false;
    const delta2 = this.$__delta();
    if (options.pathsToSave) {
      for (const key in delta2[1]["$set"]) {
        if (options.pathsToSave.includes(key)) {
          continue;
        } else if (options.pathsToSave.some((pathToSave) => key.slice(0, pathToSave.length) === pathToSave && key.charAt(pathToSave.length) === ".")) {
          continue;
        } else {
          delete delta2[1]["$set"][key];
        }
      }
    }
    if (delta2) {
      if (delta2 instanceof MongooseError) {
        callback(delta2);
        return;
      }
      const where = this.$__where(delta2[0]);
      if (where instanceof MongooseError) {
        callback(where);
        return;
      }
      _applyCustomWhere(this, where);
      const update = delta2[1];
      if (this.$__schema.options.minimize) {
        for (const updateOp of Object.values(update)) {
          if (updateOp == null) {
            continue;
          }
          for (const key of Object.keys(updateOp)) {
            if (updateOp[key] == null || typeof updateOp[key] !== "object") {
              continue;
            }
            if (!utils.isPOJO(updateOp[key])) {
              continue;
            }
            minimize(updateOp[key]);
            if (Object.keys(updateOp[key]).length === 0) {
              delete updateOp[key];
              update.$unset = update.$unset || {};
              update.$unset[key] = 1;
            }
          }
        }
      }
      this[modelCollectionSymbol].updateOne(where, update, saveOptions).then((ret) => {
        if (ret == null) {
          ret = { $where: where };
        } else {
          ret.$where = where;
        }
        callback(null, ret);
      }, (err2) => {
        this.$__undoReset();
        callback(err2);
      });
    } else {
      handleEmptyUpdate.call(this);
      return;
    }
    this.$__.modifiedPaths = this.modifiedPaths().concat(Object.keys(this.$__.activePaths.getStatePaths("default")));
    this.$__reset();
    _setIsNew(this, false);
    function handleEmptyUpdate() {
      const optionsWithCustomValues = Object.assign({}, options, saveOptions);
      const where = this.$__where();
      const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
      if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {
        const key = this.$__schema.options.versionKey;
        const val = this.$__getValue(key);
        if (val != null) {
          where[key] = val;
        }
      }
      applyReadConcern(this.$__schema, optionsWithCustomValues);
      this.constructor.collection.findOne(where, optionsWithCustomValues).then((documentExists) => {
        const matchedCount = !documentExists ? 0 : 1;
        callback(null, { $where: where, matchedCount });
      }).catch(callback);
    }
  };
  /*!
   * ignore
   */
  Model.prototype.$__save = function(options, callback) {
    this.$__handleSave(options, (error, result) => {
      if (error) {
        error = this.$__schema._transformDuplicateKeyError(error);
        const hooks = this.$__schema.s.hooks;
        return hooks.execPost("save:error", this, [this], { error }, (error2) => {
          callback(error2, this);
        });
      }
      let numAffected = 0;
      const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;
      if (writeConcern !== 0) {
        if (result != null) {
          if (Array.isArray(result)) {
            numAffected = result.length;
          } else if (result.matchedCount != null) {
            numAffected = result.matchedCount;
          } else {
            numAffected = result;
          }
        }
        const versionBump = this.$__.version;
        if (versionBump && !this.$__.inserting) {
          const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
          this.$__.version = undefined;
          const key = this.$__schema.options.versionKey;
          const version = this.$__getValue(key) || 0;
          if (numAffected <= 0) {
            this.$__undoReset();
            const err2 = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
            return callback(err2, this);
          }
          if (doIncrement) {
            this.$__setValue(key, version + 1);
          }
        }
        if (result != null && numAffected <= 0) {
          this.$__undoReset();
          error = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);
          const hooks = this.$__schema.s.hooks;
          return hooks.execPost("save:error", this, [this], { error }, (error2) => {
            callback(error2, this);
          });
        }
      }
      this.$__.saving = undefined;
      this.$__.savedState = {};
      this.$emit("save", this, numAffected);
      this.constructor.emit("save", this, numAffected);
      callback(null, this);
    });
  };
  /*!
   * ignore
   */
  function generateVersionError(doc, modifiedPaths, defaultPaths) {
    const key = doc.$__schema.options.versionKey;
    if (!key) {
      return null;
    }
    const version = doc.$__getValue(key) || 0;
    return new VersionError(doc, version, modifiedPaths.concat(defaultPaths));
  }
  Model.prototype.save = async function save(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.prototype.save() no longer accepts a callback");
    }
    let parallelSave;
    this.$op = "save";
    if (this.$__.saving) {
      parallelSave = new ParallelSaveError(this);
    } else {
      this.$__.saving = new ParallelSaveError(this);
    }
    options = new SaveOptions(options);
    if (options.hasOwnProperty("session")) {
      this.$session(options.session);
    }
    if (this.$__.timestamps != null) {
      options.timestamps = this.$__.timestamps;
    }
    this.$__.$versionError = generateVersionError(this, this.modifiedPaths(), Object.keys(this.$__.activePaths.getStatePaths("default")));
    if (parallelSave) {
      this.$__handleReject(parallelSave);
      throw parallelSave;
    }
    this.$__.saveOptions = options;
    await new Promise((resolve, reject) => {
      this.$__save(options, (error) => {
        this.$__.saving = null;
        this.$__.saveOptions = null;
        this.$__.$versionError = null;
        this.$op = null;
        if (error != null) {
          this.$__handleReject(error);
          return reject(error);
        }
        resolve();
      });
    });
    return this;
  };
  Model.prototype.$save = Model.prototype.save;
  Model.prototype.$__version = function(where, delta2) {
    const key = this.$__schema.options.versionKey;
    if (where === true) {
      if (key) {
        setDottedPath(delta2, key, 0);
        this.$__setValue(key, 0);
      }
      return;
    }
    if (key === false) {
      return;
    }
    if (!this.$__isSelected(key)) {
      return;
    }
    if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
      const value = this.$__getValue(key);
      if (value != null)
        where[key] = value;
    }
    if (VERSION_INC === (VERSION_INC & this.$__.version)) {
      if (get(delta2.$set, key, null) != null) {
        ++delta2.$set[key];
      } else {
        delta2.$inc = delta2.$inc || {};
        delta2.$inc[key] = 1;
      }
    }
  };
  Model.prototype.increment = function increment() {
    this.$__.version = VERSION_ALL;
    return this;
  };
  Model.prototype.$__where = function _where(where) {
    where || (where = {});
    if (!where._id) {
      where._id = this._doc._id;
    }
    if (this._doc._id === undefined) {
      return new MongooseError("No _id found on document!");
    }
    return where;
  };
  Model.prototype.deleteOne = function deleteOne(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.prototype.deleteOne() no longer accepts a callback");
    }
    if (!options) {
      options = {};
    }
    if (options.hasOwnProperty("session")) {
      this.$session(options.session);
    }
    const self2 = this;
    const where = this.$__where();
    if (where instanceof Error) {
      throw where;
    }
    const query = self2.constructor.deleteOne(where, options);
    if (this.$session() != null) {
      if (!("session" in query.options)) {
        query.options.session = this.$session();
      }
    }
    query.pre(function queryPreDeleteOne(cb) {
      self2.constructor._middleware.execPre("deleteOne", self2, [self2], cb);
    });
    query.pre(function callSubdocPreHooks(cb) {
      each(self2.$getAllSubdocs(), (subdoc, cb2) => {
        subdoc.constructor._middleware.execPre("deleteOne", subdoc, [subdoc], cb2);
      }, cb);
    });
    query.pre(function skipIfAlreadyDeleted(cb) {
      if (self2.$__.isDeleted) {
        return cb(Kareem.skipWrappedFunction());
      }
      return cb();
    });
    query.post(function callSubdocPostHooks(cb) {
      each(self2.$getAllSubdocs(), (subdoc, cb2) => {
        subdoc.constructor._middleware.execPost("deleteOne", subdoc, [subdoc], {}, cb2);
      }, cb);
    });
    query.post(function queryPostDeleteOne(cb) {
      self2.constructor._middleware.execPost("deleteOne", self2, [self2], {}, cb);
    });
    return query;
  };
  Model.prototype.$model = function $model(name) {
    if (arguments.length === 0) {
      return this.constructor;
    }
    return this[modelDbSymbol].model(name);
  };
  Model.prototype.model = Model.prototype.$model;
  Model.exists = function exists(filter, options) {
    _checkContext(this, "exists");
    if (typeof arguments[2] === "function") {
      throw new MongooseError("Model.exists() no longer accepts a callback");
    }
    const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options);
    return query;
  };
  Model.discriminator = function(name, schema, options) {
    let model;
    if (typeof name === "function") {
      model = name;
      name = utils.getFunctionName(model);
      if (!(model.prototype instanceof Model)) {
        throw new MongooseError("The provided class " + name + " must extend Model");
      }
    }
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone3 = typeof options.clone === "boolean" ? options.clone : true;
    const mergePlugins = typeof options.mergePlugins === "boolean" ? options.mergePlugins : true;
    const overwriteModels = typeof options.overwriteModels === "boolean" ? options.overwriteModels : false;
    _checkContext(this, "discriminator");
    if (utils.isObject(schema) && !schema.instanceOfSchema) {
      schema = new Schema(schema);
    }
    if (schema instanceof Schema && clone3) {
      schema = schema.clone();
    }
    schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks, overwriteModels);
    if (this.db.models[name] && !schema.options.overwriteModels && !overwriteModels) {
      throw new OverwriteModelError(name);
    }
    schema.$isRootDiscriminator = true;
    schema.$globalPluginsApplied = true;
    model = this.db.model(model || name, schema, this.$__collection.name);
    this.discriminators[name] = model;
    const d = this.discriminators[name];
    Object.setPrototypeOf(d.prototype, this.prototype);
    Object.defineProperty(d, "baseModelName", {
      value: this.modelName,
      configurable: true,
      writable: false
    });
    applyMethods(d, schema);
    applyStatics(d, schema);
    if (this[subclassedSymbol] != null) {
      for (const submodel of this[subclassedSymbol]) {
        submodel.discriminators = submodel.discriminators || {};
        submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
      }
    }
    return d;
  };
  function _checkContext(ctx, fnName) {
    if (ctx == null || ctx === global) {
      throw new MongooseError("`Model." + fnName + "()` cannot run without a " + "model as `this`. Make sure you are calling `MyModel." + fnName + "()` " + "where `MyModel` is a Mongoose model.");
    } else if (ctx[modelSymbol] == null) {
      throw new MongooseError("`Model." + fnName + "()` cannot run without a " + "model as `this`. Make sure you are not calling " + "`new Model." + fnName + "()`");
    }
  }
  /*!
   * Give the constructor the ability to emit events.
   */
  for (const i in EventEmitter.prototype) {
    Model[i] = EventEmitter.prototype[i];
  }
  Model.init = function init() {
    _checkContext(this, "init");
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Model.init() no longer accepts a callback");
    }
    this.schema.emit("init", this);
    if (this.$init != null) {
      return this.$init;
    }
    const conn = this.db;
    const _ensureIndexes2 = async () => {
      const autoIndex = utils.getOption("autoIndex", this.schema.options, conn.config, conn.base.options);
      if (!autoIndex) {
        return;
      }
      return await this.ensureIndexes({ _automatic: true });
    };
    const _createSearchIndexes = async () => {
      const autoSearchIndex = utils.getOption("autoSearchIndex", this.schema.options, conn.config, conn.base.options);
      if (!autoSearchIndex) {
        return;
      }
      return await this.ensureSearchIndexes();
    };
    const _createCollection = async () => {
      let autoCreate = utils.getOption("autoCreate", this.schema.options, conn.config);
      if (autoCreate == null) {
        await conn._waitForConnect(true);
        autoCreate = utils.getOption("autoCreate", this.schema.options, conn.config, conn.base.options);
      }
      if (!autoCreate) {
        return;
      }
      return await this.createCollection();
    };
    this.$init = _createCollection().then(() => _ensureIndexes2()).then(() => _createSearchIndexes());
    const _catch = this.$init.catch;
    const _this = this;
    this.$init.catch = function() {
      _this.$caught = true;
      return _catch.apply(_this.$init, arguments);
    };
    return this.$init;
  };
  Model.createCollection = async function createCollection(options) {
    _checkContext(this, "createCollection");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.createCollection() no longer accepts a callback");
    }
    const shouldSkip = await new Promise((resolve, reject) => {
      this.hooks.execPre("createCollection", this, [options], (err2) => {
        if (err2 != null) {
          if (err2 instanceof Kareem.skipWrappedFunction) {
            return resolve(true);
          }
          return reject(err2);
        }
        resolve();
      });
    });
    const collectionOptions = this && this.schema && this.schema.options && this.schema.options.collectionOptions;
    if (collectionOptions != null) {
      options = Object.assign({}, collectionOptions, options);
    }
    const schemaCollation = this && this.schema && this.schema.options && this.schema.options.collation;
    if (schemaCollation != null) {
      options = Object.assign({ collation: schemaCollation }, options);
    }
    const capped = this && this.schema && this.schema.options && this.schema.options.capped;
    if (capped != null) {
      if (typeof capped === "number") {
        options = Object.assign({ capped: true, size: capped }, options);
      } else if (typeof capped === "object") {
        options = Object.assign({ capped: true }, capped, options);
      }
    }
    const timeseries = this && this.schema && this.schema.options && this.schema.options.timeseries;
    if (timeseries != null) {
      options = Object.assign({ timeseries }, options);
      if (options.expireAfterSeconds != null) {
      } else if (options.expires != null) {
        utils.expires(options);
      } else if (this.schema.options.expireAfterSeconds != null) {
        options.expireAfterSeconds = this.schema.options.expireAfterSeconds;
      } else if (this.schema.options.expires != null) {
        options.expires = this.schema.options.expires;
        utils.expires(options);
      }
    }
    const clusteredIndex = this && this.schema && this.schema.options && this.schema.options.clusteredIndex;
    if (clusteredIndex != null) {
      options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);
    }
    try {
      if (!shouldSkip) {
        await this.db.createCollection(this.$__collection.collectionName, options);
      }
    } catch (err2) {
      if (err2 != null && (err2.name !== "MongoServerError" || err2.code !== 48)) {
        await new Promise((resolve, reject) => {
          const _opts = { error: err2 };
          this.hooks.execPost("createCollection", this, [null], _opts, (err3) => {
            if (err3 != null) {
              return reject(err3);
            }
            resolve();
          });
        });
      }
    }
    await new Promise((resolve, reject) => {
      this.hooks.execPost("createCollection", this, [this.$__collection], (err2) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve();
      });
    });
    return this.$__collection;
  };
  Model.syncIndexes = async function syncIndexes(options) {
    _checkContext(this, "syncIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.syncIndexes() no longer accepts a callback");
    }
    const autoCreate = options?.autoCreate ?? this.schema.options?.autoCreate ?? this.db.config.autoCreate ?? true;
    if (autoCreate) {
      try {
        await this.createCollection();
      } catch (err2) {
        if (err2 != null && (err2.name !== "MongoServerError" || err2.code !== 48)) {
          throw err2;
        }
      }
    }
    const diffIndexesResult = await this.diffIndexes({ indexOptionsToCreate: true });
    const dropped = await this.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });
    await this.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });
    return dropped;
  };
  Model.createSearchIndex = async function createSearchIndex(description) {
    _checkContext(this, "createSearchIndex");
    return await this.$__collection.createSearchIndex(description);
  };
  Model.updateSearchIndex = async function updateSearchIndex(name, definition) {
    _checkContext(this, "updateSearchIndex");
    return await this.$__collection.updateSearchIndex(name, definition);
  };
  Model.dropSearchIndex = async function dropSearchIndex(name) {
    _checkContext(this, "dropSearchIndex");
    return await this.$__collection.dropSearchIndex(name);
  };
  Model.listSearchIndexes = async function listSearchIndexes(options) {
    _checkContext(this, "listSearchIndexes");
    const cursor = await this.$__collection.listSearchIndexes(options);
    return await cursor.toArray();
  };
  Model.diffIndexes = async function diffIndexes(options) {
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.syncIndexes() no longer accepts a callback");
    }
    const model = this;
    let dbIndexes = await model.listIndexes().catch((err2) => {
      if (err2.codeName == "NamespaceNotFound") {
        return;
      }
      throw err2;
    });
    if (dbIndexes === undefined) {
      dbIndexes = [];
    }
    dbIndexes = getRelatedDBIndexes(model, dbIndexes);
    const schema = model.schema;
    const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());
    const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);
    const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options);
    return { toDrop, toCreate };
  };
  function getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options) {
    const toCreate = [];
    const indexOptionsToCreate = options?.indexOptionsToCreate ?? false;
    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
      let found = false;
      const options2 = decorateDiscriminatorIndexOptions(schema, clone2(schemaIndexOptions));
      for (const index of dbIndexes) {
        if (isDefaultIdIndex(index)) {
          continue;
        }
        if (isIndexEqual(schemaIndexKeysObject, options2, index) && !toDrop.includes(index.name)) {
          found = true;
          break;
        }
      }
      if (!found) {
        if (indexOptionsToCreate) {
          toCreate.push([schemaIndexKeysObject, schemaIndexOptions]);
        } else {
          toCreate.push(schemaIndexKeysObject);
        }
      }
    }
    return toCreate;
  }
  function getIndexesToDrop(schema, schemaIndexes, dbIndexes) {
    const toDrop = [];
    for (const dbIndex of dbIndexes) {
      let found = false;
      if (isDefaultIdIndex(dbIndex)) {
        continue;
      }
      if (isTimeseriesIndex(dbIndex, schema.options)) {
        continue;
      }
      for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
        const options = decorateDiscriminatorIndexOptions(schema, clone2(schemaIndexOptions));
        applySchemaCollation(schemaIndexKeysObject, options, schema.options);
        if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {
          found = true;
          break;
        }
      }
      if (found) {
        continue;
      }
      toDrop.push(dbIndex.name);
    }
    return toDrop;
  }
  Model.cleanIndexes = async function cleanIndexes(options) {
    _checkContext(this, "cleanIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.cleanIndexes() no longer accepts a callback");
    }
    const model = this;
    if (Array.isArray(options && options.toDrop)) {
      const res2 = await _dropIndexes(options.toDrop, model, options);
      return res2;
    }
    const res = await model.diffIndexes();
    return await _dropIndexes(res.toDrop, model, options);
  };
  async function _dropIndexes(toDrop, model, options) {
    if (toDrop.length === 0) {
      return [];
    }
    const collection = model.$__collection;
    if (options && options.hideIndexes) {
      await Promise.all(toDrop.map((indexName) => {
        return model.db.db.command({
          collMod: collection.collectionName,
          index: { name: indexName, hidden: true }
        });
      }));
    } else {
      await Promise.all(toDrop.map((indexName) => collection.dropIndex(indexName)));
    }
    return toDrop;
  }
  Model.listIndexes = async function listIndexes() {
    _checkContext(this, "listIndexes");
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Model.listIndexes() no longer accepts a callback");
    }
    if (this.$__collection.buffer) {
      await new Promise((resolve) => {
        this.$__collection.addQueue(resolve);
      });
    }
    return this.$__collection.listIndexes().toArray();
  };
  Model.ensureIndexes = async function ensureIndexes(options) {
    _checkContext(this, "ensureIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.ensureIndexes() no longer accepts a callback");
    }
    await new Promise((resolve, reject) => {
      _ensureIndexes(this, options, (err2) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve();
      });
    });
  };
  Model.createIndexes = async function createIndexes(options) {
    _checkContext(this, "createIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.createIndexes() no longer accepts a callback");
    }
    return this.ensureIndexes(options);
  };
  /*!
   * ignore
   */
  function _ensureIndexes(model, options, callback) {
    const indexes = Array.isArray(options?.toCreate) ? options.toCreate : model.schema.indexes();
    let indexError;
    options = options || {};
    const done = function(err2) {
      if (err2 && !model.$caught) {
        model.emit("error", err2);
      }
      model.emit("index", err2 || indexError);
      callback && callback(err2 || indexError);
    };
    for (const index of indexes) {
      if (isDefaultIdIndex(index)) {
        utils.warn("mongoose: Cannot specify a custom index on `_id` for " + 'model name "' + model.modelName + '", ' + "MongoDB does not allow overwriting the default `_id` index. See " + "https://bit.ly/mongodb-id-index");
      }
    }
    if (!indexes.length) {
      immediate(function() {
        done();
      });
      return;
    }
    const indexSingleDone = function(err2, fields, options2, name) {
      model.emit("index-single-done", err2, fields, options2, name);
    };
    const indexSingleStart = function(fields, options2) {
      model.emit("index-single-start", fields, options2);
    };
    const baseSchema = model.schema._baseSchema;
    const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
    immediate(function() {
      if (options._automatic && !model.collection.collection) {
        model.collection.addQueue(create2, []);
      } else {
        create2();
      }
    });
    function create2() {
      if (options._automatic) {
        if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
          return done();
        }
      }
      const index = indexes.shift();
      if (!index) {
        return done();
      }
      if (options._automatic && index[1]._autoIndex === false) {
        return create2();
      }
      if (baseSchemaIndexes.find((i) => utils.deepEqual(i, index))) {
        return create2();
      }
      const indexFields = clone2(index[0]);
      const indexOptions = clone2(index[1]);
      delete indexOptions._autoIndex;
      decorateDiscriminatorIndexOptions(model.schema, indexOptions);
      applyWriteConcern(model.schema, indexOptions);
      applySchemaCollation(indexFields, indexOptions, model.schema.options);
      indexSingleStart(indexFields, options);
      if ("background" in options) {
        indexOptions.background = options.background;
      }
      let promise = null;
      try {
        promise = model.collection.createIndex(indexFields, indexOptions);
      } catch (err2) {
        if (!indexError) {
          indexError = err2;
        }
        if (!model.$caught) {
          model.emit("error", err2);
        }
        indexSingleDone(err2, indexFields, indexOptions);
        create2();
        return;
      }
      promise.then((name) => {
        indexSingleDone(null, indexFields, indexOptions, name);
        create2();
      }, (err2) => {
        if (!indexError) {
          indexError = err2;
        }
        if (!model.$caught) {
          model.emit("error", err2);
        }
        indexSingleDone(err2, indexFields, indexOptions);
        create2();
      });
    }
  }
  Model.createSearchIndexes = async function createSearchIndexes() {
    _checkContext(this, "createSearchIndexes");
    const results = [];
    for (const searchIndex of this.schema._searchIndexes) {
      results.push(await this.createSearchIndex(searchIndex));
    }
    return results;
  };
  Model.schema;
  Model.db;
  Model.collection;
  Model.$__collection;
  Model.base;
  Model.discriminators;
  Model.translateAliases = function translateAliases(fields, errorOnDuplicates) {
    _checkContext(this, "translateAliases");
    const translate = (key, value) => {
      let alias;
      const translated = [];
      const fieldKeys = key.split(".");
      let currentSchema = this.schema;
      for (const i in fieldKeys) {
        const name = fieldKeys[i];
        if (currentSchema && currentSchema.aliases[name]) {
          alias = currentSchema.aliases[name];
          if (errorOnDuplicates && alias in fields) {
            throw new MongooseError(`Provided object has both field "${name}" and its alias "${alias}"`);
          }
          translated.push(alias);
        } else {
          alias = name;
          translated.push(name);
        }
        if (currentSchema && currentSchema.paths[alias]) {
          currentSchema = currentSchema.paths[alias].schema;
        } else
          currentSchema = null;
      }
      const translatedKey = translated.join(".");
      if (fields instanceof Map)
        fields.set(translatedKey, value);
      else
        fields[translatedKey] = value;
      if (translatedKey !== key) {
        if (fields instanceof Map) {
          fields.delete(key);
        } else {
          delete fields[key];
        }
      }
      return fields;
    };
    if (typeof fields === "object") {
      if (fields instanceof Map) {
        for (const field of new Map(fields)) {
          fields = translate(field[0], field[1]);
        }
      } else {
        for (const key of Object.keys(fields)) {
          fields = translate(key, fields[key]);
          if (key[0] === "$") {
            if (Array.isArray(fields[key])) {
              for (const i in fields[key]) {
                fields[key][i] = this.translateAliases(fields[key][i]);
              }
            } else {
              this.translateAliases(fields[key]);
            }
          }
        }
      }
      return fields;
    } else {
      return fields;
    }
  };
  Model.deleteOne = function deleteOne(conditions, options) {
    _checkContext(this, "deleteOne");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.prototype.deleteOne() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    return mq.deleteOne(conditions);
  };
  Model.deleteMany = function deleteMany(conditions, options) {
    _checkContext(this, "deleteMany");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.deleteMany() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    return mq.deleteMany(conditions);
  };
  Model.find = function find(conditions, projection, options) {
    _checkContext(this, "find");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.find() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    return mq.find(conditions);
  };
  Model.findById = function findById(id, projection, options) {
    _checkContext(this, "findById");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findById() no longer accepts a callback");
    }
    if (typeof id === "undefined") {
      id = null;
    }
    return this.findOne({ _id: id }, projection, options);
  };
  Model.findOne = function findOne(conditions, projection, options) {
    _checkContext(this, "findOne");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findOne() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    return mq.findOne(conditions);
  };
  Model.estimatedDocumentCount = function estimatedDocumentCount(options) {
    _checkContext(this, "estimatedDocumentCount");
    const mq = new this.Query({}, {}, this, this.$__collection);
    return mq.estimatedDocumentCount(options);
  };
  Model.countDocuments = function countDocuments(conditions, options) {
    _checkContext(this, "countDocuments");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.countDocuments() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (options != null) {
      mq.setOptions(options);
    }
    return mq.countDocuments(conditions);
  };
  Model.distinct = function distinct(field, conditions, options) {
    _checkContext(this, "distinct");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.distinct() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (options != null) {
      mq.setOptions(options);
    }
    return mq.distinct(field, conditions);
  };
  Model.where = function where(path, val) {
    _checkContext(this, "where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.where.apply(mq, arguments);
  };
  Model.$where = function $where() {
    _checkContext(this, "$where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.$where.apply(mq, arguments);
  };
  Model.findOneAndUpdate = function(conditions, update, options) {
    _checkContext(this, "findOneAndUpdate");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndUpdate() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.fields || options.projection;
    }
    update = clone2(update, {
      depopulate: true,
      _isNested: true
    });
    decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndUpdate(conditions, update, options);
  };
  Model.findByIdAndUpdate = function(id, update, options) {
    _checkContext(this, "findByIdAndUpdate");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findByIdAndUpdate() no longer accepts a callback");
    }
    if (id instanceof Document) {
      id = id._doc._id;
    }
    return this.findOneAndUpdate.call(this, { _id: id }, update, options);
  };
  Model.findOneAndDelete = function(conditions, options) {
    _checkContext(this, "findOneAndDelete");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findOneAndDelete() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndDelete(conditions, options);
  };
  Model.findByIdAndDelete = function(id, options) {
    _checkContext(this, "findByIdAndDelete");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findByIdAndDelete() no longer accepts a callback");
    }
    return this.findOneAndDelete({ _id: id }, options);
  };
  Model.findOneAndReplace = function(filter, replacement, options) {
    _checkContext(this, "findOneAndReplace");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndReplace() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndReplace(filter, replacement, options);
  };
  Model.create = async function create(doc, options) {
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.create() no longer accepts a callback");
    }
    _checkContext(this, "create");
    let args;
    const discriminatorKey = this.schema.options.discriminatorKey;
    if (Array.isArray(doc)) {
      args = doc;
      options = options != null && typeof options === "object" ? options : {};
    } else {
      const last = arguments[arguments.length - 1];
      options = {};
      const hasCallback = typeof last === "function" || typeof options === "function" || typeof arguments[2] === "function";
      if (hasCallback) {
        throw new MongooseError("Model.create() no longer accepts a callback");
      } else {
        args = [...arguments];
        if (args.length > 1 && !last) {
          args.pop();
        }
      }
      if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && last && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
        utils.warn("WARNING: to pass a `session` to `Model.create()` in " + "Mongoose, you **must** pass an array as the first argument. See: " + "https://mongoosejs.com/docs/api/model.html#Model.create()");
      }
    }
    if (args.length === 0) {
      return Array.isArray(doc) ? [] : null;
    }
    let res = [];
    const immediateError = typeof options.aggregateErrors === "boolean" ? !options.aggregateErrors : true;
    delete options.aggregateErrors;
    if (options.session && !options.ordered && args.length > 1) {
      throw new MongooseError("Cannot call `create()` with a session and multiple documents unless `ordered: true` is set");
    }
    if (options.ordered) {
      for (let i = 0;i < args.length; i++) {
        try {
          const doc2 = args[i];
          const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
          if (Model2 == null) {
            throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
          }
          let toSave = doc2;
          if (!(toSave instanceof Model2)) {
            toSave = new Model2(toSave);
          }
          await toSave.$save(options);
          res.push(toSave);
        } catch (err2) {
          if (!immediateError) {
            res.push(err2);
          } else {
            throw err2;
          }
        }
      }
      return res;
    } else if (!immediateError) {
      res = await Promise.allSettled(args.map(async (doc2) => {
        const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
        if (Model2 == null) {
          throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
        }
        let toSave = doc2;
        if (!(toSave instanceof Model2)) {
          toSave = new Model2(toSave);
        }
        await toSave.$save(options);
        return toSave;
      }));
      res = res.map((result) => result.status === "fulfilled" ? result.value : result.reason);
    } else {
      let firstError = null;
      res = await Promise.all(args.map(async (doc2) => {
        const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
        if (Model2 == null) {
          throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
        }
        try {
          let toSave = doc2;
          if (!(toSave instanceof Model2)) {
            toSave = new Model2(toSave);
          }
          await toSave.$save(options);
          return toSave;
        } catch (err2) {
          if (!firstError) {
            firstError = err2;
          }
        }
      }));
      if (firstError) {
        throw firstError;
      }
    }
    if (!Array.isArray(doc) && args.length === 1) {
      return res[0];
    }
    return res;
  };
  Model.insertOne = async function insertOne(doc, options) {
    _checkContext(this, "insertOne");
    const discriminatorKey = this.schema.options.discriminatorKey;
    const Model2 = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;
    if (Model2 == null) {
      throw new MongooseError(`Discriminator "${doc[discriminatorKey]}" not found for model "${this.modelName}"`);
    }
    if (!(doc instanceof Model2)) {
      doc = new Model2(doc);
    }
    return await doc.$save(options);
  };
  Model.watch = function(pipeline2, options) {
    _checkContext(this, "watch");
    const changeStreamThunk = (cb) => {
      pipeline2 = pipeline2 || [];
      prepareDiscriminatorPipeline(pipeline2, this.schema, "fullDocument");
      if (this.$__collection.buffer) {
        this.$__collection.addQueue(() => {
          if (this.closed) {
            return;
          }
          const driverChangeStream = this.$__collection.watch(pipeline2, options);
          cb(null, driverChangeStream);
        });
      } else {
        const driverChangeStream = this.$__collection.watch(pipeline2, options);
        cb(null, driverChangeStream);
      }
    };
    options = options || {};
    options.model = this;
    return new ChangeStream(changeStreamThunk, pipeline2, options);
  };
  Model.startSession = function() {
    _checkContext(this, "startSession");
    return this.db.startSession.apply(this.db, arguments);
  };
  Model.insertMany = async function insertMany(arr, options) {
    _checkContext(this, "insertMany");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.insertMany() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      this.$__insertMany(arr, options, (err2, res) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve(res);
      });
    });
  };
  Model.$__insertMany = function(arr, options, callback) {
    const _this = this;
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    callback = callback || utils.noop;
    options = options || {};
    const limit = options.limit || 1000;
    const rawResult = !!options.rawResult;
    const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
    const throwOnValidationError = typeof options.throwOnValidationError === "boolean" ? options.throwOnValidationError : false;
    const lean = !!options.lean;
    const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();
    if ((!options || !options.hasOwnProperty("session")) && asyncLocalStorage?.session != null) {
      options = { ...options, session: asyncLocalStorage.session };
    }
    if (!Array.isArray(arr)) {
      arr = [arr];
    }
    const validationErrors = [];
    const validationErrorsToOriginalOrder = new Map;
    const results = ordered ? null : new Array(arr.length);
    const toExecute = arr.map((doc, index) => (callback2) => {
      if (lean) {
        return immediate(() => callback2(null, doc));
      }
      let createdNewDoc = false;
      if (!(doc instanceof _this)) {
        if (doc != null && typeof doc !== "object") {
          return callback2(new ObjectParameterError(doc, "arr." + index, "insertMany"));
        }
        try {
          doc = new _this(doc);
          createdNewDoc = true;
        } catch (err2) {
          return callback2(err2);
        }
      }
      if (options.session != null) {
        doc.$session(options.session);
      }
      if (lean) {
        return immediate(() => callback2(null, doc));
      }
      doc.$validate(createdNewDoc ? { _skipParallelValidateCheck: true } : null).then(() => {
        callback2(null, doc);
      }, (error) => {
        if (ordered === false) {
          validationErrors.push(error);
          validationErrorsToOriginalOrder.set(error, index);
          results[index] = error;
          return callback2(null, null);
        }
        callback2(error);
      });
    });
    parallelLimit(toExecute, limit, function(error, docs) {
      if (error) {
        callback(error, null);
        return;
      }
      const originalDocIndex = new Map;
      const validDocIndexToOriginalIndex = new Map;
      for (let i = 0;i < docs.length; ++i) {
        originalDocIndex.set(docs[i], i);
      }
      const docAttributes = docs.filter(function(doc) {
        return doc != null;
      });
      for (let i = 0;i < docAttributes.length; ++i) {
        validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));
      }
      if (validationErrors.length > 0) {
        validationErrors.sort((err1, err2) => {
          return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);
        });
      }
      if (docAttributes.length === 0) {
        if (throwOnValidationError) {
          return callback(new MongooseBulkWriteError(validationErrors, results, null, "insertMany"));
        }
        if (rawResult) {
          const res = {
            acknowledged: true,
            insertedCount: 0,
            insertedIds: {}
          };
          decorateBulkWriteResult(res, validationErrors, validationErrors);
          return callback(null, res);
        }
        callback(null, []);
        return;
      }
      const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {
        if (doc.$__schema.options.versionKey) {
          doc[doc.$__schema.options.versionKey] = 0;
        }
        const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);
        if (shouldSetTimestamps) {
          doc.initializeTimestamps();
        }
        if (doc.$__hasOnlyPrimitiveValues()) {
          return doc.$__toObjectShallow();
        }
        return doc.toObject(internalToObjectOptions);
      });
      _this.$__collection.insertMany(docObjects, options).then((res) => {
        if (!lean) {
          for (const attribute of docAttributes) {
            attribute.$__reset();
            _setIsNew(attribute, false);
          }
        }
        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {
          for (let i = 0;i < results.length; ++i) {
            if (results[i] === undefined) {
              results[i] = docs[i];
            }
          }
          return callback(new MongooseBulkWriteError(validationErrors, results, res, "insertMany"));
        }
        if (rawResult) {
          if (ordered === false) {
            for (let i = 0;i < results.length; ++i) {
              if (results[i] === undefined) {
                results[i] = docs[i];
              }
            }
            decorateBulkWriteResult(res, validationErrors, results);
          }
          return callback(null, res);
        }
        if (options.populate != null) {
          return _this.populate(docAttributes, options.populate).then((docs2) => {
            callback(null, docs2);
          }, (err2) => {
            if (err2 != null) {
              err2.insertedDocs = docAttributes;
            }
            throw err2;
          });
        }
        callback(null, docAttributes);
      }, (error2) => {
        if (error2.writeErrors == null && (error2.result && error2.result.result && error2.result.result.writeErrors) != null) {
          error2.writeErrors = error2.result.result.writeErrors;
        }
        const hasWriteErrors = error2 && error2.writeErrors;
        const erroredIndexes = new Set((error2 && error2.writeErrors || []).map((err2) => err2.index));
        if (error2.writeErrors != null) {
          for (let i = 0;i < error2.writeErrors.length; ++i) {
            const originalIndex = validDocIndexToOriginalIndex.get(error2.writeErrors[i].index);
            error2.writeErrors[i] = { ...error2.writeErrors[i], index: originalIndex };
            if (!ordered) {
              results[originalIndex] = error2.writeErrors[i];
            }
          }
        }
        if (!ordered) {
          for (let i = 0;i < results.length; ++i) {
            if (results[i] === undefined) {
              results[i] = docs[i];
            }
          }
          error2.results = results;
        }
        let firstErroredIndex = -1;
        error2.insertedDocs = docAttributes.filter((doc, i) => {
          const isErrored = !hasWriteErrors || erroredIndexes.has(i);
          if (ordered) {
            if (firstErroredIndex > -1) {
              return i < firstErroredIndex;
            }
            if (isErrored) {
              firstErroredIndex = i;
            }
          }
          return !isErrored;
        }).map(function setIsNewForInsertedDoc(doc) {
          if (lean) {
            return doc;
          }
          doc.$__reset();
          _setIsNew(doc, false);
          return doc;
        });
        if (rawResult && ordered === false) {
          decorateBulkWriteResult(error2, validationErrors, results);
        }
        callback(error2, null);
      });
    });
  };
  /*!
   * ignore
   */
  function _setIsNew(doc, val) {
    doc.$isNew = val;
    doc.$emit("isNew", val);
    doc.constructor.emit("isNew", val);
    const subdocs = doc.$getAllSubdocs({ useCache: true });
    for (const subdoc of subdocs) {
      subdoc.$isNew = val;
      subdoc.$emit("isNew", val);
    }
  }
  Model.bulkWrite = async function bulkWrite(ops, options) {
    _checkContext(this, "bulkWrite");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.bulkWrite() no longer accepts a callback");
    }
    options = options || {};
    const shouldSkip = await new Promise((resolve, reject) => {
      this.hooks.execPre("bulkWrite", this, [ops, options], (err2) => {
        if (err2 != null) {
          if (err2 instanceof Kareem.skipWrappedFunction) {
            return resolve(err2);
          }
          return reject(err2);
        }
        resolve();
      });
    });
    if (shouldSkip) {
      return shouldSkip.args[0];
    }
    const ordered = options.ordered == null ? true : options.ordered;
    if (ops.length === 0) {
      const BulkWriteResult = this.base.driver.get().BulkWriteResult;
      const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);
      bulkWriteResult.n = 0;
      decorateBulkWriteResult(bulkWriteResult, [], []);
      return bulkWriteResult;
    }
    const validations = options?._skipCastBulkWrite ? [] : ops.map((op) => castBulkWrite(this, op, options));
    const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();
    if ((!options || !options.hasOwnProperty("session")) && asyncLocalStorage?.session != null) {
      options = { ...options, session: asyncLocalStorage.session };
    }
    let res = null;
    if (ordered) {
      await new Promise((resolve, reject) => {
        each(validations, (fn, cb) => fn(cb), (error) => {
          if (error) {
            return reject(error);
          }
          resolve();
        });
      });
      try {
        res = await this.$__collection.bulkWrite(ops, options);
      } catch (error) {
        await new Promise((resolve, reject) => {
          const _opts = { error };
          this.hooks.execPost("bulkWrite", this, [null], _opts, (err2) => {
            if (err2 != null) {
              return reject(err2);
            }
            resolve();
          });
        });
      }
    } else {
      let validOpIndexes = [];
      let validationErrors = [];
      const results = [];
      if (validations.length > 0) {
        validOpIndexes = await Promise.all(ops.map((op, i) => {
          if (i >= validations.length) {
            return i;
          }
          return new Promise((resolve) => {
            validations[i]((err2) => {
              if (err2 == null) {
                resolve(i);
              } else {
                validationErrors.push({ index: i, error: err2 });
                results[i] = err2;
              }
              resolve();
            });
          });
        }));
        validOpIndexes = validOpIndexes.filter((index) => index != null);
      } else {
        validOpIndexes = ops.map((op, i) => i);
      }
      validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map((v) => v.error);
      const validOps = validOpIndexes.sort().map((index) => ops[index]);
      if (validOps.length === 0) {
        if (options.throwOnValidationError && validationErrors.length) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        }
        const BulkWriteResult = this.base.driver.get().BulkWriteResult;
        const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);
        bulkWriteResult.result = getDefaultBulkwriteResult();
        decorateBulkWriteResult(bulkWriteResult, validationErrors, results);
        return bulkWriteResult;
      }
      let error;
      [res, error] = await this.$__collection.bulkWrite(validOps, options).then((res2) => [res2, null]).catch((error2) => [null, error2]);
      const writeErrorsByIndex = {};
      if (error?.writeErrors) {
        for (const writeError of error.writeErrors) {
          writeErrorsByIndex[writeError.err.index] = writeError;
        }
      }
      for (let i = 0;i < validOpIndexes.length; ++i) {
        results[validOpIndexes[i]] = writeErrorsByIndex[i] ?? null;
      }
      if (error) {
        if (validationErrors.length > 0) {
          decorateBulkWriteResult(error, validationErrors, results);
        }
        await new Promise((resolve, reject) => {
          const _opts = { error };
          this.hooks.execPost("bulkWrite", this, [null], _opts, (err2) => {
            if (err2 != null) {
              return reject(err2);
            }
            resolve();
          });
        });
      }
      if (validationErrors.length > 0) {
        if (options.throwOnValidationError) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        } else {
          decorateBulkWriteResult(res, validationErrors, results);
        }
      }
    }
    await new Promise((resolve, reject) => {
      this.hooks.execPost("bulkWrite", this, [res], (err2) => {
        if (err2 != null) {
          return reject(err2);
        }
        resolve();
      });
    });
    return res;
  };
  Model.bulkSave = async function bulkSave(documents, options) {
    options = options || {};
    if (options.timestamps != null) {
      for (const document2 of documents) {
        document2.$__.saveOptions = document2.$__.saveOptions || {};
        document2.$__.saveOptions.timestamps = options.timestamps;
      }
    } else {
      for (const document2 of documents) {
        if (document2.$__.timestamps != null) {
          document2.$__.saveOptions = document2.$__.saveOptions || {};
          document2.$__.saveOptions.timestamps = document2.$__.timestamps;
        }
      }
    }
    await Promise.all(documents.map((doc) => buildPreSavePromise(doc, options)));
    const writeOperations = this.buildBulkWriteOperations(documents, options);
    const opts = { skipValidation: true, _skipCastBulkWrite: true, ...options };
    const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, opts).then((res) => ({ bulkWriteResult: res, bulkWriteError: null }), (err2) => ({ bulkWriteResult: null, bulkWriteError: err2 }));
    if (bulkWriteError != null && bulkWriteError.name !== "MongoBulkWriteError") {
      throw bulkWriteError;
    }
    const matchedCount = bulkWriteResult?.matchedCount ?? 0;
    const insertedCount = bulkWriteResult?.insertedCount ?? 0;
    if (writeOperations.length > 0 && matchedCount + insertedCount < writeOperations.length && !bulkWriteError) {
      throw new MongooseBulkSaveIncompleteError(this.modelName, documents, bulkWriteResult);
    }
    const successfulDocuments = [];
    for (let i = 0;i < documents.length; i++) {
      const document2 = documents[i];
      const documentError = bulkWriteError && bulkWriteError.writeErrors.find((writeError) => {
        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
        return writeErrorDocumentId.toString() === document2._doc._id.toString();
      });
      if (documentError == null) {
        successfulDocuments.push(document2);
      }
    }
    await Promise.all(successfulDocuments.map((document2) => handleSuccessfulWrite(document2)));
    if (bulkWriteError != null) {
      throw bulkWriteError;
    }
    return bulkWriteResult;
  };
  function buildPreSavePromise(document2, options) {
    return new Promise((resolve, reject) => {
      document2.schema.s.hooks.execPre("save", document2, [options], (err2) => {
        if (err2) {
          reject(err2);
          return;
        }
        resolve();
      });
    });
  }
  function handleSuccessfulWrite(document2) {
    return new Promise((resolve, reject) => {
      if (document2.$isNew) {
        _setIsNew(document2, false);
      }
      document2.$__reset();
      document2.schema.s.hooks.execPost("save", document2, [document2], {}, (err2) => {
        if (err2) {
          reject(err2);
          return;
        }
        resolve();
      });
    });
  }
  Model.applyDefaults = function applyDefaults(doc) {
    if (doc == null) {
      return doc;
    }
    if (doc.$__ != null) {
      applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);
      for (const subdoc of doc.$getAllSubdocs()) {
        applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);
      }
      return doc;
    }
    applyDefaultsToPOJO(doc, this.schema);
    return doc;
  };
  Model.applyVirtuals = function applyVirtuals(obj, virtualsToApply) {
    if (obj == null) {
      return obj;
    }
    if (obj.$__ != null) {
      return obj;
    }
    applyVirtualsHelper(this.schema, obj, virtualsToApply);
    return obj;
  };
  Model.applyTimestamps = function applyTimestamps(obj, options) {
    if (obj == null) {
      return obj;
    }
    if (obj.$__ != null) {
      return obj;
    }
    applyTimestampsHelper(this.schema, obj, options);
    return obj;
  };
  Model.castObject = function castObject(obj, options) {
    options = options || {};
    const ret = {};
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
    }
    const paths = Object.keys(schema.paths);
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray) {
        continue;
      }
      const val = get(obj, path);
      pushNestedArrayPaths(paths, val, path);
    }
    let error = null;
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (schemaType == null) {
        continue;
      }
      let val = get(obj, path, undefined);
      if (val == null) {
        continue;
      }
      const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
      let cur = ret;
      for (let i = 0;i < pieces.length - 1; ++i) {
        if (cur[pieces[i]] == null) {
          cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];
        }
        cur = cur[pieces[i]];
      }
      if (schemaType.$isMongooseDocumentArray) {
        const castNonArraysOption = schemaType.options?.castNonArrays ?? schemaType.constructor.options.castNonArrays;
        if (!Array.isArray(val)) {
          if (!castNonArraysOption) {
            if (!options.ignoreCastErrors) {
              error = error || new ValidationError2;
              error.addError(path, new ObjectExpectedError(path, val));
            }
          } else {
            cur[pieces[pieces.length - 1]] = [
              Model.castObject.call(schemaType.caster, val)
            ];
          }
          continue;
        }
      }
      if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {
        try {
          val = Model.castObject.call(schemaType.caster, val);
        } catch (err2) {
          if (!options.ignoreCastErrors) {
            error = error || new ValidationError2;
            error.addError(path, err2);
          }
          continue;
        }
        cur[pieces[pieces.length - 1]] = val;
        continue;
      }
      try {
        val = schemaType.cast(val);
        cur[pieces[pieces.length - 1]] = val;
      } catch (err2) {
        if (!options.ignoreCastErrors) {
          error = error || new ValidationError2;
          error.addError(path, err2);
        }
        continue;
      }
    }
    if (error != null) {
      throw error;
    }
    return ret;
  };
  Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
    if (!Array.isArray(documents)) {
      throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
    }
    setDefaultOptions();
    const writeOperations = documents.map((document2, i) => {
      if (!options.skipValidation) {
        if (!(document2 instanceof Document)) {
          throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
        }
        if (options.validateBeforeSave == null || options.validateBeforeSave) {
          const err2 = document2.validateSync();
          if (err2 != null) {
            throw err2;
          }
        }
      }
      const isANewDocument = document2.isNew;
      if (isANewDocument) {
        const writeOperation = { insertOne: { document: document2 } };
        utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);
        return writeOperation;
      }
      const delta2 = document2.$__delta();
      const isDocumentWithChanges = delta2 != null && !utils.isEmptyObject(delta2[0]);
      if (isDocumentWithChanges) {
        const where = document2.$__where(delta2[0]);
        const changes = delta2[1];
        _applyCustomWhere(document2, where);
        const shardKey = this.schema.options.shardKey;
        if (shardKey) {
          const paths = Object.keys(shardKey);
          const len = paths.length;
          for (let i2 = 0;i2 < len; ++i2) {
            where[paths[i2]] = document2[paths[i2]];
          }
        }
        document2.$__version(where, delta2);
        const writeOperation = { updateOne: { filter: where, update: changes } };
        utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);
        return writeOperation;
      }
      return null;
    }).filter((op) => op !== null);
    return writeOperations;
    function setDefaultOptions() {
      options = options || {};
      if (options.skipValidation == null) {
        options.skipValidation = false;
      }
    }
  };
  Model.hydrate = function(obj, projection, options) {
    _checkContext(this, "hydrate");
    if (projection != null) {
      if (obj != null && obj.$__ != null) {
        obj = obj.toObject(internalToObjectOptions);
      }
      obj = applyProjection(obj, projection);
    }
    const document2 = require_queryHelpers().createModel(this, obj, projection);
    document2.$init(obj, options);
    return document2;
  };
  Model.updateMany = function updateMany(conditions, update, options) {
    _checkContext(this, "updateMany");
    if (update == null) {
      throw new MongooseError("updateMany `update` parameter cannot be nullish");
    }
    return _update(this, "updateMany", conditions, update, options);
  };
  Model.updateOne = function updateOne(conditions, doc, options) {
    _checkContext(this, "updateOne");
    return _update(this, "updateOne", conditions, doc, options);
  };
  Model.replaceOne = function replaceOne(conditions, doc, options) {
    _checkContext(this, "replaceOne");
    const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;
    if (versionKey && !doc[versionKey]) {
      doc[versionKey] = 0;
    }
    return _update(this, "replaceOne", conditions, doc, options);
  };
  function _update(model, op, conditions, doc, options) {
    const mq = new model.Query({}, {}, model, model.collection);
    if (conditions instanceof Document) {
      conditions = conditions.toObject();
    } else {
      conditions = clone2(conditions);
    }
    options = typeof options === "function" ? options : clone2(options);
    const versionKey = model && model.schema && model.schema.options && model.schema.options.versionKey || null;
    decorateUpdateWithVersionKey(doc, options, versionKey);
    return mq[op](conditions, doc, options);
  }
  Model.aggregate = function aggregate(pipeline2, options) {
    _checkContext(this, "aggregate");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.aggregate() no longer accepts a callback");
    }
    const aggregate = new Aggregate(pipeline2 || []);
    aggregate.model(this);
    if (options != null) {
      aggregate.option(options);
    }
    return aggregate;
  };
  Model.validate = async function validate(obj, pathsOrOptions, context) {
    if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
      context = obj;
    }
    if (typeof context === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.validate() no longer accepts a callback");
    }
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
    }
    let paths = Object.keys(schema.paths);
    if (pathsOrOptions != null) {
      const _pathsToValidate = typeof pathsOrOptions === "string" ? new Set(pathsOrOptions.split(" ")) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);
      paths = paths.filter((p) => {
        if (pathsOrOptions.pathsToSkip) {
          if (Array.isArray(pathsOrOptions.pathsToSkip)) {
            if (pathsOrOptions.pathsToSkip.find((x) => x == p)) {
              return false;
            }
          } else if (typeof pathsOrOptions.pathsToSkip == "string") {
            if (pathsOrOptions.pathsToSkip.includes(p)) {
              return false;
            }
          }
        }
        const pieces = p.split(".");
        let cur = pieces[0];
        for (const piece of pieces) {
          if (_pathsToValidate.has(cur)) {
            return true;
          }
          cur += "." + piece;
        }
        return _pathsToValidate.has(p);
      });
    }
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {
        continue;
      }
      const val = get(obj, path);
      pushNestedArrayPaths(paths, val, path);
    }
    let error = null;
    paths = new Set(paths);
    try {
      obj = this.castObject(obj);
    } catch (err2) {
      error = err2;
      for (const key of Object.keys(error.errors || {})) {
        paths.delete(key);
      }
    }
    let remaining = paths.size;
    return new Promise((resolve, reject) => {
      for (const path of paths) {
        const schemaType = schema.path(path);
        if (schemaType == null) {
          _checkDone();
          continue;
        }
        const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
        let cur = obj;
        for (let i = 0;i < pieces.length - 1; ++i) {
          cur = cur[pieces[i]];
        }
        const val = get(obj, path, undefined);
        schemaType.doValidate(val, (err2) => {
          if (err2) {
            error = error || new ValidationError2;
            error.addError(path, err2);
          }
          _checkDone();
        }, context, { path });
      }
      function _checkDone() {
        if (--remaining <= 0) {
          if (error) {
            reject(error);
          } else {
            resolve(obj);
          }
        }
      }
    });
  };
  Model.populate = async function populate(docs, paths) {
    _checkContext(this, "populate");
    if (typeof paths === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.populate() no longer accepts a callback");
    }
    paths = utils.populate(paths);
    if (paths.length === 0) {
      return docs;
    }
    if (paths.find((p) => p.ordered)) {
      for (const path of paths) {
        await _populatePath(this, docs, path);
      }
    } else {
      const promises = [];
      for (const path of paths) {
        promises.push(_populatePath(this, docs, path));
      }
      await Promise.all(promises);
    }
    return docs;
  };
  /*!
   * Populates `docs` for a single `populateOptions` instance.
   */
  var excludeIdReg = /\s?-_id\s?/;
  var excludeIdRegGlobal = /\s?-_id\s?/g;
  async function _populatePath(model, docs, populateOptions) {
    if (populateOptions.strictPopulate == null) {
      if (populateOptions._localModel != null && populateOptions._localModel.schema._userProvidedOptions.strictPopulate != null) {
        populateOptions.strictPopulate = populateOptions._localModel.schema._userProvidedOptions.strictPopulate;
      } else if (populateOptions._localModel != null && model.base.options.strictPopulate != null) {
        populateOptions.strictPopulate = model.base.options.strictPopulate;
      } else if (model.base.options.strictPopulate != null) {
        populateOptions.strictPopulate = model.base.options.strictPopulate;
      }
    }
    if (!Array.isArray(docs)) {
      docs = [docs];
    }
    if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
      return;
    }
    const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);
    if (modelsMap instanceof MongooseError) {
      throw modelsMap;
    }
    const len = modelsMap.length;
    let vals = [];
    function flatten(item) {
      return item !== undefined;
    }
    let hasOne = false;
    const params = [];
    for (let i = 0;i < len; ++i) {
      const mod = modelsMap[i];
      let select = mod.options.select;
      let ids = utils.array.flatten(mod.ids, flatten);
      ids = utils.array.unique(ids);
      const assignmentOpts = {};
      assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || undefined;
      assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
      if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {
        mod.options.options._leanTransform = mod.options.options.lean.transform;
        mod.options.options.lean = true;
      }
      if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
        _assign(model, [], mod, assignmentOpts);
        continue;
      }
      hasOne = true;
      if (typeof populateOptions.foreignField === "string") {
        mod.foreignField.clear();
        mod.foreignField.add(populateOptions.foreignField);
      }
      const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
      if (assignmentOpts.excludeId) {
        if (typeof select === "string") {
          select = select.replace(excludeIdRegGlobal, " ");
        } else if (Array.isArray(select)) {
          select = select.filter((field) => field !== "-_id");
        } else {
          select = { ...select };
          delete select._id;
        }
      }
      if (mod.options.options && mod.options.options.limit != null) {
        assignmentOpts.originalLimit = mod.options.options.limit;
      } else if (mod.options.limit != null) {
        assignmentOpts.originalLimit = mod.options.limit;
      }
      params.push([mod, match, select, assignmentOpts]);
    }
    if (!hasOne) {
      if (modelsMap.length !== 0) {
        return;
      }
      if (populateOptions.populate != null) {
        const opts = utils.populate(populateOptions.populate).map((pop) => Object.assign({}, pop, {
          path: populateOptions.path + "." + pop.path
        }));
        return model.populate(docs, opts);
      }
      return;
    }
    if (populateOptions.ordered) {
      for (const arr of params) {
        await _execPopulateQuery.apply(null, arr).then((valsFromDb) => {
          vals = vals.concat(valsFromDb);
        });
      }
    } else {
      const promises = [];
      for (const arr of params) {
        promises.push(_execPopulateQuery.apply(null, arr).then((valsFromDb) => {
          vals = vals.concat(valsFromDb);
        }));
      }
      await Promise.all(promises);
    }
    for (const arr of params) {
      const mod = arr[0];
      const assignmentOpts = arr[3];
      for (const val of vals) {
        mod.options._childDocs.push(val);
      }
      _assign(model, vals, mod, assignmentOpts);
    }
    for (const arr of params) {
      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
    }
    for (const arr of params) {
      const mod = arr[0];
      if (mod.options && mod.options.options && mod.options.options._leanTransform) {
        for (const doc of vals) {
          mod.options.options._leanTransform(doc);
        }
      }
    }
  }
  /*!
   * ignore
   */
  function _execPopulateQuery(mod, match, select) {
    let subPopulate = clone2(mod.options.populate);
    const queryOptions = Object.assign({
      skip: mod.options.skip,
      limit: mod.options.limit,
      perDocumentLimit: mod.options.perDocumentLimit
    }, mod.options.options);
    if (mod.count) {
      delete queryOptions.skip;
    }
    if (queryOptions.perDocumentLimit != null) {
      queryOptions.limit = queryOptions.perDocumentLimit;
      delete queryOptions.perDocumentLimit;
    } else if (queryOptions.limit != null) {
      queryOptions.limit = queryOptions.limit * mod.ids.length;
    }
    const query = mod.model.find(match, select, queryOptions);
    for (const foreignField of mod.foreignField) {
      if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
        query.select(foreignField);
      }
    }
    if (mod.count) {
      for (const foreignField of mod.foreignField) {
        query.select(foreignField);
      }
    }
    if (subPopulate) {
      if (mod.model.baseModelName != null) {
        if (Array.isArray(subPopulate)) {
          subPopulate.forEach((pop) => {
            pop.strictPopulate = false;
          });
        } else if (typeof subPopulate === "string") {
          subPopulate = { path: subPopulate, strictPopulate: false };
        } else {
          subPopulate.strictPopulate = false;
        }
      }
      const basePath = mod.options._fullPath || mod.options.path;
      if (Array.isArray(subPopulate)) {
        for (const pop of subPopulate) {
          pop._fullPath = basePath + "." + pop.path;
        }
      } else if (typeof subPopulate === "object") {
        subPopulate._fullPath = basePath + "." + subPopulate.path;
      }
      query.populate(subPopulate);
    }
    return query.exec().then((docs) => {
      for (const val of docs) {
        leanPopulateMap.set(val, mod.model);
      }
      return docs;
    });
  }
  /*!
   * ignore
   */
  function _assign(model, vals, mod, assignmentOpts) {
    const options = mod.options;
    const isVirtual = mod.isVirtual;
    const justOne = mod.justOne;
    let _val;
    const lean = options && options.options && options.options.lean || false;
    const len = vals.length;
    const rawOrder = {};
    const rawDocs = {};
    let key;
    let val;
    const allIds = clone2(mod.allIds);
    for (let i = 0;i < len; i++) {
      val = vals[i];
      if (val == null) {
        continue;
      }
      for (const foreignField of mod.foreignField) {
        _val = utils.getValue(foreignField, val);
        if (Array.isArray(_val)) {
          _val = utils.array.unique(utils.array.flatten(_val));
          for (let __val of _val) {
            if (__val instanceof Document) {
              __val = __val._doc._id;
            }
            if (__val?.constructor?.name === "Binary" && __val.sub_type === 4 && typeof __val.toUUID === "function") {
              key = String(__val.toUUID());
            } else if (__val?.constructor?.name === "Buffer" && __val._subtype === 4 && typeof __val.toUUID === "function") {
              key = String(__val.toUUID());
            } else {
              key = String(__val);
            }
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              if (isVirtual && !justOne) {
                rawDocs[key] = [val];
                rawOrder[key] = [i];
              } else {
                rawDocs[key] = val;
                rawOrder[key] = i;
              }
            }
          }
        } else {
          if (_val instanceof Document) {
            _val = _val._doc._id;
          }
          if (_val?.constructor?.name === "Binary" && _val.sub_type === 4 && typeof _val.toUUID === "function") {
            key = String(_val.toUUID());
          } else if (_val?.constructor?.name === "Buffer" && _val._subtype === 4 && typeof _val.toUUID === "function") {
            key = String(_val.toUUID());
          } else {
            key = String(_val);
          }
          if (rawDocs[key]) {
            if (Array.isArray(rawDocs[key])) {
              rawDocs[key].push(val);
              rawOrder[key].push(i);
            } else if (isVirtual || rawDocs[key].constructor !== val.constructor || (rawDocs[key] instanceof Document ? String(rawDocs[key]._doc._id) : String(rawDocs[key]._id)) !== (val instanceof Document ? String(val._doc._id) : String(val._id))) {
              rawDocs[key] = [rawDocs[key], val];
              rawOrder[key] = [rawOrder[key], i];
            }
          } else {
            rawDocs[key] = val;
            rawOrder[key] = i;
          }
        }
        if (!lean) {
          val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };
        }
      }
    }
    assignVals({
      originalModel: model,
      rawIds: mod.isVirtual ? allIds : mod.allIds,
      allIds,
      unpopulatedValues: mod.unpopulatedValues,
      foreignField: mod.foreignField,
      rawDocs,
      rawOrder,
      docs: mod.docs,
      path: options.path,
      options: assignmentOpts,
      justOne: mod.justOne,
      isVirtual: mod.isVirtual,
      allOptions: mod,
      populatedModel: mod.model,
      lean,
      virtual: mod.virtual,
      count: mod.count,
      match: mod.match
    });
  }
  Model.compile = function compile(name, schema, collectionName, connection, base) {
    const versioningEnabled = schema.options.versionKey !== false;
    if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
      const o = {};
      o[schema.options.versionKey] = Number;
      schema.add(o);
    }
    let model;
    if (typeof name === "function" && name.prototype instanceof Model) {
      model = name;
      name = model.name;
      schema.loadClass(model, false);
      model.prototype.$isMongooseModelPrototype = true;
    } else {
      model = function model(doc, fields, skipId) {
        model.hooks.execPreSync("createModel", doc);
        if (!(this instanceof model)) {
          return new model(doc, fields, skipId);
        }
        const discriminatorKey = model.schema.options.discriminatorKey;
        if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {
          Model.call(this, doc, fields, skipId);
          return;
        }
        const Discriminator = model.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
        if (Discriminator != null) {
          return new Discriminator(doc, fields, skipId);
        }
        Model.call(this, doc, fields, skipId);
      };
    }
    model.hooks = schema.s.hooks.clone();
    model.base = base;
    model.modelName = name;
    if (!(model.prototype instanceof Model)) {
      Object.setPrototypeOf(model, Model);
      Object.setPrototypeOf(model.prototype, Model.prototype);
    }
    model.model = function model(name2) {
      return this.db.model(name2);
    };
    model.db = connection;
    model.prototype.db = connection;
    model.prototype[modelDbSymbol] = connection;
    model.discriminators = model.prototype.discriminators = undefined;
    model[modelSymbol] = true;
    model.events = new EventEmitter;
    schema._preCompile();
    const _userProvidedOptions = schema._userProvidedOptions || {};
    const collectionOptions = {
      schemaUserProvidedOptions: _userProvidedOptions,
      capped: schema.options.capped,
      Promise: model.base.Promise,
      modelName: name
    };
    if (schema.options.autoCreate !== undefined) {
      collectionOptions.autoCreate = schema.options.autoCreate;
    }
    const collection = connection.collection(collectionName, collectionOptions);
    model.prototype.collection = collection;
    model.prototype.$collection = collection;
    model.prototype[modelCollectionSymbol] = collection;
    model.prototype.$__setSchema(schema);
    applyMethods(model, schema);
    applyStatics(model, schema);
    applyHooks(model, schema);
    applyStaticHooks(model, schema.s.hooks, schema.statics);
    model.schema = model.prototype.$__schema;
    model.collection = collection;
    model.$__collection = collection;
    model.Query = function() {
      Query.apply(this, arguments);
    };
    Object.setPrototypeOf(model.Query.prototype, Query.prototype);
    model.Query.base = Query.base;
    model.Query.prototype.constructor = Query;
    model._applyQueryMiddleware();
    applyQueryMethods(model, schema.query);
    return model;
  };
  Model.clientEncryption = function clientEncryption() {
    const ClientEncryption = this.base.driver.get().ClientEncryption;
    if (!ClientEncryption) {
      throw new Error("The mongodb driver must be used to obtain a ClientEncryption object.");
    }
    const client = this.collection?.conn?.client;
    if (!client)
      return null;
    const autoEncryptionOptions = client.options.autoEncryption;
    if (!autoEncryptionOptions)
      return null;
    const {
      keyVaultNamespace,
      keyVaultClient,
      kmsProviders,
      credentialProviders,
      proxyOptions,
      tlsOptions
    } = autoEncryptionOptions;
    return new ClientEncryption(keyVaultClient ?? client, { keyVaultNamespace, kmsProviders, credentialProviders, proxyOptions, tlsOptions });
  };
  Model.$__updateConnection = function $__updateConnection(newConnection) {
    this.db = newConnection;
    this.prototype.db = newConnection;
    this.prototype[modelDbSymbol] = newConnection;
    const collection = newConnection.collection(this.collection.collectionName, this.collection.opts);
    this.prototype.collection = collection;
    this.prototype.$collection = collection;
    this.prototype[modelCollectionSymbol] = collection;
    this.collection = collection;
    this.$__collection = collection;
  };
  function applyQueryMethods(model, methods) {
    for (const i in methods) {
      model.Query.prototype[i] = methods[i];
    }
  }
  Model.__subclass = function subclass(conn, schema, collection) {
    const _this = this;
    const Model2 = function Model(doc, fields, skipId) {
      if (!(this instanceof Model)) {
        return new Model(doc, fields, skipId);
      }
      _this.call(this, doc, fields, skipId);
    };
    Object.setPrototypeOf(Model2, _this);
    Object.setPrototypeOf(Model2.prototype, _this.prototype);
    Model2.db = conn;
    Model2.prototype.db = conn;
    Model2.prototype[modelDbSymbol] = conn;
    _this[subclassedSymbol] = _this[subclassedSymbol] || [];
    _this[subclassedSymbol].push(Model2);
    if (_this.discriminators != null) {
      Model2.discriminators = {};
      for (const key of Object.keys(_this.discriminators)) {
        Model2.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
      }
    }
    const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
    const options = s.options || {};
    const _userProvidedOptions = s._userProvidedOptions || {};
    if (!collection) {
      collection = _this.prototype.$__schema.get("collection") || utils.toCollectionName(_this.modelName, this.base.pluralize());
    }
    const collectionOptions = {
      schemaUserProvidedOptions: _userProvidedOptions,
      capped: s && options.capped
    };
    Model2.prototype.collection = conn.collection(collection, collectionOptions);
    Model2.prototype.$collection = Model2.prototype.collection;
    Model2.prototype[modelCollectionSymbol] = Model2.prototype.collection;
    Model2.collection = Model2.prototype.collection;
    Model2.$__collection = Model2.collection;
    Model2.init().catch(() => {
    });
    return Model2;
  };
  Model.recompileSchema = function recompileSchema() {
    this.prototype.$__setSchema(this.schema);
    if (this.schema._applyDiscriminators != null) {
      for (const disc of this.schema._applyDiscriminators.keys()) {
        this.discriminator(disc, this.schema._applyDiscriminators.get(disc));
      }
    }
    delete this.schema._defaultToObjectOptionsMap;
    applyEmbeddedDiscriminators(this.schema, new WeakSet, true);
  };
  Model.inspect = function() {
    return `Model { ${this.modelName} }`;
  };
  Model.namespace = function namespace() {
    return this.db.name + "." + this.collection.collectionName;
  };
  if (util3.inspect.custom) {
    Model[util3.inspect.custom] = Model.inspect;
  }
  /*!
   * Applies query middleware from this model's schema to this model's
   * Query constructor.
   */
  Model._applyQueryMiddleware = function _applyQueryMiddleware() {
    const Query2 = this.Query;
    const queryMiddleware = this.schema.s.hooks.filter((hook) => {
      const contexts = _getContexts(hook);
      if (hook.name === "validate") {
        return !!contexts.query;
      }
      if (hook.name === "deleteOne" || hook.name === "updateOne") {
        return !!contexts.query || Object.keys(contexts).length === 0;
      }
      if (hook.query != null || hook.document != null) {
        return !!hook.query;
      }
      return true;
    });
    Query2.prototype._queryMiddleware = queryMiddleware;
  };
  function _getContexts(hook) {
    const ret = {};
    if (hook.hasOwnProperty("query")) {
      ret.query = hook.query;
    }
    if (hook.hasOwnProperty("document")) {
      ret.document = hook.document;
    }
    return ret;
  }
  /*!
   * Module exports.
   */
  module.exports = exports = Model;
});

// node_modules/mongoose/lib/helpers/pluralize.js
var require_pluralize = __commonJS((exports, module) => {
  module.exports = pluralize;
  exports.pluralization = [
    [/human$/gi, "humans"],
    [/(m)an$/gi, "$1en"],
    [/(pe)rson$/gi, "$1ople"],
    [/(child)$/gi, "$1ren"],
    [/^(ox)$/gi, "$1en"],
    [/(ax|test)is$/gi, "$1es"],
    [/(octop|vir)us$/gi, "$1i"],
    [/(alias|status)$/gi, "$1es"],
    [/(bu)s$/gi, "$1ses"],
    [/(buffal|tomat|potat)o$/gi, "$1oes"],
    [/([ti])um$/gi, "$1a"],
    [/sis$/gi, "ses"],
    [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
    [/(hive)$/gi, "$1s"],
    [/([^aeiouy]|qu)y$/gi, "$1ies"],
    [/(x|ch|ss|sh)$/gi, "$1es"],
    [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
    [/([m|l])ouse$/gi, "$1ice"],
    [/(kn|w|l)ife$/gi, "$1ives"],
    [/(quiz)$/gi, "$1zes"],
    [/^goose$/i, "geese"],
    [/s$/gi, "s"],
    [/([^a-z])$/, "$1"],
    [/$/gi, "s"]
  ];
  var rules = exports.pluralization;
  exports.uncountables = [
    "advice",
    "energy",
    "excretion",
    "digestion",
    "cooperation",
    "health",
    "justice",
    "labour",
    "machinery",
    "equipment",
    "information",
    "pollution",
    "sewage",
    "paper",
    "money",
    "species",
    "series",
    "rain",
    "rice",
    "fish",
    "sheep",
    "moose",
    "deer",
    "news",
    "expertise",
    "status",
    "media"
  ];
  var uncountables = exports.uncountables;
  function pluralize(str) {
    let found;
    str = str.toLowerCase();
    if (!~uncountables.indexOf(str)) {
      found = rules.filter(function(rule) {
        return str.match(rule[0]);
      });
      if (found[0]) {
        return str.replace(found[0][0], found[0][1]);
      }
    }
    return str;
  }
});

// node_modules/mongoose/lib/error/setOptionError.js
var require_setOptionError = __commonJS((exports, module) => {
  /*!
   * Module requirements
   */
  var MongooseError = require_mongooseError();
  var util3 = __require("util");
  var combinePathErrors = require_combinePathErrors();

  class SetOptionError extends MongooseError {
    constructor() {
      super("");
      this.errors = {};
    }
    toString() {
      return combinePathErrors(this);
    }
    inspect() {
      return Object.assign(new Error(this.message), this);
    }
    addError(key, error) {
      if (error instanceof SetOptionError) {
        const { errors: errors2 } = error;
        for (const optionKey of Object.keys(errors2)) {
          this.addError(optionKey, errors2[optionKey]);
        }
        return;
      }
      this.errors[key] = error;
      this.message = combinePathErrors(this);
    }
  }
  if (util3.inspect.custom) {
    SetOptionError.prototype[util3.inspect.custom] = SetOptionError.prototype.inspect;
  }
  Object.defineProperty(SetOptionError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
      return Object.assign({}, this, { name: this.name, message: this.message });
    }
  });
  Object.defineProperty(SetOptionError.prototype, "name", {
    value: "SetOptionError"
  });

  class SetOptionInnerError extends MongooseError {
    constructor(key) {
      super(`"${key}" is not a valid option to set`);
    }
  }
  SetOptionError.SetOptionInnerError = SetOptionInnerError;
  /*!
   * Module exports
   */
  module.exports = SetOptionError;
});

// node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS(() => {
  var utils = require_utils3();
  if (typeof jest !== "undefined" && !process.env.SUPPRESS_JEST_WARNINGS) {
    if (typeof window !== "undefined") {
      utils.warn("Mongoose: looks like you're trying to test a Mongoose app " + "with Jest's default jsdom test environment. Please make sure you read " + "Mongoose's docs on configuring Jest to test Node.js apps: " + "https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true " + "to hide this warning.");
    }
    if (setTimeout.clock != null && typeof setTimeout.clock.Date === "function") {
      utils.warn("Mongoose: looks like you're trying to test a Mongoose app " + "with Jest's mock timers enabled. Please make sure you read " + "Mongoose's docs on configuring Jest to test Node.js apps: " + "https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true " + "to hide this warning.");
    }
  }
});

// node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var NodeJSDocument = require_document2();
  var EventEmitter = __require("events").EventEmitter;
  var MongooseError = require_error2();
  var Schema = require_schema2();
  var ObjectId2 = require_objectid();
  var ValidationError2 = MongooseError.ValidationError;
  var applyHooks = require_applyHooks();
  var isObject2 = require_isObject();
  function Document(obj, schema, fields, skipId, skipInit) {
    if (!(this instanceof Document)) {
      return new Document(obj, schema, fields, skipId, skipInit);
    }
    if (isObject2(schema) && !schema.instanceOfSchema) {
      schema = new Schema(schema);
    }
    schema = this.schema || schema;
    if (!this.schema && schema.options._id) {
      obj = obj || {};
      if (obj._id === undefined) {
        obj._id = new ObjectId2;
      }
    }
    if (!schema) {
      throw new MongooseError.MissingSchemaError;
    }
    this.$__setSchema(schema);
    NodeJSDocument.call(this, obj, fields, skipId, skipInit);
    applyHooks(this, schema, { decorateDoc: true });
    for (const m2 in schema.methods) {
      this[m2] = schema.methods[m2];
    }
    for (const s in schema.statics) {
      this[s] = schema.statics[s];
    }
  }
  /*!
   * Inherit from the NodeJS document
   */
  Document.prototype = Object.create(NodeJSDocument.prototype);
  Document.prototype.constructor = Document;
  /*!
   * ignore
   */
  Document.events = new EventEmitter;
  /*!
   * Browser doc exposes the event emitter API
   */
  Document.$emitter = new EventEmitter;
  [
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
  ].forEach(function(emitterFn) {
    Document[emitterFn] = function() {
      return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
    };
  });
  /*!
   * Module exports.
   */
  Document.ValidationError = ValidationError2;
  module.exports = exports = Document;
});

// node_modules/mongoose/lib/documentProvider.js
var require_documentProvider = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var Document = require_document2();
  var BrowserDocument = require_browserDocument();
  var isBrowser = false;
  module.exports = function documentProvider() {
    if (isBrowser) {
      return BrowserDocument;
    }
    return Document;
  };
  /*!
   * ignore
   */
  module.exports.setBrowser = function(flag) {
    isBrowser = flag;
  };
});

// node_modules/mongoose/lib/mongoose.js
var require_mongoose = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var Document = require_document2();
  var EventEmitter = __require("events").EventEmitter;
  var Kareem = require_kareem();
  var Schema = require_schema2();
  var SchemaType = require_schemaType();
  var SchemaTypes = require_schema();
  var VirtualType = require_virtualType();
  var STATES = require_connectionState();
  var VALID_OPTIONS = require_validOptions();
  var Types = require_types();
  var Query = require_query();
  var Model = require_model();
  var applyPlugins = require_applyPlugins();
  var builtinPlugins = require_plugins();
  var driver = require_driver();
  var legacyPluralize = require_pluralize();
  var utils = require_utils3();
  var pkg = require_package2();
  var cast2 = require_cast2();
  var Aggregate = require_aggregate2();
  var trusted = require_trusted().trusted;
  var sanitizeFilter = require_sanitizeFilter();
  var isBsonType = require_isBsonType();
  var MongooseError = require_mongooseError();
  var SetOptionError = require_setOptionError();
  var applyEmbeddedDiscriminators = require_applyEmbeddedDiscriminators();
  var defaultMongooseSymbol = Symbol.for("mongoose:default");
  var defaultConnectionSymbol = Symbol("mongoose:defaultConnection");
  require_printJestWarning();
  var objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;
  var { AsyncLocalStorage } = __require("node:async_hooks");
  function Mongoose(options) {
    this.connections = [];
    this.nextConnectionId = 0;
    this.models = {};
    this.events = new EventEmitter;
    this.__driver = driver.get();
    this.options = Object.assign({
      pluralization: true,
      autoIndex: true,
      autoCreate: true,
      autoSearchIndex: false
    }, options);
    const createInitialConnection = utils.getOption("createInitialConnection", this.options) ?? true;
    if (createInitialConnection && this.__driver != null) {
      _createDefaultConnection(this);
    }
    if (this.options.pluralization) {
      this._pluralize = legacyPluralize;
    }
    if (!options || !options[defaultMongooseSymbol]) {
      const _this = this;
      this.Schema = function() {
        this.base = _this;
        return Schema.apply(this, arguments);
      };
      this.Schema.prototype = Object.create(Schema.prototype);
      Object.assign(this.Schema, Schema);
      this.Schema.base = this;
      this.Schema.Types = Object.assign({}, Schema.Types);
    } else {
      for (const key of ["Schema", "model"]) {
        this[key] = Mongoose.prototype[key];
      }
    }
    this.Schema.prototype.base = this;
    if (options?.transactionAsyncLocalStorage) {
      this.transactionAsyncLocalStorage = new AsyncLocalStorage;
    }
    Object.defineProperty(this, "plugins", {
      configurable: false,
      enumerable: true,
      writable: false,
      value: Object.values(builtinPlugins).map((plugin) => [plugin, { deduplicate: true }])
    });
  }
  Mongoose.prototype.cast = cast2;
  Mongoose.prototype.STATES = STATES;
  Mongoose.prototype.ConnectionStates = STATES;
  Mongoose.prototype.driver = driver;
  Mongoose.prototype.setDriver = function setDriver(driver2) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (_mongoose.__driver === driver2) {
      return _mongoose;
    }
    const openConnection = _mongoose.connections && _mongoose.connections.find((conn) => conn.readyState !== STATES.disconnected);
    if (openConnection) {
      const msg = "Cannot modify Mongoose driver if a connection is already open. " + "Call `mongoose.disconnect()` before modifying the driver";
      throw new MongooseError(msg);
    }
    _mongoose.__driver = driver2;
    if (Array.isArray(driver2.plugins)) {
      for (const plugin of driver2.plugins) {
        if (typeof plugin === "function") {
          _mongoose.plugin(plugin);
        }
      }
    }
    if (driver2.SchemaTypes != null) {
      Object.assign(mongoose.Schema.Types, driver2.SchemaTypes);
    }
    const Connection = driver2.Connection;
    const oldDefaultConnection = _mongoose.connections[0];
    _mongoose.connections = [new Connection(_mongoose)];
    _mongoose.connections[0].models = _mongoose.models;
    if (oldDefaultConnection == null) {
      return _mongoose;
    }
    for (const model of Object.values(_mongoose.models)) {
      if (model.db !== oldDefaultConnection) {
        continue;
      }
      model.$__updateConnection(_mongoose.connections[0]);
    }
    return _mongoose;
  };
  Mongoose.prototype.set = function getsetOptions(key, value) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length === 1 && typeof key !== "object") {
      if (VALID_OPTIONS.indexOf(key) === -1) {
        const error2 = new SetOptionError;
        error2.addError(key, new SetOptionError.SetOptionInnerError(key));
        throw error2;
      }
      return _mongoose.options[key];
    }
    let options = {};
    if (arguments.length === 2) {
      options = { [key]: value };
    }
    if (arguments.length === 1 && typeof key === "object") {
      options = key;
    }
    let error = undefined;
    for (const [optionKey, optionValue] of Object.entries(options)) {
      if (VALID_OPTIONS.indexOf(optionKey) === -1) {
        if (!error) {
          error = new SetOptionError;
        }
        error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));
        continue;
      }
      _mongoose.options[optionKey] = optionValue;
      if (optionKey === "objectIdGetter") {
        if (optionValue) {
          Object.defineProperty(_mongoose.Types.ObjectId.prototype, "_id", {
            enumerable: false,
            configurable: true,
            get: function() {
              return this;
            }
          });
        } else {
          delete _mongoose.Types.ObjectId.prototype._id;
        }
      } else if (optionKey === "transactionAsyncLocalStorage") {
        if (optionValue && !_mongoose.transactionAsyncLocalStorage) {
          _mongoose.transactionAsyncLocalStorage = new AsyncLocalStorage;
        } else if (!optionValue && _mongoose.transactionAsyncLocalStorage) {
          delete _mongoose.transactionAsyncLocalStorage;
        }
      } else if (optionKey === "createInitialConnection") {
        if (optionValue && !_mongoose.connection) {
          _createDefaultConnection(_mongoose);
        } else if (optionValue === false && _mongoose.connection && _mongoose.connection[defaultConnectionSymbol]) {
          if (_mongoose.connection.readyState === STATES.disconnected && Object.keys(_mongoose.connection.models).length === 0) {
            _mongoose.connections.shift();
          }
        }
      }
    }
    if (error) {
      throw error;
    }
    return _mongoose;
  };
  Mongoose.prototype.get = Mongoose.prototype.set;
  Mongoose.prototype.createConnection = function createConnection(uri2, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const Connection = _mongoose.__driver.Connection;
    const conn = new Connection(_mongoose);
    _mongoose.connections.push(conn);
    _mongoose.nextConnectionId++;
    _mongoose.events.emit("createConnection", conn);
    if (arguments.length > 0) {
      conn.openUri(uri2, { ...options, _fireAndForget: true });
    }
    return conn;
  };
  Mongoose.prototype.connect = async function connect(uri2, options) {
    if (typeof options === "function" || arguments.length >= 3 && typeof arguments[2] === "function") {
      throw new MongooseError("Mongoose.prototype.connect() no longer accepts a callback");
    }
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (_mongoose.connection == null) {
      _createDefaultConnection(_mongoose);
    }
    const conn = _mongoose.connection;
    return conn.openUri(uri2, options).then(() => _mongoose);
  };
  Mongoose.prototype.disconnect = async function disconnect() {
    if (arguments.length >= 1 && typeof arguments[0] === "function") {
      throw new MongooseError("Mongoose.prototype.disconnect() no longer accepts a callback");
    }
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const remaining = _mongoose.connections.length;
    if (remaining <= 0) {
      return;
    }
    await Promise.all(_mongoose.connections.map((conn) => conn.close()));
  };
  Mongoose.prototype.startSession = function startSession() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
  };
  Mongoose.prototype.pluralize = function pluralize(fn) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length > 0) {
      _mongoose._pluralize = fn;
    }
    return _mongoose._pluralize;
  };
  Mongoose.prototype.model = function model(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (typeof schema === "string") {
      collection = schema;
      schema = false;
    }
    if (arguments.length === 1) {
      const model2 = _mongoose.models[name];
      if (!model2) {
        throw new _mongoose.Error.MissingSchemaError(name);
      }
      return model2;
    }
    if (utils.isObject(schema) && !(schema instanceof Schema)) {
      schema = new Schema(schema);
    }
    if (schema && !(schema instanceof Schema)) {
      throw new _mongoose.Error("The 2nd parameter to `mongoose.model()` should be a " + "schema or a POJO");
    }
    options = options || {};
    const originalSchema = schema;
    if (schema) {
      if (_mongoose.get("cloneSchemas")) {
        schema = schema.clone();
      }
      _mongoose._applyPlugins(schema);
    }
    const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
    if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {
      if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
        throw new _mongoose.Error.OverwriteModelError(name);
      }
      if (collection && collection !== _mongoose.models[name].collection.name) {
        const model2 = _mongoose.models[name];
        schema = model2.prototype.schema;
        const sub = model2.__subclass(_mongoose.connection, schema, collection);
        return sub;
      }
      return _mongoose.models[name];
    }
    if (schema == null) {
      throw new _mongoose.Error.MissingSchemaError(name);
    }
    const model = _mongoose._model(name, schema, collection, options);
    _mongoose.connection.models[name] = model;
    _mongoose.models[name] = model;
    return model;
  };
  /*!
   * ignore
   */
  Mongoose.prototype._model = function _model(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    let model;
    if (typeof name === "function") {
      model = name;
      name = model.name;
      if (!(model.prototype instanceof Model)) {
        throw new _mongoose.Error("The provided class " + name + " must extend Model");
      }
    }
    if (schema) {
      if (_mongoose.get("cloneSchemas")) {
        schema = schema.clone();
      }
      _mongoose._applyPlugins(schema);
    }
    if (schema == null || !("pluralization" in schema.options)) {
      schema.options.pluralization = _mongoose.options.pluralization;
    }
    if (!collection) {
      collection = schema.get("collection") || utils.toCollectionName(name, _mongoose.pluralize());
    }
    applyEmbeddedDiscriminators(schema);
    const connection = options.connection || _mongoose.connection;
    model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
    model.init().catch(function $modelInitNoop() {
    });
    connection.emit("model", model);
    if (schema._applyDiscriminators != null) {
      for (const disc of schema._applyDiscriminators.keys()) {
        const {
          schema: discriminatorSchema,
          options: options2
        } = schema._applyDiscriminators.get(disc);
        model.discriminator(disc, discriminatorSchema, options2);
      }
    }
    return model;
  };
  Mongoose.prototype.deleteModel = function deleteModel(name) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.connection.deleteModel(name);
    delete _mongoose.models[name];
    return _mongoose;
  };
  Mongoose.prototype.modelNames = function modelNames() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const names = Object.keys(_mongoose.models);
    return names;
  };
  Mongoose.prototype._applyPlugins = function _applyPlugins(schema, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    options = options || {};
    options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;
    options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === "boolean" ? _mongoose.options.applyPluginsToChildSchemas : true;
    applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
  };
  Mongoose.prototype.plugin = function plugin(fn, opts) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.plugins.push([fn, opts]);
    return _mongoose;
  };
  Mongoose.prototype.__defineGetter__("connection", function() {
    return this.connections[0];
  });
  Mongoose.prototype.__defineSetter__("connection", function(v) {
    if (v instanceof this.__driver.Connection) {
      this.connections[0] = v;
      this.models = v.models;
    }
  });
  Mongoose.prototype.connections;
  Mongoose.prototype.nextConnectionId;
  Mongoose.prototype.Aggregate = Aggregate;
  Mongoose.prototype.BaseCollection = require_collection2();
  Object.defineProperty(Mongoose.prototype, "Collection", {
    get: function() {
      return this.__driver.Collection;
    },
    set: function(Collection) {
      this.__driver.Collection = Collection;
    }
  });
  Object.defineProperty(Mongoose.prototype, "Connection", {
    get: function() {
      return this.__driver.Connection;
    },
    set: function(Connection) {
      if (Connection === this.__driver.Connection) {
        return;
      }
      this.__driver.Connection = Connection;
    }
  });
  Mongoose.prototype.BaseConnection = require_connection2();
  Mongoose.prototype.version = pkg.version;
  Mongoose.prototype.Mongoose = Mongoose;
  Mongoose.prototype.Schema = Schema;
  Mongoose.prototype.SchemaType = SchemaType;
  Mongoose.prototype.SchemaTypes = Schema.Types;
  Mongoose.prototype.VirtualType = VirtualType;
  Mongoose.prototype.Types = Types;
  Mongoose.prototype.Query = Query;
  Mongoose.prototype.Model = Model;
  Mongoose.prototype.Document = Document;
  Mongoose.prototype.DocumentProvider = require_documentProvider();
  Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
  Mongoose.prototype.isValidObjectId = function isValidObjectId(v) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.Types.ObjectId.isValid(v);
  };
  Mongoose.prototype.isObjectIdOrHexString = function isObjectIdOrHexString(v) {
    return isBsonType(v, "ObjectId") || typeof v === "string" && objectIdHexRegexp.test(v);
  };
  Mongoose.prototype.syncIndexes = function syncIndexes(options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.syncIndexes(options);
  };
  Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
  Mongoose.prototype.Mixed = SchemaTypes.Mixed;
  Mongoose.prototype.Date = SchemaTypes.Date;
  Mongoose.prototype.Number = SchemaTypes.Number;
  Mongoose.prototype.Error = MongooseError;
  Mongoose.prototype.MongooseError = MongooseError;
  Mongoose.prototype.now = function now() {
    return new Date;
  };
  Mongoose.prototype.CastError = MongooseError.CastError;
  Mongoose.prototype.SchemaTypeOptions = require_schemaTypeOptions();
  Mongoose.prototype.mquery = require_mquery();
  Mongoose.prototype.sanitizeFilter = sanitizeFilter;
  Mongoose.prototype.trusted = trusted;
  Mongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;
  Mongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;
  Mongoose.prototype.omitUndefined = require_omitUndefined();
  /*!
   * Create a new default connection (`mongoose.connection`) for a Mongoose instance.
   * No-op if there is already a default connection.
   */
  function _createDefaultConnection(mongoose2) {
    if (mongoose2.connection) {
      return;
    }
    const conn = mongoose2.createConnection();
    conn[defaultConnectionSymbol] = true;
    conn.models = mongoose2.models;
  }
  var mongoose = module.exports = exports = new Mongoose({
    [defaultMongooseSymbol]: true
  });
});

// node_modules/mongoose/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var mongodbDriver = require_node_mongodb_native();
  require_driver().set(mongodbDriver);
  var mongoose = require_mongoose();
  mongoose.setDriver(mongodbDriver);
  mongoose.Mongoose.prototype.mongo = require_lib3();
  module.exports = mongoose;
});

// node_modules/mongoose/index.js
var require_mongoose2 = __commonJS((exports, module) => {
  var mongoose = require_lib6();
  module.exports = mongoose;
  module.exports.default = mongoose;
  module.exports.mongoose = mongoose;
  module.exports.cast = mongoose.cast;
  module.exports.STATES = mongoose.STATES;
  module.exports.setDriver = mongoose.setDriver;
  module.exports.set = mongoose.set;
  module.exports.get = mongoose.get;
  module.exports.createConnection = mongoose.createConnection;
  module.exports.connect = mongoose.connect;
  module.exports.disconnect = mongoose.disconnect;
  module.exports.startSession = mongoose.startSession;
  module.exports.pluralize = mongoose.pluralize;
  module.exports.model = mongoose.model;
  module.exports.deleteModel = mongoose.deleteModel;
  module.exports.modelNames = mongoose.modelNames;
  module.exports.plugin = mongoose.plugin;
  module.exports.connections = mongoose.connections;
  module.exports.version = mongoose.version;
  module.exports.Aggregate = mongoose.Aggregate;
  module.exports.Mongoose = mongoose.Mongoose;
  module.exports.Schema = mongoose.Schema;
  module.exports.SchemaType = mongoose.SchemaType;
  module.exports.SchemaTypes = mongoose.SchemaTypes;
  module.exports.VirtualType = mongoose.VirtualType;
  module.exports.Types = mongoose.Types;
  module.exports.Query = mongoose.Query;
  module.exports.Model = mongoose.Model;
  module.exports.Document = mongoose.Document;
  module.exports.ObjectId = mongoose.ObjectId;
  module.exports.isValidObjectId = mongoose.isValidObjectId;
  module.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;
  module.exports.syncIndexes = mongoose.syncIndexes;
  module.exports.Decimal128 = mongoose.Decimal128;
  module.exports.Mixed = mongoose.Mixed;
  module.exports.Date = mongoose.Date;
  module.exports.Number = mongoose.Number;
  module.exports.Error = mongoose.Error;
  module.exports.MongooseError = mongoose.MongooseError;
  module.exports.now = mongoose.now;
  module.exports.CastError = mongoose.CastError;
  module.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;
  module.exports.mongo = mongoose.mongo;
  module.exports.mquery = mongoose.mquery;
  module.exports.sanitizeFilter = mongoose.sanitizeFilter;
  module.exports.trusted = mongoose.trusted;
  module.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;
  module.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;
});

// node_modules/dotenv/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.6.1",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto2 = __require("crypto");
  var packageJson = require_package3();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse3(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath;
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
      const err2 = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err2.code = "MISSING_DATA";
      throw err2;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _log(message) {
    console.log(`[dotenv@${version}] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri2;
    try {
      uri2 = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err2 = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err2.code = "INVALID_DOTENV_KEY";
        throw err2;
      }
      throw error;
    }
    const key = uri2.password;
    if (!key) {
      const err2 = new Error("INVALID_DOTENV_KEY: Missing key part");
      err2.code = "INVALID_DOTENV_KEY";
      throw err2;
    }
    const environment = uri2.searchParams.get("environment");
    if (!environment) {
      const err2 = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err2.code = "INVALID_DOTENV_KEY";
      throw err2;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err2 = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err2.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err2;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    const debug2 = Boolean(options && options.debug);
    const quiet = options && "quiet" in options ? options.quiet : true;
    if (debug2 || !quiet) {
      _log("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug2 = Boolean(options && options.debug);
    const quiet = options && "quiet" in options ? options.quiet : true;
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug2) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug2) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (debug2 || !quiet) {
      const keysCount = Object.keys(parsedAll).length;
      const shortPaths = [];
      for (const filePath of optionPaths) {
        try {
          const relative = path.relative(process.cwd(), filePath);
          shortPaths.push(relative);
        } catch (e) {
          if (debug2) {
            _debug(`Failed to load ${filePath} ${e.message}`);
          }
          lastError = e;
        }
      }
      _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
    }
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err2 = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err2.code = "INVALID_DOTENV_KEY";
        throw err2;
      } else if (decryptionFailed) {
        const err2 = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err2.code = "DECRYPTION_FAILED";
        throw err2;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug2 = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err2 = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err2.code = "OBJECT_REQUIRED";
      throw err2;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug2) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse3,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/bcryptjs/dist/bcrypt.js
var require_bcrypt = __commonJS((exports, module) => {
  (function(global2, factory) {
    if (typeof define === "function" && define["amd"])
      define([], factory);
    else if (typeof module === "object" && module && module.exports)
      module["exports"] = factory();
    else
      (global2["dcodeIO"] = global2["dcodeIO"] || {})["bcrypt"] = factory();
  })(exports, function() {
    var bcrypt = {};
    var randomFallback = null;
    function random(len) {
      if (typeof module !== "undefined" && module && module["exports"])
        try {
          return __require("crypto")["randomBytes"](len);
        } catch (e) {
        }
      try {
        var a12;
        (self["crypto"] || self["msCrypto"])["getRandomValues"](a12 = new Uint32Array(len));
        return Array.prototype.slice.call(a12);
      } catch (e) {
      }
      if (!randomFallback)
        throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return randomFallback(len);
    }
    var randomAvailable = false;
    try {
      random(1);
      randomAvailable = true;
    } catch (e) {
    }
    randomFallback = null;
    bcrypt.setRandomFallback = function(random2) {
      randomFallback = random2;
    };
    bcrypt.genSaltSync = function(rounds, seed_length) {
      rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
      if (typeof rounds !== "number")
        throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
      if (rounds < 4)
        rounds = 4;
      else if (rounds > 31)
        rounds = 31;
      var salt = [];
      salt.push("$2a$");
      if (rounds < 10)
        salt.push("0");
      salt.push(rounds.toString());
      salt.push("$");
      salt.push(base64_encode(random(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
      return salt.join("");
    };
    bcrypt.genSalt = function(rounds, seed_length, callback) {
      if (typeof seed_length === "function")
        callback = seed_length, seed_length = undefined;
      if (typeof rounds === "function")
        callback = rounds, rounds = undefined;
      if (typeof rounds === "undefined")
        rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
      else if (typeof rounds !== "number")
        throw Error("illegal arguments: " + typeof rounds);
      function _async(callback2) {
        nextTick(function() {
          try {
            callback2(null, bcrypt.genSaltSync(rounds));
          } catch (err2) {
            callback2(err2);
          }
        });
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err2, res) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve(res);
          });
        });
    };
    bcrypt.hashSync = function(s, salt) {
      if (typeof salt === "undefined")
        salt = GENSALT_DEFAULT_LOG2_ROUNDS;
      if (typeof salt === "number")
        salt = bcrypt.genSaltSync(salt);
      if (typeof s !== "string" || typeof salt !== "string")
        throw Error("Illegal arguments: " + typeof s + ", " + typeof salt);
      return _hash(s, salt);
    };
    bcrypt.hash = function(s, salt, callback, progressCallback) {
      function _async(callback2) {
        if (typeof s === "string" && typeof salt === "number")
          bcrypt.genSalt(salt, function(err2, salt2) {
            _hash(s, salt2, callback2, progressCallback);
          });
        else if (typeof s === "string" && typeof salt === "string")
          _hash(s, salt, callback2, progressCallback);
        else
          nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof salt)));
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err2, res) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve(res);
          });
        });
    };
    function safeStringCompare(known, unknown) {
      var right = 0, wrong = 0;
      for (var i = 0, k = known.length;i < k; ++i) {
        if (known.charCodeAt(i) === unknown.charCodeAt(i))
          ++right;
        else
          ++wrong;
      }
      if (right < 0)
        return false;
      return wrong === 0;
    }
    bcrypt.compareSync = function(s, hash2) {
      if (typeof s !== "string" || typeof hash2 !== "string")
        throw Error("Illegal arguments: " + typeof s + ", " + typeof hash2);
      if (hash2.length !== 60)
        return false;
      return safeStringCompare(bcrypt.hashSync(s, hash2.substr(0, hash2.length - 31)), hash2);
    };
    bcrypt.compare = function(s, hash2, callback, progressCallback) {
      function _async(callback2) {
        if (typeof s !== "string" || typeof hash2 !== "string") {
          nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof s + ", " + typeof hash2)));
          return;
        }
        if (hash2.length !== 60) {
          nextTick(callback2.bind(this, null, false));
          return;
        }
        bcrypt.hash(s, hash2.substr(0, 29), function(err2, comp) {
          if (err2)
            callback2(err2);
          else
            callback2(null, safeStringCompare(comp, hash2));
        }, progressCallback);
      }
      if (callback) {
        if (typeof callback !== "function")
          throw Error("Illegal callback: " + typeof callback);
        _async(callback);
      } else
        return new Promise(function(resolve, reject) {
          _async(function(err2, res) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve(res);
          });
        });
    };
    bcrypt.getRounds = function(hash2) {
      if (typeof hash2 !== "string")
        throw Error("Illegal arguments: " + typeof hash2);
      return parseInt(hash2.split("$")[2], 10);
    };
    bcrypt.getSalt = function(hash2) {
      if (typeof hash2 !== "string")
        throw Error("Illegal arguments: " + typeof hash2);
      if (hash2.length !== 60)
        throw Error("Illegal hash length: " + hash2.length + " != 60");
      return hash2.substring(0, 29);
    };
    var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
    function stringToBytes2(str) {
      var out = [], i = 0;
      utfx.encodeUTF16toUTF8(function() {
        if (i >= str.length)
          return null;
        return str.charCodeAt(i++);
      }, function(b) {
        out.push(b);
      });
      return out;
    }
    var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    var BASE64_INDEX = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    var stringFromCharCode = String.fromCharCode;
    function base64_encode(b, len) {
      var off = 0, rs2 = [], c1, c2;
      if (len <= 0 || len > b.length)
        throw Error("Illegal len: " + len);
      while (off < len) {
        c1 = b[off++] & 255;
        rs2.push(BASE64_CODE[c1 >> 2 & 63]);
        c1 = (c1 & 3) << 4;
        if (off >= len) {
          rs2.push(BASE64_CODE[c1 & 63]);
          break;
        }
        c2 = b[off++] & 255;
        c1 |= c2 >> 4 & 15;
        rs2.push(BASE64_CODE[c1 & 63]);
        c1 = (c2 & 15) << 2;
        if (off >= len) {
          rs2.push(BASE64_CODE[c1 & 63]);
          break;
        }
        c2 = b[off++] & 255;
        c1 |= c2 >> 6 & 3;
        rs2.push(BASE64_CODE[c1 & 63]);
        rs2.push(BASE64_CODE[c2 & 63]);
      }
      return rs2.join("");
    }
    function base64_decode(s, len) {
      var off = 0, slen = s.length, olen = 0, rs2 = [], c1, c2, c3, c4, o, code;
      if (len <= 0)
        throw Error("Illegal len: " + len);
      while (off < slen - 1 && olen < len) {
        code = s.charCodeAt(off++);
        c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        code = s.charCodeAt(off++);
        c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        if (c1 == -1 || c2 == -1)
          break;
        o = c1 << 2 >>> 0;
        o |= (c2 & 48) >> 4;
        rs2.push(stringFromCharCode(o));
        if (++olen >= len || off >= slen)
          break;
        code = s.charCodeAt(off++);
        c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        if (c3 == -1)
          break;
        o = (c2 & 15) << 4 >>> 0;
        o |= (c3 & 60) >> 2;
        rs2.push(stringFromCharCode(o));
        if (++olen >= len || off >= slen)
          break;
        code = s.charCodeAt(off++);
        c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
        o = (c3 & 3) << 6 >>> 0;
        o |= c4;
        rs2.push(stringFromCharCode(o));
        ++olen;
      }
      var res = [];
      for (off = 0;off < olen; off++)
        res.push(rs2[off].charCodeAt(0));
      return res;
    }
    var utfx = function() {
      var utfx2 = {};
      utfx2.MAX_CODEPOINT = 1114111;
      utfx2.encodeUTF8 = function(src, dst) {
        var cp = null;
        if (typeof src === "number")
          cp = src, src = function() {
            return null;
          };
        while (cp !== null || (cp = src()) !== null) {
          if (cp < 128)
            dst(cp & 127);
          else if (cp < 2048)
            dst(cp >> 6 & 31 | 192), dst(cp & 63 | 128);
          else if (cp < 65536)
            dst(cp >> 12 & 15 | 224), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
          else
            dst(cp >> 18 & 7 | 240), dst(cp >> 12 & 63 | 128), dst(cp >> 6 & 63 | 128), dst(cp & 63 | 128);
          cp = null;
        }
      };
      utfx2.decodeUTF8 = function(src, dst) {
        var a12, b, c, d, fail = function(b2) {
          b2 = b2.slice(0, b2.indexOf(null));
          var err2 = Error(b2.toString());
          err2.name = "TruncatedError";
          err2["bytes"] = b2;
          throw err2;
        };
        while ((a12 = src()) !== null) {
          if ((a12 & 128) === 0)
            dst(a12);
          else if ((a12 & 224) === 192)
            (b = src()) === null && fail([a12, b]), dst((a12 & 31) << 6 | b & 63);
          else if ((a12 & 240) === 224)
            ((b = src()) === null || (c = src()) === null) && fail([a12, b, c]), dst((a12 & 15) << 12 | (b & 63) << 6 | c & 63);
          else if ((a12 & 248) === 240)
            ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a12, b, c, d]), dst((a12 & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63);
          else
            throw RangeError("Illegal starting byte: " + a12);
        }
      };
      utfx2.UTF16toUTF8 = function(src, dst) {
        var c1, c2 = null;
        while (true) {
          if ((c1 = c2 !== null ? c2 : src()) === null)
            break;
          if (c1 >= 55296 && c1 <= 57343) {
            if ((c2 = src()) !== null) {
              if (c2 >= 56320 && c2 <= 57343) {
                dst((c1 - 55296) * 1024 + c2 - 56320 + 65536);
                c2 = null;
                continue;
              }
            }
          }
          dst(c1);
        }
        if (c2 !== null)
          dst(c2);
      };
      utfx2.UTF8toUTF16 = function(src, dst) {
        var cp = null;
        if (typeof src === "number")
          cp = src, src = function() {
            return null;
          };
        while (cp !== null || (cp = src()) !== null) {
          if (cp <= 65535)
            dst(cp);
          else
            cp -= 65536, dst((cp >> 10) + 55296), dst(cp % 1024 + 56320);
          cp = null;
        }
      };
      utfx2.encodeUTF16toUTF8 = function(src, dst) {
        utfx2.UTF16toUTF8(src, function(cp) {
          utfx2.encodeUTF8(cp, dst);
        });
      };
      utfx2.decodeUTF8toUTF16 = function(src, dst) {
        utfx2.decodeUTF8(src, function(cp) {
          utfx2.UTF8toUTF16(cp, dst);
        });
      };
      utfx2.calculateCodePoint = function(cp) {
        return cp < 128 ? 1 : cp < 2048 ? 2 : cp < 65536 ? 3 : 4;
      };
      utfx2.calculateUTF8 = function(src) {
        var cp, l2 = 0;
        while ((cp = src()) !== null)
          l2 += utfx2.calculateCodePoint(cp);
        return l2;
      };
      utfx2.calculateUTF16asUTF8 = function(src) {
        var n2 = 0, l2 = 0;
        utfx2.UTF16toUTF8(src, function(cp) {
          ++n2;
          l2 += utfx2.calculateCodePoint(cp);
        });
        return [n2, l2];
      };
      return utfx2;
    }();
    Date.now = Date.now || function() {
      return +new Date;
    };
    var BCRYPT_SALT_LEN = 16;
    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
    var BLOWFISH_NUM_ROUNDS = 16;
    var MAX_EXECUTION_TIME = 100;
    var P_ORIG = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ];
    var S_ORIG = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      2909710000,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409000,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ];
    var C_ORIG = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    function _encipher(lr, off, P, S) {
      var n2, l2 = lr[off], r2 = lr[off + 1];
      l2 ^= P[0];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[1];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[2];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[3];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[4];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[5];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[6];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[7];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[8];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[9];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[10];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[11];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[12];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[13];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[14];
      n2 = S[l2 >>> 24];
      n2 += S[256 | l2 >> 16 & 255];
      n2 ^= S[512 | l2 >> 8 & 255];
      n2 += S[768 | l2 & 255];
      r2 ^= n2 ^ P[15];
      n2 = S[r2 >>> 24];
      n2 += S[256 | r2 >> 16 & 255];
      n2 ^= S[512 | r2 >> 8 & 255];
      n2 += S[768 | r2 & 255];
      l2 ^= n2 ^ P[16];
      lr[off] = r2 ^ P[BLOWFISH_NUM_ROUNDS + 1];
      lr[off + 1] = l2;
      return lr;
    }
    function _streamtoword(data, offp) {
      for (var i = 0, word = 0;i < 4; ++i)
        word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
      return { key: word, offp };
    }
    function _key(key, P, S) {
      var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
      for (var i = 0;i < plen; i++)
        sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
      for (i = 0;i < plen; i += 2)
        lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
      for (i = 0;i < slen; i += 2)
        lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
    }
    function _ekskey(data, key, P, S) {
      var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
      for (var i = 0;i < plen; i++)
        sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
      offp = 0;
      for (i = 0;i < plen; i += 2)
        sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
      for (i = 0;i < slen; i += 2)
        sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
    }
    function _crypt(b, salt, rounds, callback, progressCallback) {
      var cdata = C_ORIG.slice(), clen = cdata.length, err2;
      if (rounds < 4 || rounds > 31) {
        err2 = Error("Illegal number of rounds (4-31): " + rounds);
        if (callback) {
          nextTick(callback.bind(this, err2));
          return;
        } else
          throw err2;
      }
      if (salt.length !== BCRYPT_SALT_LEN) {
        err2 = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
        if (callback) {
          nextTick(callback.bind(this, err2));
          return;
        } else
          throw err2;
      }
      rounds = 1 << rounds >>> 0;
      var P, S, i = 0, j;
      if (Int32Array) {
        P = new Int32Array(P_ORIG);
        S = new Int32Array(S_ORIG);
      } else {
        P = P_ORIG.slice();
        S = S_ORIG.slice();
      }
      _ekskey(salt, b, P, S);
      function next() {
        if (progressCallback)
          progressCallback(i / rounds);
        if (i < rounds) {
          var start = Date.now();
          for (;i < rounds; ) {
            i = i + 1;
            _key(b, P, S);
            _key(salt, P, S);
            if (Date.now() - start > MAX_EXECUTION_TIME)
              break;
          }
        } else {
          for (i = 0;i < 64; i++)
            for (j = 0;j < clen >> 1; j++)
              _encipher(cdata, j << 1, P, S);
          var ret = [];
          for (i = 0;i < clen; i++)
            ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
          if (callback) {
            callback(null, ret);
            return;
          } else
            return ret;
        }
        if (callback)
          nextTick(next);
      }
      if (typeof callback !== "undefined") {
        next();
      } else {
        var res;
        while (true)
          if (typeof (res = next()) !== "undefined")
            return res || [];
      }
    }
    function _hash(s, salt, callback, progressCallback) {
      var err2;
      if (typeof s !== "string" || typeof salt !== "string") {
        err2 = Error("Invalid string / salt: Not a string");
        if (callback) {
          nextTick(callback.bind(this, err2));
          return;
        } else
          throw err2;
      }
      var minor, offset;
      if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
        err2 = Error("Invalid salt version: " + salt.substring(0, 2));
        if (callback) {
          nextTick(callback.bind(this, err2));
          return;
        } else
          throw err2;
      }
      if (salt.charAt(2) === "$")
        minor = String.fromCharCode(0), offset = 3;
      else {
        minor = salt.charAt(2);
        if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
          err2 = Error("Invalid salt revision: " + salt.substring(2, 4));
          if (callback) {
            nextTick(callback.bind(this, err2));
            return;
          } else
            throw err2;
        }
        offset = 4;
      }
      if (salt.charAt(offset + 2) > "$") {
        err2 = Error("Missing salt rounds");
        if (callback) {
          nextTick(callback.bind(this, err2));
          return;
        } else
          throw err2;
      }
      var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
      s += minor >= "a" ? "\x00" : "";
      var passwordb = stringToBytes2(s), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
      function finish(bytes) {
        var res = [];
        res.push("$2");
        if (minor >= "a")
          res.push(minor);
        res.push("$");
        if (rounds < 10)
          res.push("0");
        res.push(rounds.toString());
        res.push("$");
        res.push(base64_encode(saltb, saltb.length));
        res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
        return res.join("");
      }
      if (typeof callback == "undefined")
        return finish(_crypt(passwordb, saltb, rounds));
      else {
        _crypt(passwordb, saltb, rounds, function(err3, bytes) {
          if (err3)
            callback(err3, null);
          else
            callback(null, finish(bytes));
        }, progressCallback);
      }
    }
    bcrypt.encodeBase64 = base64_encode;
    bcrypt.decodeBase64 = base64_decode;
    return bcrypt;
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream3 = __require("stream");
  var util3 = __require("util");
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util3.inherits(DataStream, Stream3);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset;offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  var SlowBuffer = __require("buffer").SlowBuffer;
  module.exports = bufferEq;
  function bufferEq(a12, b) {
    if (!Buffer2.isBuffer(a12) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a12.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0;i < a12.length; i++) {
      c |= a12[i] ^ b[i];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto2 = __require("crypto");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util3 = __require("util");
  var MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`;
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i = 0;i < padding; ++i) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util3.format.bind(util3, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits2) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto2.createHmac("sha" + bits2, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  var bufferEqual;
  var timingSafeEqual = "timingSafeEqual" in crypto2 ? function timingSafeEqual(a12, b) {
    if (a12.byteLength !== b.byteLength) {
      return false;
    }
    return crypto2.timingSafeEqual(a12, b);
  } : function timingSafeEqual(a12, b) {
    if (!bufferEqual) {
      bufferEqual = require_buffer_equal_constant_time();
    }
    return bufferEqual(a12, b);
  };
  function createHmacVerifier(bits2) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits2)(thing, secret);
      return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  }
  function createKeySigner(bits2) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits2);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits2) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits2);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits2) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits2);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits2) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits2);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits2) {
    var inner = createKeySigner(bits2);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits2);
      return signature;
    };
  }
  function createECDSAVerifer(bits2) {
    var inner = createKeyVerifier(bits2);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits2).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === "";
    };
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits2 = match[2];
    return {
      sign: signerFactories[algo](bits2),
      verify: verifierFactories[algo](bits2)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer2 = __require("buffer").Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream3 = __require("stream");
  var toString = require_tostring();
  var util3 = __require("util");
  function base64url(string, encoding) {
    return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util3.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util3.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util3.inherits(SignStream, Stream3);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream3 = __require("stream");
  var toString = require_tostring();
  var util3 = __require("util");
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject2(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject2(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err2 = new Error("Missing algorithm parameter for jws.verify");
      err2.code = "MISSING_ALGORITHM";
      throw err2;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util3.inherits(VerifyStream, Stream3);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports, module) => {
  var jws = require_jws();
  module.exports = function(jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e) {
      }
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
  var JsonWebTokenError = function(message, error) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error)
      this.inner = error;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function(message, date2) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date2;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module.exports = TokenExpiredError;
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
  var ms = require_ms();
  module.exports = function(time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);
    if (typeof time === "string") {
      var milliseconds = ms(time);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1000);
    } else if (typeof time === "number") {
      return timestamp + time;
    } else {
      return;
    }
  };
});

// node_modules/semver/internal/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug2;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants4();
  var debug2 = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t2 = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.` + `(${src[t2.NUMERICIDENTIFIER]})\\.` + `(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIER]})` + `(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?` + `(?:${src[t2.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t2.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t2.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a12, b) => {
    const anum = numeric.test(a12);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a12 = +a12;
      b = +b;
    }
    return a12 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a12 < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a12, b) => compareIdentifiers(b, a12);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug2 = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4();
  var { safeRe: re, t: t2 } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug2("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m2 = version.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a12 = this.prerelease[i];
        const b = other.prerelease[i];
        debug2("prerelease compare", i, a12, b);
        if (a12 === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a12 === undefined) {
          return -1;
        } else if (a12 === b) {
          continue;
        } else {
          return compareIdentifiers(a12, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a12 = this.build[i];
        const b = other.build[i];
        debug2("build compare", i, a12, b);
        if (a12 === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a12 === undefined) {
          return -1;
        } else if (a12 === b) {
          continue;
        } else {
          return compareIdentifiers(a12, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re[t2.PRERELEASELOOSE] : re[t2.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse3 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse3;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse3 = require_parse();
  var valid = (version, options) => {
    const v = parse3(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse3 = require_parse();
  var clean2 = (version, options) => {
    const s = parse3(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  module.exports = clean2;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse3 = require_parse();
  var diff = (version1, version2) => {
    const v1 = parse3(version1, null, true);
    const v2 = parse3(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a12, loose) => new SemVer(a12, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a12, loose) => new SemVer(a12, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a12, loose) => new SemVer(a12, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse3 = require_parse();
  var prerelease = (version, options) => {
    const parsed = parse3(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a12, b, loose) => new SemVer(a12, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a12, b, loose) => compare(b, a12, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a12, b) => compare(a12, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a12, b, loose) => {
    const versionA = new SemVer(a12, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort2 = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a12, b) => compareBuild(a12, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a12, b) => compareBuild(b, a12, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a12, b, loose) => compare(a12, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a12, b, loose) => compare(a12, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a12, b, loose) => compare(a12, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a12, b, loose) => compare(a12, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a12, b, loose) => compare(a12, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a12, b, loose) => compare(a12, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a12, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a12 === "object") {
          a12 = a12.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a12 === b;
      case "!==":
        if (typeof a12 === "object") {
          a12 = a12.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a12 !== b;
      case "":
      case "=":
      case "==":
        return eq(a12, b, loose);
      case "!=":
        return neq(a12, b, loose);
      case ">":
        return gt(a12, b, loose);
      case ">=":
        return gte(a12, b, loose);
      case "<":
        return lt(a12, b, loose);
      case "<=":
        return lte(a12, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse3 = require_parse();
  var { safeRe: re, t: t2 } = require_re();
  var coerce2 = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t2.COERCEFULL] : re[t2.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t2.COERCERTLFULL] : re[t2.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce2;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range);
      range = range.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range);
      range = range.replace(re[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range);
      range = range.replace(re[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug2 = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants4();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r2 = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
    return comp.replace(r2, (_, M, m2, p, pr) => {
      debug2("tilde", comp, _, M, m2, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r2 = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M, m2, p, pr) => {
      debug2("caret", comp, _, M, m2, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
    return comp.replace(r2, (ret, gtlt, M, m2, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m2, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m2);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re[t2.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set2, version, options) => {
    for (let i = 0;i < set2.length; i++) {
      if (!set2[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== undefined ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t: t2 } = require_re();
  var cmp = require_cmp();
  var debug2 = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max2 = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max2 || maxSV.compare(v) === -1) {
          max2 = v;
          maxSV = new SemVer(max2, options);
        }
      }
    });
    return max2;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a12, b) => compare(a12, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max2] of set2) {
      if (min === max2) {
        ranges.push(min);
      } else if (!max2 && min === v[0]) {
        ranges.push("*");
      } else if (!max2) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max2}`);
      } else {
        ranges.push(`${min} - ${max2}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt, c, options);
          if (lower === c && lower !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a12, b, options) => {
    if (!a12) {
      return b;
    }
    const comp = compare(a12.semver, b.semver, options);
    return comp > 0 ? a12 : comp < 0 ? b : b.operator === ">" && a12.operator === ">=" ? b : a12;
  };
  var lowerLT = (a12, b, options) => {
    if (!a12) {
      return b;
    }
    const comp = compare(a12.semver, b.semver, options);
    return comp < 0 ? a12 : comp > 0 ? b : b.operator === "<" && a12.operator === "<=" ? b : a12;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants4();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse3 = require_parse();
  var valid = require_valid();
  var clean2 = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort2();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce2 = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse3,
    valid,
    clean: clean2,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce: coerce2,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
  var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
  var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
  var allowedAlgorithmsForKeys = {
    ec: ["ES256", "ES384", "ES512"],
    rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  var allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  module.exports = function(algorithm, key) {
    if (!algorithm || !key)
      return;
    const keyType = key.asymmetricKeyType;
    if (!keyType)
      return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== undefined && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode4 = require_decode();
  var timespan = require_timespan();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var { KeyObject, createSecretKey, createPublicKey } = __require("crypto");
  var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err2, data) {
        if (err2)
          throw err2;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode4(jwtString, { complete: true });
    } catch (err2) {
      return done(err2);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err2, secretOrPublicKey2) {
      if (err2) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err2.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_2) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
      }
      let valid;
      try {
        valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e) {
        return done(e);
      }
      if (!valid) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseTimes(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function includes(collection, value, fromIndex, guard2) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard2 ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function values(object) {
    return object ? baseValues(object, keys(object)) : [];
  }
  module.exports = includes;
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module.exports = isBoolean;
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  module.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
  }
  module.exports = isNumber;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject;
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS((exports, module) => {
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  }
  module.exports = isString;
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS((exports, module) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function before(n2, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n2 = toInteger(n2);
    return function() {
      if (--n2 > 0) {
        result = func.apply(this, arguments);
      }
      if (n2 <= 1) {
        func = undefined;
      }
      return result;
    };
  }
  function once(func) {
    return before(2, func);
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  module.exports = once;
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports, module) => {
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var jws = require_jws();
  var includes = require_lodash();
  var isBoolean = require_lodash2();
  var isInteger = require_lodash3();
  var isNumber = require_lodash4();
  var isPlainObject = require_lodash5();
  var isString = require_lodash6();
  var once = require_lodash7();
  var { KeyObject, createSecretKey, createPrivateKey } = __require("crypto");
  var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  var sign_options_schema = {
    expiresIn: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value) {
      return isString(value) || Array.isArray(value);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
  };
  function validate(schema, allowUnknown, object, parameterName) {
    if (!isPlainObject(object)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object).forEach(function(key) {
      const validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
  }
  function validateOptions(options) {
    return validate(sign_options_schema, false, options, "options");
  }
  function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  }
  var options_to_payload = {
    audience: "aud",
    issuer: "iss",
    subject: "sub",
    jwtid: "jti"
  };
  var options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : undefined,
      kid: options.keyid
    }, options.header);
    function failure(err2) {
      if (callback) {
        return callback(err2);
      }
      throw err2;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
      try {
        secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
      } catch (_) {
        try {
          secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
        } catch (_2) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error) {
        return failure(error);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error) {
      return failure(error);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPrivateKey);
      } catch (error) {
        return failure(error);
      }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan(options.notBefore, timestamp);
      } catch (err2) {
        return failure(err2);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan(options.expiresIn, timestamp);
      } catch (err2) {
        return failure(err2);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once(callback);
      jws.createSign({
        header,
        privateKey: secretOrPrivateKey,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
  module.exports = {
    decode: require_decode(),
    verify: require_verify(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError()
  };
});

// node_modules/ws/lib/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants5();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{throw new Error("Cannot require module "+"bufferutil");})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants5();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err2, result) => {
          done();
          callback(err2, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err2, result) => {
          done();
          callback(err2, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err2 = this._inflate[kError];
        if (err2) {
          this._inflate.close();
          this._inflate = null;
          callback(err2);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err2) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err2[kStatusCode] = 1007;
    this[kCallback](err2);
  }
});

// node_modules/ws/lib/validation.js
var require_validation2 = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants5();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{throw new Error("Cannot require module "+"utf-8-validate");})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants5();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation2();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n2) {
      this._bufferedBytes -= n2;
      if (n2 === this._buffers[0].length)
        return this._buffers.shift();
      if (n2 < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n2, buf.length - n2);
        return new FastBuffer(buf.buffer, buf.byteOffset, n2);
      }
      const dst = Buffer.allocUnsafe(n2);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n2;
        if (n2 >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n2, buf.length - n2);
        }
        n2 -= buf.length;
      } while (n2 > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err2, buf) => {
        if (err2)
          return cb(err2);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err2 = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err2, this.createError);
      err2.code = errorCode;
      err2[kStatusCode] = statusCode;
      return err2;
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants5();
  var { isBlob, isValidStatusCode } = require_validation2();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions2, generateMask) {
      this._extensions = extensions2 || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options, cb) {
      this._bufferedBytes += options[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err2 = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err2, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      }).catch((err2) => {
        process.nextTick(onError, this, err2, cb);
      });
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err2 = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err2, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._state = DEFAULT;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err2, cb) {
    if (typeof cb === "function")
      cb(err2);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err2);
    }
  }
  function onError(sender, err2, cb) {
    callCallbacks(sender, err2, cb);
    sender.onerror(err2);
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants5();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation2();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse3(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions2) {
    return Object.keys(extensions2).map((extension) => {
      let configurations = extensions2[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse: parse3 };
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable: Readable2 } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation2();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants5();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse: parse3 } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err2) => {
        if (err2)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
  function initAsClient(websocket2, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket2._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket2._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err2 = new SyntaxError(invalidUrlMessage);
      if (websocket2._redirects === 0) {
        throw err2;
      } else {
        emitErrorAndClose(websocket2, err2);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket2._redirects === 0) {
        websocket2._originalIpc = isIpcUrl;
        websocket2._originalSecure = isSecure;
        websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket2.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
        if (!isSameHost || websocket2._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket2._req = request(opts);
      if (websocket2._redirects) {
        websocket2.emit("redirect", websocket2.url, req);
      }
    } else {
      req = websocket2._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket2, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err2) => {
      if (req === null || req[kAborted])
        return;
      req = websocket2._req = null;
      emitErrorAndClose(websocket2, err2);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket2._redirects > opts.maxRedirects) {
          abortHandshake(websocket2, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err2 = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket2, err2);
          return;
        }
        initAsClient(websocket2, addr, protocols, options);
      } else if (!websocket2.emit("unexpected-response", req, res)) {
        abortHandshake(websocket2, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket2.emit("upgrade", res);
      if (websocket2.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket2._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket2, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket2, socket, protError);
        return;
      }
      if (serverProt)
        websocket2._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket2, socket, message);
          return;
        }
        let extensions2;
        try {
          extensions2 = parse3(secWebSocketExtensions);
        } catch (err2) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket2, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions2);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket2, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
        } catch (err2) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket2, socket, message);
          return;
        }
        websocket2._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket2.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket2);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket2, err2) {
    websocket2._readyState = WebSocket.CLOSING;
    websocket2._errorEmitted = true;
    websocket2.emit("error", err2);
    websocket2.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket2, stream, message) {
    websocket2._readyState = WebSocket.CLOSING;
    const err2 = new Error(message);
    Error.captureStackTrace(err2, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket2, err2);
    } else {
      stream.destroy(err2);
      stream.once("error", websocket2.emit.bind(websocket2, "error"));
      stream.once("close", websocket2.emitClose.bind(websocket2));
    }
  }
  function sendAfterClose(websocket2, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket2._socket)
        websocket2._sender._bufferedBytes += length;
      else
        websocket2._bufferedAmount += length;
    }
    if (cb) {
      const err2 = new Error(`WebSocket is not open: readyState ${websocket2.readyState} ` + `(${readyStates[websocket2.readyState]})`);
      process.nextTick(cb, err2);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket2 = this[kWebSocket];
    websocket2._closeFrameReceived = true;
    websocket2._closeMessage = reason;
    websocket2._closeCode = code;
    if (websocket2._socket[kWebSocket] === undefined)
      return;
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    if (code === 1005)
      websocket2.close();
    else
      websocket2.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket2 = this[kWebSocket];
    if (!websocket2.isPaused)
      websocket2._socket.resume();
  }
  function receiverOnError(err2) {
    const websocket2 = this[kWebSocket];
    if (websocket2._socket[kWebSocket] !== undefined) {
      websocket2._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket2._socket);
      websocket2.close(err2[kStatusCode]);
    }
    if (!websocket2._errorEmitted) {
      websocket2._errorEmitted = true;
      websocket2.emit("error", err2);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket2 = this[kWebSocket];
    if (websocket2._autoPong)
      websocket2.pong(data, !this._isServer, NOOP);
    websocket2.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function senderOnError(err2) {
    const websocket2 = this[kWebSocket];
    if (websocket2.readyState === WebSocket.CLOSED)
      return;
    if (websocket2.readyState === WebSocket.OPEN) {
      websocket2._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket2);
    }
    this._socket.end();
    if (!websocket2._errorEmitted) {
      websocket2._errorEmitted = true;
      websocket2.emit("error", err2);
    }
  }
  function setCloseTimer(websocket2) {
    websocket2._closeTimer = setTimeout(websocket2._socket.destroy.bind(websocket2._socket), closeTimeout);
  }
  function socketOnClose() {
    const websocket2 = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket2._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
      websocket2._receiver.write(chunk);
    }
    websocket2._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket2._closeTimer);
    if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
      websocket2.emitClose();
    } else {
      websocket2._receiver.on("error", receiverOnFinish);
      websocket2._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket2 = this[kWebSocket];
    websocket2._readyState = WebSocket.CLOSING;
    websocket2._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket2 = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket2) {
      websocket2._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err2) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err2);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err2) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err2);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err2, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err2);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err3) {
        called = true;
        callback(err3);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err2);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation2();
  function parse3(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse: parse3 };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants5();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 13 && version !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err2) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions2 = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err2) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions2, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions2, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions2, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions2[PerMessageDeflate.extensionName]) {
        const params = extensions2[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions2;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map3) {
    for (const event of Object.keys(map3))
      server.on(event, map3[event]);
    return function removeListeners() {
      for (const event of Object.keys(map3)) {
        server.removeListener(event, map3[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err2 = new Error(message);
      Error.captureStackTrace(err2, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err2, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined,
  IsUint8Array: () => IsUint8Array,
  IsSymbol: () => IsSymbol,
  IsString: () => IsString,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject,
  IsNumber: () => IsNumber,
  IsNull: () => IsNull,
  IsIterator: () => IsIterator,
  IsFunction: () => IsFunction,
  IsDate: () => IsDate,
  IsBoolean: () => IsBoolean,
  IsBigInt: () => IsBigInt,
  IsAsyncIterator: () => IsAsyncIterator,
  IsArray: () => IsArray,
  HasPropertyKey: () => HasPropertyKey
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === undefined;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsImport: () => IsImport,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsComputed: () => IsComputed2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsArgument: () => IsArgument2,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type.IsNever(right) || exports_type.IsIntersect(right) || exports_type.IsUnion(right) || exports_type.IsUnknown(right) || exports_type.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) && right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right) ? ExtendsResult.Union : exports_type.IsUnknown(right) ? ExtendsResult.True : exports_type.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return exports_type.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return exports_type.IsNot(left) ? Visit3(UnwrapTNot(left), right) : exports_type.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type.IsLiteralNumber(left) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left) && !exports_type.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) || exports_type.IsLiteralString(left) && IsObjectStringLike(right) || exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type.IsString(left) && IsObjectStringLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsNumber(left) && IsObjectNumberLike(right) || exports_type.IsInteger(left) && IsObjectNumberLike(right) || exports_type.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type.IsDate(left) && IsObjectDateLike(right) || exports_type.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : !exports_type.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type.IsLiteralString(left) && exports_type.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsString(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsArray(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = exports_type.IsRegExp(left) ? String2() : left;
  const R = exports_type.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return exports_type.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : exports_type.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type.IsNever(left) ? ExtendsResult.True : exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsVoid(right) ? FromVoidRight(left, right) : exports_type.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type.IsArray(right) ? FromArrayRight(left, right) : exports_type.IsTuple(right) ? FromTupleRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type.IsUndefined(left) ? ExtendsResult.True : exports_type.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : exports_type.IsRegExp(left) || exports_type.IsRegExp(right) ? FromRegExp(left, right) : exports_type.IsNot(left) || exports_type.IsNot(right) ? FromNot(left, right) : exports_type.IsAny(left) ? FromAny(left, right) : exports_type.IsArray(left) ? FromArray4(left, right) : exports_type.IsBigInt(left) ? FromBigInt(left, right) : exports_type.IsBoolean(left) ? FromBoolean(left, right) : exports_type.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : exports_type.IsConstructor(left) ? FromConstructor(left, right) : exports_type.IsDate(left) ? FromDate(left, right) : exports_type.IsFunction(left) ? FromFunction(left, right) : exports_type.IsInteger(left) ? FromInteger(left, right) : exports_type.IsIntersect(left) ? FromIntersect4(left, right) : exports_type.IsIterator(left) ? FromIterator(left, right) : exports_type.IsLiteral(left) ? FromLiteral2(left, right) : exports_type.IsNever(left) ? FromNever(left, right) : exports_type.IsNull(left) ? FromNull(left, right) : exports_type.IsNumber(left) ? FromNumber(left, right) : exports_type.IsObject(left) ? FromObject(left, right) : exports_type.IsRecord(left) ? FromRecord(left, right) : exports_type.IsString(left) ? FromString(left, right) : exports_type.IsSymbol(left) ? FromSymbol(left, right) : exports_type.IsTuple(left) ? FromTuple3(left, right) : exports_type.IsPromise(left) ? FromPromise2(left, right) : exports_type.IsUint8Array(left) ? FromUint8Array(left, right) : exports_type.IsUndefined(left) ? FromUndefined(left, right) : exports_type.IsUnion(left) ? FromUnion6(left, right) : exports_type.IsUnknown(left) ? FromUnknown(left, right) : exports_type.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}
function Module(properties) {
  return new TModule(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
}
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Module: () => Module,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  Instantiate: () => Instantiate,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Argument: () => Argument,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== undefined;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {
}
function* FromArgument3(schema, references, path, value) {
}
function* FromArray8(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator5(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction5(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect10(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject9(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {
}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = exports_type2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator) {
    const error = iterator.First();
    super(error === undefined ? "Invalid Value" : error.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject10(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray9(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray9(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject10(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray10(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromImport3(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit7(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromRef7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple8(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion13(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray10(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport3(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect11(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord6(schema_, references_);
    case "Ref":
      return FromRef7(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple8(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion13(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else if (schema[Kind] === "Union") {
    const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
    const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value));
    return Math.max(...scores);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray11(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor7(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport4(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit8(target, [...references, ...definitions], value);
}
function IntersectAssign(correct, value) {
  if (IsObject2(correct) && !IsObject2(value) || !IsObject2(correct) && IsObject2(value))
    return correct;
  if (!IsObject2(correct) || !IsObject2(value))
    return value;
  return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
    const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];
    return { ...result, [key]: property };
  }, {});
}
function FromIntersect12(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  const correct = Create2(schema, references);
  const assigned = IntersectAssign(correct, value);
  return Check(schema, references, assigned) ? assigned : correct;
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject12(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef8(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion14(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value);
    case "Constructor":
      return FromConstructor7(schema_, references_, value);
    case "Import":
      return FromImport4(schema_, references_, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject12(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef8(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Union":
      return FromUnion14(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray12(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromImport5(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit9(target, [...references, ...definitions], value);
}
function FromIntersect13(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject13(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord8(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef9(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion15(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value);
    case "Import":
      return FromImport5(schema_, references_, value);
    case "Intersect":
      return FromIntersect13(schema_, references_, value);
    case "Object":
      return FromObject13(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef9(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion15(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray13(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport6(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect14(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject14(schema, references, value) {
  if (!IsObject2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit10(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord9(schema, references, value) {
  const isConvertable = IsObject2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit10(property, references, propValue);
  }
  return value;
}
function FromRef10(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple11(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion16(schema, references, value) {
  for (const subschema of schema.anyOf) {
    if (Check(subschema, references, value)) {
      return value;
    }
  }
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport6(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect14(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject14(schema_, references_, value);
    case "Record":
      return FromRecord9(schema_, references_, value);
    case "Ref":
      return FromRef10(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple11(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion16(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default3(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
}
function FromArray14(schema, references, path, value) {
  return IsArray2(value) ? Default3(schema, path, value.map((value2, index) => Visit11(schema.items, references, `${path}/${index}`, value2))) : Default3(schema, path, value);
}
function FromIntersect15(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default3(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit11(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromImport7(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit11(target, [...references, ...additional], path, value);
  return Default3(schema, path, result);
}
function FromNot5(schema, references, path, value) {
  return Default3(schema, path, Visit11(schema.not, references, path, value));
}
function FromObject15(schema, references, path, value) {
  if (!IsObject2(value))
    return Default3(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit11(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRecord10(schema, references, path, value) {
  if (!IsObject2(value))
    return Default3(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit11(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRef11(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value));
}
function FromThis7(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value));
}
function FromTuple12(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default3(schema, path, schema.items.map((schema2, index) => Visit11(schema2, references, `${path}/${index}`, value[index]))) : Default3(schema, path, value);
}
function FromUnion17(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit11(subschema, references, path, value);
    return Default3(schema, path, decoded);
  }
  return Default3(schema, path, value);
}
function Visit11(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, path, value);
    case "Import":
      return FromImport7(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject15(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef11(schema_, references_, path, value);
    case "Symbol":
      return Default3(schema_, path, value);
    case "This":
      return FromThis7(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion17(schema_, references_, path, value);
    default:
      return Default3(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit11(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
}
function FromArray15(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit12(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport8(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default4(schema, path, value);
  return Visit12(target, [...references, ...additional], path, result);
}
function FromIntersect16(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit12(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default4(schema.not, path, Default4(schema, path, value));
}
function FromObject16(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit12(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord11(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit12(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef12(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value);
  return Default4(schema, path, resolved);
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value);
  return Default4(schema, path, resolved);
}
function FromTuple13(schema, references, path, value) {
  const value1 = Default4(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit12(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion18(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit12(subschema, references, path, value);
    return Default4(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit12(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default4(schema, path, value1);
  }
  return Default4(schema, path, value);
}
function Visit12(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, path, value);
    case "Import":
      return FromImport8(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject16(schema_, references_, path, value);
    case "Record":
      return FromRecord11(schema_, references_, path, value);
    case "Ref":
      return FromRef12(schema_, references_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple13(schema_, references_, path, value);
    case "Union":
      return FromUnion18(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit12(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray16(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromAsyncIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromConstructor8(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromFunction7(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromIntersect17(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit13(schema2, references));
}
function FromImport9(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit13(target, [...additional, ...references]);
}
function FromIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform(schema) || Visit13(schema.not, references);
}
function FromObject17(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit13(schema2, references)) || IsSchema(schema.additionalProperties) && Visit13(schema.additionalProperties, references);
}
function FromPromise7(schema, references) {
  return IsTransform(schema) || Visit13(schema.item, references);
}
function FromRecord12(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit13(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef13(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromThis9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromTuple14(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit13(schema2, references));
}
function FromUnion19(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit13(schema2, references));
}
function Visit13(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "Constructor":
      return FromConstructor8(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport9(schema_, references_);
    case "Intersect":
      return FromIntersect17(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject17(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord12(schema_, references_);
    case "Ref":
      return FromRef13(schema_, references_);
    case "This":
      return FromThis9(schema_, references_);
    case "Tuple":
      return FromTuple14(schema_, references_);
    case "Union":
      return FromUnion19(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit13(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0;i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Intersect":
      return FromIntersect18(schema_, references_, value);
    case "Object":
      return FromObject18(schema_, references_, value);
    case "Record":
      return FromRecord13(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple15(schema_, references_, value);
    case "Union":
      return FromUnion20(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = new Map([
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Cast", (type, references, value) => Cast(type, references, value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => ValueErrorIterator,
  Patch: () => Patch,
  Parse: () => Parse,
  Mutate: () => Mutate,
  Hash: () => Hash,
  Errors: () => Errors,
  Equal: () => Equal,
  Encode: () => Encode,
  Edit: () => Edit,
  Diff: () => Diff,
  Default: () => Default5,
  Decode: () => Decode,
  Create: () => Create2,
  Convert: () => Convert,
  Clone: () => Clone2,
  Clean: () => Clean,
  Check: () => Check,
  Cast: () => Cast,
  Assert: () => Assert
});
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check2 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check2)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value) {
    yield "true";
  }
  function* FromArgument5(schema, references, value) {
    yield "true";
  }
  function* FromArray18(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check2} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt6(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value) {
    yield* Visit17(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate8(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport11(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger6(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral7(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value) {
    yield `false`;
  }
  function* FromNot8(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber6(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit17(target, references, value);
  }
  function* FromRegExp5(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol6(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis11(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple16(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === undefined)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion21(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value) {
    yield "true";
  }
  function* FromVoid5(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind4(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit17(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value);
      case "Array":
        return yield* FromArray18(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value);
      case "Date":
        return yield* FromDate8(schema_, references_, value);
      case "Function":
        return yield* FromFunction8(schema_, references_, value);
      case "Import":
        return yield* FromImport11(schema_, references_, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value);
      case "Never":
        return yield* FromNever6(schema_, references_, value);
      case "Not":
        return yield* FromNot8(schema_, references_, value);
      case "Null":
        return yield* FromNull6(schema_, references_, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, value);
      case "Object":
        return yield* FromObject19(schema_, references_, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value);
      case "Record":
        return yield* FromRecord14(schema_, references_, value);
      case "Ref":
        return yield* FromRef15(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value);
      case "String":
        return yield* FromString6(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return yield* FromThis11(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value);
      case "Union":
        return yield* FromUnion21(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, value);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!exports_type2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/index.mjs
var import_cookie = __toESM(require_dist(), 1);
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component3 = __toESM(require_fast_decode_uri_component(), 1);

// node_modules/exact-mirror/dist/index.mjs
var Kind2 = Symbol.for("TypeBox.Kind");
var Hint2 = Symbol.for("TypeBox.Hint");
var isSpecialProperty = (name) => /(\ |-|\t|\n)/.test(name) || !isNaN(+name[0]);
var joinProperty = (v1, v2, isOptional = false) => {
  if (typeof v2 === "number")
    return `${v1}[${v2}]`;
  if (isSpecialProperty(v2))
    return `${v1}${isOptional ? "?." : ""}["${v2}"]`;
  return `${v1}${isOptional ? "?" : ""}.${v2}`;
};
var encodeProperty = (v) => isSpecialProperty(v) ? `"${v}"` : v;
var sanitize = (key, sanitize2 = 0, schema) => {
  if (schema.type !== "string" || schema.const || schema.trusted)
    return key;
  let hof = "";
  for (let i = sanitize2 - 1;i >= 0; i--)
    hof += `d.h${i}(`;
  return hof + key + ")".repeat(sanitize2);
};
var mergeObjectIntersection = (schema) => {
  if (!schema.allOf || Kind2 in schema && (schema[Kind2] !== "Intersect" || schema.type !== "object"))
    return schema;
  const { allOf, ...newSchema } = schema;
  newSchema.properties = {};
  if (Kind2 in newSchema)
    newSchema[Kind2] = "Object";
  for (const type of allOf) {
    if (type.type !== "object")
      continue;
    const { properties, required, type: _, [Kind2]: __, ...rest } = type;
    if (required)
      newSchema.required = newSchema.required ? newSchema.required.concat(required) : required;
    Object.assign(newSchema, rest);
    for (const property in type.properties)
      newSchema.properties[property] = mergeObjectIntersection(type.properties[property]);
  }
  return newSchema;
};
var handleRecord = (schema, property, instruction) => {
  const child = schema.patternProperties["^(.*)$"] ?? schema.patternProperties[Object.keys(schema.patternProperties)[0]];
  if (!child)
    return property;
  const i = instruction.array;
  instruction.array++;
  return `(()=>{const ar${i}s=Object.keys(${property}),ar${i}v={};for(let i=0;i<ar${i}s.length;i++){const ar${i}p=${property}[ar${i}s[i]];ar${i}v[ar${i}s[i]]=${mirror(child, `ar${i}p`, instruction)}}return ar${i}v})()`;
};
var handleTuple = (schema, property, instruction) => {
  const i = instruction.array;
  instruction.array++;
  const isRoot = property === "v" && !instruction.unions.length;
  let v = "";
  if (!isRoot)
    v = `(()=>{`;
  v += `const ar${i}v=[`;
  for (let i2 = 0;i2 < schema.length; i2++) {
    if (i2 !== 0)
      v += ",";
    v += mirror(schema[i2], joinProperty(property, i2, instruction.parentIsOptional), instruction);
  }
  v += `];`;
  if (!isRoot)
    v += `return ar${i}v})()`;
  return v;
};
function deepClone(source, weak = /* @__PURE__ */ new WeakMap) {
  if (source === null || typeof source !== "object" || typeof source === "function")
    return source;
  if (weak.has(source))
    return weak.get(source);
  if (Array.isArray(source)) {
    const copy = new Array(source.length);
    weak.set(source, copy);
    for (let i = 0;i < source.length; i++)
      copy[i] = deepClone(source[i], weak);
    return copy;
  }
  if (typeof source === "object") {
    const keys = Object.keys(source).concat(Object.getOwnPropertySymbols(source));
    const cloned = {};
    for (const key of keys)
      cloned[key] = deepClone(source[key], weak);
    return cloned;
  }
  return source;
}
var handleUnion = (schemas, property, instruction) => {
  if (instruction.TypeCompiler === undefined) {
    if (!instruction.typeCompilerWanred) {
      console.warn(new Error("[exact-mirror] TypeBox's TypeCompiler is required to use Union"));
      instruction.typeCompilerWanred = true;
    }
    return property;
  }
  instruction.unionKeys[property] = 1;
  const ui = instruction.unions.length;
  const typeChecks = instruction.unions[ui] = [];
  let v = `(()=>{
`;
  const unwrapRef = (type) => {
    if (!(Kind2 in type) || !type.$ref)
      return type;
    if (type[Kind2] === "This") {
      return deepClone(instruction.definitions[type.$ref]);
    } else if (type[Kind2] === "Ref") {
      if (!instruction.modules)
        console.warn(new Error("[exact-mirror] modules is required when using nested cyclic reference"));
      else
        return instruction.modules.Import(type.$ref);
    }
    return type;
  };
  for (let i = 0;i < schemas.length; i++) {
    let type = unwrapRef(schemas[i]);
    if (Array.isArray(type.anyOf))
      for (let i2 = 0;i2 < type.anyOf.length; i2++)
        type.anyOf[i2] = unwrapRef(type.anyOf[i2]);
    else if (type.items) {
      if (Array.isArray(type.items))
        for (let i2 = 0;i2 < type.items.length; i2++)
          type.items[i2] = unwrapRef(type.items[i2]);
      else
        type.items = unwrapRef(type.items);
    }
    typeChecks.push(TypeCompiler.Compile(type));
    v += `if(d.unions[${ui}][${i}].Check(${property})){return ${mirror(type, property, {
      ...instruction,
      recursion: instruction.recursion + 1,
      parentIsOptional: true
    })}}
`;
  }
  v += `return ${instruction.removeUnknownUnionType ? "undefined" : property}})()`;
  return v;
};
var mirror = (schema, property, instruction) => {
  if (!schema)
    return "";
  const isRoot = property === "v" && !instruction.unions.length;
  if (Kind2 in schema && schema[Kind2] === "Import" && schema.$ref in schema.$defs)
    return mirror(schema.$defs[schema.$ref], property, {
      ...instruction,
      definitions: Object.assign(instruction.definitions, schema.$defs)
    });
  if (isRoot && schema.type !== "object" && schema.type !== "array" && !schema.anyOf)
    return `return ${sanitize("v", instruction.sanitize?.length, schema)}`;
  if (instruction.recursion >= instruction.recursionLimit)
    return property;
  let v = "";
  if (schema.$id && Hint2 in schema)
    instruction.definitions[schema.$id] = schema;
  switch (schema.type) {
    case "object":
      if (schema[Kind2] === "Record") {
        v = handleRecord(schema, property, instruction);
        break;
      }
      schema = mergeObjectIntersection(schema);
      v += "{";
      if (schema.additionalProperties)
        v += `...${property}`;
      const keys = Object.keys(schema.properties);
      for (let i2 = 0;i2 < keys.length; i2++) {
        const key = keys[i2];
        let isOptional = schema.required && !schema.required.includes(key) || Array.isArray(schema.properties[key].anyOf);
        const name = joinProperty(property, key, instruction.parentIsOptional);
        if (isOptional) {
          const index = instruction.array;
          if (property.startsWith("ar")) {
            const refName = name.slice(name.indexOf(".") + 1);
            const array = instruction.optionalsInArray;
            if (array[index])
              array[index].push(refName);
            else
              array[index] = [refName];
          } else {
            instruction.optionals.push(name);
          }
        }
        const child = schema.properties[key];
        if (schema.additionalProperties && child.type !== "object")
          continue;
        if (i2 !== 0)
          v += ",";
        v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : ""}${mirror(child, name, {
          ...instruction,
          recursion: instruction.recursion + 1,
          parentIsOptional: isOptional
        })}`;
      }
      v += "}";
      break;
    case "array":
      if (schema.items.type !== "object" && schema.items.type !== "array") {
        if (Array.isArray(schema.items)) {
          v = handleTuple(schema.items, property, instruction);
          break;
        } else if (isRoot)
          return "return v";
        else if (Kind2 in schema.items && schema.items.$ref && (schema.items[Kind2] === "Ref" || schema.items[Kind2] === "This"))
          v = mirror(deepClone(instruction.definitions[schema.items.$ref]), property, {
            ...instruction,
            parentIsOptional: true,
            recursion: instruction.recursion + 1
          });
        else {
          v = property;
          break;
        }
      }
      const i = instruction.array;
      instruction.array++;
      let reference = property;
      if (isRoot)
        v = `const ar${i}v=new Array(${property}.length);`;
      else {
        reference = `ar${i}s`;
        v = `((${reference})=>{const ar${i}v=new Array(${reference}.length);`;
      }
      v += `for(let i=0;i<${reference}.length;i++){const ar${i}p=${reference}[i];ar${i}v[i]=${mirror(schema.items, `ar${i}p`, instruction)}`;
      const optionals = instruction.optionalsInArray[i + 1];
      if (optionals) {
        for (let oi = 0;oi < optionals.length; oi++) {
          const target = `ar${i}v[i].${optionals[oi]}`;
          v += `;if(${target}===undefined)delete ${target}`;
        }
      }
      v += `}`;
      if (!isRoot)
        v += `return ar${i}v})(${property})`;
      break;
    default:
      if (schema.$ref && schema.$ref in instruction.definitions)
        return mirror(instruction.definitions[schema.$ref], property, instruction);
      if (Array.isArray(schema.anyOf)) {
        v = handleUnion(schema.anyOf, property, instruction);
        break;
      }
      v = sanitize(property, instruction.sanitize?.length, schema);
      break;
  }
  if (!isRoot)
    return v;
  if (schema.type === "array")
    return `${v}return ar0v`;
  v = `const x=${v}
`;
  for (let i = 0;i < instruction.optionals.length; i++) {
    const key = instruction.optionals[i];
    const prop = key.slice(1);
    v += `if(${key}===undefined`;
    if (instruction.unionKeys[key])
      v += `||x${prop}===undefined`;
    v += `)delete x${prop.charCodeAt(0) !== 63 ? "?" : ""}${prop}
`;
  }
  return `${v}return x`;
};
var createMirror = (schema, {
  TypeCompiler: TypeCompiler2,
  modules,
  definitions,
  sanitize: sanitize2,
  recursionLimit = 8,
  removeUnknownUnionType = false
} = {}) => {
  const unions = [];
  if (typeof sanitize2 === "function")
    sanitize2 = [sanitize2];
  const f = mirror(schema, "v", {
    optionals: [],
    optionalsInArray: [],
    array: 0,
    parentIsOptional: false,
    unions,
    unionKeys: {},
    TypeCompiler: TypeCompiler2,
    modules,
    definitions: definitions ?? modules?.$defs ?? {},
    sanitize: sanitize2,
    recursion: 0,
    recursionLimit,
    removeUnknownUnionType
  });
  if (!unions.length && !sanitize2?.length)
    return Function("v", f);
  let hof;
  if (sanitize2?.length) {
    hof = {};
    for (let i = 0;i < sanitize2.length; i++)
      hof[`h${i}`] = sanitize2[i];
  }
  return Function("d", `return function mirror(v){${f}}`)({
    unions,
    ...hof
  });
};

// node_modules/elysia/dist/index.mjs
var createNode = (part, inert) => {
  let inertMap = inert?.length ? {} : null;
  if (inertMap)
    for (let child of inert)
      inertMap[child.part.charCodeAt(0)] = child;
  return {
    part,
    store: null,
    inert: inertMap,
    params: null,
    wildcardStore: null
  };
};
var cloneNode = (node, part) => ({
  ...node,
  part
});
var createParamNode = (name) => ({
  name,
  store: null,
  inert: null
});
var Memoirist = class _Memoirist {
  constructor(config = {}) {
    this.config = config, config.lazy && (this.find = this.lazyFind);
  }
  root = {};
  history = [];
  deferred = [];
  static regex = {
    static: /:.+?(?=\/|$)/,
    params: /:.+?(?=\/|$)/g,
    optionalParams: /(\/:\w+\?)/g
  };
  lazyFind = (method, url) => this.config.lazy ? (this.build(), this.find(method, url)) : this.find;
  build() {
    if (this.config.lazy) {
      for (let [method, path, store] of this.deferred)
        this.add(method, path, store, { lazy: false, ignoreHistory: true });
      this.deferred = [], this.find = (method, url) => {
        let root = this.root[method];
        return root ? matchRoute(url, url.length, root, 0) : null;
      };
    }
  }
  add(method, path, store, {
    ignoreError = false,
    ignoreHistory = false,
    lazy = this.config.lazy
  } = {}) {
    if (lazy)
      return this.find = this.lazyFind, this.deferred.push([method, path, store]), store;
    if (typeof path != "string")
      throw new TypeError("Route path must be a string");
    path === "" ? path = "/" : path[0] !== "/" && (path = `/${path}`);
    let isWildcard = path[path.length - 1] === "*", optionalParams = path.match(_Memoirist.regex.optionalParams);
    if (optionalParams) {
      let originalPath = path.replaceAll("?", "");
      this.add(method, originalPath, store, {
        ignoreError,
        ignoreHistory,
        lazy
      });
      for (let i = 0;i < optionalParams.length; i++) {
        let newPath = path.replace(optionalParams[i], "");
        this.add(method, newPath, store, {
          ignoreError: true,
          ignoreHistory,
          lazy
        });
      }
      return store;
    }
    if (optionalParams && (path = path.replaceAll("?", "")), this.history.find(([m, p, s]) => m === method && p === path))
      return store;
    (isWildcard || optionalParams && path.charCodeAt(path.length - 1) === 63) && (path = path.slice(0, -1)), ignoreHistory || this.history.push([method, path, store]);
    let inertParts = path.split(_Memoirist.regex.static), paramParts = path.match(_Memoirist.regex.params) || [];
    inertParts[inertParts.length - 1] === "" && inertParts.pop();
    let node;
    this.root[method] ? node = this.root[method] : node = this.root[method] = createNode("/");
    let paramPartsIndex = 0;
    for (let i = 0;i < inertParts.length; ++i) {
      let part = inertParts[i];
      if (i > 0) {
        let param = paramParts[paramPartsIndex++].slice(1);
        if (node.params === null)
          node.params = createParamNode(param);
        else if (node.params.name !== param) {
          if (ignoreError)
            return store;
          throw new Error(`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`);
        }
        let params = node.params;
        if (params.inert === null) {
          node = params.inert = createNode(part);
          continue;
        }
        node = params.inert;
      }
      for (let j = 0;; ) {
        if (j === part.length) {
          if (j < node.part.length) {
            let childNode = cloneNode(node, node.part.slice(j));
            Object.assign(node, createNode(part, [childNode]));
          }
          break;
        }
        if (j === node.part.length) {
          node.inert === null && (node.inert = {});
          let inert = node.inert[part.charCodeAt(j)];
          if (inert) {
            node = inert, part = part.slice(j), j = 0;
            continue;
          }
          let childNode = createNode(part.slice(j));
          node.inert[part.charCodeAt(j)] = childNode, node = childNode;
          break;
        }
        if (part[j] !== node.part[j]) {
          let existingChild = cloneNode(node, node.part.slice(j)), newChild = createNode(part.slice(j));
          Object.assign(node, createNode(node.part.slice(0, j), [
            existingChild,
            newChild
          ])), node = newChild;
          break;
        }
        ++j;
      }
    }
    if (paramPartsIndex < paramParts.length) {
      let name = paramParts[paramPartsIndex].slice(1);
      if (node.params === null)
        node.params = createParamNode(name);
      else if (node.params.name !== name) {
        if (ignoreError)
          return store;
        throw new Error(`Cannot create route "${path}" with parameter "${name}" because a route already exists with a different parameter name ("${node.params.name}") in the same location`);
      }
      return node.params.store === null && (node.params.store = store), node.params.store;
    }
    return isWildcard ? (node.wildcardStore === null && (node.wildcardStore = store), node.wildcardStore) : (node.store === null && (node.store = store), node.store);
  }
  find(method, url) {
    let root = this.root[method];
    return root ? matchRoute(url, url.length, root, 0) : null;
  }
};
var matchRoute = (url, urlLength, node, startIndex) => {
  let part = node.part, length = part.length, endIndex = startIndex + length;
  if (length > 1) {
    if (endIndex > urlLength)
      return null;
    if (length < 15) {
      for (let i = 1, j = startIndex + 1;i < length; ++i, ++j)
        if (part.charCodeAt(i) !== url.charCodeAt(j))
          return null;
    } else if (url.slice(startIndex, endIndex) !== part)
      return null;
  }
  if (endIndex === urlLength)
    return node.store !== null ? {
      store: node.store,
      params: {}
    } : node.wildcardStore !== null ? {
      store: node.wildcardStore,
      params: { "*": "" }
    } : null;
  if (node.inert !== null) {
    let inert = node.inert[url.charCodeAt(endIndex)];
    if (inert !== undefined) {
      let route = matchRoute(url, urlLength, inert, endIndex);
      if (route !== null)
        return route;
    }
  }
  if (node.params !== null) {
    let { store, name, inert } = node.params, slashIndex = url.indexOf("/", endIndex);
    if (slashIndex !== endIndex) {
      if (slashIndex === -1 || slashIndex >= urlLength) {
        if (store !== null) {
          let params = {};
          return params[name] = url.substring(endIndex, urlLength), {
            store,
            params
          };
        }
      } else if (inert !== null) {
        let route = matchRoute(url, urlLength, inert, slashIndex);
        if (route !== null)
          return route.params[name] = url.substring(endIndex, slashIndex), route;
      }
    }
  }
  return node.wildcardStore !== null ? {
    store: node.wildcardStore,
    params: {
      "*": url.substring(endIndex, urlLength)
    }
  } : null;
};
var fullFormats = {
  date,
  time: getTime(true),
  "date-time": getDateTime(true),
  "iso-time": getTime(false),
  "iso-date-time": getDateTime(false),
  duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
  uri,
  "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
  url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
  regex,
  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
  "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
  "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
  "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
  byte,
  int32: { type: "number", validate: validateInt32 },
  int64: { type: "number", validate: validateInt64 },
  float: { type: "number", validate: validateNumber },
  double: { type: "number", validate: validateNumber },
  password: true,
  binary: true
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var parseDateTimeEmptySpace = (str) => str.charCodeAt(str.length - 6) === 32 ? str.slice(0, -6) + "+" + str.slice(-5) : str;
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  let time = getTime(strictTimeZone);
  return function(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
}
var MIN_INT32 = -(2 ** 31);
var MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
  return Number.isInteger(value);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch {
    return false;
  }
}
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
exports_format.Has("date") || exports_format.Set("date", (value) => {
  let temp = parseDateTimeEmptySpace(value).replace(/"/g, "");
  if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
    let date2 = new Date(temp);
    if (!Number.isNaN(date2.getTime()))
      return true;
  }
  return false;
});
exports_format.Has("date-time") || exports_format.Set("date-time", (value) => {
  let temp = value.replace(/"/g, "");
  if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
    let date2 = new Date(temp);
    if (!Number.isNaN(date2.getTime()))
      return true;
  }
  return false;
});
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  exports_format.Has(formatName) || (formatValue instanceof RegExp ? exports_format.Set(formatName, (value) => formatValue.test(value)) : typeof formatValue == "function" && exports_format.Set(formatName, formatValue));
});
exports_format.Has("numeric") || exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
exports_format.Has("integer") || exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
exports_format.Has("boolean") || exports_format.Set("boolean", (value) => value === "true" || value === "false");
exports_format.Has("ObjectString") || exports_format.Set("ObjectString", (value) => {
  let start = value.charCodeAt(0);
  if ((start === 9 || start === 10 || start === 32) && (start = value.trimStart().charCodeAt(0)), start !== 123 && start !== 91)
    return false;
  try {
    return JSON.parse(value), true;
  } catch {
    return false;
  }
});
exports_format.Has("ArrayString") || exports_format.Set("ArrayString", (value) => {
  let start = value.charCodeAt(0);
  if ((start === 9 || start === 10 || start === 32) && (start = value.trimStart().charCodeAt(0)), start !== 123 && start !== 91)
    return false;
  try {
    return JSON.parse(value), true;
  } catch {
    return false;
  }
});
var isBun = typeof Bun < "u";
var mime2 = {
  aac: "audio/aac",
  abw: "application/x-abiword",
  ai: "application/postscript",
  arc: "application/octet-stream",
  avi: "video/x-msvideo",
  azw: "application/vnd.amazon.ebook",
  bin: "application/octet-stream",
  bz: "application/x-bzip",
  bz2: "application/x-bzip2",
  csh: "application/x-csh",
  css: "text/css",
  csv: "text/csv",
  doc: "application/msword",
  dll: "application/octet-stream",
  eot: "application/vnd.ms-fontobject",
  epub: "application/epub+zip",
  gif: "image/gif",
  htm: "text/html",
  html: "text/html",
  ico: "image/x-icon",
  ics: "text/calendar",
  jar: "application/java-archive",
  jpeg: "image/jpeg",
  jpg: "image/jpeg",
  js: "application/javascript",
  json: "application/json",
  mid: "audio/midi",
  midi: "audio/midi",
  mp2: "audio/mpeg",
  mp3: "audio/mpeg",
  mp4: "video/mp4",
  mpa: "video/mpeg",
  mpe: "video/mpeg",
  mpeg: "video/mpeg",
  mpkg: "application/vnd.apple.installer+xml",
  odp: "application/vnd.oasis.opendocument.presentation",
  ods: "application/vnd.oasis.opendocument.spreadsheet",
  odt: "application/vnd.oasis.opendocument.text",
  oga: "audio/ogg",
  ogv: "video/ogg",
  ogx: "application/ogg",
  otf: "font/otf",
  png: "image/png",
  pdf: "application/pdf",
  ppt: "application/vnd.ms-powerpoint",
  rar: "application/x-rar-compressed",
  rtf: "application/rtf",
  sh: "application/x-sh",
  svg: "image/svg+xml",
  swf: "application/x-shockwave-flash",
  tar: "application/x-tar",
  tif: "image/tiff",
  tiff: "image/tiff",
  ts: "application/typescript",
  ttf: "font/ttf",
  txt: "text/plain",
  vsd: "application/vnd.visio",
  wav: "audio/x-wav",
  weba: "audio/webm",
  webm: "video/webm",
  webp: "image/webp",
  woff: "font/woff",
  woff2: "font/woff2",
  xhtml: "application/xhtml+xml",
  xls: "application/vnd.ms-excel",
  xlsx: "application/vnd.ms-excel",
  xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  xml: "application/xml",
  xul: "application/vnd.mozilla.xul+xml",
  zip: "application/zip",
  "3gp": "video/3gpp",
  "3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp",
  "3gp2": "video/3gpp2",
  "3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2",
  "7z": "application/x-7z-compressed"
};
var getFileExtension = (path) => {
  let index = path.lastIndexOf(".");
  return index === -1 ? "" : path.slice(index + 1);
};
var createReadStream;
var stat;
var ElysiaFile = class {
  constructor(path) {
    this.path = path;
    if (isBun)
      this.value = Bun.file(path);
    else if (typeof window < "u")
      console.warn("Browser environment does not support file");
    else if (!createReadStream || !stat)
      try {
        this.value = import("fs").then((fs) => (createReadStream = fs.createReadStream, fs.createReadStream(path))), this.stats = import("fs/promises").then((fs) => (stat = fs.stat, fs.stat(path)));
      } catch {
      }
    else
      this.value = createReadStream(path), this.stats = stat(path);
  }
  get type() {
    return mime2[getFileExtension(this.path)] || "application/octet-stream";
  }
  get length() {
    return isBun ? this.value.size : this.stats?.then((x) => x.size) ?? 0;
  }
};
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v == "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item == "object" && !Array.isArray(item);
var mergeDeep = (target, source, options) => {
  let skipKeys = options?.skipKeys, override = options?.override ?? true;
  if (!isObject(target) || !isObject(source))
    return target;
  for (let [key, value] of Object.entries(source))
    if (!skipKeys?.includes(key)) {
      if (!isObject(value) || !(key in target) || isClass(value)) {
        (override || !(key in target)) && (target[key] = value);
        continue;
      }
      target[key] = mergeDeep(target[key], value, { skipKeys, override });
    }
  return target;
};
var mergeCookie = (a, b) => {
  let v = mergeDeep(Object.assign({}, a), b, {
    skipKeys: ["properties"]
  });
  return v.properties && delete v.properties, v;
};
var mergeObjectArray = (a, b) => {
  if (!b)
    return a;
  let array = [], checksums = [];
  if (a) {
    Array.isArray(a) || (a = [a]);
    for (let item of a)
      array.push(item), item.checksum && checksums.push(item.checksum);
  }
  if (b) {
    Array.isArray(b) || (b = [b]);
    for (let item of b)
      checksums.includes(item.checksum) || array.push(item);
  }
  return array;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "mapResponse",
  "afterResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a, b) => {
  let isRecordNumber = (x) => typeof x == "object" && Object.keys(x).every(isNumericString);
  return isRecordNumber(a) && isRecordNumber(b) ? Object.assign(a, b) : a && !isRecordNumber(a) && isRecordNumber(b) ? Object.assign({ 200: a }, b) : b ?? a;
};
var mergeSchemaValidator = (a, b) => !a && !b ? {
  body: undefined,
  headers: undefined,
  params: undefined,
  query: undefined,
  cookie: undefined,
  response: undefined
} : {
  body: b?.body ?? a?.body,
  headers: b?.headers ?? a?.headers,
  params: b?.params ?? a?.params,
  query: b?.query ?? a?.query,
  cookie: b?.cookie ?? a?.cookie,
  response: mergeResponse(a?.response, b?.response)
};
var mergeHook = (a, b) => {
  if (!Object.values(b).find((x) => x != null))
    return { ...a };
  let hook = {
    ...a,
    ...b,
    body: b?.body ?? a?.body,
    headers: b?.headers ?? a?.headers,
    params: b?.params ?? a?.params,
    query: b?.query ?? a?.query,
    cookie: b?.cookie ?? a?.cookie,
    response: mergeResponse(a?.response, b?.response),
    type: a?.type || b?.type,
    detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}),
    parse: mergeObjectArray(a?.parse, b?.parse),
    transform: mergeObjectArray(a?.transform, b?.transform),
    beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a?.resolve, "resolve"), a?.beforeHandle), mergeObjectArray(fnToContainer(b.resolve, "resolve"), b?.beforeHandle)),
    afterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),
    mapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse),
    afterResponse: mergeObjectArray(a?.afterResponse, b?.afterResponse),
    trace: mergeObjectArray(a?.trace, b?.trace),
    error: mergeObjectArray(a?.error, b?.error)
  };
  return hook.resolve && delete hook.resolve, hook;
};
var lifeCycleToArray = (a) => {
  a.parse && !Array.isArray(a.parse) && (a.parse = [a.parse]), a.transform && !Array.isArray(a.transform) && (a.transform = [a.transform]), a.afterHandle && !Array.isArray(a.afterHandle) && (a.afterHandle = [a.afterHandle]), a.mapResponse && !Array.isArray(a.mapResponse) && (a.mapResponse = [a.mapResponse]), a.afterResponse && !Array.isArray(a.afterResponse) && (a.afterResponse = [a.afterResponse]), a.trace && !Array.isArray(a.trace) && (a.trace = [a.trace]), a.error && !Array.isArray(a.error) && (a.error = [a.error]);
  let beforeHandle = [];
  return a.resolve && (beforeHandle = fnToContainer(Array.isArray(a.resolve) ? a.resolve : [a.resolve], "resolve"), delete a.resolve), a.beforeHandle && (beforeHandle.length ? beforeHandle = beforeHandle.concat(Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle]) : beforeHandle = Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle]), beforeHandle.length && (a.beforeHandle = beforeHandle), a;
};
var isBun2 = typeof Bun < "u";
var hasBunHash = isBun2 && typeof Bun.hash == "function";
var checksum = (s) => {
  if (hasBunHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
  return h = h ^ h >>> 9;
};
var injectChecksum = (checksum2, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    let fn = x;
    return checksum2 && !fn.checksum && (fn.checksum = checksum2), fn.scope === "scoped" && (fn.scope = "local"), fn;
  }
  let fns = [...x];
  for (let fn of fns)
    checksum2 && !fn.checksum && (fn.checksum = checksum2), fn.scope === "scoped" && (fn.scope = "local");
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => ({
  start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)),
  request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)),
  parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)),
  transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)),
  beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum2, mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))),
  afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)),
  mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)),
  afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)),
  trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)),
  error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)),
  stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop))
});
var asHookType = (fn, inject, { skipIfHasType = false }) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    return skipIfHasType ? fn.scope ??= inject : fn.scope = inject, fn;
  for (let x of fn)
    skipIfHasType ? x.scope ??= inject : x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array = [];
  for (let x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array.push({
          ...x
        });
        break;
    }
  return array;
};
var filterGlobalHook = (hook) => ({
  ...hook,
  type: hook?.type,
  detail: hook?.detail,
  parse: filterGlobal(hook?.parse),
  transform: filterGlobal(hook?.transform),
  beforeHandle: filterGlobal(hook?.beforeHandle),
  afterHandle: filterGlobal(hook?.afterHandle),
  mapResponse: filterGlobal(hook?.mapResponse),
  afterResponse: filterGlobal(hook?.afterResponse),
  error: filterGlobal(hook?.error),
  trace: filterGlobal(hook?.trace)
});
var StatusMap = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k, v]) => [v, k]));
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  for (;trimmedDigest.endsWith("="); )
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret) === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, manage) => {
  if (!(!extension || typeof extension != "object" || !property))
    for (let [key, value] of Object.entries(property)) {
      if (primitiveHookMap[key] || !(key in extension))
        continue;
      let v = extension[key];
      if (typeof v == "function") {
        let hook = v(value);
        if (typeof hook == "object")
          for (let [k, v2] of Object.entries(hook))
            manage(k)({
              fn: v2
            });
      }
      delete property[key];
    }
};
var createMacroManager = ({
  globalHook,
  localHook
}) => (stackName) => (type, fn) => {
  if (typeof type == "function" && (type = {
    fn: type
  }), stackName === "resolve" && (type = {
    ...type,
    subType: "resolve"
  }), localHook[stackName] || (localHook[stackName] = []), typeof localHook[stackName] == "function" && (localHook[stackName] = [localHook[stackName]]), Array.isArray(localHook[stackName]) || (localHook[stackName] = [localHook[stackName]]), "fn" in type || Array.isArray(type)) {
    Array.isArray(type) ? localHook[stackName] = localHook[stackName].concat(type) : localHook[stackName].push(type);
    return;
  }
  let { insert = "after", stack = "local" } = type;
  typeof fn == "function" && (fn = { fn }), stack === "global" ? Array.isArray(fn) ? insert === "before" ? globalHook[stackName] = fn.concat(globalHook[stackName]) : globalHook[stackName] = globalHook[stackName].concat(fn) : insert === "before" ? globalHook[stackName].unshift(fn) : globalHook[stackName].push(fn) : Array.isArray(fn) ? insert === "before" ? localHook[stackName] = fn.concat(localHook[stackName]) : localHook[stackName] = localHook[stackName].concat(fn) : insert === "before" ? localHook[stackName].unshift(fn) : localHook[stackName].push(fn);
};
var parseNumericString = (message) => {
  if (typeof message == "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    return Number.isNaN(length) ? null : length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number = Number(message);
    return Number.isNaN(number) || number.toString() !== message ? null : number;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;
var PromiseGroup = class {
  constructor(onError = console.error, onFinally = () => {
  }) {
    this.onError = onError;
    this.onFinally = onFinally;
    this.root = null;
    this.promises = [];
  }
  get size() {
    return this.promises.length;
  }
  add(promise) {
    return this.promises.push(promise), this.root ||= this.drain(), this.promises.length === 1 && this.then(this.onFinally), promise;
  }
  async drain() {
    for (;this.promises.length > 0; ) {
      try {
        await this.promises[0];
      } catch (error2) {
        this.onError(error2);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
};
var fnToContainer = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn == "function" || typeof fn == "string")
      return subType ? { fn, subType } : { fn };
    if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x of fn)
    typeof x == "function" || typeof x == "string" ? fns.push(subType ? { fn: x, subType } : { fn: x }) : ("fn" in x) && fns.push(x);
  return fns;
};
var localHookToLifeCycleStore = (a) => (a.start && (a.start = fnToContainer(a.start)), a.request && (a.request = fnToContainer(a.request)), a.parse && (a.parse = fnToContainer(a.parse)), a.transform && (a.transform = fnToContainer(a.transform)), a.beforeHandle && (a.beforeHandle = fnToContainer(a.beforeHandle)), a.afterHandle && (a.afterHandle = fnToContainer(a.afterHandle)), a.mapResponse && (a.mapResponse = fnToContainer(a.mapResponse)), a.afterResponse && (a.afterResponse = fnToContainer(a.afterResponse)), a.trace && (a.trace = fnToContainer(a.trace)), a.error && (a.error = fnToContainer(a.error)), a.stop && (a.stop = fnToContainer(a.stop)), a);
var lifeCycleToFn = (a) => {
  let lifecycle = /* @__PURE__ */ Object.create(null);
  return a.start?.map && (lifecycle.start = a.start.map((x) => x.fn)), a.request?.map && (lifecycle.request = a.request.map((x) => x.fn)), a.parse?.map && (lifecycle.parse = a.parse.map((x) => x.fn)), a.transform?.map && (lifecycle.transform = a.transform.map((x) => x.fn)), a.beforeHandle?.map && (lifecycle.beforeHandle = a.beforeHandle.map((x) => x.fn)), a.afterHandle?.map && (lifecycle.afterHandle = a.afterHandle.map((x) => x.fn)), a.mapResponse?.map && (lifecycle.mapResponse = a.mapResponse.map((x) => x.fn)), a.afterResponse?.map && (lifecycle.afterResponse = a.afterResponse.map((x) => x.fn)), a.error?.map && (lifecycle.error = a.error.map((x) => x.fn)), a.stop?.map && (lifecycle.stop = a.stop.map((x) => x.fn)), a.trace?.map ? lifecycle.trace = a.trace.map((x) => x.fn) : lifecycle.trace = [], lifecycle;
};
var cloneInference = (inference) => ({
  body: inference.body,
  cookie: inference.cookie,
  headers: inference.headers,
  query: inference.query,
  set: inference.set,
  server: inference.server,
  path: inference.path,
  route: inference.route,
  url: inference.url
});
var redirect = (url, status2 = 302) => Response.redirect(url, status2);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
  let formData = new FormData;
  if (formData[ELYSIA_FORM_DATA] = {}, items)
    for (let [key, value] of Object.entries(items)) {
      if (Array.isArray(value)) {
        formData[ELYSIA_FORM_DATA][key] = [];
        for (let v of value)
          value instanceof File ? formData.append(key, value, value.name) : value instanceof ElysiaFile ? formData.append(key, value.value, value.value?.name) : formData.append(key, value), formData[ELYSIA_FORM_DATA][key].push(value);
        continue;
      }
      value instanceof File ? formData.append(key, value, value.name) : value instanceof ElysiaFile ? formData.append(key, value.value, value.value?.name) : formData.append(key, value), formData[ELYSIA_FORM_DATA][key] = value;
    }
  return formData;
};
var randomId = () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum = (array) => {
  if (!array.length)
    return [];
  let hashes = [];
  for (let i = 0;i < array.length; i++) {
    let item = array[i];
    item.checksum && (hashes.includes(item.checksum) && (array.splice(i, 1), i--), hashes.push(item.checksum));
  }
  return array;
};
var promoteEvent = (events, as = "scoped") => {
  if (events) {
    if (as === "scoped") {
      for (let event of events)
        "scope" in event && event.scope === "local" && (event.scope = "scoped");
      return;
    }
    for (let event of events)
      "scope" in event && (event.scope = "global");
  }
};
var getLoosePath = (path) => path.charCodeAt(path.length - 1) === 47 ? path.slice(0, path.length - 1) : path + "/";
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let _ in obj)
    return true;
  return false;
};
var encodePath = (path, { dynamic = false } = {}) => {
  let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
  return dynamic && (encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?")), encoded;
};
var supportPerMethodInlineHandler = (() => {
  if (typeof Bun > "u")
    return true;
  let semver = Bun.version.split(".");
  return !(+semver[0] < 1 || +semver[1] < 2 || +semver[2] < 14);
})();
var env = typeof Bun < "u" ? Bun.env : typeof process < "u" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var emptyHttpStatus = {
  101: undefined,
  204: undefined,
  205: undefined,
  304: undefined,
  307: undefined,
  308: undefined
};
var ElysiaCustomStatusResponse = class {
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    this.code = StatusMap[code] ?? code, code in emptyHttpStatus ? this.response = undefined : this.response = res;
  }
};
var status = (code, response) => new ElysiaCustomStatusResponse(code, response);
var NotFoundError = class extends Error {
  constructor(message) {
    super(message ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
};
var ParseError2 = class extends Error {
  constructor(cause) {
    super("Bad Request", {
      cause
    });
    this.code = "PARSE";
    this.status = 400;
  }
};
var InvalidCookieSignature = class extends Error {
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
};
var mapValueError = (error2) => {
  if (!error2)
    return {
      summary: undefined
    };
  let { message, path, value, type } = error2, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type) {
    case 42:
      return {
        ...error2,
        summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided`
      };
    case 45:
      return {
        ...error2,
        summary: isRoot ? "Value is missing" : `Property '${property}' is missing`
      };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return {
        ...error2,
        summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}`
      };
    case 54:
      return {
        ...error2,
        summary: `${message.slice(0, 9).trim()} property '${property}' to be ${message.slice(8).trim()} but found: ${value}`
      };
    case 62:
      let union = error2.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return {
        ...error2,
        summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}`
      };
    default:
      return { summary: message, ...error2 };
  }
};
var InvalidFileType = class _InvalidFileType extends Error {
  constructor(property, expected, message = `"${property}" has invalid file type`) {
    super(message);
    this.property = property;
    this.expected = expected;
    this.message = message;
    this.code = "INVALID_FILE_TYPE";
    this.status = 422;
    Object.setPrototypeOf(this, _InvalidFileType.prototype);
  }
  toResponse(headers) {
    return isProduction ? new Response(JSON.stringify({
      type: "validation",
      on: "body"
    }), {
      status: 422,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    }) : new Response(JSON.stringify({
      type: "validation",
      on: "body",
      summary: "Invalid file type",
      message: this.message,
      property: this.property,
      expected: this.expected
    }), {
      status: 422,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    });
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(type, validator, value, errors) {
    value && typeof value == "object" && value instanceof ElysiaCustomStatusResponse && (value = value.response);
    let error2 = errors?.First() || (isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : exports_value2.Errors(validator, value).First()), customError = error2?.schema?.message || error2?.schema?.error !== undefined ? typeof error2.schema.error == "function" ? error2.schema.error({
      type,
      validator,
      value,
      get errors() {
        return [...validator.Errors(value)].map(mapValueError);
      }
    }) : error2.schema.error : undefined, accessor = error2?.path || "root", message = "";
    if (customError !== undefined)
      message = typeof customError == "object" ? JSON.stringify(customError) : customError + "";
    else if (isProduction)
      message = JSON.stringify({
        type: "validation",
        on: type,
        summary: mapValueError(error2).summary,
        message: error2?.message,
        found: value
      });
    else {
      let schema = validator?.schema ?? validator, errors2 = "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...exports_value2.Errors(validator, value)].map(mapValueError), expected;
      try {
        expected = exports_value2.Create(schema);
      } catch (error3) {
        expected = {
          type: "Could not create expected value",
          message: error3?.message,
          error: error3
        };
      }
      message = JSON.stringify({
        type: "validation",
        on: type,
        summary: mapValueError(error2).summary,
        property: accessor,
        message: error2?.message,
        expected,
        found: value,
        errors: errors2
      }, null, 2);
    }
    super(message);
    this.type = type;
    this.validator = validator;
    this.value = value;
    this.code = "VALIDATION";
    this.status = 422;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return _ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    });
  }
};
var tryParse = (v, schema) => {
  try {
    return JSON.parse(v);
  } catch {
    throw new ValidationError("property", schema, v);
  }
};
function createType(kind, func) {
  return exports_type2.Has(kind) || exports_type2.Set(kind, func), (options = {}) => Unsafe({ ...options, [Kind]: kind });
}
var compile = (schema) => {
  try {
    let compiler = TypeCompiler.Compile(schema);
    return compiler.Create = () => exports_value2.Create(schema), compiler.Error = (v) => new ValidationError("property", schema, v, compiler.Errors(v)), compiler;
  } catch {
    return {
      Check: (v) => exports_value2.Check(schema, v),
      CheckThrow: (v) => {
        if (!exports_value2.Check(schema, v))
          throw new ValidationError("property", schema, v, exports_value2.Errors(schema, v));
      },
      Decode: (v) => exports_value2.Decode(schema, v),
      Create: () => exports_value2.Create(schema),
      Error: (v) => new ValidationError("property", schema, v, exports_value2.Errors(schema, v))
    };
  }
};
var parseFileUnit = (size) => {
  if (typeof size == "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var checkFileExtension = (type, extension) => type.startsWith(extension) ? true : extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type.startsWith(extension.slice(0, -1));
var _fileTypeFromBlobWarn = false;
var warnIfFileTypeIsNotInstalled = () => {
  _fileTypeFromBlobWarn || (console.warn("[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension."), _fileTypeFromBlobWarn = true);
};
var loadFileType = async () => Promise.resolve().then(() => (init_file_type(), exports_file_type)).then((x) => (_fileTypeFromBlob = x.fileTypeFromBlob, _fileTypeFromBlob)).catch(warnIfFileTypeIsNotInstalled);
var _fileTypeFromBlob;
var fileTypeFromBlob2 = (file2) => _fileTypeFromBlob ? _fileTypeFromBlob(file2) : loadFileType().then((mod) => {
  if (mod)
    return mod(file2);
});
var validateFileExtension = async (file2, extension, name = file2?.name ?? "") => {
  if (Array.isArray(file2))
    return await Promise.all(file2.map((f) => validateFileExtension(f, extension, name))), true;
  if (!file2)
    return false;
  let result = await fileTypeFromBlob2(file2);
  if (!result)
    throw new InvalidFileType(name, extension);
  if (typeof extension == "string" && !checkFileExtension(result.mime, extension))
    throw new InvalidFileType(name, extension);
  for (let i = 0;i < extension.length; i++)
    if (checkFileExtension(result.mime, extension[i]))
      return true;
  throw new InvalidFileType(name, extension);
};
var validateFile = (options, value) => {
  if (value instanceof ElysiaFile)
    return true;
  if (!(value instanceof Blob) || options.minSize && value.size < parseFileUnit(options.minSize) || options.maxSize && value.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension) {
    if (typeof options.extension == "string")
      return checkFileExtension(value.type, options.extension);
    for (let i = 0;i < options.extension.length; i++)
      if (checkFileExtension(value.type, options.extension[i]))
        return true;
    return false;
  }
  return true;
};
var t = Object.assign({}, Type);
createType("UnionEnum", (schema, value) => (typeof value == "number" || typeof value == "string" || value === null) && schema.enum.includes(value));
var internalFiles = createType("Files", (options, value) => {
  if (!Array.isArray(value))
    return validateFile(options, value);
  if (options.minItems && value.length < options.minItems || options.maxItems && value.length > options.maxItems)
    return false;
  for (let i = 0;i < value.length; i++)
    if (!validateFile(options, value[i]))
      return false;
  return true;
});
var internalFormData = createType("ElysiaForm", ({ compiler, ...schema }, value) => {
  if (!(value instanceof FormData))
    return false;
  if (compiler) {
    if (!(ELYSIA_FORM_DATA in value))
      throw new ValidationError("property", schema, value);
    if (!compiler.Check(value[ELYSIA_FORM_DATA]))
      throw compiler.Error(value[ELYSIA_FORM_DATA]);
  }
  return true;
});
var ElysiaType = {
  String: (property) => Type.String(property),
  Numeric: (property) => {
    let schema = Type.Number(property), compiler = compile(schema);
    return t.Transform(t.Union([
      t.String({
        format: "numeric",
        default: 0
      }),
      t.Number(property)
    ], property)).Decode((value) => {
      let number = +value;
      if (isNaN(number))
        return value;
      if (property && !compiler.Check(number))
        throw compiler.Error(value);
      return number;
    }).Encode((value) => value);
  },
  Integer: (property) => {
    let schema = Type.Integer(property), compiler = compile(schema);
    return t.Transform(t.Union([
      t.String({
        format: "integer",
        default: 0
      }),
      Type.Integer(property)
    ], property)).Decode((value) => {
      let number = +value;
      if (!compiler.Check(number))
        throw compiler.Error(number);
      return number;
    }).Encode((value) => value);
  },
  Date: (property) => {
    let schema = Type.Date(property), compiler = compile(schema), _default = property?.default ? new Date(property.default) : undefined;
    return t.Transform(t.Union([
      Type.Date(property),
      t.String({
        format: "date-time",
        default: _default?.toISOString()
      }),
      t.String({
        format: "date",
        default: _default?.toISOString()
      }),
      t.Number({ default: _default?.getTime() })
    ], property)).Decode((value) => {
      if (typeof value == "number") {
        let date3 = new Date(value);
        if (!compiler.Check(date3))
          throw compiler.Error(date3);
        return date3;
      }
      if (value instanceof Date)
        return value;
      let date2 = new Date(parseDateTimeEmptySpace(value));
      if (!date2 || isNaN(date2.getTime()))
        throw new ValidationError("property", schema, date2);
      if (!compiler.Check(date2))
        throw compiler.Error(date2);
      return date2;
    }).Encode((value) => value.toISOString());
  },
  BooleanString: (property) => {
    let schema = Type.Boolean(property), compiler = compile(schema);
    return t.Transform(t.Union([
      t.Boolean(property),
      t.String({
        format: "boolean",
        default: false
      })
    ], property)).Decode((value) => {
      if (typeof value == "string")
        return value === "true";
      if (value !== undefined && !compiler.Check(value))
        throw compiler.Error(value);
      return value;
    }).Encode((value) => value);
  },
  ObjectString: (properties, options) => {
    let schema = t.Object(properties, options), compiler = compile(schema), defaultValue = JSON.stringify(compiler.Create());
    return t.Transform(t.Union([
      t.String({
        format: "ObjectString",
        default: defaultValue
      }),
      schema
    ])).Decode((value) => {
      if (typeof value == "string") {
        if (value.charCodeAt(0) !== 123)
          throw new ValidationError("property", schema, value);
        if (!compiler.Check(value = tryParse(value, schema)))
          throw compiler.Error(value);
        return compiler.Decode(value);
      }
      return value;
    }).Encode((value) => {
      let original;
      if (typeof value == "string" && (value = tryParse(original = value, schema)), !compiler.Check(value))
        throw compiler.Error(value);
      return original ?? JSON.stringify(value);
    });
  },
  ArrayString: (children = t.String(), options) => {
    let schema = t.Array(children, options), compiler = compile(schema), decode4 = (value, isProperty = false) => {
      if (value.charCodeAt(0) === 91) {
        if (!compiler.Check(value = tryParse(value, schema)))
          throw compiler.Error(value);
        return compiler.Decode(value);
      }
      if (value.indexOf(",") !== -1) {
        if (!compiler.Check(value))
          throw compiler.Error(value);
        return compiler.Decode(value);
      }
      if (isProperty)
        return value;
      throw new ValidationError("property", schema, value);
    };
    return t.Transform(t.Union([
      t.String({
        format: "ArrayString",
        default: options?.default
      }),
      schema
    ])).Decode((value) => {
      if (Array.isArray(value)) {
        let values = [];
        for (let i = 0;i < value.length; i++) {
          let v = value[i];
          if (typeof v == "string") {
            let t2 = decode4(v, true);
            Array.isArray(t2) ? values = values.concat(t2) : values.push(t2);
            continue;
          }
          values.push(v);
        }
        return values;
      }
      return typeof value == "string" ? decode4(value) : value;
    }).Encode((value) => {
      let original;
      if (typeof value == "string" && (value = tryParse(original = value, schema)), !compiler.Check(value))
        throw new ValidationError("property", schema, value);
      return original ?? JSON.stringify(value);
    });
  },
  File: createType("File", validateFile),
  Files: (options = {}) => t.Transform(internalFiles(options)).Decode((value) => Array.isArray(value) ? value : [value]).Encode((value) => value),
  Nullable: (schema, options) => t.Union([schema, t.Null()], options),
  MaybeEmpty: (schema, options) => t.Union([schema, t.Null(), t.Undefined()], options),
  Cookie: (properties, {
    domain,
    expires,
    httpOnly,
    maxAge,
    path,
    priority,
    sameSite,
    secure,
    secrets,
    sign,
    ...options
  } = {}) => {
    let v = t.Object(properties, options);
    return v.config = {
      domain,
      expires,
      httpOnly,
      maxAge,
      path,
      priority,
      sameSite,
      secure,
      secrets,
      sign
    }, v;
  },
  UnionEnum: (values, options = {}) => {
    let type = values.every((value) => typeof value == "string") ? { type: "string" } : values.every((value) => typeof value == "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
    if (values.some((x) => typeof x == "object" && x !== null))
      throw new Error("This type does not support objects or arrays");
    return {
      default: values[0],
      ...options,
      [Kind]: "UnionEnum",
      ...type,
      enum: values
    };
  },
  NoValidate: (v, enabled = true) => (v.noValidate = enabled, v),
  Form: (v, options = {}) => {
    let schema = t.Object(v, {
      default: form({}),
      ...options
    }), compiler = compile(schema);
    return t.Union([
      schema,
      internalFormData({
        compiler
      })
    ]);
  }
};
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg) => (arg?.type && loadFileType(), ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
}));
t.Files = (arg) => (arg?.type && loadFileType(), ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
}));
t.Nullable = (schema) => ElysiaType.Nullable(schema);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
t.NoValidate = ElysiaType.NoValidate;
t.Form = ElysiaType.Form;
var separateFunction = (code) => {
  code.startsWith("async") && (code = code.slice(5)), code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40 && (index = code.indexOf("=>", code.indexOf(")")), index !== -1)) {
    let bracketEndIndex = index;
    for (;bracketEndIndex > 0 && code.charCodeAt(--bracketEndIndex) !== 41; )
      ;
    let body = code.slice(index + 2);
    return body.charCodeAt(0) === 32 && (body = body.trimStart()), [
      code.slice(1, bracketEndIndex),
      body,
      {
        isArrowReturn: body.charCodeAt(0) !== 123
      }
    ];
  }
  if (/^(\w+)=>/g.test(code) && (index = code.indexOf("=>"), index !== -1)) {
    let body = code.slice(index + 2);
    return body.charCodeAt(0) === 32 && (body = body.trimStart()), [
      code.slice(0, index),
      body,
      {
        isArrowReturn: body.charCodeAt(0) !== 123
      }
    ];
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [
      code.slice(index + 1, end),
      code.slice(end + 2),
      {
        isArrowReturn: false
      }
    ];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [
      parameter.slice(start, end),
      "{" + body,
      {
        isArrowReturn: false
      }
    ];
  }
  let x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123 ? deep++ : char === 125 && deep--, deep === 0)
      break;
  }
  return deep !== 0 ? [0, parameter.length] : [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125 ? deep++ : char === 123 && deep--, deep === 0)
      break;
  }
  return deep !== 0 ? [-1, 0] : [start, end + 1];
};
var removeColonAlias = (parameter) => {
  for (;; ) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    end === -1 && (end = parameter.indexOf("}", start) - 1), end === -2 && (end = parameter.length), parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  parameter.charCodeAt(0) === 40 && (parameter = parameter.slice(1, -1)), parameter.charCodeAt(0) === 123 && (hasParenthesis = true, parameter = parameter.slice(1, -1)), parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  for (;; ) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44 && end++, parameter = parameter.slice(end);
  }
  parameter = removeColonAlias(parameter), parameter && (parameters = parameters.concat(parameter.split(",")));
  let parameterMap = /* @__PURE__ */ Object.create(null);
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      parameterMap[p] = true;
      continue;
    }
    for (let q of p.split(","))
      parameterMap[q.trim()] = true;
  }
  return {
    hasParenthesis,
    parameters: parameterMap
  };
};
var findParameterReference = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  return parameters.query && (inference.query = true), parameters.headers && (inference.headers = true), parameters.body && (inference.body = true), parameters.cookie && (inference.cookie = true), parameters.set && (inference.set = true), parameters.server && (inference.server = true), parameters.route && (inference.route = true), parameters.url && (inference.url = true), parameters.path && (inference.path = true), hasParenthesis ? `{ ${Object.keys(parameters).join(", ")} }` : Object.keys(parameters).join(", ");
};
var findEndIndex = (type, content, index) => {
  let regex2 = new RegExp(`${type.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\n\\t,; ]`);
  index !== undefined && (regex2.lastIndex = index);
  let match = regex2.exec(content);
  return match ? match.index : -1;
};
var findAlias = (type, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  for (;; ) {
    let index = findEndIndex(" = " + type, content);
    if (index === -1 && (index = findEndIndex("=" + type, content)), index === -1) {
      let lastIndex = content.indexOf(" = " + type);
      if (lastIndex === -1 && (lastIndex = content.indexOf("=" + type)), lastIndex + 3 + type.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end))), content = content.slice(index + 3 + type.length);
      continue;
    }
    for (;variable.charCodeAt(0) === 44; )
      variable = variable.slice(1);
    for (;variable.charCodeAt(0) === 9; )
      variable = variable.slice(1);
    variable.includes("(") || aliases.push(variable), content = content.slice(index + 3 + type.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    deepAlias.length > 0 && aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(","))
    return parameter.indexOf("...") !== -1 ? parameter.slice(parameter.indexOf("...") + 3) : undefined;
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex !== -1)
    return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type, alias) => new RegExp(`${alias}\\.(${type})|${alias}\\["${type}"\\]|${alias}\\['${type}'\\]`).test(code);
  for (let alias of aliases)
    if (alias) {
      if (alias.charCodeAt(0) === 123) {
        let parameters = retrieveRootParamters(alias).parameters;
        parameters.query && (inference.query = true), parameters.headers && (inference.headers = true), parameters.body && (inference.body = true), parameters.cookie && (inference.cookie = true), parameters.set && (inference.set = true), parameters.server && (inference.server = true), parameters.url && (inference.url = true), parameters.route && (inference.route = true), parameters.path && (inference.path = true);
        continue;
      }
      if (!inference.query && (access("query", alias) || code.includes("return " + alias) || code.includes("return " + alias + ".query")) && (inference.query = true), !inference.headers && access("headers", alias) && (inference.headers = true), !inference.body && access("body", alias) && (inference.body = true), !inference.cookie && access("cookie", alias) && (inference.cookie = true), !inference.set && access("set", alias) && (inference.set = true), !inference.server && access("server", alias) && (inference.server = true), !inference.route && access("route", alias) && (inference.route = true), !inference.url && access("url", alias) && (inference.url = true), !inference.path && access("path", alias) && (inference.path = true), inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.route && inference.url && inference.path)
        break;
    }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`\\w\\((.*?)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    return nextChar === 41 || nextChar === 44 ? (inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.url = true, inference.route = true, inference.path = true, true) : false;
  } catch {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var pendingGC;
var caches = {};
var clearSucroseCache = (delay = 0) => {
  pendingGC && clearTimeout(pendingGC), pendingGC = setTimeout(() => {
    caches = {}, pendingGC = undefined, isBun && Bun.gc(false);
  }, delay);
};
var mergeInference = (a, b) => ({
  body: a.body || b.body,
  cookie: a.cookie || b.cookie,
  headers: a.headers || b.headers,
  query: a.query || b.query,
  set: a.set || b.set,
  server: a.server || b.server,
  url: a.url || b.url,
  route: a.route || b.route,
  path: a.path || b.path
});
var sucrose = (lifeCycle, inference = {
  query: false,
  headers: false,
  body: false,
  cookie: false,
  set: false,
  server: false,
  url: false,
  route: false,
  path: false
}) => {
  let events = [];
  lifeCycle.request?.length && events.push(...lifeCycle.request), lifeCycle.beforeHandle?.length && events.push(...lifeCycle.beforeHandle), lifeCycle.parse?.length && events.push(...lifeCycle.parse), lifeCycle.error?.length && events.push(...lifeCycle.error), lifeCycle.transform?.length && events.push(...lifeCycle.transform), lifeCycle.afterHandle?.length && events.push(...lifeCycle.afterHandle), lifeCycle.mapResponse?.length && events.push(...lifeCycle.mapResponse), lifeCycle.afterResponse?.length && events.push(...lifeCycle.afterResponse), lifeCycle.handler && typeof lifeCycle.handler == "function" && events.push(lifeCycle.handler);
  for (let i = 0;i < events.length; i++) {
    let e = events[i];
    if (!e)
      continue;
    let event = typeof e == "object" ? e.fn : e;
    if (typeof event != "function")
      continue;
    let content = event.toString(), key = checksum(content), cachedInference = caches[key];
    if (cachedInference) {
      inference = mergeInference(inference, cachedInference);
      continue;
    }
    let fnInference = {
      query: false,
      headers: false,
      body: false,
      cookie: false,
      set: false,
      server: false,
      url: false,
      route: false,
      path: false
    }, [parameter, body] = separateFunction(content), rootParameters = findParameterReference(parameter, fnInference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body.slice(1, -1));
      aliases.splice(0, -1, mainParameter);
      let code = body;
      code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125 && (code = code.slice(1, -1)), isContextPassToFunction(mainParameter, code, fnInference) || inferBodyReference(code, aliases, fnInference), !fnInference.query && code.includes("return " + mainParameter + ".query") && (fnInference.query = true);
    }
    if (caches[key] || (caches[key] = fnInference), inference = mergeInference(inference, fnInference), inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.url && inference.route && inference.path)
      break;
  }
  return inference;
};
var Cookie = class {
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    this.name in this.jar || (this.jar[this.name] = this.initial), this.jar[this.name] = jar;
  }
  get setCookie() {
    return this.name in this.jar || (this.jar[this.name] = this.initial), this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    this.setCookie.value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config) {
    return this.setCookie = Object.assign(this.cookie, typeof config == "function" ? config(this.cookie) : config), this;
  }
  set(config) {
    return this.setCookie = Object.assign({
      ...this.initial,
      value: this.value
    }, typeof config == "function" ? config(this.cookie) : config), this;
  }
  remove() {
    if (this.value !== undefined)
      return this.set({
        expires: /* @__PURE__ */ new Date(0),
        maxAge: 0,
        value: ""
      }), this;
  }
  toString() {
    return typeof this.value == "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
};
var createCookieJar = (set2, store, initial) => (set2.cookie || (set2.cookie = {}), new Proxy(store, {
  get(_, key) {
    return key in store ? new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key])) : new Cookie(key, set2.cookie, Object.assign({}, initial));
  }
}));
var parseCookie = async (set2, cookieString, {
  secrets,
  sign,
  ...initial
} = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  let isStringKey = typeof secrets == "string";
  sign && sign !== true && !Array.isArray(sign) && (sign = [sign]);
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    if (v === undefined)
      continue;
    let value = import_fast_decode_uri_component.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          let temp = await unsignCookie(value, secrets[i]);
          if (temp !== false) {
            decoded = true, value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = {
      value
    };
  }
  return createCookieJar(set2, jar, initial);
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set2 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value = property.value;
    value != null && set2.push(import_cookie.serialize(key, typeof value == "object" ? JSON.stringify(value) : value + "", property));
  }
  if (set2.length !== 0)
    return set2.length === 1 ? set2[0] : set2;
};
var handleFile = (response, set2) => {
  if (!isBun && response instanceof Promise)
    return response.then((res) => handleFile(res, set2));
  let size = response.size, immutable = set2 && (set2.status === 206 || set2.status === 304 || set2.status === 412 || set2.status === 416), defaultHeader = immutable ? {
    "transfer-encoding": "chunked"
  } : {
    "accept-ranges": "bytes",
    "content-range": size ? `bytes 0-${size - 1}/${size}` : undefined,
    "transfer-encoding": "chunked"
  };
  if (!set2 && !size)
    return new Response(response);
  if (!set2)
    return new Response(response, {
      headers: defaultHeader
    });
  if (set2.headers instanceof Headers) {
    let setHeaders = defaultHeader;
    if (hasHeaderShorthand)
      setHeaders = set2.headers.toJSON();
    else {
      setHeaders = {};
      for (let [key, value] of set2.headers.entries())
        key in set2.headers && (setHeaders[key] = value);
    }
    return immutable && (delete set2.headers["content-length"], delete set2.headers["accept-ranges"]), new Response(response, {
      status: set2.status,
      headers: setHeaders
    });
  }
  return isNotEmpty(set2.headers) ? new Response(response, {
    status: set2.status,
    headers: Object.assign(defaultHeader, set2.headers)
  }) : new Response(response, {
    status: set2.status,
    headers: defaultHeader
  });
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    let index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var responseToSetHeaders = (response, set2) => {
  if (set2?.headers) {
    if (response)
      if (hasHeaderShorthand)
        Object.assign(set2.headers, response.headers.toJSON());
      else
        for (let [key, value] of response.headers.entries())
          key in set2.headers && (set2.headers[key] = value);
    return set2.status === 200 && (set2.status = response.status), set2.headers["content-encoding"] && delete set2.headers["content-encoding"], set2;
  }
  if (!response)
    return {
      headers: {},
      status: set2?.status ?? 200
    };
  if (hasHeaderShorthand)
    return set2 = {
      headers: response.headers.toJSON(),
      status: set2?.status ?? 200
    }, set2.headers["content-encoding"] && delete set2.headers["content-encoding"], set2;
  set2 = {
    headers: {},
    status: set2?.status ?? 200
  };
  for (let [key, value] of response.headers.entries())
    key !== "content-encoding" && key in set2.headers && (set2.headers[key] = value);
  return set2;
};
var createStreamHandler = ({ mapResponse: mapResponse3, mapCompactResponse: mapCompactResponse3 }) => async (generator, set2, request) => {
  let init = generator.next();
  if (init instanceof Promise && (init = await init), typeof init?.done > "u" || init?.done)
    return set2 ? mapResponse3(init.value, set2, request) : mapCompactResponse3(init.value, request);
  let contentType = init.value && typeof init.value?.stream ? "text/event-stream" : init.value && typeof init.value == "object" ? "application/json" : "text/plain";
  return set2?.headers ? (set2.headers["transfer-encoding"] || (set2.headers["transfer-encoding"] = "chunked"), set2.headers["content-type"] || (set2.headers["content-type"] = contentType), set2.headers["cache-control"] || (set2.headers["cache-control"] = "no-cache")) : set2 = {
    status: 200,
    headers: {
      "content-type": contentType,
      "transfer-encoding": "chunked",
      "cache-control": "no-cache",
      connection: "keep-alive"
    }
  }, new Response(new ReadableStream({
    async start(controller) {
      let end = false;
      if (request?.signal?.addEventListener("abort", () => {
        end = true;
        try {
          controller.close();
        } catch {
        }
      }), init.value !== undefined && init.value !== null)
        if (init.value.toStream)
          controller.enqueue(init.value.toStream());
        else if (typeof init.value == "object")
          try {
            controller.enqueue(Buffer.from(JSON.stringify(init.value)));
          } catch {
            controller.enqueue(Buffer.from(init.value.toString()));
          }
        else
          controller.enqueue(Buffer.from(init.value.toString()));
      for await (let chunk of generator) {
        if (end)
          break;
        if (chunk != null) {
          if (chunk.toStream)
            controller.enqueue(chunk.toStream());
          else if (typeof chunk == "object")
            try {
              controller.enqueue(Buffer.from(JSON.stringify(chunk)));
            } catch {
              controller.enqueue(Buffer.from(chunk.toString()));
            }
          else
            controller.enqueue(Buffer.from(chunk.toString()));
          await new Promise((resolve) => setTimeout(() => resolve(), 0));
        }
      }
      try {
        controller.close();
      } catch {
      }
    }
  }), set2);
};
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    for (;; ) {
      let { done, value } = await reader.read();
      if (done)
        break;
      yield decoder.decode(value);
    }
  } finally {
    reader.releaseLock();
  }
}
var handleSet = (set2) => {
  if (typeof set2.status == "string" && (set2.status = StatusMap[set2.status]), set2.cookie && isNotEmpty(set2.cookie)) {
    let cookie = serializeCookie(set2.cookie);
    cookie && (set2.headers["set-cookie"] = cookie);
  }
  set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]) && (set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]));
};
var createResponseHandler = (handler) => {
  let handleStream3 = createStreamHandler(handler);
  return (response, set2, request) => {
    let isCookieSet = false;
    if (set2.headers instanceof Headers)
      for (let key of set2.headers.keys())
        if (key === "set-cookie") {
          if (isCookieSet)
            continue;
          isCookieSet = true;
          for (let cookie of set2.headers.getSetCookie())
            response.headers.append("set-cookie", cookie);
        } else
          response.headers.append(key, set2.headers?.get(key) ?? "");
    else
      for (let key in set2.headers)
        response.headers.append(key, set2.headers[key]);
    let status2 = set2.status ?? 200;
    return response.status !== status2 && status2 !== 200 && (response.status <= 300 || response.status > 400) ? response.text().then((value) => {
      let newResponse = new Response(value, {
        headers: response.headers,
        status: set2.status
      });
      return !newResponse.headers.has("content-length") && newResponse.headers.get("transfer-encoding") === "chunked" ? handleStream3(streamResponse(newResponse), responseToSetHeaders(newResponse, set2), request) : newResponse;
    }) : !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked" ? handleStream3(streamResponse(response), responseToSetHeaders(response, set2), request) : response;
  };
};
var handleElysiaFile = (file2, set2 = {
  headers: {}
}) => {
  let path = file2.path, contentType = mime[path.slice(path.lastIndexOf(".") + 1)];
  return contentType && (set2.headers["content-type"] = contentType), file2.stats && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416 ? file2.stats.then((stat2) => {
    let size = stat2.size;
    return size !== undefined && (set2.headers["content-range"] = `bytes 0-${size - 1}/${size}`, set2.headers["content-length"] = size), handleFile(file2.value, set2);
  }) : handleFile(file2.value, set2);
};
var mapResponse = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse(response.response, set2, request);
      case "ReadableStream":
        return set2.headers["content-type"]?.startsWith("text/event-stream") || (set2.headers["content-type"] = "text/event-stream; charset=utf-8"), request?.signal?.addEventListener("abort", {
          handleEvent() {
            request?.signal && !request?.signal?.aborted && response.cancel();
          }
        }, {
          once: true
        }), new Response(response, set2);
      case undefined:
        return response ? new Response(JSON.stringify(response), set2) : new Response("", set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2, request));
      case "Function":
        return mapResponse(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        return response instanceof Cookie ? new Response(response.value, set2) : new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse(response.response, set2, request);
        if (typeof response?.next == "function")
          return handleStream(response, set2, request);
        if (typeof response?.then == "function")
          return response.then((x) => mapResponse(x, set2));
        if (typeof response?.toResponse == "function")
          return mapResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91)
            return set2.headers["Content-Type"] || (set2.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(response), set2);
        }
        return new Response(response, set2);
    }
  return response instanceof Response && !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked" ? handleStream(streamResponse(response), responseToSetHeaders(response, set2), request) : typeof response?.next == "function" || response instanceof ReadableStream ? handleStream(response, set2, request) : mapCompactResponse(response, request);
};
var mapEarlyResponse = (response, set2, request) => {
  if (response != null)
    if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
      switch (handleSet(set2), response?.constructor?.name) {
        case "String":
          return set2.headers["content-type"] = "text/plain", new Response(response, set2);
        case "Array":
        case "Object":
          return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
        case "ElysiaFile":
          return handleElysiaFile(response, set2);
        case "File":
          return handleFile(response, set2);
        case "Blob":
          return handleFile(response, set2);
        case "ElysiaCustomStatusResponse":
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        case "ReadableStream":
          return set2.headers["content-type"]?.startsWith("text/event-stream") || (set2.headers["content-type"] = "text/event-stream; charset=utf-8"), request?.signal?.addEventListener("abort", {
            handleEvent() {
              request?.signal && !request?.signal?.aborted && response.cancel();
            }
          }, {
            once: true
          }), new Response(response, set2);
        case undefined:
          return response ? new Response(JSON.stringify(response), set2) : undefined;
        case "Response":
          return handleResponse(response, set2, request);
        case "Promise":
          return response.then((x) => mapEarlyResponse(x, set2));
        case "Error":
          return errorToResponse(response, set2);
        case "Function":
          return mapEarlyResponse(response(), set2);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set2);
        case "FormData":
          return new Response(response);
        case "Cookie":
          return response instanceof Cookie ? new Response(response.value, set2) : new Response(response?.toString(), set2);
        default:
          if (response instanceof Response)
            return handleResponse(response, set2, request);
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse(x, set2));
          if (response instanceof Error)
            return errorToResponse(response, set2);
          if (response instanceof ElysiaCustomStatusResponse)
            return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
          if (typeof response?.next == "function")
            return handleStream(response, set2, request);
          if (typeof response?.then == "function")
            return response.then((x) => mapEarlyResponse(x, set2));
          if (typeof response?.toResponse == "function")
            return mapEarlyResponse(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            let code = response.charCodeAt(0);
            if (code === 123 || code === 91)
              return set2.headers["Content-Type"] || (set2.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(response), set2);
          }
          return new Response(response, set2);
      }
    else
      switch (response?.constructor?.name) {
        case "String":
          return set2.headers["content-type"] = "text/plain", new Response(response);
        case "Array":
        case "Object":
          return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
        case "ElysiaFile":
          return handleElysiaFile(response, set2);
        case "File":
          return handleFile(response, set2);
        case "Blob":
          return handleFile(response, set2);
        case "ElysiaCustomStatusResponse":
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        case "ReadableStream":
          return request?.signal?.addEventListener("abort", {
            handleEvent() {
              request?.signal && !request?.signal?.aborted && response.cancel();
            }
          }, {
            once: true
          }), new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          return response ? new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          }) : new Response("");
        case "Response":
          return !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked" ? handleStream(streamResponse(response), responseToSetHeaders(response), request) : response;
        case "Promise":
          return response.then((x) => {
            let r = mapEarlyResponse(x, set2);
            if (r !== undefined)
              return r;
          });
        case "Error":
          return errorToResponse(response, set2);
        case "Function":
          return mapCompactResponse(response(), request);
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          return response instanceof Cookie ? new Response(response.value, set2) : new Response(response?.toString(), set2);
        case "FormData":
          return new Response(response);
        default:
          if (response instanceof Response)
            return response;
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse(x, set2));
          if (response instanceof Error)
            return errorToResponse(response, set2);
          if (response instanceof ElysiaCustomStatusResponse)
            return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
          if (typeof response?.next == "function")
            return handleStream(response, set2, request);
          if (typeof response?.then == "function")
            return response.then((x) => mapEarlyResponse(x, set2));
          if (typeof response?.toResponse == "function")
            return mapEarlyResponse(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            let code = response.charCodeAt(0);
            if (code === 123 || code === 91)
              return set2.headers["Content-Type"] || (set2.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(response), set2);
          }
          return new Response(response);
      }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, {
        headers: {
          "Content-Type": "text/plain"
        }
      });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "Content-Type": "application/json"
        }
      });
    case "ElysiaFile":
      return handleElysiaFile(response);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, {
        status: response.code,
        headers: {}
      });
    case "ReadableStream":
      return request?.signal?.addEventListener("abort", {
        handleEvent() {
          request?.signal && !request?.signal?.aborted && response.cancel();
        }
      }, {
        once: true
      }), new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      return response ? new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      }) : new Response("");
    case "Response":
      return response.headers.get("transfer-encoding") === "chunked" ? handleStream(streamResponse(response), responseToSetHeaders(response), request) : response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x) => mapCompactResponse(x, request));
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse(x, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, {
          status: response.code,
          headers: {}
        });
      if (typeof response?.next == "function")
        return handleStream(response, undefined, request);
      if (typeof response?.then == "function")
        return response.then((x) => mapResponse(x, set));
      if (typeof response?.toResponse == "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
      }
      return new Response(response);
  }
};
var errorToResponse = (error2, set2) => new Response(JSON.stringify({
  name: error2?.name,
  message: error2?.message,
  cause: error2?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle == "function")
    return;
  let response = mapResponse(handle, {
    headers: setHeaders
  });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return response.clone.bind(response);
};
var handleResponse = createResponseHandler({
  mapResponse,
  mapCompactResponse
});
var handleStream = createStreamHandler({
  mapResponse,
  mapCompactResponse
});
var WebStandardAdapter = {
  name: "web-standard",
  isWebStandard: true,
  handler: {
    mapResponse,
    mapEarlyResponse,
    mapCompactResponse,
    createStaticHandler
  },
  composeHandler: {
    mapResponseContext: "c.request",
    preferWebstandardHeaders: true,
    headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`,
    parser: {
      json(isOptional2) {
        return isOptional2 ? `try{c.body=await c.request.json()}catch{}
` : `c.body=await c.request.json()
`;
      },
      text() {
        return `c.body=await c.request.text()
`;
      },
      urlencoded() {
        return `c.body=parseQuery(await c.request.text())
`;
      },
      arrayBuffer() {
        return `c.body=await c.request.arrayBuffer()
`;
      },
      formData(isOptional2) {
        let fnLiteral = `
c.body={}
`;
        return isOptional2 ? fnLiteral += "let form;try{form=await c.request.formData()}catch{}" : fnLiteral += `const form=await c.request.formData()
`, fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
      }
    }
  },
  async stop(app, closeActiveConnections) {
    if (!app.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (app.server && (app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length))
      for (let i = 0;i < app.event.stop.length; i++)
        app.event.stop[i].fn(app);
  },
  composeGeneralHandler: {
    parameters: "r",
    createContext(app) {
      let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
      for (let key of Object.keys(app.decorator))
        decoratorsLiteral += `,'${key}':decorator['${key}']`;
      let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = !!app.event.trace?.length;
      return fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?',s+1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace && (fnLiteral += `const id=randomId()
`), fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,error:status,status,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({},app.setHeaders)" : "Object.create(null)", fnLiteral += ",status:200}", app.inference.server && (fnLiteral += ",get server(){return app.getServer()}"), hasTrace && (fnLiteral += ",[ELYSIA_REQUEST_ID]:id"), fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
    },
    error404(hasEventHook, hasErrorHook) {
      let findDynamicRoute = "if(route===null)return ";
      return hasErrorHook ? findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})` : findDynamicRoute += hasEventHook ? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "error404.clone()", {
        declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`,
        code: findDynamicRoute
      };
    }
  },
  composeError: {
    mapResponseContext: "",
    validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})",
    unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})"
  },
  listen() {
    return () => {
      throw new Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
    };
  }
};
function parseQueryFromURL(input, startIndex = 0) {
  let result = /* @__PURE__ */ Object.create(null), KEY_PLUS_FLAG = 1, KEY_DECODE_FLAG = 2, VALUE_PLUS_FLAG = 4, VALUE_DECODE_FLAG = 8, flags = 0, startingIndex = startIndex - 1, equalityIndex = startingIndex, inputLength = input.length;
  for (let i = startIndex;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        equalityIndex <= startingIndex ? equalityIndex = i : flags |= VALUE_DECODE_FLAG;
        break;
      case 43:
        equalityIndex > startingIndex ? flags |= VALUE_PLUS_FLAG : flags |= KEY_PLUS_FLAG;
        break;
      case 37:
        equalityIndex > startingIndex ? flags |= VALUE_DECODE_FLAG : flags |= KEY_DECODE_FLAG;
        break;
    }
  return processKeyValuePair(inputLength), result;
  function processKeyValuePair(endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, keyEndIndex = hasBothKeyValuePair ? equalityIndex : endIndex;
    if (keyEndIndex <= startingIndex + 1)
      return;
    let keySlice = input.slice(startingIndex + 1, keyEndIndex);
    if (flags & KEY_PLUS_FLAG && (keySlice = keySlice.replace(/\+/g, " ")), flags & KEY_DECODE_FLAG && (keySlice = import_fast_decode_uri_component3.default(keySlice) || keySlice), result[keySlice] !== undefined)
      return;
    let finalValue = "";
    hasBothKeyValuePair && (finalValue = input.slice(equalityIndex + 1, endIndex), flags & VALUE_PLUS_FLAG && (finalValue = finalValue.replace(/\+/g, " ")), flags & VALUE_DECODE_FLAG && (finalValue = import_fast_decode_uri_component3.default(finalValue) || finalValue)), result[keySlice] = finalValue;
  }
}
function parseQuery(input) {
  let result = /* @__PURE__ */ Object.create(null), flags = 0, KEY_HAS_PLUS = 1, KEY_NEEDS_DECODE = 2, VALUE_HAS_PLUS = 4, VALUE_NEEDS_DECODE = 8, inputLength = input.length, startingIndex = -1, equalityIndex = -1;
  for (let i = 0;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(input, i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        equalityIndex <= startingIndex ? equalityIndex = i : flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        equalityIndex > startingIndex ? flags |= VALUE_HAS_PLUS : flags |= KEY_HAS_PLUS;
        break;
      case 37:
        equalityIndex > startingIndex ? flags |= VALUE_NEEDS_DECODE : flags |= KEY_NEEDS_DECODE;
        break;
    }
  return startingIndex < inputLength && processKeyValuePair(input, inputLength), result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    flags & KEY_HAS_PLUS && (finalKey = finalKey.replace(/\+/g, " ")), flags & KEY_NEEDS_DECODE && (finalKey = import_fast_decode_uri_component3.default(finalKey) || finalKey);
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      flags & VALUE_HAS_PLUS && (valueSlice = valueSlice.replace(/\+/g, " ")), flags & VALUE_NEEDS_DECODE && (valueSlice = import_fast_decode_uri_component3.default(valueSlice) || valueSlice), finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    currentValue === undefined ? result[finalKey] = finalValue : Array.isArray(currentValue) ? currentValue.push(finalValue) : result[finalKey] = [currentValue, finalValue];
  }
}
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error2, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [
    (callback) => (callback && callbacks.push(callback), promise),
    (process2) => {
      let processes = [], resolvers = [], groupError = null;
      for (let i = 0;i < (process2.total ?? 0); i++) {
        let { promise: promise2, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error3, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
        processes.push((callback) => (callback && callbacks2.push(callback), promise2)), resolvers.push((process3) => {
          let result2 = {
            ...process3,
            end: end2,
            error: error3,
            index: i,
            onStop(callback) {
              return callback && callbacksEnd2.push(callback), end2;
            }
          };
          resolve2(result2);
          for (let i2 = 0;i2 < callbacks2.length; i2++)
            callbacks2[i2](result2);
          return (error4 = null) => {
            let end3 = performance.now();
            error4 && (groupError = error4);
            let detail = {
              end: end3,
              error: error4,
              get elapsed() {
                return end3 - process3.begin;
              }
            };
            for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
              callbacksEnd2[i2](detail);
            resolveEnd2(end3), resolveError2(error4);
          };
        });
      }
      let result = {
        ...process2,
        end,
        error: error2,
        onEvent(callback) {
          for (let i = 0;i < processes.length; i++)
            processes[i](callback);
        },
        onStop(callback) {
          return callback && callbacksEnd.push(callback), end;
        }
      };
      resolve(result);
      for (let i = 0;i < callbacks.length; i++)
        callbacks[i](result);
      return {
        resolveChild: resolvers,
        resolve(error3 = null) {
          let end2 = performance.now();
          !error3 && groupError && (error3 = groupError);
          let detail = {
            end: end2,
            error: error3,
            get elapsed() {
              return end2 - process2.begin;
            }
          };
          for (let i = 0;i < callbacksEnd.length; i++)
            callbacksEnd[i](detail);
          resolveEnd(end2), resolveError(error3);
        }
      };
    }
  ];
};
var createTracer = (traceListener) => (context) => {
  let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
  return traceListener({
    id: context[ELYSIA_REQUEST_ID],
    context,
    set: context.set,
    onRequest,
    onParse,
    onTransform,
    onBeforeHandle,
    onHandle,
    onAfterHandle,
    onMapResponse,
    onAfterResponse,
    onError,
    time: Date.now(),
    store: context.store
  }), {
    request: resolveRequest,
    parse: resolveParse,
    transform: resolveTransform,
    beforeHandle: resolveBeforeHandle,
    handle: resolveHandle,
    afterHandle: resolveAfterHandle,
    error: resolveError,
    mapResponse: resolveMapResponse,
    afterResponse: resolveAfterResponse
  };
};
var isOptional = (schema) => schema ? schema?.[Kind] === "Import" && schema.References ? schema.References().some(isOptional) : (schema.schema && (schema = schema.schema), !!schema && (OptionalKind in schema)) : false;
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some(hasAdditionalProperties);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  return schema.type === "array" && schema.items && !Array.isArray(schema.items) ? hasAdditionalProperties(schema.items) : false;
};
var hasType = (type, schema) => {
  if (!schema)
    return false;
  if (Kind in schema && schema[Kind] === type)
    return true;
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasType(type, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasType(type, property.anyOf[i]))
            return true;
      }
      if (Kind in property && property[Kind] === type)
        return true;
    }
    return false;
  }
  return !!schema.properties && Kind in schema.properties && schema.properties[Kind] === type;
};
var hasProperty = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var hasRef = (schema) => {
  if (!schema)
    return false;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasRef(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasRef(schema.anyOf[i]))
        return true;
  }
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasRef(schema.oneOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasRef(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasRef(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasRef(property) || property.type === "array" && property.items && hasRef(property.items))
        return true;
    }
  }
  return schema.type === "array" && schema.items && hasRef(schema.items) ? true : schema[Kind] === "Ref" && ("$ref" in schema);
};
var hasTransform = (schema) => {
  if (!schema)
    return false;
  if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform(schema.$defs[schema.$ref]))
    return true;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasTransform(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasTransform(schema.anyOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasTransform(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasTransform(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasTransform(property) || property.type === "array" && property.items && hasTransform(property.items))
        return true;
    }
  }
  return schema.type === "array" && schema.items && hasTransform(schema.items) ? true : (TransformKind in schema);
};
var replaceSchemaType = (schema, options, _config = {}) => {
  let config = _config;
  if (config.root = true, !Array.isArray(options))
    return options.original = schema, _replaceSchemaType(schema, options, config);
  for (let option of options)
    option.original = schema, schema = _replaceSchemaType(schema, option, config);
  return schema;
};
var _replaceSchemaType = (schema, options, config) => {
  if (!schema)
    return schema;
  let root = config.root;
  if (options.onlyFirstObject && schema.type === "object")
    return options.to(schema) ?? schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, config);
    return schema;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, config);
    return schema;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, config);
    return schema;
  }
  if (schema.not)
    return _replaceSchemaType(schema.not, options, config);
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema, to = options.to(rest);
    if (!to)
      return schema;
    let transform2, composeProperties = (schema2) => {
      let v = _composeProperties(schema2);
      return v.$id && delete v.$id, v;
    }, _composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value2, options, {
            ...config,
            root: false
          });
        return {
          ...rest,
          ...v,
          properties: newProperties
        };
      }
      if (items && v.type === "array")
        return {
          ...rest,
          ...v,
          items: _replaceSchemaType(items, options, {
            ...config,
            root: false
          })
        };
      let value = {
        ...rest,
        ...v
      };
      return delete value.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}" && (transform2 = t.ObjectString(properties2, rest), value.default = JSON.stringify(exports_value2.Create(t.Object(properties2))), value.properties = properties2), items && v.type === "string" && v.format === "ArrayString" && v.default === "[]" && (transform2 = t.ArrayString(items, rest), value.default = JSON.stringify(exports_value2.Create(t.Array(items))), value.items = items), value;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value, options, {
            ...config,
            root: false
          });
        return {
          ...rest,
          properties: newProperties
        };
      } else if (items?.map)
        return {
          ...rest,
          items: items.map((v) => _replaceSchemaType(v, options, {
            ...config,
            root: false
          }))
        };
      return rest;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else
      to.not && (to.not = composeProperties(to.not));
    if (transform2 && (to[TransformKind] = transform2[TransformKind]), to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value, options, {
          ...config,
          root: false
        });
      return {
        ...rest,
        ...to,
        properties: newProperties
      };
    } else if (items?.map)
      return {
        ...rest,
        ...to,
        items: items.map((v) => _replaceSchemaType(v, options, {
          ...config,
          root: false
        }))
      };
    return {
      ...rest,
      ...to
    };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value] of Object.entries(properties))
      switch (value[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not, type, ...rest } = value, to = options.to(rest);
          if (!to)
            return schema;
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest, ...to.allOf[i] };
          else
            to.not && (to.not = { ...rest, ...to.not });
          properties[key] = {
            ...rest,
            ..._replaceSchemaType(rest, options, {
              ...config,
              root: false
            })
          };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value, options, {
            ...config,
            root: false
          });
          break;
        default:
          if (Array.isArray(value.items))
            for (let i = 0;i < value.items.length; i++)
              value.items[i] = _replaceSchemaType(value.items[i], options, {
                ...config,
                root: false
              });
          else
            value.anyOf || value.oneOf || value.allOf || value.not ? properties[key] = _replaceSchemaType(value, options, {
              ...config,
              root: false
            }) : value.type === "array" && (value.items = _replaceSchemaType(value.items, options, {
              ...config,
              root: false
            }));
          break;
      }
  return schema.type === "array" && schema.items && (Array.isArray(schema.items) ? schema.items = schema.items.map((item) => _replaceSchemaType(item, options, {
    ...config,
    root: false
  })) : schema.items = _replaceSchemaType(schema.items, options, {
    ...config,
    root: false
  })), schema;
};
var createCleaner = (schema) => (value) => {
  if (typeof value == "object")
    try {
      return exports_value2.Clean(schema, value);
    } catch {
    }
  return value;
};
var getSchemaValidator = (s, {
  models = {},
  dynamic = false,
  modules,
  normalize = false,
  additionalProperties = false,
  coerce = false,
  additionalCoerce = [],
  validators,
  sanitize: sanitize2
} = {}) => {
  if (validators = validators?.filter((x) => x), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let doesHaveRef, replaceSchema = (schema2) => coerce ? replaceSchemaType(schema2, [
    {
      from: t.Number(),
      to: (options) => t.Numeric(options),
      untilObjectFound: true
    },
    {
      from: t.Boolean(),
      to: (options) => t.BooleanString(options),
      untilObjectFound: true
    },
    ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]
  ]) : replaceSchemaType(schema2, additionalCoerce), mapSchema = (s2) => {
    let schema2;
    if (!s2)
      return;
    if (typeof s2 != "string")
      schema2 = s2;
    else {
      let isArray = s2.endsWith("[]"), key = isArray ? s2.substring(0, s2.length - 2) : s2;
      schema2 = modules?.Import(key) ?? models[key], isArray && (schema2 = t.Array(schema2));
    }
    if (!schema2)
      return;
    let _doesHaveRef;
    if (schema2[Kind] !== "Import" && (_doesHaveRef = hasRef(schema2))) {
      let id = randomId();
      doesHaveRef === undefined && (doesHaveRef = _doesHaveRef), schema2 = t.Module({
        ...modules?.$defs,
        [id]: schema2
      }).Import(id);
    }
    if (schema2[Kind] === "Import") {
      let newDefs = {};
      for (let [key2, value] of Object.entries(schema2.$defs))
        newDefs[key2] = replaceSchema(value);
      let key = schema2.$ref;
      schema2 = t.Module(newDefs).Import(key);
    } else
      (coerce || additionalCoerce) && (schema2 = replaceSchema(schema2));
    return schema2;
  }, schema = mapSchema(s);
  if (validators?.length) {
    let hasAdditional = false, { schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([
      schema,
      ...validators.map(mapSchema)
    ]);
    notObjects && (schema = t.Intersect([
      ...mergedObjectSchema ? [mergedObjectSchema] : [],
      ...notObjects.map((x) => {
        let schema2 = mapSchema(x);
        return schema2.type === "object" && "additionalProperties" in schema2 && (!hasAdditional && schema2.additionalProperties === false && (hasAdditional = true), delete schema2.additionalProperties), schema2;
      })
    ]), schema.type === "object" && hasAdditional && (schema.additionalProperties = false));
  } else
    schema.type === "object" && !("additionalProperties" in schema) ? schema.additionalProperties = additionalProperties : schema = replaceSchemaType(schema, {
      onlyFirstObject: true,
      from: t.Object({}),
      to({ properties, ...options }) {
        if (properties && !("additionalProperties" in schema))
          return t.Object(properties, {
            ...options,
            additionalProperties: false
          });
      }
    });
  if (dynamic) {
    let validator = {
      schema,
      references: "",
      checkFunc: () => {
      },
      code: "",
      Check: (value) => exports_value2.Check(schema, value),
      Errors: (value) => exports_value2.Errors(schema, value),
      Code: () => "",
      Clean: createCleaner(schema),
      Decode: (value) => exports_value2.Decode(schema, value),
      Encode: (value) => exports_value2.Encode(schema, value),
      get hasAdditionalProperties() {
        return "~hasAdditionalProperties" in this ? this["~hasAdditionalProperties"] : this["~hasAdditionalProperties"] = hasAdditionalProperties(schema);
      },
      get hasDefault() {
        return "~hasDefault" in this ? this["~hasDefault"] : this["~hasDefault"] = hasProperty("default", schema);
      },
      get isOptional() {
        return "~isOptional" in this ? this["~isOptional"] : this["~isOptional"] = isOptional(schema);
      },
      get hasTransform() {
        return "~hasTransform" in this ? this["~hasTransform"] : this["~hasTransform"] = hasTransform(schema);
      },
      "~hasRef": doesHaveRef,
      get hasRef() {
        return "~hasRef" in this ? this["~hasRef"] : this["~hasRef"] = hasTransform(schema);
      }
    };
    if (schema.config && (validator.config = schema.config, validator?.schema?.config && delete validator.schema.config), normalize && schema.additionalProperties === false)
      if (normalize === true || normalize === "exactMirror")
        try {
          validator.Clean = createMirror(schema, {
            TypeCompiler,
            sanitize: sanitize2?.(),
            modules
          });
        } catch {
          console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), validator.Clean = createCleaner(schema);
        }
      else
        validator.Clean = createCleaner(schema);
    return validator.parse = (v) => {
      try {
        return validator.Decode(v);
      } catch {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(v), error: null };
      } catch {
        let errors = [...compiled.Errors(v)].map(mapValueError);
        return {
          success: false,
          data: null,
          error: errors[0]?.summary,
          errors
        };
      }
    }, validator;
  }
  let compiled = TypeCompiler.Compile(schema, Object.values(models));
  if (schema.config && (compiled.config = schema.config, compiled?.schema?.config && delete compiled.schema.config), normalize === true || normalize === "exactMirror")
    try {
      compiled.Clean = createMirror(schema, {
        TypeCompiler,
        sanitize: sanitize2?.(),
        modules
      });
    } catch {
      console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), compiled.Clean = createCleaner(schema);
    }
  else
    compiled.Clean = createCleaner(schema);
  return compiled.parse = (v) => {
    try {
      return compiled.Decode(v);
    } catch {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(v), error: null };
    } catch {
      let errors = [...compiled.Errors(v)].map(mapValueError);
      return {
        success: false,
        data: null,
        error: errors[0]?.summary,
        errors
      };
    }
  }, Object.assign(compiled, {
    get hasAdditionalProperties() {
      return "~hasAdditionalProperties" in this ? this["~hasAdditionalProperties"] : this["~hasAdditionalProperties"] = hasAdditionalProperties(compiled);
    },
    get hasDefault() {
      return "~hasDefault" in this ? this["~hasDefault"] : this["~hasDefault"] = hasProperty("default", compiled);
    },
    get isOptional() {
      return "~isOptional" in this ? this["~isOptional"] : this["~isOptional"] = isOptional(compiled);
    },
    get hasTransform() {
      return "~hasTransform" in this ? this["~hasTransform"] : this["~hasTransform"] = hasTransform(schema);
    },
    get hasRef() {
      return "~hasRef" in this ? this["~hasRef"] : this["~hasRef"] = hasRef(schema);
    },
    "~hasRef": doesHaveRef
  }), compiled;
};
var isUnion = (schema) => schema[Kind] === "Union" || !schema.schema && !!schema.anyOf;
var mergeObjectSchemas = (schemas) => {
  if (schemas.length === 0)
    return {
      schema: undefined,
      notObjects: []
    };
  if (schemas.length === 1)
    return schemas[0].type === "object" ? {
      schema: schemas[0],
      notObjects: []
    } : {
      schema: undefined,
      notObjects: schemas
    };
  let newSchema, notObjects = [], additionalPropertiesIsTrue = false, additionalPropertiesIsFalse = false;
  for (let schema of schemas) {
    if (schema.type !== "object") {
      notObjects.push(schema);
      continue;
    }
    if ("additionalProperties" in schema && (schema.additionalProperties === true ? additionalPropertiesIsTrue = true : schema.additionalProperties === false && (additionalPropertiesIsFalse = true)), !newSchema) {
      newSchema = schema;
      continue;
    }
    newSchema = {
      ...newSchema,
      ...schema,
      properties: {
        ...newSchema.properties,
        ...schema.properties
      },
      required: [...newSchema?.required ?? [], ...schema.required]
    };
  }
  return newSchema && (newSchema.required && (newSchema.required = [...new Set(newSchema.required)]), additionalPropertiesIsFalse ? newSchema.additionalProperties = false : additionalPropertiesIsTrue && (newSchema.additionalProperties = true)), {
    schema: newSchema,
    notObjects
  };
};
var getResponseSchemaValidator = (s, {
  models = {},
  modules,
  dynamic = false,
  normalize = false,
  additionalProperties = false,
  validators = [],
  sanitize: sanitize2
}) => {
  if (validators = validators.filter((x) => x), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let maybeSchemaOrRecord;
  if (typeof s != "string")
    maybeSchemaOrRecord = s;
  else {
    let isArray = s.endsWith("[]"), key = isArray ? s.substring(0, s.length - 2) : s;
    maybeSchemaOrRecord = modules.Import(key) ?? models[key], isArray && (maybeSchemaOrRecord = t.Array(maybeSchemaOrRecord));
  }
  if (!maybeSchemaOrRecord)
    return;
  if (Kind in maybeSchemaOrRecord)
    return {
      200: getSchemaValidator(maybeSchemaOrRecord, {
        modules,
        models,
        additionalProperties,
        dynamic,
        normalize,
        coerce: false,
        additionalCoerce: [],
        validators: validators.map((x) => x[200]),
        sanitize: sanitize2
      })
    };
  let record = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status2) => {
    if (isNaN(+status2))
      return;
    let maybeNameOrSchema = maybeSchemaOrRecord[+status2];
    if (typeof maybeNameOrSchema == "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        record[+status2] = Kind in schema ? getSchemaValidator(schema, {
          modules,
          models,
          additionalProperties,
          dynamic,
          normalize,
          coerce: false,
          additionalCoerce: [],
          validators: validators.map((x) => x[+status2]),
          sanitize: sanitize2
        }) : schema;
      }
      return;
    }
    record[+status2] = Kind in maybeNameOrSchema ? getSchemaValidator(maybeNameOrSchema, {
      modules,
      models,
      additionalProperties,
      dynamic,
      normalize,
      coerce: false,
      additionalCoerce: [],
      validators: validators.map((x) => x[+status2]),
      sanitize: sanitize2
    }) : maybeNameOrSchema;
  }), record;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => (_stringToStructureCoercions || (_stringToStructureCoercions = [
  {
    from: t.Object({}),
    to: () => t.ObjectString({}),
    excludeRoot: true
  },
  {
    from: t.Array(t.Any()),
    to: () => t.ArrayString(t.Any())
  }
]), _stringToStructureCoercions);
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => (_coercePrimitiveRoot || (_coercePrimitiveRoot = [
  {
    from: t.Number(),
    to: (options) => t.Numeric(options),
    rootOnly: true
  },
  {
    from: t.Boolean(),
    to: (options) => t.BooleanString(options),
    rootOnly: true
  }
]), _coercePrimitiveRoot);
var getCookieValidator = ({
  validator,
  modules,
  defaultConfig = {},
  config,
  dynamic,
  models,
  validators,
  sanitize: sanitize2
}) => {
  let cookieValidator = getSchemaValidator(validator, {
    modules,
    dynamic,
    models,
    additionalProperties: true,
    coerce: true,
    additionalCoerce: stringToStructureCoercions(),
    validators,
    sanitize: sanitize2
  });
  return cookieValidator ? cookieValidator.config = mergeCookie(cookieValidator.config, config) : (cookieValidator = getSchemaValidator(t.Cookie(t.Any()), {
    modules,
    dynamic,
    models,
    additionalProperties: true,
    validators,
    sanitize: sanitize2
  }), cookieValidator.config = defaultConfig), cookieValidator;
};
var unwrapImportSchema = (schema) => schema[Kind] === "Import" && schema.$defs[schema.$ref][Kind] === "Object" ? schema.$defs[schema.$ref] : schema;
var allocateIf = (value, condition) => condition ? value : "";
var defaultParsers = [
  "json",
  "text",
  "urlencoded",
  "arrayBuffer",
  "formdata",
  "application/json",
  "text/plain",
  "application/x-www-form-urlencoded",
  "application/octet-stream",
  "multipart/form-data"
];
var createReport = ({
  context = "c",
  trace = [],
  addFn
}) => {
  if (!trace.length)
    return () => ({
      resolveChild() {
        return () => {
        };
      },
      resolve() {
      }
    });
  for (let i = 0;i < trace.length; i++)
    addFn(`let report${i},reportChild${i},reportErr${i},reportErrChild${i};let trace${i}=${context}[ELYSIA_TRACE]?.[${i}]??trace[${i}](${context});
`);
  return (event, {
    name,
    total = 0
  } = {}) => {
    name || (name = "anonymous");
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace.length; i++)
      addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return {
      resolve() {
        for (let i = 0;i < trace.length; i++)
          addFn(`${reporter}${i}.resolve()
`);
      },
      resolveChild(name2) {
        for (let i = 0;i < trace.length; i++)
          addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
        return (binding) => {
          for (let i = 0;i < trace.length; i++)
            addFn(binding ? `if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}` : `${reporter}Child${i}?.()
`);
        };
      }
    };
  };
};
var composeCleaner = ({
  schema,
  name,
  type,
  typeAlias = type,
  normalize,
  ignoreTryCatch = false
}) => !normalize || !schema.Clean || schema.hasAdditionalProperties ? "" : normalize === true || normalize === "exactMirror" ? ignoreTryCatch ? `${name}=validator.${typeAlias}.Clean(${name})
` : `try{${name}=validator.${typeAlias}.Clean(${name})
}catch{}` : normalize === "typebox" ? `${name}=validator.${typeAlias}.Clean(${name})
` : "";
var composeValidationFactory = ({
  injectResponse = "",
  normalize = false,
  validator,
  encodeSchema = false,
  isStaticResponse = false,
  hasSanitize = false
}) => ({
  validate: (type, value = `c.${type}`) => `c.set.status=422;throw new ValidationError('${type}',validator.${type},${value})`,
  response: (name = "r") => {
    if (isStaticResponse)
      return "";
    let code = injectResponse + `
`;
    code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}switch(c.set.status){`;
    for (let [status2, value] of Object.entries(validator.response)) {
      code += `
case ${status2}:if(${name} instanceof Response)break
`;
      let noValidate = value.schema?.noValidate === true, appliedCleaner = noValidate || hasSanitize, clean2 = ({ ignoreTryCatch = false } = {}) => composeCleaner({
        name,
        schema: value,
        type: "response",
        typeAlias: `response[${status2}]`,
        normalize,
        ignoreTryCatch
      });
      appliedCleaner && (code += clean2());
      let applyErrorCleaner = !appliedCleaner && normalize && !noValidate;
      encodeSchema && value.hasTransform ? code += `try{${name}=validator.response[${status2}].Encode(${name})
c.set.status=${status2}}catch{` + (applyErrorCleaner ? `try{
` + clean2({ ignoreTryCatch: true }) + `${name}=validator.response[${status2}].Encode(${name})
}catch{throw new ValidationError('response',validator.response[${status2}],${name})}` : `throw new ValidationError('response',validator.response[${status2}],${name})`) + "}" : (appliedCleaner || (code += clean2()), noValidate || (code += `if(validator.response[${status2}].Check(${name})===false)throw new ValidationError('response',validator.response[${status2}],${name})
c.set.status=${status2}
`)), code += `break
`;
    }
    return code + "}";
  }
});
var isAsyncName = (v) => (v?.fn ?? v).constructor.name === "AsyncFunction";
var matchResponseClone = /=>\s?response\.clone\(/;
var matchFnReturn = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/;
var isAsync = (v) => {
  let isObject2 = typeof v == "object";
  if (isObject2 && v.isAsync !== undefined)
    return v.isAsync;
  let fn = isObject2 ? v.fn : v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal = fn.toString();
  if (matchResponseClone.test(literal))
    return isObject2 && (v.isAsync = false), false;
  let result = matchFnReturn.test(literal);
  return isObject2 && (v.isAsync = result), result;
};
var hasReturn = (v) => {
  let isObject2 = typeof v == "object";
  if (isObject2 && v.hasReturn !== undefined)
    return v.hasReturn;
  let fnLiteral = isObject2 ? v.fn.toString() : typeof v == "string" ? v.toString() : v, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123)
    return isObject2 && (v.hasReturn = true), true;
  let result = fnLiteral.includes("return");
  return isObject2 && (v.hasReturn = result), result;
};
var isGenerator = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var coerceTransformDecodeError = (fnLiteral, type, value = `c.${type}`) => `try{${fnLiteral}}catch(error){if(error.constructor.name === 'TransformDecodeError'){c.set.status=422
throw error.error ?? new ValidationError('${type}',validator.${type},${value})}}`;
var composeHandler = ({
  app,
  path,
  method,
  hooks,
  validator,
  handler,
  allowMeta = false,
  inference
}) => {
  let adapter = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler == "function";
  if (!isHandleFn && (handler = adapterHandler.mapResponse(handler, {
    headers: app.setHeaders ?? {}
  }), hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length))
    return handler instanceof Response ? Function("a", `"use strict";
return function(){return a.clone()}`)(handler) : Function("a", `"use strict";
return function(){return a}`)(handler);
  let handle = isHandleFn ? "handler(c)" : "handler", hasAfterResponse = !!hooks.afterResponse?.length, hasTrace = !!hooks.trace?.length, fnLiteral = "";
  if (inference = sucrose(hooks, inference), inference = sucrose({
    handler
  }, inference), adapter.declare) {
    let literal = adapter.declare(inference);
    literal && (fnLiteral += literal);
  }
  inference.server && (fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`), validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasValidation = !!validator.body || !!validator.headers || !!validator.params || !!validator.query || !!validator.cookie || !!validator.response, hasQuery = inference.query || !!validator.query, requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none", hasBody = method !== "" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody, defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || !!validator.headers || adapter.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieMeta = validator.cookie?.config ? mergeCookie(validator?.cookie?.config, app.config.cookie) : app.config.cookie, _encodeCookie = "", encodeCookie = () => {
    if (_encodeCookie)
      return _encodeCookie;
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      let secret = cookieMeta.secrets ? typeof cookieMeta.secrets == "string" ? cookieMeta.secrets : cookieMeta.secrets[0] : undefined;
      if (_encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
        _encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
      else
        for (let name of cookieMeta.sign)
          _encodeCookie += `if(_setCookie['${name}']?.value)c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')
`;
      _encodeCookie += `}
`;
    }
    return _encodeCookie;
  }, normalize = app.config.normalize, encodeSchema = app.config.encodeSchema, validation = composeValidationFactory({
    normalize,
    validator,
    encodeSchema,
    isStaticResponse: handler instanceof Response,
    hasSanitize: !!app.config.sanitize
  });
  hasHeaders && (fnLiteral += adapter.headers), hasTrace && (fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`);
  let report = createReport({
    trace: hooks.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  if (fnLiteral += "try{", hasCookie) {
    let get = (name, defaultValue) => {
      let value = cookieMeta?.[name] ?? defaultValue;
      return value ? typeof value == "string" ? `${name}:'${value}',` : value instanceof Date ? `${name}: new Date(${value.getTime()}),` : `${name}:${value},` : typeof defaultValue == "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets == "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    hasHeaders ? fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
` : fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      let properties = validator.query.schema.properties;
      if (!validator.query.hasAdditionalProperties)
        for (let [key, _value] of Object.entries(properties)) {
          let value = _value, isArray = value.type === "array" || !!value.anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
          value && OptionalKind in value && value.type === "array" && value.items && (value = value.items);
          let { type, anyOf } = value;
          destructured.push({
            key,
            isArray,
            isNestedObjectArray: isArray && value.items?.type === "object" || !!value.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"),
            isObject: type === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"),
            anyOf: !!anyOf
          });
        }
    }
    if (!destructured.length)
      fnLiteral += "if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}";
    else {
      fnLiteral += `if(c.qi!==-1){let url='&'+c.url.slice(c.qi+1)
`;
      let index = 0;
      for (let {
        key,
        isArray,
        isObject: isObject2,
        isNestedObjectArray,
        anyOf
      } of destructured) {
        let init2 = (index === 0 ? "let " : "") + `memory=url.indexOf('&${key}=')
let a${index}
`;
        isArray ? (fnLiteral += init2, isNestedObjectArray ? fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)
a${index}=''
else
a${index}+=','
let temp
if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else temp=decodeURIComponent(url.slice(start, memory).replace(/\\+/g,' '))
const charCode=temp.charCodeAt(0)
if(charCode!==91&&charCode !== 123)
temp='"'+temp+'"'
a${index}+=temp
if(memory===-1)break
memory=url.indexOf('&${key}=',memory)
if(memory===-1)break}try{if(a${index}.charCodeAt(0)===91)a${index} = JSON.parse(a${index})
else
a${index}=JSON.parse('['+a${index}+']')}catch{}
` : fnLiteral += `while(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(a${index}===undefined)a${index}=[]
if(memory===-1){const temp=decodeURIComponent(url.slice(start)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\+/g,' '))}
break}else{const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\+/g,' ')
if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}else{a${index}.push(temp)}
}memory=url.indexOf('&${key}=',memory)
if(memory===-1) break
}`) : isObject2 ? fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))if(a${index}!==undefined)try{a${index}=JSON.parse(a${index})}catch{}}` : (fnLiteral += init2 + `if(memory!==-1){const start=memory+${key.length + 2}
memory=url.indexOf('&',start)
if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\+/g,' '))
else{a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\+/g,' '))`, anyOf && (fnLiteral += `
let deepMemory=url.indexOf('&${key}=',memory)
if(deepMemory!==-1){a${index}=[a${index}]
let first=true
while(true){const start=deepMemory+${key.length + 2}
if(first)first=false
else deepMemory = url.indexOf('&', start)
let value
if(deepMemory===-1)value=url.slice(start).replace(/\\+/g,' ')
else value=url.slice(start, deepMemory).replace(/\\+/g,' ')
value=decodeURIComponent(value)
if(value===null){if(deepMemory===-1){break}else{continue}}
const vStart=value.charCodeAt(0)
const vEnd=value.charCodeAt(value.length - 1)
if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))
try{a${index}.push(JSON.parse(value))}catch{a${index}.push(value)}if(deepMemory===-1)break}}`), fnLiteral += "}}"), index++, fnLiteral += `
`;
      }
      fnLiteral += "c.query={" + destructured.map(({ key }, index2) => `'${key}':a${index2}`).join(",") + "}", fnLiteral += `} else c.query = {}
`;
    }
  }
  let isAsyncHandler = typeof handler == "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response= " : "", maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync) || !!hooks.beforeHandle?.some(isAsync) || !!hooks.transform?.some(isAsync) || !!hooks.mapResponse?.some(isAsync), maybeStream = (typeof handler == "function" ? isGenerator(handler) : false) || !!hooks.beforeHandle?.some(isGenerator) || !!hooks.afterHandle?.some(isGenerator) || !!hooks.transform?.some(isGenerator), responseKeys = Object.keys(validator.response ?? {}), hasMultipleResponses = responseKeys.length > 1, hasSingle200 = responseKeys.length === 0 || responseKeys.length === 1 && responseKeys[0] === "200", hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || hasMultipleResponses || !hasSingle200 || isHandleFn && hasDefaultHeaders || maybeStream, mapResponse3 = (r = "r") => `return ${hasSet ? "mapResponse" : "mapCompactResponse"}(${saveResponse}${r}${hasSet ? ",c.set" : ""}${mapResponseContext})
`, mapResponseContext = maybeStream || adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  (hasTrace || inference.route) && (fnLiteral += `c.route=\`${path}\`
`);
  let parseReporter = report("parse", {
    total: hooks.parse?.length
  });
  if (hasBody) {
    let hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
    adapter.parser.declare && (fnLiteral += adapter.parser.declare), fnLiteral += `
try{`;
    let parser = typeof hooks.parse == "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] == "string" ? hooks.parse[0] : typeof hooks.parse[0].fn == "string" ? hooks.parse[0].fn : undefined : undefined;
    if (!parser && validator.body && !hooks.parse?.length) {
      let schema = validator.body.schema;
      schema && schema.anyOf && schema[Kind] === "Union" && schema.anyOf?.length === 2 && schema.anyOf?.find((x) => x[Kind] === "ElysiaForm") && (parser = "formdata");
    }
    if (parser && defaultParsers.includes(parser)) {
      let reporter = report("parse", {
        total: hooks.parse?.length
      }), isOptionalBody = !!validator.body?.isOptional;
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          parser[0] in app["~parser"] && (fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`);
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      fnLiteral += `
`;
      let declaration = hooks.parse?.length ? "let" : "const";
      fnLiteral += hasHeaders ? `${declaration} contentType=c.headers['content-type']
` : `${declaration} contentType=c.request.headers.get('content-type')
`;
      let hasDefaultParser = false;
      if (hooks.parse?.length)
        fnLiteral += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
      else {
        hasDefaultParser = true;
        let isOptionalBody = !!validator.body?.isOptional;
        fnLiteral += `if(contentType)switch(contentType.charCodeAt(12)){
case 106:` + adapter.parser.json(isOptionalBody) + `break
case 120:` + adapter.parser.urlencoded(isOptionalBody) + `break
case 111:` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 114:` + adapter.parser.formData(isOptionalBody) + `break
default:if(contentType.charCodeAt(0)===116){` + adapter.parser.text(isOptionalBody) + `}break
}`;
      }
      let reporter = report("parse", {
        total: hooks.parse?.length
      });
      if (hooks.parse)
        for (let i = 0;i < hooks.parse.length; i++) {
          let name = `bo${i}`;
          if (i !== 0 && (fnLiteral += `
if(!used){`), typeof hooks.parse[i].fn == "string") {
            let endUnit = reporter.resolveChild(hooks.parse[i].fn), isOptionalBody = !!validator.body?.isOptional;
            switch (hooks.parse[i].fn) {
              case "json":
              case "application/json":
                hasDefaultParser = true, fnLiteral += adapter.parser.json(isOptionalBody);
                break;
              case "text":
              case "text/plain":
                hasDefaultParser = true, fnLiteral += adapter.parser.text(isOptionalBody);
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                hasDefaultParser = true, fnLiteral += adapter.parser.urlencoded(isOptionalBody);
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                hasDefaultParser = true, fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
                break;
              case "formdata":
              case "multipart/form-data":
                hasDefaultParser = true, fnLiteral += adapter.parser.formData(isOptionalBody);
                break;
              default:
                fnLiteral += `let ${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true;}
`;
            }
            endUnit();
          } else {
            let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
            fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
          }
          if (i !== 0 && (fnLiteral += "}"), hasDefaultParser)
            break;
        }
      if (reporter.resolve(), !hasDefaultParser) {
        let isOptionalBody = !!validator.body?.isOptional;
        hooks.parse?.length && (fnLiteral += `
if(!used){
if(!contentType) throw new ParseError()
`), fnLiteral += "switch(contentType){", fnLiteral += `case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse)throw result
if(bo${key}!==undefined)c.body=bo${key}
break
`;
        hooks.parse?.length && (fnLiteral += "}"), fnLiteral += "}";
      }
      hooks.parse?.length && (fnLiteral += `
delete c.contentType`);
    }
    fnLiteral += "}catch(error){throw new ParseError(error)}";
  }
  if (parseReporter.resolve(), hooks?.transform) {
    let reporter = report("transform", {
      total: hooks.transform.length
    });
    hooks.transform.length && (fnLiteral += `let transformed
`);
    for (let i = 0;i < hooks.transform.length; i++) {
      let transform2 = hooks.transform[i], endUnit = reporter.resolveChild(transform2.fn.name);
      fnLiteral += isAsync(transform2) ? `transformed=await e.transform[${i}](c)
` : `transformed=e.transform[${i}](c)
`, transform2.subType === "mapDerive" ? fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}` : fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)throw transformed
else Object.assign(c,transformed)
`, endUnit();
    }
    reporter.resolve();
  }
  let fileUnions = [];
  if (validator) {
    if (validator.headers) {
      if (validator.headers.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value == "object" ? JSON.stringify(value) : typeof value == "string" ? `'${value}'` : value;
          parsed !== undefined && (fnLiteral += `c.headers['${key}']??=${parsed}
`);
        }
      fnLiteral += composeCleaner({
        name: "c.headers",
        schema: validator.headers,
        type: "headers",
        normalize
      }), validator.headers.isOptional && (fnLiteral += "if(isNotEmpty(c.headers)){"), validator.body?.schema?.noValidate !== true && (fnLiteral += "if(validator.headers.Check(c.headers) === false){" + validation.validate("headers") + "}"), validator.headers.hasTransform && (fnLiteral += coerceTransformDecodeError(`c.headers=validator.headers.Decode(c.headers)
`, "headers")), validator.headers.isOptional && (fnLiteral += "}");
    }
    if (validator.params) {
      if (validator.params.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value == "object" ? JSON.stringify(value) : typeof value == "string" ? `'${value}'` : value;
          parsed !== undefined && (fnLiteral += `c.params['${key}']??=${parsed}
`);
        }
      validator.params?.schema?.noValidate !== true && (fnLiteral += "if(validator.params.Check(c.params)===false){" + validation.validate("params") + "}"), validator.params.hasTransform && (fnLiteral += coerceTransformDecodeError(`c.params=validator.params.Decode(c.params)
`, "params"));
    }
    if (validator.query) {
      if (validator.query.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value == "object" ? JSON.stringify(value) : typeof value == "string" ? `'${value}'` : value;
          parsed !== undefined && (fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`), fnLiteral += composeCleaner({
            name: "c.query",
            schema: validator.query,
            type: "query",
            normalize
          });
        }
      validator.query.isOptional && (fnLiteral += "if(isNotEmpty(c.query)){"), validator.query?.schema?.noValidate !== true && (fnLiteral += "if(validator.query.Check(c.query)===false){" + validation.validate("query") + "}"), validator.query.hasTransform && (fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(Object.assign({},c.query))
`, "query")), validator.query.isOptional && (fnLiteral += "}");
    }
    if (hasBody && validator.body) {
      (validator.body.hasTransform || validator.body.isOptional) && (fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&isNotEmpty(c.body))
`);
      let hasUnion = isUnion(validator.body.schema), hasNonUnionFileWithDefault = false;
      if (validator.body.hasDefault) {
        let value = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" || validator.body.schema[Kind] === "Import" && validator.body.schema.$defs[validator.body.schema.$ref][Kind] === "Object" ? {} : undefined), schema = unwrapImportSchema(validator.body.schema);
        if (!hasUnion && value && typeof value == "object" && (hasType("File", schema) || hasType("Files", schema))) {
          hasNonUnionFileWithDefault = true;
          for (let [k, v] of Object.entries(value))
            (v === "File" || v === "Files") && delete value[k];
          isNotEmpty(value) || (value = undefined);
        }
        let parsed = typeof value == "object" ? JSON.stringify(value) : typeof value == "string" ? `'${value}'` : value;
        value != null && (Array.isArray(value) ? fnLiteral += `if(!c.body)c.body=${parsed}
` : typeof value == "object" ? fnLiteral += `c.body=Object.assign(${parsed},c.body)
` : fnLiteral += `c.body=${parsed}
`), fnLiteral += composeCleaner({
          name: "c.body",
          schema: validator.body,
          type: "body",
          normalize
        }), validator.body?.schema?.noValidate !== true && (validator.body.isOptional ? fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}" : fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}");
      } else
        fnLiteral += composeCleaner({
          name: "c.body",
          schema: validator.body,
          type: "body",
          normalize
        }), validator.body?.schema?.noValidate !== true && (validator.body.isOptional ? fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}" : fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}");
      if (validator.body.hasTransform && (fnLiteral += coerceTransformDecodeError(`if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`, "body")), hasUnion && validator.body.schema.anyOf?.length) {
        let iterator = Object.values(validator.body.schema.anyOf);
        for (let i = 0;i < iterator.length; i++) {
          let type = iterator[i];
          if (hasType("File", type) || hasType("Files", type)) {
            let candidate = getSchemaValidator(type, {
              modules: app.definitions.typebox,
              dynamic: !app.config.aot,
              models: app.definitions.type,
              normalize: app.config.normalize,
              additionalCoerce: coercePrimitiveRoot(),
              sanitize: () => app.config.sanitize
            });
            if (candidate) {
              let isFirst = fileUnions.length === 0, iterator2 = Object.entries(type.properties), validator2 = isFirst ? `
` : " else ";
              validator2 += `if(fileUnions[${fileUnions.length}].Check(c.body)){`;
              let validateFile2 = "", validatorLength = 0;
              for (let i2 = 0;i2 < iterator2.length; i2++) {
                let [k, v] = iterator2[i2];
                !v.extension || v[Kind] !== "File" && v[Kind] !== "Files" || (validatorLength && (validateFile2 += ","), validateFile2 += `validateFileExtension(c.body.${k},${JSON.stringify(v.extension)},'body.${k}')`, validatorLength++);
              }
              validateFile2 && (validatorLength === 1 ? validator2 += `await ${validateFile2}
` : validatorLength > 1 && (validator2 += `await Promise.all([${validateFile2}])
`), validator2 += "}", fnLiteral += validator2, fileUnions.push(candidate));
            }
          }
        }
      } else if (hasNonUnionFileWithDefault || !hasUnion && (hasType("File", unwrapImportSchema(validator.body.schema)) || hasType("Files", unwrapImportSchema(validator.body.schema)))) {
        let validateFile2 = "", i = 0;
        for (let [k, v] of Object.entries(unwrapImportSchema(validator.body.schema).properties))
          !v.extension || v[Kind] !== "File" && v[Kind] !== "Files" || (i && (validateFile2 += ","), validateFile2 += `validateFileExtension(c.body.${k},${JSON.stringify(v.extension)},'body.${k}')`, i++);
        i && (fnLiteral += `
`), i === 1 ? fnLiteral += `await ${validateFile2}
` : i > 1 && (fnLiteral += `await Promise.all([${validateFile2}])
`);
      }
    }
    if (validator.cookie) {
      let cookieValidator = getCookieValidator({
        modules: app.definitions.typebox,
        validator: validator.cookie,
        defaultConfig: app.config.cookie,
        dynamic: !!app.config.aot,
        config: validator.cookie?.config ?? {},
        models: app.definitions.type
      });
      if (fnLiteral += `const cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, cookieValidator.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(cookieValidator.schema, {})))
          fnLiteral += `cookieValue['${key}'] = ${typeof value == "object" ? JSON.stringify(value) : value}
`;
      cookieValidator.isOptional && (fnLiteral += "if(isNotEmpty(c.cookie)){"), validator.body?.schema?.noValidate !== true && (fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + validation.validate("cookie", "cookieValue") + "}"), cookieValidator.hasTransform && (fnLiteral += coerceTransformDecodeError(`for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))c.cookie[key].value=value
`, "cookie")), cookieValidator.isOptional && (fnLiteral += "}");
    }
  }
  if (hooks?.beforeHandle) {
    let reporter = report("beforeHandle", {
      total: hooks.beforeHandle.length
    }), hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let beforeHandle = hooks.beforeHandle[i], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
      if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve")
        hasResolve || (hasResolve = true, fnLiteral += `
let resolved
`), fnLiteral += isAsync(beforeHandle) ? `resolved=await e.beforeHandle[${i}](c);
` : `resolved=e.beforeHandle[${i}](c);
`, beforeHandle.subType === "mapResolve" ? fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}` : fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)throw resolved
else Object.assign(c, resolved)
`;
      else if (!returning)
        fnLiteral += isAsync(beforeHandle) ? `await e.beforeHandle[${i}](c)
` : `e.beforeHandle[${i}](c)
`, endUnit();
      else {
        if (fnLiteral += isAsync(beforeHandle) ? `be=await e.beforeHandle[${i}](c)
` : `be=e.beforeHandle[${i}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length) {
          report("handle", {
            name: isHandleFn ? handler.name : undefined
          }).resolve();
          let reporter2 = report("afterHandle", {
            total: hooks.afterHandle.length
          });
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let hook = hooks.afterHandle[i2], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
            fnLiteral += `c.response = be
`, returning2 ? (fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i2}](c)
` : `af=e.afterHandle[${i2}](c)
`, fnLiteral += `if(af!==undefined) c.response=be=af
`) : fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i2}](c, be)
` : `e.afterHandle[${i2}](c, be)
`, endUnit2("af");
          }
          reporter2.resolve();
        }
        validator.response && (fnLiteral += validation.response("be"));
        let mapResponseReporter = report("mapResponse", {
          total: hooks.mapResponse?.length
        });
        if (hooks.mapResponse?.length) {
          fnLiteral += `c.response=be
`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse4 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
            fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=mr}`, endUnit2();
          }
        }
        mapResponseReporter.resolve(), fnLiteral += encodeCookie(), fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks.afterHandle?.length) {
    let handleReporter = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    hooks.afterHandle.length ? fnLiteral += isAsyncHandler ? `let r=c.response=await ${handle}
` : `let r=c.response=${handle}
` : fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve();
    let reporter = report("afterHandle", {
      total: hooks.afterHandle.length
    });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      let hook = hooks.afterHandle[i], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
      returning ? (fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i}](c)
` : `af=e.afterHandle[${i}](c)
`, endUnit("af"), validator.response ? (fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += validation.response("af"), fnLiteral += "c.response=af}") : (fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=af}")) : (fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i}](c)
` : `e.afterHandle[${i}](c)
`, endUnit());
    }
    reporter.resolve(), fnLiteral += `r=c.response
`, validator.response && (fnLiteral += validation.response()), fnLiteral += encodeCookie();
    let mapResponseReporter = report("mapResponse", {
      total: hooks.mapResponse?.length
    });
    if (hooks.mapResponse?.length)
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        let mapResponse4 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr
`, endUnit();
      }
    mapResponseReporter.resolve(), fnLiteral += mapResponse3();
  } else {
    let handleReporter = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (validator.response || hooks.mapResponse?.length) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), validator.response && (fnLiteral += validation.response()), report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length) {
        fnLiteral += `
c.response=r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse4 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}
`, endUnit();
        }
      }
      mapResponseReporter.resolve(), fnLiteral += encodeCookie(), handler instanceof Response ? (fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`) : fnLiteral += mapResponse3();
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length) {
        fnLiteral += `c.response= r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse4 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=mr}`, endUnit();
        }
      }
      mapResponseReporter.resolve(), fnLiteral += encodeCookie() + mapResponse3();
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      report("afterHandle").resolve(), handler instanceof Response ? fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
` : fnLiteral += mapResponse3(handled);
    }
  }
  if (fnLiteral += `
}catch(error){`, !maybeAsync && hooks.error?.length && (fnLiteral += "return(async()=>{"), fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasCookie && (fnLiteral += encodeCookie()), hasTrace && hooks.trace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
  let errorReporter = report("error", {
    total: hooks.error?.length
  });
  if (hooks.error?.length) {
    fnLiteral += `c.error=error
`, hasValidation ? fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}` : fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`, fnLiteral += `let er
`;
    for (let i = 0;i < hooks.error.length; i++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      isAsync(hooks.error[i]) ? fnLiteral += `er=await e.error[${i}](c)
` : fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`, endUnit();
      let mapResponseReporter = report("mapResponse", {
        total: hooks.mapResponse?.length
      });
      if (hooks.mapResponse?.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse4 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `c.response=er
er=e.mapResponse[${i2}](c)
if(er instanceof Promise)er=await er
`, endUnit2();
        }
      if (mapResponseReporter.resolve(), fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace && hooks.trace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync && hooks.error?.length && (fnLiteral += "})()"), fnLiteral += "}", hasAfterResponse || hasTrace) {
    fnLiteral += "finally{ ", maybeAsync || (fnLiteral += ";(async()=>{");
    let reporter = report("afterResponse", {
      total: hooks.afterResponse?.length
    });
    if (hasAfterResponse && hooks.afterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
        fnLiteral += `
await e.afterResponse[${i}](c)
`, endUnit();
      }
    reporter.resolve(), maybeAsync || (fnLiteral += "})()"), fnLiteral += "}";
  }
  let adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", init = "const {handler,handleError,hooks:e, " + allocateIf("validator,", hasValidation) + "mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" + allocateIf("parseQuery,", hasBody) + allocateIf("parseQueryFromURL,", hasQuery) + "},error:{" + allocateIf("ValidationError,", hasValidation) + allocateIf("ParseError", hasBody) + "},validateFileExtension,schema,definitions,ERROR_CODE," + allocateIf("parseCookie,", hasCookie) + allocateIf("signCookie,", hasCookie) + allocateIf("decodeURIComponent,", hasQuery) + "ElysiaCustomStatusResponse," + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + allocateIf("parser,", hooks.parse?.length) + allocateIf("getServer,", inference.server) + allocateIf("fileUnions,", fileUnions.length) + adapterVariables + allocateIf("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace
return ${maybeAsync ? "async " : ""}function handle(c){`;
  hooks.beforeHandle?.length && (init += `let be
`), hooks.afterHandle?.length && (init += `let af
`), hooks.mapResponse?.length && (init += `let mr
`), allowMeta && (init += `c.schema=schema
c.defs=definitions
`), fnLiteral = init + fnLiteral + "}", init = "";
  try {
    return Function("hooks", `"use strict";
` + fnLiteral)({
      handler,
      hooks: lifeCycleToFn(hooks),
      validator: hasValidation ? validator : undefined,
      handleError: app.handleError,
      mapResponse: adapterHandler.mapResponse,
      mapCompactResponse: adapterHandler.mapCompactResponse,
      mapEarlyResponse: adapterHandler.mapEarlyResponse,
      isNotEmpty,
      utils: {
        parseQuery: hasBody ? parseQuery : undefined,
        parseQueryFromURL: hasQuery ? parseQueryFromURL : undefined
      },
      error: {
        ValidationError: hasValidation ? ValidationError : undefined,
        ParseError: hasBody ? ParseError2 : undefined
      },
      validateFileExtension,
      schema: app.router.history,
      definitions: app.definitions.type,
      ERROR_CODE,
      parseCookie: hasCookie ? parseCookie : undefined,
      signCookie: hasCookie ? signCookie : undefined,
      decodeURIComponent: hasQuery ? import_fast_decode_uri_component2.default : undefined,
      ElysiaCustomStatusResponse,
      ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
      ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
      getServer: inference.server ? () => app.getServer() : undefined,
      fileUnions: fileUnions.length ? fileUnions : undefined,
      TypeBoxError: hasValidation ? TypeBoxError : undefined,
      parser: app["~parser"],
      ...adapter.inject
    });
  } catch (error2) {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({
      handler: typeof handler == "function" ? handler.toString() : handler,
      instruction: fnLiteral,
      hooks: {
        ...debugHooks,
        transform: debugHooks?.transform?.map?.((x) => x.toString()),
        resolve: debugHooks?.resolve?.map?.((x) => x.toString()),
        beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()),
        afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()),
        mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()),
        parse: debugHooks?.parse?.map?.((x) => x.toString()),
        error: debugHooks?.error?.map?.((x) => x.toString()),
        afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()),
        stop: debugHooks?.stop?.map?.((x) => x.toString())
      },
      validator,
      definitions: app.definitions.type,
      error: error2
    }), console.log("---"), process.exit(1);
  }
};
var createOnRequestHandler = (app, addFn) => {
  let fnLiteral = "", reporter = createReport({
    trace: app.event.trace,
    addFn: addFn ?? ((word) => {
      fnLiteral += word;
    })
  })("request", {
    total: app.event.request?.length
  });
  if (app.event.request?.length) {
    fnLiteral += "try{";
    for (let i = 0;i < app.event.request.length; i++) {
      let hook = app.event.request[i], withReturn = hasReturn(hook), maybeAsync = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      withReturn ? (fnLiteral += `re=mapEarlyResponse(${maybeAsync ? "await " : ""}onRequest[${i}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`) : (fnLiteral += `${maybeAsync ? "await " : ""}onRequest[${i}](c)
`, endUnit());
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  return reporter.resolve(), fnLiteral;
};
var createHoc = (app, fnName = "map") => {
  let hoc = app.extender.higherOrderFunctions;
  if (!hoc.length)
    return "return " + fnName;
  let adapter = app["~adapter"].composeGeneralHandler, handler = fnName;
  for (let i = 0;i < hoc.length; i++)
    handler = `hoc[${i}](${handler},${adapter.parameters})`;
  return `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
};
var composeGeneralHandler = (app) => {
  let adapter = app["~adapter"].composeGeneralHandler;
  app.router.http.build();
  let error404 = adapter.error404(!!app.event.request?.length, !!app.event.error?.length), hasTrace = app.event.trace?.length, fnLiteral = "", router = app.router, findDynamicRoute = router.http.root.WS ? `const route=router.find(r.method === "GET" && r.headers.get('upgrade')==='websocket'?'WS':r.method,p)` : "const route=router.find(r.method,p)";
  findDynamicRoute += router.http.root.ALL ? `??router.find("ALL",p)
` : `
`, findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`;
  let switchMap = "";
  for (let [path, methods] of Object.entries(router.static)) {
    switchMap += `case'${path}':`, app.config.strictPath !== true && (switchMap += `case'${getLoosePath(path)}':`);
    let encoded = encodePath(path);
    path !== encoded && (switchMap += `case'${encoded}':`), switchMap += "switch(r.method){", (("GET" in methods) || ("WS" in methods)) && (switchMap += "case 'GET':", ("WS" in methods) && (switchMap += `if(r.headers.get('upgrade')==='websocket')return ht[${methods.WS}].composed(c)
`), ("GET" in methods) && (switchMap += `return ht[${methods.GET}].composed(c)
`));
    for (let [method, index] of Object.entries(methods))
      method === "ALL" || method === "GET" || method === "WS" || (switchMap += `case '${method}':return ht[${index}].composed(c)
`);
    "ALL" in methods ? switchMap += `default:return ht[${methods.ALL}].composed(c)
` : switchMap += `default:break map
`, switchMap += "}";
  }
  let maybeAsync = !!app.event.request?.some(isAsync), adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,` + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request?.length && (fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`), fnLiteral += error404.declare, app.event.trace?.length && (fnLiteral += "const " + app.event.trace.map((_, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`), fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`, app.event.request?.length && (fnLiteral += `let re
`), fnLiteral += adapter.createContext(app), app.event.trace?.length && (fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_, i) => `tr${i}(c)`).join(",") + `]
`), fnLiteral += createOnRequestHandler(app), switchMap && (fnLiteral += `
map: switch(p){
` + switchMap + "}"), fnLiteral += findDynamicRoute + `}
` + createHoc(app);
  let handleError = composeErrorHandler(app);
  app.handleError = handleError;
  let fn = Function("data", `"use strict";
` + fnLiteral)({
    app,
    mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse,
    NotFoundError,
    randomId,
    handleError,
    status,
    redirect,
    ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
    ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
    ...adapter.inject
  });
  return isBun && Bun.gc(false), fn;
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "", adapter = app["~adapter"].composeError, adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", hasTrace = !!app.event.trace?.length;
  fnLiteral += "const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse," + allocateIf("onError,", app.event.error) + allocateIf("afterResponse,", app.event.afterResponse) + allocateIf("trace,", app.event.trace) + allocateIf("onMapResponse,", app.event.mapResponse) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=inject
`, fnLiteral += `return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`, fnLiteral += "", hasTrace && (fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`);
  let report = createReport({
    context: "context",
    trace: hooks.trace,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter.declare && (fnLiteral += adapter.declare);
  let saveResponse = hasTrace || hooks.afterResponse?.length || hooks.afterResponse?.length ? "context.response = " : "";
  if (app.event.error)
    for (let i = 0;i < app.event.error.length; i++) {
      let handler = app.event.error[i], response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
      if (fnLiteral += "if(skipGlobal!==true){", hasReturn(handler)) {
        fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})
if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
        let mapResponseReporter2 = report("mapResponse", {
          total: hooks.mapResponse?.length,
          name: "context"
        });
        if (hooks.mapResponse?.length)
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse3 = hooks.mapResponse[i2], endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
            fnLiteral += `context.response=_r_r=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
`, endUnit();
          }
        mapResponseReporter2.resolve(), fnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
      } else
        fnLiteral += response;
      fnLiteral += "}";
    }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){
if(error.error)error=error.error
set.status=error.status??422
` + adapter.validationError + `
}
`, fnLiteral += `if(error instanceof Error){
if(typeof error.toResponse==='function')return context.response=error.toResponse()
` + adapter.unknownError + `
}`;
  let mapResponseReporter = report("mapResponse", {
    total: hooks.mapResponse?.length,
    name: "context"
  });
  if (fnLiteral += `
if(!context.response)context.response=error.message??error
`, hooks.mapResponse?.length) {
    fnLiteral += `let mr
`;
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      let mapResponse3 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=mr}`, endUnit();
    }
  }
  mapResponseReporter.resolve(), fnLiteral += `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`;
  let mapFn = (x) => typeof x == "function" ? x : x.fn;
  return Function("inject", `"use strict";
` + fnLiteral)({
    mapResponse: app["~adapter"].handler.mapResponse,
    ERROR_CODE,
    ElysiaCustomStatusResponse,
    onError: app.event.error?.map(mapFn),
    afterResponse: app.event.afterResponse?.map(mapFn),
    trace: app.event.trace?.map(mapFn),
    onMapResponse: app.event.mapResponse?.map(mapFn),
    ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
    ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
    ...adapter.inject
  });
};
var mapResponse2 = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse2(response.response, set2, request);
      case "ReadableStream":
        return set2.headers["content-type"]?.startsWith("text/event-stream") || (set2.headers["content-type"] = "text/event-stream; charset=utf-8"), request?.signal?.addEventListener("abort", {
          handleEvent() {
            request?.signal && !request?.signal?.aborted && response.cancel();
          }
        }, {
          once: true
        }), new Response(response, set2);
      case undefined:
        return response ? new Response(JSON.stringify(response), set2) : new Response("", set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Error":
        return errorToResponse2(response, set2);
      case "Promise":
        return response.then((x) => mapResponse2(x, set2, request));
      case "Function":
        return mapResponse2(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        return response instanceof Cookie ? new Response(response.value, set2) : new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x) => mapResponse2(x, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse2(response.response, set2, request);
        if (typeof response?.next == "function")
          return handleStream2(response, set2, request);
        if (typeof response?.then == "function")
          return response.then((x) => mapResponse2(x, set2));
        if (typeof response?.toResponse == "function")
          return mapResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91)
            return set2.headers["Content-Type"] || (set2.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(response), set2);
        }
        return new Response(response, set2);
    }
  return response instanceof Response && !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked" ? handleStream2(streamResponse(response), responseToSetHeaders(response, set2), request) : typeof response?.next == "function" || response instanceof ReadableStream ? handleStream2(response, set2, request) : mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
  if (response != null)
    if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
      switch (handleSet(set2), response?.constructor?.name) {
        case "String":
          return new Response(response, set2);
        case "Array":
        case "Object":
          return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
        case "ElysiaFile":
          return handleFile(response.value);
        case "File":
          return handleFile(response, set2);
        case "Blob":
          return handleFile(response, set2);
        case "ElysiaCustomStatusResponse":
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        case "ReadableStream":
          return set2.headers["content-type"]?.startsWith("text/event-stream") || (set2.headers["content-type"] = "text/event-stream; charset=utf-8"), request?.signal?.addEventListener("abort", {
            handleEvent() {
              request?.signal && !request?.signal?.aborted && response.cancel();
            }
          }, {
            once: true
          }), new Response(response, set2);
        case undefined:
          return response ? new Response(JSON.stringify(response), set2) : undefined;
        case "Response":
          return handleResponse2(response, set2, request);
        case "Promise":
          return response.then((x) => mapEarlyResponse2(x, set2));
        case "Error":
          return errorToResponse2(response, set2);
        case "Function":
          return mapEarlyResponse2(response(), set2);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set2);
        case "FormData":
          return new Response(response);
        case "Cookie":
          return response instanceof Cookie ? new Response(response.value, set2) : new Response(response?.toString(), set2);
        default:
          if (response instanceof Response)
            return handleResponse2(response, set2, request);
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse2(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if (response instanceof ElysiaCustomStatusResponse)
            return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
          if (typeof response?.next == "function")
            return handleStream2(response, set2, request);
          if (typeof response?.then == "function")
            return response.then((x) => mapEarlyResponse2(x, set2));
          if (typeof response?.toResponse == "function")
            return mapEarlyResponse2(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            let code = response.charCodeAt(0);
            if (code === 123 || code === 91)
              return set2.headers["Content-Type"] || (set2.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(response), set2);
          }
          return new Response(response, set2);
      }
    else
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Array":
        case "Object":
          return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
        case "ElysiaFile":
          return handleFile(response.value);
        case "File":
          return handleFile(response, set2);
        case "Blob":
          return handleFile(response, set2);
        case "ElysiaCustomStatusResponse":
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        case "ReadableStream":
          return request?.signal?.addEventListener("abort", {
            handleEvent() {
              request?.signal && !request?.signal?.aborted && response.cancel();
            }
          }, {
            once: true
          }), new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          return response ? new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          }) : new Response("");
        case "Response":
          return !response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked" ? handleStream2(streamResponse(response), responseToSetHeaders(response), request) : response;
        case "Promise":
          return response.then((x) => {
            let r = mapEarlyResponse2(x, set2);
            if (r !== undefined)
              return r;
          });
        case "Error":
          return errorToResponse2(response, set2);
        case "Function":
          return mapCompactResponse2(response(), request);
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          return response instanceof Cookie ? new Response(response.value, set2) : new Response(response?.toString(), set2);
        case "FormData":
          return new Response(response);
        default:
          if (response instanceof Response)
            return response;
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse2(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if (response instanceof ElysiaCustomStatusResponse)
            return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
          if (typeof response?.next == "function")
            return handleStream2(response, set2, request);
          if (typeof response?.then == "function")
            return response.then((x) => mapEarlyResponse2(x, set2));
          if (typeof response?.toResponse == "function")
            return mapEarlyResponse2(response.toResponse(), set2);
          if ("charCodeAt" in response) {
            let code = response.charCodeAt(0);
            if (code === 123 || code === 91)
              return set2.headers["Content-Type"] || (set2.headers["Content-Type"] = "application/json"), new Response(JSON.stringify(response), set2);
          }
          return new Response(response);
      }
};
var mapCompactResponse2 = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "Content-Type": "application/json"
        }
      });
    case "ElysiaFile":
      return handleFile(response.value);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, {
        status: response.code,
        headers: {}
      });
    case "ReadableStream":
      return request?.signal?.addEventListener("abort", {
        handleEvent() {
          request?.signal && !request?.signal?.aborted && response.cancel();
        }
      }, {
        once: true
      }), new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      return response ? new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      }) : new Response("");
    case "Response":
      return response.headers.get("transfer-encoding") === "chunked" ? handleStream2(streamResponse(response), responseToSetHeaders(response), request) : response;
    case "Error":
      return errorToResponse2(response);
    case "Promise":
      return response.then((x) => mapCompactResponse2(x, request));
    case "Function":
      return mapCompactResponse2(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse2(x, request));
      if (response instanceof Error)
        return errorToResponse2(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse2(response.response, {
          status: response.code,
          headers: {}
        });
      if (typeof response?.next == "function")
        return handleStream2(response, undefined, request);
      if (typeof response?.then == "function")
        return response.then((x) => mapResponse2(x, set));
      if (typeof response?.toResponse == "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
      }
      return new Response(response);
  }
};
var errorToResponse2 = (error2, set2) => new Response(JSON.stringify({
  name: error2?.name,
  message: error2?.message,
  cause: error2?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle == "function")
    return;
  let response = mapResponse2(handle, {
    headers: setHeaders
  });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return response.clone.bind(response);
};
var handleResponse2 = createResponseHandler({
  mapResponse: mapResponse2,
  mapCompactResponse: mapCompactResponse2
});
var handleStream2 = createStreamHandler({
  mapResponse: mapResponse2,
  mapCompactResponse: mapCompactResponse2
});
var allocateIf2 = (value, condition) => condition ? value : "";
var createContext = (app, route, inference, isInline = false) => {
  let fnLiteral = "", defaultHeaders = app.setHeaders, hasTrace = !!app.event.trace?.length;
  hasTrace && (fnLiteral += `const id=randomId()
`);
  let isDynamic = /[:*]/.test(route.path), getQi = `const u=request.url,s=u.indexOf('/',${app.config.handler?.standardHostname ?? true ? 11 : 7}),qi=u.indexOf('?', s + 1)
`, needsQuery = inference.query || !!route.hooks.query || !!route.standaloneValidators?.find((x) => x.query) || app.event.request?.length;
  needsQuery && (fnLiteral += getQi);
  let getPath = inference.path ? isDynamic ? "get path(){" + (needsQuery ? "" : getQi) + `if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},` : `path:'${route.path}',` : "";
  fnLiteral += allocateIf2("const c=", !isInline) + "{request,store," + allocateIf2("qi,", needsQuery) + allocateIf2("params:request.params,", isDynamic) + getPath + allocateIf2("url:request.url,", hasTrace || inference.url || needsQuery) + "redirect,error:status,status,set:{headers:" + (isNotEmpty(defaultHeaders) ? "Object.assign({},app.setHeaders)" : "Object.create(null)") + ",status:200}", inference.server && (fnLiteral += ",get server(){return app.getServer()}"), hasTrace && (fnLiteral += ",[ELYSIA_REQUEST_ID]:id");
  {
    let decoratorsLiteral = "";
    for (let key of Object.keys(app.singleton.decorator))
      decoratorsLiteral += `,'${key}':decorator['${key}']`;
    fnLiteral += decoratorsLiteral;
  }
  return fnLiteral += `}
`, fnLiteral;
};
var createBunRouteHandler = (app, route) => {
  let hasTrace = !!app.event.trace?.length, hasHoc = !!app.extender.higherOrderFunctions.length, inference = sucrose(route.hooks, app.inference);
  inference = sucrose({
    handler: route.handler
  }, inference);
  let fnLiteral = "const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse," + allocateIf2("randomId=data.randomId,", hasTrace) + allocateIf2("ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,", hasTrace) + allocateIf2("ELYSIA_TRACE=data.ELYSIA_TRACE,", hasTrace) + allocateIf2("trace=data.trace,", hasTrace) + allocateIf2("hoc=data.hoc,", hasHoc) + `status=data.status
`;
  app.event.request?.length && (fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`), fnLiteral += `${app.event.request?.find(isAsync) ? "async" : ""} function map(request){`;
  let needsQuery = inference.query || !!route.hooks.query || !!route.standaloneValidators?.find((x) => x.query);
  return hasTrace || needsQuery || app.event.request?.length ? (fnLiteral += createContext(app, route, inference), fnLiteral += createOnRequestHandler(app), fnLiteral += "return handler(c)}") : fnLiteral += `return handler(${createContext(app, route, inference, true)})}`, fnLiteral += createHoc(app), Function("data", fnLiteral)({
    app,
    handler: route.compile?.() ?? route.composed,
    redirect,
    status,
    hoc: app.extender.higherOrderFunctions.map((x) => x.fn),
    store: app.store,
    decorator: app.decorator,
    route: route.path,
    randomId: hasTrace ? randomId : undefined,
    ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
    ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
    trace: hasTrace ? app.event.trace?.map((x) => x?.fn ?? x) : undefined,
    mapEarlyResponse: mapEarlyResponse2
  });
};
var createNativeStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle == "function" || handle instanceof Blob)
    return;
  if (typeof handle == "object" && handle?.toString() === "[object HTMLBundle]")
    return () => handle;
  let response = mapResponse2(handle, {
    headers: setHeaders
  });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return response instanceof Promise ? response.then((response2) => {
      if (response2)
        return response2.headers.has("content-type") || response2.headers.append("content-type", "text/plain"), response2.clone();
    }) : (response.headers.has("content-type") || response.headers.append("content-type", "text/plain"), () => response.clone());
};
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message) {
    ws.data.message?.(ws, message);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code, reason) {
    ws.data.close?.(ws, code, reason);
  }
};
var ElysiaWS = class {
  constructor(raw, data, body = undefined) {
    this.raw = raw;
    this.data = data;
    this.body = body;
    this.validator = raw.data?.validator, this.sendText = raw.sendText.bind(raw), this.sendBinary = raw.sendBinary.bind(raw), this.close = raw.close.bind(raw), this.terminate = raw.terminate.bind(raw), this.publishText = raw.publishText.bind(raw), this.publishBinary = raw.publishBinary.bind(raw), this.subscribe = raw.subscribe.bind(raw), this.unsubscribe = raw.unsubscribe.bind(raw), this.isSubscribed = raw.isSubscribed.bind(raw), this.cork = raw.cork.bind(raw), this.remoteAddress = raw.remoteAddress, this.binaryType = raw.binaryType, this.data = raw.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  get id() {
    return this.data.id;
  }
  send(data, compress) {
    return Buffer.isBuffer(data) ? this.raw.send(data, compress) : this.validator?.Check(data) === false ? this.raw.send(new ValidationError("message", this.validator, data).message) : (typeof data == "object" && (data = JSON.stringify(data)), this.raw.send(data, compress));
  }
  ping(data) {
    return Buffer.isBuffer(data) ? this.raw.ping(data) : this.validator?.Check(data) === false ? this.raw.send(new ValidationError("message", this.validator, data).message) : (typeof data == "object" && (data = JSON.stringify(data)), this.raw.ping(data));
  }
  pong(data) {
    return Buffer.isBuffer(data) ? this.raw.pong(data) : this.validator?.Check(data) === false ? this.raw.send(new ValidationError("message", this.validator, data).message) : (typeof data == "object" && (data = JSON.stringify(data)), this.raw.pong(data));
  }
  publish(topic, data, compress) {
    return Buffer.isBuffer(data) ? this.raw.publish(topic, data, compress) : this.validator?.Check(data) === false ? this.raw.send(new ValidationError("message", this.validator, data).message) : (typeof data == "object" && (data = JSON.stringify(data)), this.raw.publish(topic, data, compress));
  }
  get readyState() {
    return this.raw.readyState;
  }
};
var createWSMessageParser = (parse22) => {
  let parsers = typeof parse22 == "function" ? [parse22] : parse22;
  return async function(ws, message) {
    if (typeof message == "string") {
      let start = message?.charCodeAt(0);
      if (start === 34 || start === 47 || start === 91 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {
        }
      else
        isNumericString(message) ? message = +message : message === "true" ? message = true : message === "false" ? message = false : message === "null" && (message = null);
    }
    if (parsers)
      for (let i = 0;i < parsers.length; i++) {
        let temp = parsers[i](ws, message);
        if (temp instanceof Promise && (temp = await temp), temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError("message", validateResponse, datum).message);
      if (typeof datum == "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next != "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError("message", validateResponse, first).message);
        if (send(first.value), !first.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var optionalParam = /:.+?\?(?=\/|$)/;
var getPossibleParams = (path) => {
  let match = optionalParam.exec(path);
  if (!match)
    return [path];
  let routes = [], head = path.slice(0, match.index), param = match[0].slice(0, -1), tail = path.slice(match.index + match[0].length);
  routes.push(head.slice(0, -1)), routes.push(head + param);
  for (let fragment of getPossibleParams(tail))
    fragment && (fragment.startsWith("/:") || routes.push(head.slice(0, -1) + fragment), routes.push(head + param + fragment));
  return routes;
};
var supportedMethods = {
  GET: true,
  HEAD: true,
  OPTIONS: true,
  DELETE: true,
  PATCH: true,
  POST: true,
  PUT: true
};
var mapRoutes = (app) => {
  if (!app.config.aot || !app.config.systemRouter)
    return;
  let routes = {}, add = (route, handler) => {
    routes[route.path] ? routes[route.path][route.method] || (routes[route.path][route.method] = handler) : routes[route.path] = {
      [route.method]: handler
    };
  }, tree = app.routeTree;
  for (let route of app.router.history) {
    if (typeof route.handler != "function")
      continue;
    let method = route.method;
    if (method === "GET" && `WS_${route.path}` in tree || method === "WS" || route.path.charCodeAt(route.path.length - 1) === 42 || !(method in supportedMethods))
      continue;
    if (method === "ALL") {
      `WS_${route.path}` in tree || (routes[route.path] = route.hooks?.config?.mount ? route.hooks.trace || app.event.trace || app.extender.higherOrderFunctions ? createBunRouteHandler(app, route) : route.hooks.mount || route.handler : route.handler);
      continue;
    }
    let compiled, handler = app.config.precompile ? createBunRouteHandler(app, route) : (request) => compiled ? compiled(request) : (compiled = createBunRouteHandler(app, route))(request);
    for (let path of getPossibleParams(route.path))
      add({
        method,
        path
      }, handler);
  }
  return routes;
};
var mergeRoutes = (r1, r2) => {
  if (!r2)
    return r1;
  for (let key of Object.keys(r2))
    if (r1[key] !== r2[key]) {
      if (!r1[key]) {
        r1[key] = r2[key];
        continue;
      }
      if (r1[key] && r2[key]) {
        if (typeof r1[key] == "function" || r1[key] instanceof Response) {
          r1[key] = r2[key];
          continue;
        }
        r1[key] = {
          ...r1[key],
          ...r2[key]
        };
      }
    }
  return r1;
};
var BunAdapter = {
  ...WebStandardAdapter,
  name: "bun",
  handler: {
    mapResponse: mapResponse2,
    mapEarlyResponse: mapEarlyResponse2,
    mapCompactResponse: mapCompactResponse2,
    createStaticHandler: createStaticHandler2,
    createNativeStaticHandler
  },
  composeHandler: {
    ...WebStandardAdapter.composeHandler,
    headers: hasHeaderShorthand ? `c.headers=c.request.headers.toJSON()
` : `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`
  },
  listen(app) {
    return (options, callback) => {
      if (typeof Bun > "u")
        throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      if (app.compile(), typeof options == "string") {
        if (!isNumericString(options))
          throw new Error("Port must be a numeric value");
        options = parseInt(options);
      }
      let createStaticRoute = (iterator, { withAsync = false } = {}) => {
        let staticRoutes = {}, ops = [];
        for (let [path, route] of Object.entries(iterator))
          if (supportPerMethodInlineHandler) {
            if (!route)
              continue;
            for (let [method, value] of Object.entries(route))
              if (!(!value || !(method in supportedMethods))) {
                if (value instanceof Promise) {
                  withAsync && (staticRoutes[path] || (staticRoutes[path] = {}), ops.push(value.then((awaited) => {
                    awaited instanceof Response && (staticRoutes[path][method] = awaited), typeof awaited == "object" && awaited?.toString() === "[object HTMLBundle]" && (staticRoutes[path][method] = awaited);
                  })));
                  continue;
                }
                !(value instanceof Response) && !(typeof value == "object" && value?.toString() === "[object HTMLBundle]") || (staticRoutes[path] || (staticRoutes[path] = {}), staticRoutes[path][method] = value);
              }
          } else {
            if (!route)
              continue;
            if (route instanceof Promise) {
              withAsync && (staticRoutes[path] || (staticRoutes[path] = {}), ops.push(route.then((awaited) => {
                awaited instanceof Response && (staticRoutes[path] = awaited);
              })));
              continue;
            }
            if (!(route instanceof Response))
              continue;
            staticRoutes[path] = route;
          }
        return withAsync ? Promise.all(ops).then(() => staticRoutes) : staticRoutes;
      }, serve = typeof options == "object" ? {
        development: !isProduction,
        reusePort: true,
        ...app.config.serve || {},
        ...options || {},
        routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes),
        websocket: {
          ...app.config.websocket || {},
          ...websocket || {}
        },
        fetch: app.fetch
      } : {
        development: !isProduction,
        reusePort: true,
        ...app.config.serve || {},
        routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes),
        websocket: {
          ...app.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch: app.fetch
      };
      if (app.server = Bun.serve(serve), app.event.start)
        for (let i = 0;i < app.event.start.length; i++)
          app.event.start[i].fn(app);
      callback && callback(app.server), process.on("beforeExit", () => {
        if (app.server && (app.server.stop?.(), app.server = null, app.event.stop))
          for (let i = 0;i < app.event.stop.length; i++)
            app.event.stop[i].fn(app);
      }), app.promisedModules.then(async () => {
        app.server?.reload({
          ...serve,
          fetch: app.fetch,
          routes: mergeRoutes(mergeRoutes(await createStaticRoute(app.router.response, {
            withAsync: true
          }), mapRoutes(app)), app.config.serve?.routes)
        }), Bun?.gc(false);
      });
    };
  },
  async stop(app, closeActiveConnections) {
    if (app.server) {
      if (app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
        for (let i = 0;i < app.event.stop.length; i++)
          app.event.stop[i].fn(app);
    } else
      console.log("Elysia isn't running. Call `app.listen` to start the server.", new Error().stack);
  },
  ws(app, path, options) {
    let { parse: parse22, body, response, ...rest } = options, validateMessage = getSchemaValidator(body, {
      modules: app.definitions.typebox,
      models: app.definitions.type,
      normalize: app.config.normalize
    }), validateResponse = getSchemaValidator(response, {
      modules: app.definitions.typebox,
      models: app.definitions.type,
      normalize: app.config.normalize
    });
    app.route("WS", path, async (context) => {
      let server = context.server ?? app.server, { set: set2, path: path2, qi, headers, query, params } = context;
      if (context.validator = validateResponse, options.upgrade)
        if (typeof options.upgrade == "function") {
          let temp = options.upgrade(context);
          temp instanceof Promise && await temp;
        } else
          options.upgrade && Object.assign(set2.headers, options.upgrade);
      if (set2.cookie && isNotEmpty(set2.cookie)) {
        let cookie = serializeCookie(set2.cookie);
        cookie && (set2.headers["set-cookie"] = cookie);
      }
      set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]) && (set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]));
      let handleResponse3 = createHandleWSResponse(validateResponse), parseMessage = createWSMessageParser(parse22), _id;
      if (typeof options.beforeHandle == "function") {
        let result = options.beforeHandle(context);
        result instanceof Promise && await result;
      }
      let errorHandlers = [
        ...options.error ? Array.isArray(options.error) ? options.error : [options.error] : [],
        ...(app.event.error ?? []).map((x) => typeof x == "function" ? x : x.fn)
      ].filter((x) => x), handleErrors = errorHandlers.length ? async (ws, error2) => {
        for (let handleError of errorHandlers) {
          let response2 = handleError(Object.assign(context, { error: error2 }));
          if (response2 instanceof Promise && (response2 = await response2), await handleResponse3(ws, response2), response2)
            break;
        }
      } : () => {
      };
      if (!server?.upgrade(context.request, {
        headers: isNotEmpty(set2.headers) ? set2.headers : undefined,
        data: {
          ...context,
          get id() {
            return _id || (_id = randomId());
          },
          validator: validateResponse,
          ping(data) {
            options.ping?.(data);
          },
          pong(data) {
            options.pong?.(data);
          },
          open: async (ws) => {
            try {
              await handleResponse3(ws, options.open?.(new ElysiaWS(ws, context)));
            } catch (error2) {
              handleErrors(ws, error2);
            }
          },
          message: async (ws, _message) => {
            let message = await parseMessage(ws, _message);
            if (validateMessage?.Check(message) === false)
              return void ws.send(new ValidationError("message", validateMessage, message).message);
            try {
              await handleResponse3(ws, options.message?.(new ElysiaWS(ws, context, message), message));
            } catch (error2) {
              handleErrors(ws, error2);
            }
          },
          drain: async (ws) => {
            try {
              await handleResponse3(ws, options.drain?.(new ElysiaWS(ws, context)));
            } catch (error2) {
              handleErrors(ws, error2);
            }
          },
          close: async (ws, code, reason) => {
            try {
              await handleResponse3(ws, options.close?.(new ElysiaWS(ws, context), code, reason));
            } catch (error2) {
              handleErrors(ws, error2);
            }
          }
        }
      }))
        return set2.status = 400, "Expected a websocket connection";
    }, {
      ...rest,
      websocket: options
    });
  }
};
var env2 = isBun ? Bun.env : typeof process < "u" && process?.env ? process.env : {};
var injectDefaultValues = (typeChecker, obj) => {
  for (let [key, keySchema] of Object.entries(typeChecker.schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
  let { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler;
  return async (request) => {
    let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set2 = {
      cookie: {},
      status: 200,
      headers: {}
    }, context = Object.assign({}, app.singleton.decorator, {
      set: set2,
      store: app.singleton.store,
      request,
      path,
      qi,
      error: status,
      status,
      redirect
    });
    try {
      if (app.event.request)
        for (let i = 0;i < app.event.request.length; i++) {
          let onRequest = app.event.request[i].fn, response2 = onRequest(context);
          if (response2 instanceof Promise && (response2 = await response2), response2 = mapEarlyResponse3(response2, set2), response2)
            return context.response = response2;
        }
      let methodKey = request.method === "GET" && request.headers.get("upgrade")?.toLowerCase() === "websocket" ? "WS" : request.method, handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find(methodKey, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw new NotFoundError;
      let { handle, hooks, validator, content, route } = handler.store, body;
      if (request.method !== "GET" && request.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value = form2.getAll(key);
                value.length === 1 ? body[key] = value[0] : body[key] = value;
              }
              break;
          }
        else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1 && (contentType = contentType.slice(0, index)), context.contentType = contentType, hooks.parse)
              for (let i = 0;i < hooks.parse.length; i++) {
                let hook = hooks.parse[i].fn, temp = hook(context, contentType);
                if (temp instanceof Promise && (temp = await temp), temp) {
                  body = temp;
                  break;
                }
              }
            if (delete context.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value = form2.getAll(key);
                    value.length === 1 ? body[key] = value[0] : body[key] = value;
                  }
                  break;
              }
          }
        }
      context.route = route, context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), context.headers = {};
      for (let [key, value] of request.headers.entries())
        context.headers[key] = value;
      let cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config), cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? {
        secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets == "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
        sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign == "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
      } : undefined);
      let headerValidator = validator?.createHeaders?.();
      headerValidator && injectDefaultValues(headerValidator, context.headers);
      let paramsValidator = validator?.createParams?.();
      paramsValidator && injectDefaultValues(paramsValidator, context.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator && injectDefaultValues(queryValidator, context.query), hooks.transform)
        for (let i = 0;i < hooks.transform.length; i++) {
          let hook = hooks.transform[i], response2 = hook.fn(context);
          if (response2 instanceof Promise && (response2 = await response2), response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          hook.subType === "derive" && Object.assign(context, response2);
        }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context.headers);
          for (let [key, value] of request.headers)
            _header[key] = value;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        } else
          validator.headers?.Decode && (context.headers = validator.headers.Decode(context.headers));
        if (paramsValidator?.Check(context.params) === false)
          throw new ValidationError("params", validator.params, context.params);
        if (validator.params?.Decode && (context.params = validator.params.Decode(context.params)), queryValidator?.Check(context.query) === false)
          throw new ValidationError("query", validator.query, context.query);
        if (validator.query?.Decode && (context.query = validator.query.Decode(context.query)), validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
          validator.cookie?.Decode && (cookieValue = validator.cookie.Decode(cookieValue));
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
        validator.body?.Decode && (context.body = validator.body.Decode(body));
      }
      if (hooks.beforeHandle)
        for (let i = 0;i < hooks.beforeHandle.length; i++) {
          let hook = hooks.beforeHandle[i], response2 = hook.fn(context);
          if (response2 instanceof Promise && (response2 = await response2), response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "resolve") {
            Object.assign(context, response2);
            continue;
          }
          if (response2 !== undefined) {
            if (context.response = response2, hooks.afterHandle)
              for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
                let newResponse = hooks.afterHandle[i2].fn(context);
                newResponse instanceof Promise && (newResponse = await newResponse), newResponse && (response2 = newResponse);
              }
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
        }
      let response = typeof handle == "function" ? handle(context) : handle;
      if (response instanceof Promise && (response = await response), hooks.afterHandle)
        if (hooks.afterHandle.length) {
          context.response = response;
          for (let i = 0;i < hooks.afterHandle.length; i++) {
            let newResponse = hooks.afterHandle[i].fn(context);
            newResponse instanceof Promise && (newResponse = await newResponse);
            let result = mapEarlyResponse3(newResponse, context.set);
            if (result !== undefined) {
              let responseValidator = validator?.response?.[result.status];
              if (responseValidator?.Check(result) === false)
                throw new ValidationError("response", responseValidator, result);
              return responseValidator?.Encode && (response = responseValidator.Encode(response)), context.response = result;
            }
          }
        } else {
          let status2 = response instanceof ElysiaCustomStatusResponse ? response.code : set2.status ? typeof set2.status == "string" ? StatusMap[set2.status] : set2.status : 200, responseValidator = validator?.createResponse?.()?.[status2];
          if (responseValidator?.Check(response) === false)
            throw new ValidationError("response", responseValidator, response);
          responseValidator?.Encode && (response = responseValidator.Encode(response));
        }
      if (context.set.cookie && cookieMeta?.sign) {
        let secret = cookieMeta.secrets ? typeof cookieMeta.secrets == "string" ? cookieMeta.secrets : cookieMeta.secrets[0] : undefined;
        if (cookieMeta.sign === true) {
          if (secret)
            for (let [key, cookie] of Object.entries(context.set.cookie))
              context.set.cookie[key].value = await signCookie(cookie.value, secret);
        } else {
          let properties = validator?.cookie?.schema?.properties;
          if (secret)
            for (let name of cookieMeta.sign)
              name in properties && context.set.cookie[name]?.value && (context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret));
        }
      }
      return mapResponse3(context.response = response, context.set);
    } catch (error2) {
      let reportedError = error2 instanceof TransformDecodeError && error2.error ? error2.error : error2;
      return app.handleError(context, reportedError);
    } finally {
      if (app.event.afterResponse)
        for (let afterResponse of app.event.afterResponse)
          await afterResponse.fn(context);
    }
  };
};
var createDynamicErrorHandler = (app) => {
  let { mapResponse: mapResponse3 } = app["~adapter"].handler;
  return async (context, error2) => {
    let errorContext = Object.assign(context, { error: error2, code: error2.code });
    if (errorContext.set = context.set, app.event.error)
      for (let i = 0;i < app.event.error.length; i++) {
        let response = app.event.error[i].fn(errorContext);
        if (response instanceof Promise && (response = await response), response != null)
          return context.response = mapResponse3(response, context.set);
      }
    return new Response(typeof error2.cause == "string" ? error2.cause : error2.message, {
      headers: context.set.headers,
      status: error2.status ?? 500
    });
  };
};
var _a2;
_a2 = Symbol.dispose;
var _Elysia = class _Elysia2 {
  constructor(config = {}) {
    this.server = null;
    this.dependencies = {};
    this["~Prefix"] = "";
    this["~Singleton"] = null;
    this["~Definitions"] = null;
    this["~Metadata"] = null;
    this["~Ephemeral"] = null;
    this["~Volatile"] = null;
    this["~Routes"] = null;
    this.singleton = {
      decorator: {},
      store: {},
      derive: {},
      resolve: {}
    };
    this.definitions = {
      typebox: t.Module({}),
      type: {},
      error: {}
    };
    this.extender = {
      macros: [],
      higherOrderFunctions: []
    };
    this.validator = {
      global: null,
      scoped: null,
      local: null,
      getCandidate() {
        return !this.global && !this.scoped && !this.local ? {
          body: undefined,
          headers: undefined,
          params: undefined,
          query: undefined,
          cookie: undefined,
          response: undefined
        } : mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
      }
    };
    this.standaloneValidator = {
      global: null,
      scoped: null,
      local: null
    };
    this.event = {};
    this.router = {
      "~http": undefined,
      get http() {
        return this["~http"] || (this["~http"] = new Memoirist({ lazy: true })), this["~http"];
      },
      "~dynamic": undefined,
      get dynamic() {
        return this["~dynamic"] || (this["~dynamic"] = new Memoirist), this["~dynamic"];
      },
      static: {},
      response: {},
      history: []
    };
    this.routeTree = {};
    this.inference = {
      body: false,
      cookie: false,
      headers: false,
      query: false,
      set: false,
      server: false,
      path: false,
      route: false,
      url: false
    };
    this["~parser"] = {};
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    this.handleError = async (context, error2) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error2);
    this.listen = (options, callback) => (this["~adapter"].listen(this)(options, callback), this.promisedModules.size && clearSucroseCache(5000), this.promisedModules.then(() => {
      clearSucroseCache(1000);
    }), this);
    this.stop = async (closeActiveConnections) => (await this["~adapter"].stop?.(this, closeActiveConnections), this);
    this[_a2] = () => {
      this.server && this.stop();
    };
    config.tags && (config.detail ? config.detail.tags = config.tags : config.detail = {
      tags: config.tags
    }), this.config = {
      prefix: "",
      aot: env2.ELYSIA_AOT !== "false",
      nativeStaticResponse: true,
      systemRouter: true,
      encodeSchema: true,
      normalize: true,
      ...config,
      cookie: {
        path: "/",
        ...config?.cookie
      },
      experimental: config?.experimental ?? {},
      seed: config?.seed === undefined ? "" : config?.seed
    }, this["~adapter"] = config.adapter ?? (typeof Bun < "u" ? BunAdapter : WebStandardAdapter), config?.analytic && (config?.name || config?.seed !== undefined) && (this.telemetry = {
      stack: new Error().stack
    });
  }
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getGlobalDefinitions() {
    return this.definitions;
  }
  getServer() {
    return this.server;
  }
  getParent() {
    return null;
  }
  get promisedModules() {
    return this._promisedModules || (this._promisedModules = new PromiseGroup(console.error, () => {
    })), this._promisedModules;
  }
  env(model, _env = env2) {
    if (getSchemaValidator(model, {
      modules: this.definitions.typebox,
      dynamic: true,
      additionalProperties: true,
      coerce: true,
      sanitize: () => this.config.sanitize
    }).Check(_env) === false) {
      let error2 = new ValidationError("env", model, _env);
      throw new Error(error2.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({
      checksum: checksum(JSON.stringify({
        name: this.config.name,
        seed: this.config.seed,
        content: fn.toString()
      })),
      fn
    }), this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      let manage = createMacroManager({
        globalHook: this.event,
        localHook
      }), manager = {
        events: {
          global: this.event,
          local: localHook
        },
        get onParse() {
          return manage("parse");
        },
        get onTransform() {
          return manage("transform");
        },
        get onBeforeHandle() {
          return manage("beforeHandle");
        },
        get onAfterHandle() {
          return manage("afterHandle");
        },
        get mapResponse() {
          return manage("mapResponse");
        },
        get onAfterResponse() {
          return manage("afterResponse");
        },
        get onError() {
          return manage("error");
        }
      };
      for (let macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook, manage);
    }
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, options, standaloneValidators) {
    let skipPrefix = options?.skipPrefix ?? false, allowMeta = options?.allowMeta ?? false;
    if (localHook ??= {}, standaloneValidators === undefined && (standaloneValidators = [], this.standaloneValidator.local && (standaloneValidators = standaloneValidators.concat(this.standaloneValidator.local)), this.standaloneValidator.scoped && (standaloneValidators = standaloneValidators.concat(this.standaloneValidator.scoped)), this.standaloneValidator.global && (standaloneValidators = standaloneValidators.concat(this.standaloneValidator.global))), path !== "" && path.charCodeAt(0) !== 47 && (path = "/" + path), this.config.prefix && !skipPrefix && (path = this.config.prefix + path), localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let instanceValidator = this.validator.getCandidate(), cloned = {
      body: localHook?.body ?? instanceValidator?.body,
      headers: localHook?.headers ?? instanceValidator?.headers,
      params: localHook?.params ?? instanceValidator?.params,
      query: localHook?.query ?? instanceValidator?.query,
      cookie: localHook?.cookie ?? instanceValidator?.cookie,
      response: localHook?.response ?? instanceValidator?.response
    }, shouldPrecompile = this.config.precompile === true || typeof this.config.precompile == "object" && this.config.precompile.compose === true, createValidator = () => {
      let models = this.definitions.type, dynamic = !this.config.aot, normalize = this.config.normalize, modules = this.definitions.typebox, sanitize2 = () => this.config.sanitize, cookieValidator = () => {
        if (cloned.cookie || standaloneValidators.find((x) => x.cookie))
          return getCookieValidator({
            modules,
            validator: cloned.cookie,
            defaultConfig: this.config.cookie,
            config: cloned.cookie?.config ?? {},
            dynamic,
            models,
            validators: standaloneValidators.map((x) => x.cookie),
            sanitize: sanitize2
          });
      };
      return shouldPrecompile ? {
        body: getSchemaValidator(cloned.body, {
          modules,
          dynamic,
          models,
          normalize,
          additionalCoerce: coercePrimitiveRoot(),
          validators: standaloneValidators.map((x) => x.body),
          sanitize: sanitize2
        }),
        headers: getSchemaValidator(cloned.headers, {
          modules,
          dynamic,
          models,
          additionalProperties: true,
          coerce: true,
          additionalCoerce: stringToStructureCoercions(),
          validators: standaloneValidators.map((x) => x.headers),
          sanitize: sanitize2
        }),
        params: getSchemaValidator(cloned.params, {
          modules,
          dynamic,
          models,
          coerce: true,
          additionalCoerce: stringToStructureCoercions(),
          validators: standaloneValidators.map((x) => x.params),
          sanitize: sanitize2
        }),
        query: getSchemaValidator(cloned.query, {
          modules,
          dynamic,
          models,
          normalize,
          coerce: true,
          additionalCoerce: stringToStructureCoercions(),
          validators: standaloneValidators.map((x) => x.query),
          sanitize: sanitize2
        }),
        cookie: cookieValidator(),
        response: getResponseSchemaValidator(cloned.response, {
          modules,
          dynamic,
          models,
          normalize,
          validators: standaloneValidators.map((x) => x.response),
          sanitize: sanitize2
        })
      } : {
        createBody() {
          return this.body ? this.body : this.body = getSchemaValidator(cloned.body, {
            modules,
            dynamic,
            models,
            normalize,
            additionalCoerce: coercePrimitiveRoot(),
            validators: standaloneValidators.map((x) => x.body),
            sanitize: sanitize2
          });
        },
        createHeaders() {
          return this.headers ? this.headers : this.headers = getSchemaValidator(cloned.headers, {
            modules,
            dynamic,
            models,
            additionalProperties: !normalize,
            coerce: true,
            additionalCoerce: stringToStructureCoercions(),
            validators: standaloneValidators.map((x) => x.headers),
            sanitize: sanitize2
          });
        },
        createParams() {
          return this.params ? this.params : this.params = getSchemaValidator(cloned.params, {
            modules,
            dynamic,
            models,
            coerce: true,
            additionalCoerce: stringToStructureCoercions(),
            validators: standaloneValidators.map((x) => x.params),
            sanitize: sanitize2
          });
        },
        createQuery() {
          return this.query ? this.query : this.query = getSchemaValidator(cloned.query, {
            modules,
            dynamic,
            models,
            coerce: true,
            additionalCoerce: stringToStructureCoercions(),
            validators: standaloneValidators.map((x) => x.query),
            sanitize: sanitize2
          });
        },
        createCookie() {
          return this.cookie ? this.cookie : this.cookie = cookieValidator();
        },
        createResponse() {
          return this.response ? this.response : this.response = getResponseSchemaValidator(cloned.response, {
            modules,
            dynamic,
            models,
            normalize,
            validators: standaloneValidators.map((x) => x.response),
            sanitize: sanitize2
          });
        }
      };
    };
    (instanceValidator.body || instanceValidator.cookie || instanceValidator.headers || instanceValidator.params || instanceValidator.query || instanceValidator.response) && (localHook = mergeHook(localHook, instanceValidator)), localHook.tags && (localHook.detail ? localHook.detail.tags = localHook.tags : localHook.detail = {
      tags: localHook.tags
    }), isNotEmpty(this.config.detail) && (localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail)), this.applyMacro(localHook);
    let hooks = isNotEmpty(this.event) ? mergeHook(this.event, localHookToLifeCycleStore(localHook)) : lifeCycleToArray(localHookToLifeCycleStore(localHook));
    if (this.config.aot === false) {
      let validator = createValidator();
      this.router.dynamic.add(method, path, {
        validator,
        hooks,
        content: localHook?.type,
        handle,
        route: path
      });
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded && this.router.dynamic.add(method, encoded, {
        validator,
        hooks,
        content: localHook?.type,
        handle,
        route: path
      }), this.config.strictPath === false) {
        let loosePath = getLoosePath(path);
        this.router.dynamic.add(method, loosePath, {
          validator,
          hooks,
          content: localHook?.type,
          handle,
          route: path
        });
        let encoded2 = encodePath(loosePath);
        loosePath !== encoded2 && this.router.dynamic.add(method, loosePath, {
          validator,
          hooks,
          content: localHook?.type,
          handle,
          route: path
        });
      }
      this.router.history.push({
        method,
        path,
        composed: null,
        handler: handle,
        compile: undefined,
        hooks,
        standaloneValidators
      });
      return;
    }
    let adapter = this["~adapter"].handler, nativeStaticHandler = typeof handle != "function" ? () => {
      let fn = adapter.createNativeStaticHandler?.(handle, hooks, this.setHeaders);
      return fn instanceof Promise ? fn.then((fn2) => {
        if (fn2)
          return fn2;
      }) : fn?.();
    } : undefined, useNativeStaticResponse = this.config.nativeStaticResponse === true, addResponsePath = (path2) => {
      !useNativeStaticResponse || !nativeStaticHandler || (supportPerMethodInlineHandler ? this.router.response[path2] ? this.router.response[path2][method] = nativeStaticHandler() : this.router.response[path2] = {
        [method]: nativeStaticHandler()
      } : this.router.response[path2] = nativeStaticHandler());
    };
    addResponsePath(path);
    let _compiled, compile2 = () => _compiled || (_compiled = composeHandler({
      app: this,
      path,
      method,
      hooks,
      validator: createValidator(),
      handler: typeof handle != "function" && typeof adapter.createStaticHandler != "function" ? () => handle : handle,
      allowMeta,
      inference: this.inference
    })), oldIndex;
    if (`${method}_${path}` in this.routeTree)
      for (let i = 0;i < this.router.history.length; i++) {
        let route = this.router.history[i];
        if (route.path === path && route.method === method) {
          oldIndex = i;
          break;
        }
      }
    else
      this.routeTree[`${method}_${path}`] = this.router.history.length;
    let index = oldIndex ?? this.router.history.length, mainHandler = shouldPrecompile ? compile2() : (ctx) => (this.router.history[index].composed = compile2())(ctx);
    oldIndex !== undefined ? this.router.history[oldIndex] = Object.assign({
      method,
      path,
      composed: mainHandler,
      compile: compile2,
      handler: handle,
      hooks
    }, standaloneValidators.length ? {
      standaloneValidators
    } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined) : this.router.history.push(Object.assign({
      method,
      path,
      composed: mainHandler,
      compile: compile2,
      handler: handle,
      hooks
    }, standaloneValidators.length ? {
      standaloneValidators
    } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined));
    let handler = {
      handler: shouldPrecompile ? mainHandler : undefined,
      compile() {
        return this.handler = compile2();
      }
    }, staticRouter = this.router.static, isStaticPath = path.indexOf(":") === -1 && path.indexOf("*") === -1;
    if (method === "WS") {
      if (isStaticPath) {
        path in staticRouter ? staticRouter[path][method] = index : staticRouter[path] = {
          [method]: index
        };
        return;
      }
      this.router.http.add("WS", path, handler), this.config.strictPath || this.router.http.add("WS", getLoosePath(path), handler);
      let encoded = encodePath(path, { dynamic: true });
      path !== encoded && this.router.http.add("WS", encoded, handler);
      return;
    }
    if (isStaticPath)
      path in staticRouter ? staticRouter[path][method] = index : staticRouter[path] = {
        [method]: index
      }, this.config.strictPath || addResponsePath(getLoosePath(path));
    else {
      if (this.router.http.add(method, path, handler), !this.config.strictPath) {
        let loosePath = getLoosePath(path);
        addResponsePath(loosePath), this.router.http.add(method, loosePath, handler);
      }
      let encoded = encodePath(path, { dynamic: true });
      path !== encoded && (this.router.http.add(method, encoded, handler), addResponsePath(encoded));
    }
  }
  headers(header) {
    return header ? (this.setHeaders || (this.setHeaders = {}), this.setHeaders = mergeDeep(this.setHeaders, header), this) : this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    return handler ? this.on(options, "parse", handler) : typeof options == "string" ? this.on("parse", this["~parser"][options]) : this.on("parse", options);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    return handler ? this.on(options, "transform", handler) : this.on("transform", options);
  }
  resolve(optionsOrResolve, resolve) {
    resolve || (resolve = optionsOrResolve, optionsOrResolve = { as: "local" });
    let hook = {
      subType: "resolve",
      fn: resolve
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    mapper || (mapper = optionsOrResolve, optionsOrResolve = { as: "local" });
    let hook = {
      subType: "mapResolve",
      fn: mapper
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    return handler ? this.on(options, "beforeHandle", handler) : this.on("beforeHandle", options);
  }
  onAfterHandle(options, handler) {
    return handler ? this.on(options, "afterHandle", handler) : this.on("afterHandle", options);
  }
  mapResponse(options, handler) {
    return handler ? this.on(options, "mapResponse", handler) : this.on("mapResponse", options);
  }
  onAfterResponse(options, handler) {
    return handler ? this.on(options, "afterResponse", handler) : this.on("afterResponse", options);
  }
  trace(options, handler) {
    handler || (handler = options, options = { as: "local" }), Array.isArray(handler) || (handler = [handler]);
    for (let fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error2) {
    switch (typeof name) {
      case "string":
        return error2.prototype[ERROR_CODE] = name, this.definitions.error[name] = error2, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error3] of Object.entries(name))
      error3.prototype[ERROR_CODE] = code, this.definitions.error[code] = error3;
    return this;
  }
  onError(options, handler) {
    return handler ? this.on(options, "error", handler) : this.on("error", options);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type;
    switch (typeof optionsOrType) {
      case "string":
        type = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        type = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers == "object" && (handlers = typeOrHandlers);
        break;
    }
    Array.isArray(handlers) ? handlers = fnToContainer(handlers) : typeof handlers == "function" ? handlers = [
      {
        fn: handlers
      }
    ] : handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      handle.scope = typeof optionsOrType == "string" ? "local" : optionsOrType?.as ?? "local", (type === "resolve" || type === "derive") && (handle.subType = type);
    type !== "trace" && (this.inference = sucrose({
      [type]: handles.map((x) => x.fn)
    }, this.inference));
    for (let handle of handles) {
      let fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type) {
        case "start":
          this.event.start ??= [], this.event.start.push(fn);
          break;
        case "request":
          this.event.request ??= [], this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse ??= [], this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform ??= [], this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform ??= [], this.event.transform.push(fnToContainer(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle ??= [], this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse ??= [], this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse ??= [], this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace ??= [], this.event.trace.push(fn);
          break;
        case "error":
          this.event.error ??= [], this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop ??= [], this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  as(type) {
    return promoteEvent(this.event.parse, type), promoteEvent(this.event.transform, type), promoteEvent(this.event.beforeHandle, type), promoteEvent(this.event.afterHandle, type), promoteEvent(this.event.mapResponse, type), promoteEvent(this.event.afterResponse, type), promoteEvent(this.event.trace, type), promoteEvent(this.event.error, type), type === "scoped" ? (this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null, this.standaloneValidator.local !== null && (this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null)) : type === "global" && (this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null, this.standaloneValidator.local !== null && (this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null), this.standaloneValidator.scoped !== null && (this.standaloneValidator.global ||= [], this.standaloneValidator.global.push(...this.standaloneValidator.scoped), this.standaloneValidator.scoped = null)), this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new _Elysia2({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance["~parser"] = this["~parser"], instance.standaloneValidator = {
      local: [...this.standaloneValidator.local ?? []],
      scoped: [...this.standaloneValidator.scoped ?? []],
      global: [...this.standaloneValidator.global ?? []]
    };
    let isSchema = typeof schemaOrRun == "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    return this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.event.request?.length && (this.event.request = [
      ...this.event.request || [],
      ...sandbox.event.request || []
    ]), sandbox.event.mapResponse?.length && (this.event.mapResponse = [
      ...this.event.mapResponse || [],
      ...sandbox.event.mapResponse || []
    ]), this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks, standaloneValidators }) => {
      if (path = (isSchema ? "" : this.config.prefix) + prefix + path, isSchema) {
        let hook = schemaOrRun, localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, {
          ...localHook || {},
          error: localHook.error ? Array.isArray(localHook.error) ? [
            ...localHook.error ?? [],
            ...sandbox.event.error ?? []
          ] : [
            localHook.error,
            ...sandbox.event.error ?? []
          ] : sandbox.event.error
        }), undefined, standaloneValidators);
      } else
        this.add(method, path, handler, mergeHook(hooks, {
          error: sandbox.event.error
        }), {
          skipPrefix: true
        }, standaloneValidators);
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook == "object") {
        this.applyMacro(hook), hook.detail && (this.config.detail ? this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail) : this.config.detail = hook.detail), hook.tags && (this.config.detail ? this.config.detail.tags = hook.tags : this.config.detail = {
          tags: hook.tags
        });
        let type = hook.as ?? "local";
        if (hook.schema === "standalone") {
          this.standaloneValidator[type] || (this.standaloneValidator[type] = []);
          let response = hook?.response || typeof hook?.response == "string" || hook?.response && Kind in hook.response ? {
            200: hook.response
          } : hook?.response;
          this.standaloneValidator[type].push({
            body: hook.body,
            headers: hook.headers,
            params: hook.params,
            query: hook.query,
            response,
            cookie: hook.cookie
          });
        } else
          this.validator[type] = {
            body: hook.body ?? this.validator[type]?.body,
            headers: hook.headers ?? this.validator[type]?.headers,
            params: hook.params ?? this.validator[type]?.params,
            query: hook.query ?? this.validator[type]?.query,
            response: hook.response ?? this.validator[type]?.response,
            cookie: hook.cookie ?? this.validator[type]?.cookie
          };
        return hook.parse && this.on({ as: type }, "parse", hook.parse), hook.transform && this.on({ as: type }, "transform", hook.transform), hook.derive && this.on({ as: type }, "derive", hook.derive), hook.beforeHandle && this.on({ as: type }, "beforeHandle", hook.beforeHandle), hook.resolve && this.on({ as: type }, "resolve", hook.resolve), hook.afterHandle && this.on({ as: type }, "afterHandle", hook.afterHandle), hook.mapResponse && this.on({ as: type }, "mapResponse", hook.mapResponse), hook.afterResponse && this.on({ as: type }, "afterResponse", hook.afterResponse), hook.error && this.on({ as: type }, "error", hook.error), this;
      }
      return this.guard({}, hook);
    }
    let instance = new _Elysia2({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance.getServer = () => this.getServer();
    let sandbox = run(instance);
    return this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request?.length && (this.event.request = [
      ...this.event.request || [],
      ...sandbox.event.request || []
    ]), sandbox.event.mapResponse?.length && (this.event.mapResponse = [
      ...this.event.mapResponse || [],
      ...sandbox.event.mapResponse || []
    ]), this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, {
        ...localHook || {},
        error: localHook.error ? Array.isArray(localHook.error) ? [
          ...localHook.error ?? [],
          ...sandbox.event.error ?? []
        ] : [
          localHook.error,
          ...sandbox.event.error ?? []
        ] : sandbox.event.error
      }));
    }), this;
  }
  use(plugin) {
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    return plugin instanceof Promise ? (this.promisedModules.add(plugin.then((plugin2) => {
      if (typeof plugin2 == "function")
        return plugin2(this);
      if (plugin2 instanceof _Elysia2)
        return this._use(plugin2).compile();
      if (plugin2.constructor.name === "Elysia")
        return this._use(plugin2).compile();
      if (typeof plugin2.default == "function")
        return plugin2.default(this);
      if (plugin2.default instanceof _Elysia2)
        return this._use(plugin2.default);
      if (plugin2.constructor.name === "Elysia")
        return this._use(plugin2.default);
      if (plugin2.constructor.name === "_Elysia")
        return this._use(plugin2.default);
      try {
        return this._use(plugin2.default);
      } catch (error2) {
        throw console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'), error2;
      }
    }).then((v) => (v && typeof v.compile == "function" && v.compile(), v))), this) : this._use(plugin);
  }
  propagatePromiseModules(plugin) {
    if (plugin.promisedModules.size <= 0)
      return this;
    for (let promise of plugin.promisedModules.promises)
      this.promisedModules.add(promise.then((v) => {
        if (!v)
          return;
        let t2 = this._use(v);
        return t2 instanceof Promise ? t2.then((v2) => {
          v2 ? v2.compile() : v.compile();
        }) : v.compile();
      }));
    return this;
  }
  _use(plugin) {
    if (typeof plugin == "function") {
      let instance = plugin(this);
      return instance instanceof Promise ? (this.promisedModules.add(instance.then((plugin2) => {
        if (plugin2 instanceof _Elysia2) {
          plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
          for (let {
            method,
            path,
            handler,
            hooks,
            standaloneValidators
          } of Object.values(plugin2.router.history))
            this.add(method, path, handler, isNotEmpty(plugin2.event.error) ? mergeHook(hooks, {
              error: plugin2.event.error
            }) : hooks, undefined, standaloneValidators);
          return plugin2 === this ? undefined : (this.propagatePromiseModules(plugin2), plugin2);
        }
        return typeof plugin2 == "function" ? plugin2(this) : typeof plugin2.default == "function" ? plugin2.default(this) : this._use(plugin2);
      }).then((v) => (v && typeof v.compile == "function" && v.compile(), v))), this) : instance;
    }
    this.propagatePromiseModules(plugin);
    let name = plugin.config.name, seed = plugin.config.seed;
    if (plugin.getParent = () => this, plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin.standaloneValidator?.scoped && (this.standaloneValidator.local ? this.standaloneValidator.local = this.standaloneValidator.local.concat(plugin.standaloneValidator.scoped) : this.standaloneValidator.local = plugin.standaloneValidator.scoped), plugin.standaloneValidator?.global && (this.standaloneValidator.global ? this.standaloneValidator.global = this.standaloneValidator.global.concat(plugin.standaloneValidator.global) : this.standaloneValidator.global = plugin.standaloneValidator.global), isNotEmpty(plugin["~parser"]) && (this["~parser"] = {
      ...plugin["~parser"],
      ...this["~parser"]
    }), plugin.setHeaders && this.headers(plugin.setHeaders), name) {
      name in this.dependencies || (this.dependencies[name] = []);
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2) || (this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions));
    } else
      plugin.extender.macros.length && (this.extender.macros = this.extender.macros.concat(plugin.extender.macros)), plugin.extender.higherOrderFunctions.length && (this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions));
    if (deduplicateChecksum(this.extender.macros), plugin.extender.higherOrderFunctions.length) {
      deduplicateChecksum(this.extender.higherOrderFunctions);
      let hofHashes = [];
      for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
        let hof = this.extender.higherOrderFunctions[i];
        hof.checksum && (hofHashes.includes(hof.checksum) && (this.extender.higherOrderFunctions.splice(i, 1), i--), hofHashes.push(hof.checksum));
      }
      hofHashes.length = 0;
    }
    this.inference = mergeInference(this.inference, plugin.inference), isNotEmpty(plugin.singleton.decorator) && this.decorate(plugin.singleton.decorator), isNotEmpty(plugin.singleton.store) && this.state(plugin.singleton.store), isNotEmpty(plugin.definitions.type) && this.model(plugin.definitions.type), isNotEmpty(plugin.definitions.error) && this.error(plugin.definitions.error), isNotEmpty(plugin.definitions.error) && (plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros));
    for (let {
      method,
      path,
      handler,
      hooks,
      standaloneValidators
    } of Object.values(plugin.router.history))
      this.add(method, path, handler, isNotEmpty(plugin.event.error) ? mergeHook(hooks, {
        error: plugin.event.error
      }) : hooks, undefined, standaloneValidators);
    if (name) {
      name in this.dependencies || (this.dependencies[name] = []);
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        return this;
      this.dependencies[name].push(this.config?.analytic ? {
        name: plugin.config.name,
        seed: plugin.config.seed,
        checksum: current,
        dependencies: plugin.dependencies,
        stack: plugin.telemetry?.stack,
        routes: plugin.router.history,
        decorators: plugin.singleton,
        store: plugin.singleton.store,
        error: plugin.definitions.error,
        derive: plugin.event.transform?.filter((x) => x?.subType === "derive").map((x) => ({
          fn: x.toString(),
          stack: new Error().stack ?? ""
        })),
        resolve: plugin.event.transform?.filter((x) => x?.subType === "resolve").map((x) => ({
          fn: x.toString(),
          stack: new Error().stack ?? ""
        }))
      } : {
        name: plugin.config.name,
        seed: plugin.config.seed,
        checksum: current,
        dependencies: plugin.dependencies
      }), isNotEmpty(plugin.event) && (this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current));
    } else
      isNotEmpty(plugin.event) && (this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event)));
    return plugin.validator.global && (this.validator.global = mergeHook(this.validator.global, {
      ...plugin.validator.global
    })), plugin.validator.scoped && (this.validator.local = mergeHook(this.validator.local, {
      ...plugin.validator.scoped
    })), this;
  }
  macro(macro) {
    if (typeof macro == "function") {
      let hook = {
        checksum: checksum(JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: macro.toString()
        })),
        fn: macro
      };
      this.extender.macros.push(hook);
    } else if (typeof macro == "object") {
      for (let name of Object.keys(macro))
        if (typeof macro[name] == "object") {
          let actualValue = { ...macro[name] };
          macro[name] = (v) => {
            if (v === true)
              return actualValue;
          };
        }
      let hook = {
        checksum: checksum(JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: Object.entries(macro).map(([k, v]) => `${k}+${v}`).join(",")
        })),
        fn: () => macro
      };
      this.extender.macros.push(hook);
    }
    return this;
  }
  mount(path, handleOrConfig, config) {
    if (path instanceof _Elysia2 || typeof path == "function" || path.length === 0 || path === "/") {
      let run = typeof path == "function" ? path : path instanceof _Elysia2 ? path.compile().fetch : handleOrConfig instanceof _Elysia2 ? handleOrConfig.compile().fetch : typeof handleOrConfig == "function" ? handleOrConfig : (() => {
        throw new Error("Invalid handler");
      })(), handler2 = ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2), {
        method: request.method,
        headers: request.headers,
        signal: request.signal,
        credentials: request.credentials,
        referrerPolicy: request.referrerPolicy,
        duplex: request.duplex,
        redirect: request.redirect,
        mode: request.mode,
        keepalive: request.keepalive,
        integrity: request.integrity,
        body: request.body
      }));
      return this.route("ALL", "/*", handler2, {
        parse: "none",
        ...config,
        detail: {
          ...config?.detail,
          hide: true
        },
        config: {
          mount: run
        }
      }), this;
    }
    let handle = handleOrConfig instanceof _Elysia2 ? handleOrConfig.compile().fetch : typeof handleOrConfig == "function" ? handleOrConfig : (() => {
      throw new Error("Invalid handler");
    })(), length = path.length - (path.endsWith("*") ? 1 : 0), handler = ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), {
      method: request.method,
      headers: request.headers,
      signal: request.signal,
      credentials: request.credentials,
      referrerPolicy: request.referrerPolicy,
      duplex: request.duplex,
      redirect: request.redirect,
      mode: request.mode,
      keepalive: request.keepalive,
      integrity: request.integrity,
      body: request.body
    }));
    return this.route("ALL", path, handler, {
      parse: "none",
      ...config,
      detail: {
        ...config?.detail,
        hide: true
      },
      config: {
        mount: handle
      }
    }), this.route("ALL", path + (path.endsWith("/") ? "*" : "/*"), handler, {
      parse: "none",
      ...config,
      detail: {
        ...config?.detail,
        hide: true
      },
      config: {
        mount: handle
      }
    }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    return this["~adapter"].ws ? this["~adapter"].ws(this, path, options) : console.warn("Current adapter doesn't support WebSocket"), this;
  }
  state(options, name, value) {
    name === undefined ? (value = options, options = { as: "append" }, name = "") : value === undefined && (typeof options == "string" ? (value = name, name = options, options = { as: "append" }) : typeof options == "object" && (value = name, name = ""));
    let { as } = options;
    if (typeof name != "string")
      return this;
    switch (typeof value) {
      case "object":
        return !value || !isNotEmpty(value) ? this : name ? ((name in this.singleton.store) ? this.singleton.store[name] = mergeDeep(this.singleton.store[name], value, {
          override: as === "override"
        }) : this.singleton.store[name] = value, this) : value === null ? this : (this.singleton.store = mergeDeep(this.singleton.store, value, {
          override: as === "override"
        }), this);
      case "function":
        return name ? (as === "override" || !(name in this.singleton.store)) && (this.singleton.store[name] = value) : this.singleton.store = value(this.singleton.store), this;
      default:
        return (as === "override" || !(name in this.singleton.store)) && (this.singleton.store[name] = value), this;
    }
  }
  decorate(options, name, value) {
    name === undefined ? (value = options, options = { as: "append" }, name = "") : value === undefined && (typeof options == "string" ? (value = name, name = options, options = { as: "append" }) : typeof options == "object" && (value = name, name = ""));
    let { as } = options;
    if (typeof name != "string")
      return this;
    switch (typeof value) {
      case "object":
        return name ? ((name in this.singleton.decorator) ? this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value, {
          override: as === "override"
        }) : this.singleton.decorator[name] = value, this) : value === null ? this : (this.singleton.decorator = mergeDeep(this.singleton.decorator, value, {
          override: as === "override"
        }), this);
      case "function":
        return name ? (as === "override" || !(name in this.singleton.decorator)) && (this.singleton.decorator[name] = value) : this.singleton.decorator = value(this.singleton.decorator), this;
      default:
        return (as === "override" || !(name in this.singleton.decorator)) && (this.singleton.decorator[name] = value), this;
    }
  }
  derive(optionsOrTransform, transform2) {
    transform2 || (transform2 = optionsOrTransform, optionsOrTransform = { as: "local" });
    let hook = {
      subType: "derive",
      fn: transform2
    };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        let parsedSchemas = {}, kvs = Object.entries(name);
        if (!kvs.length)
          return this;
        for (let [key, value] of kvs)
          key in this.definitions.type || (parsedSchemas[key] = this.definitions.type[key] = value, parsedSchemas[key].$id ??= `#/components/schemas/${key}`);
        return this.definitions.typebox = t.Module({
          ...this.definitions.typebox.$defs,
          ...parsedSchemas
        }), this;
      case "function":
        let result = name(this.definitions.type);
        return this.definitions.type = result, this.definitions.typebox = t.Module(result), this;
      case "string":
        if (!model)
          break;
        let newModel = {
          ...model,
          id: model.$id ?? `#/components/schemas/${name}`
        };
        return this.definitions.type[name] = model, this.definitions.typebox = t.Module({
          ...this.definitions.typebox.$defs,
          ...newModel
        }), this;
    }
    return this.definitions.type[name] = model, this.definitions.typebox = t.Module({
      ...this.definitions.typebox.$defs,
      [name]: model
    }), this;
  }
  Ref(key) {
    return t.Ref(key);
  }
  mapDerive(optionsOrDerive, mapper) {
    mapper || (mapper = optionsOrDerive, optionsOrDerive = { as: "local" });
    let hook = {
      subType: "mapDerive",
      fn: mapper
    };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix), remap = (type2) => {
      let store = {};
      switch (type2) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type) ? type : [type];
    for (let type2 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type2);
    return this;
  }
  prefix(type, word) {
    return this.affix("prefix", type, word);
  }
  suffix(type, word) {
    return this.affix("suffix", type, word);
  }
  compile() {
    return this["~adapter"].isWebStandard ? (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload == "function" && this.server.reload({
      ...this.server || {},
      fetch: this.fetch
    }), this) : (typeof this.server?.reload == "function" && this.server.reload(this.server || {}), this._handle = composeGeneralHandler(this), this);
  }
  get modules() {
    return this.promisedModules;
  }
};
var Elysia = _Elysia;

// node_modules/@elysiajs/cors/dist/index.mjs
var isBun3 = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
  if (isBun3)
    return Object.keys(headers.toJSON()).join(", ");
  let keys = "";
  let i = 0;
  headers.forEach((_, key) => {
    if (i)
      keys = keys + ", " + key;
    else
      keys = key;
    i++;
  });
  return keys;
};
var cors = (config) => {
  let {
    aot = true,
    origin = true,
    methods = true,
    allowedHeaders = true,
    exposeHeaders = true,
    credentials = true,
    maxAge = 5,
    preflight = true
  } = config ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposeHeaders))
    exposeHeaders = exposeHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config,
    aot
  });
  const anyOrigin = origins?.some((o) => o === "*");
  const originMap = {};
  if (origins) {
    for (const origin2 of origins)
      if (typeof origin2 === "string")
        originMap[origin2] = true;
  }
  const processOrigin = (origin2, request, from) => {
    if (Array.isArray(origin2))
      return origin2.some((o) => processOrigin(o, request, from));
    switch (typeof origin2) {
      case "string":
        if (from in originMap)
          return true;
        const fromProtocol = from.indexOf("://");
        if (fromProtocol !== -1)
          from = from.slice(fromProtocol + 3);
        return origin2 === from;
      case "function":
        return origin2(request) === true;
      case "object":
        if (origin2 instanceof RegExp)
          return origin2.test(from);
    }
    return false;
  };
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value = processOrigin(origins[i], request, from);
        if (value === true) {
          set2.headers.vary = origin ? "Origin" : "*";
          set2.headers["access-control-allow-origin"] = from || "*";
          return;
        }
      }
    }
    set2.headers.vary = "Origin";
    if (headers.length)
      set2.headers["access-control-allow-origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (!method)
      return;
    if (methods === true)
      return set2.headers["access-control-allow-methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["access-control-allow-methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["access-control-allow-methods"] = methods;
    set2.headers["access-control-allow-methods"] = methods.join(", ");
  };
  const defaultHeaders = {};
  if (typeof exposeHeaders === "string")
    defaultHeaders["access-control-expose-headers"] = exposeHeaders;
  if (typeof allowedHeaders === "string")
    defaultHeaders["access-control-allow-headers"] = allowedHeaders;
  if (credentials === true)
    defaultHeaders["access-control-allow-credentials"] = "true";
  app.headers(defaultHeaders);
  function handleOption({ set: set2, request, headers }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.headers.get("access-control-request-method"));
    if (allowedHeaders === true || exposeHeaders === true) {
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
    }
    if (maxAge)
      set2.headers["access-control-max-age"] = maxAge.toString();
    return new Response(null, {
      status: 204
    });
  }
  if (preflight)
    app.options("/", handleOption).options("/*", handleOption);
  return app.onRequest(function processCors({ set: set2, request }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
    if (allowedHeaders === true || exposeHeaders === true) {
      const headers = processHeaders(request.headers);
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers;
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = headers;
    }
  });
};

// node_modules/@scalar/themes/dist/presets/alternate.css2.js
var a = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode,
.light-mode .dark-mode {
  --scalar-background-1: #f9f9f9;
  --scalar-background-2: #f1f1f1;
  --scalar-background-3: #e7e7e7;
  --scalar-background-card: #fff;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-background-1: #131313;
  --scalar-background-2: #1d1d1d;
  --scalar-background-3: #272727;
  --scalar-background-card: #1d1d1d;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: #2a2b2a;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode .dark-mode,
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dd2f2c;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}

.scalar-api-client__item,
.scalar-card,
.dark-mode .dark-mode.scalar-card {
  --scalar-background-1: var(--scalar-background-card);
  --scalar-background-2: var(--scalar-background-1);
  --scalar-background-3: var(--scalar-background-1);
}
.dark-mode .dark-mode.scalar-card {
  --scalar-background-3: var(--scalar-background-3);
}
.t-doc__sidebar {
  --scalar-color-green: var(--scalar-color-1);
  --scalar-color-red: var(--scalar-color-1);
  --scalar-color-yellow: var(--scalar-color-1);
  --scalar-color-blue: var(--scalar-color-1);
  --scalar-color-orange: var(--scalar-color-1);
  --scalar-color-purple: var(--scalar-color-1);
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/bluePlanet.css2.js
var a2 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f0f2f5;
  --scalar-background-2: #eaecf0;
  --scalar-background-3: #e0e2e6;
  --scalar-border-color: rgb(213 213 213);

  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;
}
.light-mode .scalar-card.dark-mode,
.dark-mode {
  --scalar-background-1: #000e23;
  --scalar-background-2: #01132e;
  --scalar-background-3: #03193b;
  --scalar-border-color: #2e394c;

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  z-index: 1;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
/* Document header */
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
/* Hero Section Flare */
.section-flare-item:nth-of-type(1) {
  --c1: #ffffff;
  --c2: #babfd8;
  --c3: #2e8bb2;
  --c4: #1a8593;
  --c5: #0a143e;
  --c6: #0a0f52;
  --c7: #2341b8;

  --solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6), var(--c7);
  --solid-wrap: var(--solid), var(--c1);
  --trans:
    var(--c1), transparent, var(--c2), transparent, var(--c3),
    transparent, var(--c4), transparent, var(--c5), transparent, var(--c6),
    transparent, var(--c7);
  --trans-wrap: var(--trans), transparent, var(--c1);

  background: radial-gradient(circle, var(--trans)), conic-gradient(from 180deg, var(--trans-wrap)),
    radial-gradient(circle, var(--trans)), conic-gradient(var(--solid-wrap));
  width: 70vw;
  height: 700px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
  right: 0;
  position: absolute;
  transform: rotate(-45deg);
  top: -300px;
  opacity: 0.3;
}
.section-flare-item:nth-of-type(3) {
  --star-color: #6b9acc;
  --star-color2: #446b8d;
  --star-color3: #3e5879;
  background-image: radial-gradient(2px 2px at 20px 30px, var(--star-color2), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 160px 120px, var(--star-color3), rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 200px 200px;
  width: 100%;
  height: 100%;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
}
.section-flare {
  top: -150px !important;
  height: 100vh;
  background: linear-gradient(#000, var(--scalar-background-1));
  width: 100vw;
  overflow-x: hidden;
}
.light-mode .section-flare {
  display: none;
}
.light-mode .scalar-card {
  --scalar-background-1: #fff;
  --scalar-background-2: #fff;
  --scalar-background-3: #fff;
}

*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 60%);
}
`;

// node_modules/@scalar/themes/dist/presets/deepSpace.css2.js
var a3 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #fff;
  --scalar-background-2: #f4f4f5;
  --scalar-background-3: #e3e3e6;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgb(228, 228, 231);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgba(255, 255, 255, 0.16);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-item-active-background: var(--scalar-background-2);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  width: 100vw;
  height: 550px;
  position: absolute;
}
.section-flare-item:nth-of-type(1) {
  position: absolute;
  width: 100vw;
  height: 550px;
  --stripesDark: repeating-linear-gradient(100deg, #000 0%, #000 7%, transparent 10%, transparent 12%, #000 16%);
  --rainbow: repeating-linear-gradient(100deg, #fff 10%, #fff 16%, #fff 22%, #fff 30%);
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.07;
}
.dark-mode .section-flare-item:nth-of-type(1) {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
  height: 350px;
}
.section-flare-item:nth-of-type(1):after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
.section-flare-item:nth-of-type(2) {
  --star-color: #fff;
  --star-color2: #fff;
  --star-color3: #fff;
  width: 100%;
  height: 100%;
  position: absolute;
  background-image: radial-gradient(2px 2px at 20px 30px, var(--star-color2), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 160px 120px, var(--star-color3), rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 200px 200px;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  opacity: 0.2;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/default.css2.js
var r = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #8ab4f81f;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #0099ff;
  --scalar-border-color: #dfdfdf;
}
.dark-mode {
  --scalar-background-1: #0f0f0f;
  --scalar-background-2: #1a1a1a;
  --scalar-background-3: #272727;

  --scalar-color-1: #e7e7e7;
  --scalar-color-2: #a4a4a4;
  --scalar-color-3: #797979;

  --scalar-color-accent: #3ea6ff;
  --scalar-background-accent: #3ea6ff1f;

  --scalar-border-color: #2d2d2d;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-2);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);

  --scalar-color-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-color-1) 20%);

  --scalar-background-alert: color-mix(in srgb, var(--scalar-color-orange), var(--scalar-background-1) 95%);
  --scalar-background-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 95%);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;

  --scalar-color-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 20%);

  --scalar-background-alert: color-mix(in srgb, var(--scalar-color-orange), var(--scalar-background-1) 95%);
  --scalar-background-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 95%);
}
@supports (color: color(display-p3 1 1 1)) {
  .light-mode {
    --scalar-color-accent: color(display-p3 0.0 0.6 1.0 / 1.0);
    --scalar-color-green: color(display-p3 0.023529 0.564706 0.380392 / 1.0);
    --scalar-color-red: color(display-p3 0.937255 0.0 0.023529 / 1.0);
    --scalar-color-yellow: color(display-p3 0.929412 0.745098 0.12549 / 1.0);
    --scalar-color-blue: color(display-p3 0.0 0.509804 0.815686 / 1.0);
    --scalar-color-orange: color(display-p3 0.984314 0.537255 0.172549 / 1.0);
    --scalar-color-purple: color(display-p3 0.321569 0.011765 0.819608 / 1.0);
  }
  .dark-mode {
    --scalar-color-accent: color(display-p3 0.243137 0.65098 1.0 / 1.0);
    --scalar-color-green: color(display-p3 0.0 0.713725 0.282353 / 1.0);
    --scalar-color-red: color(display-p3 0.862745 0.105882 0.098039 / 1.0);
    --scalar-color-yellow: color(display-p3 1.0 0.788235 0.05098 / 1.0);
    --scalar-color-blue: color(display-p3 0.305882 0.701961 0.92549 / 1.0);
    --scalar-color-orange: color(display-p3 1.0 0.552941 0.301961 / 1.0);
    --scalar-color-purple: color(display-p3 0.694118 0.568627 0.976471 / 1.0);
  }
}
`;

// node_modules/@scalar/themes/dist/presets/elysiajs.css2.js
var a4 = `.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #f06292;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(156, 163, 175, 1);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-accent: #f06292;

  --scalar-background-1: #111728;
  --scalar-background-2: #1e293b;
  --scalar-background-3: #334155;
  --scalar-background-accent: #f062921f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: #f062921f;
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #a3ffa9;
  --scalar-color-red: #ffa3a3;
  --scalar-color-yellow: #fffca3;
  --scalar-color-blue: #a5d6ff;
  --scalar-color-orange: #e2ae83;
  --scalar-color-purple: #d2a8ff;

  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
.section-flare {
  width: 100%;
  height: 400px;
  position: absolute;
}
.section-flare-item:first-of-type:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  --stripes: repeating-linear-gradient(100deg, #fff 0%, #fff 0%, transparent 2%, transparent 12%, #fff 17%);
  --stripesDark: repeating-linear-gradient(100deg, #000 0%, #000 0%, transparent 10%, transparent 12%, #000 17%);
  --rainbow: repeating-linear-gradient(100deg, #60a5fa 10%, #e879f9 16%, #5eead4 22%, #60a5fa 30%);
  contain: strict;
  contain-intrinsic-size: 100vw 40vh;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: opacity(20%) saturate(200%);
  -webkit-mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
}
.section-flare-item:first-of-type:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
  background-image: var(--stripesDark), var(--rainbow);
  pointer-events: none;
}
.light-mode .section-flare-item:first-of-type:after,
.light-mode .section-flare-item:first-of-type:before {
  background-image: var(--stripes), var(--rainbow);
  filter: opacity(4%) saturate(200%);
}
`;

// node_modules/@scalar/themes/dist/presets/fastify.css2.js
var a5 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #1c1e21;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-disabled: #b4b1b1;
  --scalar-color-ghost: #a7a7a7;
  --scalar-color-accent: #2f8555;
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f5f5;
  --scalar-background-3: #ededed;
  --scalar-background-4: rgba(0, 0, 0, 0.06);
  --scalar-background-accent: #2f85551f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #007300;
  --scalar-color-red: #af272b;
  --scalar-color-yellow: #b38200;
  --scalar-color-blue: #3b8ba5;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-disabled: rgba(255, 255, 255, 0.34);
  --scalar-color-ghost: rgba(255, 255, 255, 0.26);
  --scalar-color-accent: #27c2a0;
  --scalar-background-1: #1b1b1d;
  --scalar-background-2: #242526;
  --scalar-background-3: #3b3b3b;
  --scalar-background-4: rgba(255, 255, 255, 0.06);
  --scalar-background-accent: #27c2a01f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #26b226;
  --scalar-color-red: #fb565b;
  --scalar-color-yellow: #ffc426;
  --scalar-color-blue: #6ecfef;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}
`;

// node_modules/@scalar/themes/dist/presets/kepler.css2.js
var a6 = `/* basic theme */
.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #7070ff;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #7070ff1f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);

  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
.dark-mode {
  --scalar-color-1: #f7f8f8;
  --scalar-color-2: rgb(180, 188, 208);
  --scalar-color-3: #b4bcd099;
  --scalar-color-accent: #828fff;

  --scalar-background-1: #000212;
  --scalar-background-2: #0d0f1e;
  --scalar-background-3: #232533;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: #313245;
  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-background-2: rgba(0, 0, 0, 0.03);
}
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.sidebar-search {
  backdrop-filter: blur(12px);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode .scalar-card {
  background: rgba(255, 255, 255, 0.05) !important;
}
.dark-mode .scalar-card * {
  --scalar-background-2: transparent !important;
  --scalar-background-1: transparent !important;
}
.light-mode .dark-mode.scalar-card *,
.light-mode .dark-mode.scalar-card {
  --scalar-background-1: #0d0f1e !important;
  --scalar-background-2: #0d0f1e !important;
  --scalar-background-3: #191b29 !important;
}
.light-mode .dark-mode.scalar-card {
  background: #191b29 !important;
}
.badge {
  box-shadow: 0 0 0 1px var(--scalar-border-color);
  margin-right: 6px;
}

.table-row.required-parameter .table-row-item:nth-of-type(2):after {
  background: transparent;
  box-shadow: none;
}
/* Hero Section Flare */
.section-flare {
  width: 100vw;
  background: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(120, 119, 198, 0.3), transparent);
  height: 100vh;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/mars.css2.js
var a7 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f9f6f0;
  --scalar-background-2: #f2efe8;
  --scalar-background-3: #e9e7e2;
  --scalar-border-color: rgba(203, 165, 156, 0.6);

  --scalar-color-1: #c75549;
  --scalar-color-2: #c75549;
  --scalar-color-3: #c75549;

  --scalar-color-accent: #c75549;
  --scalar-background-accent: #dcbfa81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-background-1: #140507;
  --scalar-background-2: #20090c;
  --scalar-background-3: #321116;
  --scalar-border-color: #3c3031;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: rgba(255, 255, 255, 0.9);
  --scalar-background-accent: #441313;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  z-index: 1;
}
/* advanced */
.light-mode {
  --scalar-color-green: #09533a;
  --scalar-color-red: #aa181d;
  --scalar-color-yellow: #ab8d2b;
  --scalar-color-blue: #19689a;
  --scalar-color-orange: #b26c34;
  --scalar-color-purple: #4c2191;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  overflow-x: hidden;
  height: 100vh;
  left: initial;
}
.section-flare-item:nth-of-type(1) {
  background: #d25019;
  position: relative;
  top: -150px;
  right: -400px;
  width: 80vw;
  height: 500px;
  margin-top: -150px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
}
.light-mode .section-flare {
  display: none;
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-red), transparent 75%);
}
`;

// node_modules/@scalar/themes/dist/presets/moon.css2.js
var a8 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #000000;
  --scalar-color-2: #000000;
  --scalar-color-3: #000000;
  --scalar-color-accent: #645b0f;
  --scalar-background-1: #ccc9b3;
  --scalar-background-2: #c2bfaa;
  --scalar-background-3: #b8b5a1;
  --scalar-background-accent: #000000;

  --scalar-border-color: rgba(0, 0, 0, 0.2);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px,
    var(--scalar-border-color) 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fffef3;
  --scalar-color-2: #fffef3;
  --scalar-color-3: #fffef3;
  --scalar-color-accent: #c3b531;
  --scalar-background-1: #313332;
  --scalar-background-2: #393b3a;
  --scalar-background-3: #414342;
  --scalar-background-accent: #fffef3;

  --scalar-border-color: #505452;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 80%);
}
`;

// node_modules/@scalar/themes/dist/presets/purple.css2.js
var a9 = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f6f8;
  --scalar-background-3: #eceef1;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: rgba(215, 215, 206, 0.68);
}
.dark-mode {
  --scalar-background-1: #15171c;
  --scalar-background-2: #1c1e24;
  --scalar-background-3: #22252b;

  --scalar-color-1: #fafafa;
  --scalar-color-2: #c9ced8;
  --scalar-color-3: #8c99ad;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: #3f4145;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-3);

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/saturn.css2.js
var a10 = `/* basic theme */
.light-mode {
  --scalar-background-1: #f3f3ee;
  --scalar-background-2: #e8e8e3;
  --scalar-background-3: #e4e4df;
  --scalar-border-color: rgba(215, 215, 206, 0.85);

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #1763a6;
  --scalar-background-accent: #1f648e1f;
}
.dark-mode {
  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-border-color: rgba(255, 255, 255, 0.17);

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: #4eb3ec;
  --scalar-background-accent: #8ab4f81f;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/solarized.css2.js
var a11 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #584c27;
  --scalar-color-2: #616161;
  --scalar-color-3: #a89f84;
  --scalar-color-accent: #b58900;
  --scalar-background-1: #fdf6e3;
  --scalar-background-2: #eee8d5;
  --scalar-background-3: #ddd6c1;
  --scalar-background-accent: #b589001f;

  --scalar-border-color: #ded8c8;
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fff;
  --scalar-color-2: #cccccc;
  --scalar-color-3: #6d8890;
  --scalar-color-accent: #007acc;
  --scalar-background-1: #00212b;
  --scalar-background-2: #012b36;
  --scalar-background-3: #004052;
  --scalar-background-accent: #015a6f;

  --scalar-border-color: #2f4851;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}

.dark-mode .sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-sidebar-color-1);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
`;

// node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync2,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map3) {
  overrideErrorMap = map3;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status2, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status2.dirty();
      arrayValue.push(s.value);
    }
    return { status: status2.value, value: arrayValue };
  }
  static async mergeObjectAsync(status2, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status2, syncPairs);
  }
  static mergeObjectSync(status2, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status2.dirty();
      if (value.status === "dirty")
        status2.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status2.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync2(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err2) {
        if (err2?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check2(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status2 = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.length < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "length") {
        const tooBig = input.data.length > check2.value;
        const tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check2.message
            });
          }
          status2.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "regex") {
        check2.regex.lastIndex = 0;
        const testResult = check2.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "trim") {
        input.data = input.data.trim();
      } else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check2.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "datetime") {
        const regex2 = datetimeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "time") {
        const regex2 = timeRegex(check2);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "jwt") {
        if (!isValidJWT(input.data, check2.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status2 = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: false,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check2.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check2.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status2.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status2 = new ParseStatus;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          });
          status2.dirty();
        }
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status2 = new ParseStatus;
    let ctx = undefined;
    for (const check2 of this._def.checks) {
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check2.message,
            inclusive: true,
            exact: false,
            minimum: check2.value,
            type: "date"
          });
          status2.dirty();
        }
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check2.message,
            inclusive: true,
            exact: false,
            maximum: check2.value,
            type: "date"
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check2);
      }
    }
    return {
      status: status2.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status: status2 } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status2.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status2.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status2.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status2, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status2, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status: status2, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status2.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status2, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a12, b) {
  const aType = getParsedType(a12);
  const bType = getParsedType(b);
  if (a12 === b) {
    return { valid: true, data: a12 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a12).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a12, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a12[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a12.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a12.length; index++) {
      const itemA = a12[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a12 === +b) {
    return { valid: true, data: a12 };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status2.dirty();
      }
      return { status: status2.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status2.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status2, results);
      });
    } else {
      return ParseStatus.mergeArray(status2, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status2, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status2.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status2.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status2.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status2.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status2.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status2.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status2.dirty();
        parsedSet.add(element.value);
      }
      return { status: status2.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status2.abort();
        } else {
          status2.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status2.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status2.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status2.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status2.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status2.dirty();
        executeRefinement(inner.value);
        return { status: status2.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status2.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status2.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status2.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status2.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync2(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status2.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status2.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a12, b) {
    return new ZodPipeline({
      in: a12,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync2(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      const r2 = check2(data);
      if (r2 instanceof Promise) {
        return r2.then((r3) => {
          if (!r3) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r2) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/api-reference-plugin.js
var OpenApiExtensionSchema = exports_external.object({
  name: exports_external.string().regex(/^x-/),
  component: exports_external.unknown()
});
var ApiReferencePluginSchema = exports_external.function().returns(exports_external.object({
  name: exports_external.string(),
  extensions: exports_external.array(OpenApiExtensionSchema)
}));

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/helpers/migrate-theme-variables.js
var PREFIX_MIGRATIONS = [
  ["--theme-", "--scalar-"],
  ["--sidebar-", "--scalar-sidebar-"]
];
var LEGACY_PREFIXES = PREFIX_MIGRATIONS.map(([legacy]) => legacy);
function migrateThemeVariables(styles) {
  const hasLegacyPrefixes = LEGACY_PREFIXES.some((p) => styles.includes(p));
  if (!hasLegacyPrefixes) {
    return styles;
  }
  console.warn(`DEPRECATION WARNING: It looks like you're using legacy CSS variables in your custom CSS string. Please migrate them to use the updated prefixes. See https://github.com/scalar/scalar/blob/main/documentation/themes.md#theme-prefix-changes`);
  return PREFIX_MIGRATIONS.reduce((s, [o, n]) => s.replaceAll(o, n), styles);
}

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/api-reference-configuration.js
var themeIdEnum = exports_external.enum([
  "alternate",
  "default",
  "moon",
  "purple",
  "solarized",
  "bluePlanet",
  "deepSpace",
  "saturn",
  "kepler",
  "elysiajs",
  "fastify",
  "mars",
  "none"
]);
var searchHotKeyEnum = exports_external.enum([
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z"
]);
var integrationEnum = exports_external.enum([
  "adonisjs",
  "docusaurus",
  "dotnet",
  "elysiajs",
  "express",
  "fastapi",
  "fastify",
  "go",
  "hono",
  "html",
  "laravel",
  "litestar",
  "nestjs",
  "nextjs",
  "nitro",
  "nuxt",
  "platformatic",
  "react",
  "rust",
  "vue"
]).nullable();
var specConfigurationSchema = exports_external.object({
  url: exports_external.string().optional(),
  content: exports_external.union([exports_external.string(), exports_external.record(exports_external.any()), exports_external.function().returns(exports_external.record(exports_external.any())), exports_external.null()]).optional(),
  title: exports_external.string().optional(),
  slug: exports_external.string().optional()
});
var pathRoutingSchema = exports_external.object({
  basePath: exports_external.string()
});
var apiClientConfigurationSchema = exports_external.object({
  url: exports_external.string().optional(),
  content: exports_external.union([exports_external.string(), exports_external.record(exports_external.any()), exports_external.function().returns(exports_external.record(exports_external.any())), exports_external.null()]).optional(),
  title: exports_external.string().optional(),
  slug: exports_external.string().optional(),
  spec: specConfigurationSchema.optional(),
  authentication: exports_external.any().optional(),
  baseServerURL: exports_external.string().optional(),
  hideClientButton: exports_external.boolean().optional().default(false).catch(false),
  proxyUrl: exports_external.string().optional(),
  searchHotKey: searchHotKeyEnum.optional(),
  servers: exports_external.array(exports_external.any()).optional(),
  showSidebar: exports_external.boolean().optional().default(true).catch(true),
  theme: themeIdEnum.optional().default("default").catch("default"),
  _integration: integrationEnum.optional(),
  onRequestSent: exports_external.function().args(exports_external.string()).returns(exports_external.void()).optional()
});
var OLD_PROXY_URL = "https://api.scalar.com/request-proxy";
var NEW_PROXY_URL = "https://proxy.scalar.com";
var _apiReferenceConfigurationSchema = apiClientConfigurationSchema.merge(exports_external.object({
  layout: exports_external.enum(["modern", "classic"]).optional().default("modern").catch("modern"),
  proxy: exports_external.string().optional(),
  plugins: exports_external.array(ApiReferencePluginSchema).optional(),
  isEditable: exports_external.boolean().optional().default(false).catch(false),
  isLoading: exports_external.boolean().optional().default(false).catch(false),
  hideModels: exports_external.boolean().optional().default(false).catch(false),
  hideDownloadButton: exports_external.boolean().optional().default(false).catch(false),
  hideTestRequestButton: exports_external.boolean().optional().default(false).catch(false),
  hideSearch: exports_external.boolean().optional().default(false).catch(false),
  darkMode: exports_external.boolean().optional(),
  forceDarkModeState: exports_external.enum(["dark", "light"]).optional(),
  hideDarkModeToggle: exports_external.boolean().optional().default(false).catch(false),
  metaData: exports_external.any().optional(),
  favicon: exports_external.string().optional(),
  hiddenClients: exports_external.union([exports_external.record(exports_external.union([exports_external.boolean(), exports_external.array(exports_external.string())])), exports_external.array(exports_external.string()), exports_external.literal(true)]).optional(),
  defaultHttpClient: exports_external.object({
    targetKey: exports_external.custom(),
    clientKey: exports_external.string()
  }).optional(),
  customCss: exports_external.string().optional(),
  onSpecUpdate: exports_external.function().args(exports_external.string()).returns(exports_external.void()).optional(),
  onServerChange: exports_external.function().args(exports_external.string()).returns(exports_external.void()).optional(),
  onDocumentSelect: exports_external.function().returns(exports_external.void().or(exports_external.void().promise())).optional(),
  onLoaded: exports_external.function().returns(exports_external.void().or(exports_external.void().promise())).optional(),
  onShowMore: exports_external.function().args(exports_external.string()).returns(exports_external.void().or(exports_external.void().promise())).optional(),
  onSidebarClick: exports_external.function().args(exports_external.string()).returns(exports_external.void().or(exports_external.void().promise())).optional(),
  pathRouting: pathRoutingSchema.optional(),
  generateHeadingSlug: exports_external.function().args(exports_external.object({
    slug: exports_external.string().default("headingSlug")
  })).returns(exports_external.string()).optional(),
  generateModelSlug: exports_external.function().args(exports_external.object({
    name: exports_external.string().default("modelName")
  })).returns(exports_external.string()).optional(),
  generateTagSlug: exports_external.function().args(exports_external.object({
    name: exports_external.string().default("tagName")
  })).returns(exports_external.string()).optional(),
  generateOperationSlug: exports_external.function().args(exports_external.object({
    path: exports_external.string(),
    operationId: exports_external.string().optional(),
    method: exports_external.string(),
    summary: exports_external.string().optional()
  })).returns(exports_external.string()).optional(),
  generateWebhookSlug: exports_external.function().args(exports_external.object({
    name: exports_external.string(),
    method: exports_external.string().optional()
  })).returns(exports_external.string()).optional(),
  redirect: exports_external.function().args(exports_external.string()).returns(exports_external.string().nullable().optional()).optional(),
  withDefaultFonts: exports_external.boolean().optional().default(true).catch(true),
  defaultOpenAllTags: exports_external.boolean().optional(),
  tagsSorter: exports_external.union([exports_external.literal("alpha"), exports_external.function().args(exports_external.any(), exports_external.any()).returns(exports_external.number())]).optional(),
  operationsSorter: exports_external.union([exports_external.literal("alpha"), exports_external.literal("method"), exports_external.function().args(exports_external.any(), exports_external.any()).returns(exports_external.number())]).optional()
}));
var migrateConfiguration = (_configuration) => {
  const configuration = { ..._configuration };
  if (configuration.spec?.url) {
    console.warn(`[DEPRECATED] You're using the deprecated 'spec.url' attribute. Remove the spec prefix and move the 'url' attribute to the top level.`);
    configuration.url = configuration.spec.url;
    delete configuration.spec;
  }
  if (configuration.spec?.content) {
    console.warn(`[DEPRECATED] You're using the deprecated 'spec.content' attribute. Remove the spec prefix and move the 'content' attribute to the top level.`);
    configuration.content = configuration.spec.content;
    delete configuration.spec;
  }
  if (configuration.customCss) {
    configuration.customCss = migrateThemeVariables(configuration.customCss);
  }
  if (configuration.proxy) {
    console.warn(`[DEPRECATED] You're using the deprecated 'proxy' attribute, rename it to 'proxyUrl' or update the package.`);
    if (!configuration.proxyUrl) {
      configuration.proxyUrl = configuration.proxy;
    }
    delete configuration.proxy;
  }
  if (configuration.proxyUrl === OLD_PROXY_URL) {
    console.warn(`[DEPRECATED] Warning: configuration.proxyUrl points to our old proxy (${OLD_PROXY_URL}).`);
    console.warn(`[DEPRECATED] We are overwriting the value and use the new proxy URL (${NEW_PROXY_URL}) instead.`);
    console.warn(`[DEPRECATED] Action Required: You should manually update your configuration to use the new URL (${NEW_PROXY_URL}). Read more: https://github.com/scalar/scalar`);
    configuration.proxyUrl = NEW_PROXY_URL;
  }
  return configuration;
};
var apiReferenceConfigurationSchema = _apiReferenceConfigurationSchema.transform(migrateConfiguration);
// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/html-rendering-configuration.js
var htmlRenderingConfigurationSchema = exports_external.object({
  cdn: exports_external.string().optional().default("https://cdn.jsdelivr.net/npm/@scalar/api-reference"),
  pageTitle: exports_external.string().optional().default("Scalar API Reference")
});
// node_modules/@scalar/themes/dist/index.js
var m = {
  alternate: a,
  default: r,
  moon: a8,
  elysiajs: a4,
  fastify: a5,
  purple: a9,
  solarized: a11,
  bluePlanet: a2,
  deepSpace: a3,
  saturn: a10,
  kepler: a6,
  mars: a7
};
var K = Object.keys(m);

// node_modules/@elysiajs/swagger/dist/index.mjs
function isSchemaObject(schema) {
  return "type" in schema || "properties" in schema || "items" in schema;
}
function isDateTimeProperty(key, schema) {
  return (key === "createdAt" || key === "updatedAt") && "anyOf" in schema && Array.isArray(schema.anyOf);
}
function transformDateProperties(schema) {
  if (!isSchemaObject(schema) || typeof schema !== "object" || schema === null) {
    return schema;
  }
  const newSchema = { ...schema };
  Object.entries(newSchema).forEach(([key, value]) => {
    if (isSchemaObject(value)) {
      if (isDateTimeProperty(key, value)) {
        const dateTimeFormat = value.anyOf?.find((item) => isSchemaObject(item) && item.format === "date-time");
        if (dateTimeFormat) {
          const dateTimeSchema = {
            type: "string",
            format: "date-time",
            default: dateTimeFormat.default
          };
          newSchema[key] = dateTimeSchema;
        }
      } else {
        newSchema[key] = transformDateProperties(value);
      }
    }
  });
  return newSchema;
}
var SwaggerUIRender = (info, version, theme, stringifiedSwaggerOptions, autoDarkMode) => {
  const swaggerOptions = JSON.parse(stringifiedSwaggerOptions);
  if (swaggerOptions.components && swaggerOptions.components.schemas) {
    swaggerOptions.components.schemas = Object.fromEntries(Object.entries(swaggerOptions.components.schemas).map(([key, schema]) => [
      key,
      transformDateProperties(schema)
    ]));
  }
  const transformedStringifiedSwaggerOptions = JSON.stringify(swaggerOptions);
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${transformedStringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
};
var ScalarRender = (info, version, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? a4}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version}/dist/browser/standalone.min.js`}" crossorigin></script>
  </body>
</html>`;
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint3 = Symbol.for("TypeBox.Hint");
var Kind3 = Symbol.for("TypeBox.Kind");
var toOpenAPIPath = (path) => path.split("/").map((x) => {
  if (x.startsWith(":")) {
    x = x.slice(1, x.length);
    if (x.endsWith("?"))
      x = x.slice(0, -1);
    x = `{${x}}`;
  }
  return x;
}).join("/");
var mapProperties = (name, schema, models) => {
  if (schema === undefined)
    return [];
  if (typeof schema === "string")
    if (schema in models)
      schema = models[schema];
    else
      throw new Error(`Can't find model ${schema}`);
  return Object.entries(schema?.properties ?? []).map(([key, value]) => {
    const {
      type: valueType = undefined,
      description,
      examples,
      ...schemaKeywords
    } = value;
    return {
      description,
      examples,
      schema: { type: valueType, ...schemaKeywords },
      in: name,
      name: key,
      required: schema.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types2, schema) => {
  if (typeof schema === "object" && ["void", "undefined", "null"].includes(schema.type))
    return;
  const responses = {};
  for (const type of types2) {
    responses[type] = {
      schema: typeof schema === "string" ? {
        $ref: `#/components/schemas/${schema}`
      } : ("$ref" in schema) && (Kind3 in schema) && schema[Kind3] === "Ref" ? {
        ...schema,
        $ref: `#/components/schemas/${schema.$ref}`
      } : replaceSchemaType({ ...schema }, {
        from: t.Ref(""),
        to: ({ $ref, ...options }) => {
          if (!$ref.startsWith("#/components/schemas/"))
            return t.Ref(`#/components/schemas/${$ref}`, options);
          return t.Ref($ref, options);
        }
      })
    };
  }
  return responses;
};
var capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path of paths.split("/")) {
    if (path.charCodeAt(0) === 123) {
      operationId += "By" + capitalize(path.slice(1, -1));
    } else {
      operationId += capitalize(path);
    }
  }
  return operationId;
};
var cloneHook = (hook) => {
  if (!hook)
    return;
  if (typeof hook === "string")
    return hook;
  if (Array.isArray(hook))
    return [...hook];
  return { ...hook };
};
var registerSchemaPath = ({
  schema,
  path,
  method,
  hook,
  models
}) => {
  hook = cloneHook(hook);
  if (hook.parse && !Array.isArray(hook.parse))
    hook.parse = [hook.parse];
  let contentType = hook.parse?.map((x) => {
    switch (typeof x) {
      case "string":
        return x;
      case "object":
        if (x && typeof x?.fn !== "string")
          return;
        switch (x?.fn) {
          case "json":
          case "application/json":
            return "application/json";
          case "text":
          case "text/plain":
            return "text/plain";
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            return "application/x-www-form-urlencoded";
          case "arrayBuffer":
          case "application/octet-stream":
            return "application/octet-stream";
          case "formdata":
          case "multipart/form-data":
            return "multipart/form-data";
        }
    }
  }).filter((x) => x !== undefined);
  if (!contentType || contentType.length === 0)
    contentType = ["application/json", "multipart/form-data", "text/plain"];
  path = toOpenAPIPath(path);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = cloneHook(hook?.body);
  const paramsSchema = cloneHook(hook?.params);
  const headerSchema = cloneHook(hook?.headers);
  const querySchema = cloneHook(hook?.query);
  let responseSchema = cloneHook(hook?.response);
  if (typeof responseSchema === "object") {
    if (Kind3 in responseSchema) {
      const {
        type,
        properties,
        required,
        additionalProperties,
        patternProperties,
        $ref,
        ...rest
      } = responseSchema;
      responseSchema = {
        "200": {
          ...rest,
          description: rest.description,
          content: mapTypesResponse(contentTypes, type === "object" || type === "array" ? {
            type,
            properties,
            patternProperties,
            items: responseSchema.items,
            required
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value]) => {
        if (typeof value === "string") {
          if (!models[value])
            return;
          const {
            type,
            properties,
            required,
            additionalProperties: _1,
            patternProperties: _2,
            ...rest
          } = models[value];
          responseSchema[key] = {
            ...rest,
            description: rest.description,
            content: mapTypesResponse(contentTypes, value)
          };
        } else {
          const {
            type,
            properties,
            required,
            additionalProperties,
            patternProperties,
            ...rest
          } = value;
          responseSchema[key] = {
            ...rest,
            description: rest.description,
            content: mapTypesResponse(contentTypes, type === "object" || type === "array" ? {
              type,
              properties,
              patternProperties,
              items: value.items,
              required
            } : value)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const {
      type,
      properties,
      required,
      $ref,
      additionalProperties: _1,
      patternProperties: _2,
      ...rest
    } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema[path] = {
    ...schema[path] ? schema[path] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          required: true,
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, {
  excludeStaticFile = true,
  exclude = []
}) => {
  const newPaths = {};
  for (const [key, value] of Object.entries(paths))
    if (!exclude.some((x) => {
      if (typeof x === "string")
        return key === x;
      return x.test(key);
    }) && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value).forEach((method) => {
        const schema = value[method];
        if (key.includes("{")) {
          if (!schema.parameters)
            schema.parameters = [];
          schema.parameters = [
            ...key.split("/").filter((x) => x.startsWith("{") && !schema.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
              schema: { type: "string" },
              in: "path",
              name: x.slice(1, x.length - 1),
              required: true
            })),
            ...schema.parameters
          ];
        }
        if (!schema.responses)
          schema.responses = {
            200: {}
          };
      });
      newPaths[key] = value;
    }
  return newPaths;
};
var swagger = ({
  provider = "scalar",
  scalarVersion = "latest",
  scalarCDN = "",
  scalarConfig = {},
  documentation = {},
  version = "5.9.0",
  excludeStaticFile = true,
  path = "/swagger",
  specPath = `${path}/json`,
  exclude = [],
  swaggerOptions = {},
  theme = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`,
  autoDarkMode = true,
  excludeMethods = ["OPTIONS"],
  excludeTags = []
} = {}) => {
  const schema = {};
  let totalRoutes = 0;
  if (!version)
    version = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = specPath.startsWith("/") ? specPath.slice(1) : specPath;
  const app = new Elysia({ name: "@elysiajs/swagger" });
  const page = new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version, theme, JSON.stringify({
    url: relativePath,
    dom_id: "#swagger-ui",
    ...swaggerOptions
  }, (_, value) => typeof value === "function" ? undefined : value), autoDarkMode) : ScalarRender(info, scalarVersion, {
    spec: {
      url: relativePath,
      ...scalarConfig.spec
    },
    ...scalarConfig,
    _integration: "elysiajs"
  }, scalarCDN), {
    headers: {
      "content-type": "text/html; charset=utf8"
    }
  });
  app.get(path, page, {
    detail: {
      hide: true
    }
  }).get(specPath, function openAPISchema() {
    const routes = app.getGlobalRoutes();
    if (routes.length !== totalRoutes) {
      const ALLOWED_METHODS = [
        "GET",
        "PUT",
        "POST",
        "DELETE",
        "OPTIONS",
        "HEAD",
        "PATCH",
        "TRACE"
      ];
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (route.hooks?.detail?.hide === true)
          return;
        if (excludeMethods.includes(route.method))
          return;
        if (ALLOWED_METHODS.includes(route.method) === false && route.method !== "ALL")
          return;
        if (route.method === "ALL")
          ALLOWED_METHODS.forEach((method) => {
            registerSchemaPath({
              schema,
              hook: route.hooks,
              method,
              path: route.path,
              models: app.getGlobalDefinitions?.().type,
              contentType: route.hooks.type
            });
          });
        else
          registerSchemaPath({
            schema,
            hook: route.hooks,
            method: route.method,
            path: route.path,
            models: app.getGlobalDefinitions?.().type,
            contentType: route.hooks.type
          });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        tags: documentation.tags?.filter((tag) => !excludeTags?.includes(tag?.name)),
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: {
        ...filterPaths(schema, {
          excludeStaticFile,
          exclude: Array.isArray(exclude) ? exclude : [exclude]
        }),
        ...documentation.paths
      },
      components: {
        ...documentation.components,
        schemas: {
          ...app.getGlobalDefinitions?.().type,
          ...documentation.components?.schemas
        }
      }
    };
  }, {
    detail: {
      hide: true
    }
  });
  return app;
};

// src/config/database.ts
var import_mongoose = __toESM(require_mongoose2(), 1);
var connectDatabase = async () => {
  const mongoUri = process.env.MONGODB_URI || "mongodb://localhost:27017/streaming-platform";
  try {
    await import_mongoose.default.connect(mongoUri, {
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000
    });
    console.log("✅ Connected to MongoDB");
  } catch (error) {
    console.error("❌ MongoDB connection error:", error);
    if (mongoUri.includes("mongodb+srv")) {
      console.log("\uD83D\uDD04 Atlas connection failed, falling back to local MongoDB...");
      try {
        await import_mongoose.default.connect("mongodb://localhost:27017/streaming-platform");
        console.log("✅ Connected to local MongoDB");
      } catch (localError) {
        console.error("❌ Local MongoDB connection also failed:", localError);
        console.log("\uD83D\uDCA1 Please ensure MongoDB is running locally or whitelist your IP in Atlas");
        process.exit(1);
      }
    } else {
      process.exit(1);
    }
  }
};
import_mongoose.default.connection.on("disconnected", () => {
  console.log("\uD83D\uDCE4 MongoDB disconnected");
});
import_mongoose.default.connection.on("error", (error) => {
  console.error("❌ MongoDB error:", error);
});

// src/config/env.ts
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.config();
var env3 = {
  PORT: process.env.PORT || 3001,
  NODE_ENV: "development",
  MONGODB_URI: process.env.MONGODB_URI || "mongodb://localhost:27017/streaming-platform",
  JWT_SECRET: process.env.JWT_SECRET || "your-super-secret-jwt-key",
  JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET || "your-super-secret-refresh-key",
  STRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY || "",
  STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET || "",
  FRONTEND_URL: process.env.FRONTEND_URL || "http://localhost:3000",
  TURN_SERVER_URL: process.env.TURN_SERVER_URL || "",
  TURN_USERNAME: process.env.TURN_USERNAME || "",
  TURN_CREDENTIAL: process.env.TURN_CREDENTIAL || "",
  STUN_SERVER_URL: process.env.STUN_SERVER_URL || "stun:stun.l.google.com:19302"
};

// src/models/User.ts
var import_mongoose2 = __toESM(require_mongoose2(), 1);
var import_bcryptjs = __toESM(require_bcrypt(), 1);
var userSchema = new import_mongoose2.Schema({
  username: {
    type: String,
    required: true,
    trim: true,
    minlength: 3,
    maxlength: 30
  },
  email: {
    type: String,
    required: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  displayName: {
    type: String,
    required: true,
    trim: true,
    maxlength: 50
  },
  avatar: {
    type: String,
    default: null
  },
  bio: {
    type: String,
    maxlength: 500,
    default: ""
  },
  role: {
    type: String,
    enum: ["viewer", "streamer", "moderator", "admin"],
    default: "viewer"
  },
  isLive: {
    type: Boolean,
    default: false
  },
  followers: [{
    type: import_mongoose2.Schema.Types.ObjectId,
    ref: "User"
  }],
  following: [{
    type: import_mongoose2.Schema.Types.ObjectId,
    ref: "User"
  }],
  streamKey: {
    type: String,
    sparse: true
  }
}, {
  timestamps: true
});
userSchema.pre("save", async function(next) {
  if (!this.isModified("password"))
    return next();
  try {
    const salt = await import_bcryptjs.default.genSalt(10);
    this.password = await import_bcryptjs.default.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});
userSchema.methods.comparePassword = async function(candidatePassword) {
  console.log("Comparing passwords...");
  console.log("Candidate password length:", candidatePassword.length);
  console.log("Stored hash length:", this.password.length);
  const result = await import_bcryptjs.default.compare(candidatePassword, this.password);
  console.log("Password comparison result:", result);
  return result;
};
userSchema.methods.generateStreamKey = function() {
  const streamKey = `sk_${this._id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  this.streamKey = streamKey;
  return streamKey;
};
userSchema.index({ username: 1 }, { unique: true });
userSchema.index({ email: 1 }, { unique: true });
userSchema.index({ streamKey: 1 }, { unique: true, sparse: true });
var User = import_mongoose2.default.model("User", userSchema);
// src/models/Stream.ts
var import_mongoose3 = __toESM(require_mongoose2(), 1);
var streamSchema = new import_mongoose3.Schema({
  streamerId: {
    type: import_mongoose3.Schema.Types.ObjectId,
    ref: "User",
    required: true
  },
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100
  },
  description: {
    type: String,
    maxlength: 500,
    default: ""
  },
  category: {
    type: String,
    required: true,
    enum: [
      "Gaming",
      "Just Chatting",
      "Music",
      "Art",
      "Technology",
      "Education",
      "Sports",
      "Cooking",
      "IRL",
      "Other"
    ]
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: 25
  }],
  isLive: {
    type: Boolean,
    default: false
  },
  viewerCount: {
    type: Number,
    default: 0,
    min: 0
  },
  streamKey: {
    type: String,
    required: true
  },
  thumbnail: {
    type: String,
    default: null
  },
  startedAt: {
    type: Date,
    default: null
  },
  endedAt: {
    type: Date,
    default: null
  }
}, {
  timestamps: true
});
streamSchema.index({ streamerId: 1 });
streamSchema.index({ isLive: 1 });
streamSchema.index({ category: 1 });
streamSchema.index({ createdAt: -1 });
streamSchema.index({ viewerCount: -1 });
streamSchema.index({ streamKey: 1 }, { unique: true });
var Stream = import_mongoose3.default.model("Stream", streamSchema);
// src/models/ChatMessage.ts
var import_mongoose4 = __toESM(require_mongoose2(), 1);
var chatMessageSchema = new import_mongoose4.Schema({
  streamId: {
    type: import_mongoose4.Schema.Types.ObjectId,
    ref: "Stream",
    required: true
  },
  userId: {
    type: import_mongoose4.Schema.Types.ObjectId,
    ref: "User",
    required: true
  },
  username: {
    type: String,
    required: true
  },
  message: {
    type: String,
    required: true,
    maxlength: 500
  },
  timestamp: {
    type: Date,
    default: Date.now
  },
  isDeleted: {
    type: Boolean,
    default: false
  },
  isModerated: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: false
});
chatMessageSchema.index({ streamId: 1, timestamp: -1 });
chatMessageSchema.index({ userId: 1 });
var ChatMessage = import_mongoose4.default.model("ChatMessage", chatMessageSchema);
// src/models/GuestStream.ts
var import_mongoose5 = __toESM(require_mongoose2(), 1);
var guestStreamSchema = new import_mongoose5.Schema({
  guestId: {
    type: String,
    required: true,
    unique: true
  },
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 100
  },
  description: {
    type: String,
    maxlength: 500,
    default: ""
  },
  category: {
    type: String,
    required: true,
    enum: [
      "Gaming",
      "Just Chatting",
      "Music",
      "Art",
      "Technology",
      "Education",
      "Sports",
      "Cooking",
      "IRL",
      "Other"
    ]
  },
  tags: [{
    type: String,
    trim: true,
    maxlength: 25
  }],
  isLive: {
    type: Boolean,
    default: false
  },
  viewerCount: {
    type: Number,
    default: 0,
    min: 0
  },
  streamKey: {
    type: String,
    required: true,
    unique: true
  },
  thumbnail: {
    type: String,
    default: null
  },
  startedAt: {
    type: Date,
    default: null
  },
  endedAt: {
    type: Date,
    default: null
  },
  expiresAt: {
    type: Date,
    required: true,
    default: () => new Date(Date.now() + 2 * 60 * 60 * 1000)
  },
  guestDisplayName: {
    type: String,
    required: true,
    trim: true,
    maxlength: 30
  }
}, {
  timestamps: true
});
guestStreamSchema.index({ guestId: 1 });
guestStreamSchema.index({ isLive: 1 });
guestStreamSchema.index({ category: 1 });
guestStreamSchema.index({ createdAt: -1 });
guestStreamSchema.index({ viewerCount: -1 });
guestStreamSchema.index({ streamKey: 1 }, { unique: true });
guestStreamSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
var GuestStream = import_mongoose5.default.model("GuestStream", guestStreamSchema);
// src/middleware/auth.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
var authMiddleware = async (context) => {
  try {
    const authHeader = context.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return {
        success: false,
        error: "No token provided"
      };
    }
    const token = authHeader.substring(7);
    const decoded = import_jsonwebtoken.default.verify(token, env3.JWT_SECRET);
    const user = await User.findById(decoded.userId).select("-password");
    if (!user) {
      return {
        success: false,
        error: "User not found"
      };
    }
    return {
      success: true,
      user: {
        id: user._id.toString(),
        username: user.username,
        email: user.email,
        displayName: user.displayName,
        role: user.role,
        avatar: user.avatar,
        isLive: user.isLive
      }
    };
  } catch (error) {
    return {
      success: false,
      error: "Invalid token"
    };
  }
};
var generateTokens = (user) => {
  try {
    console.log("GenerateTokens: Creating payload for user:", user.username);
    const payload = {
      userId: user._id.toString(),
      username: user.username,
      role: user.role
    };
    console.log("GenerateTokens: Payload created:", payload);
    console.log("GenerateTokens: Signing access token...");
    const accessToken = import_jsonwebtoken.default.sign(payload, env3.JWT_SECRET, { expiresIn: "15m" });
    console.log("GenerateTokens: Access token created, length:", accessToken.length);
    console.log("GenerateTokens: Signing refresh token...");
    const refreshToken = import_jsonwebtoken.default.sign(payload, env3.JWT_REFRESH_SECRET, { expiresIn: "7d" });
    console.log("GenerateTokens: Refresh token created, length:", refreshToken.length);
    return { accessToken, refreshToken };
  } catch (error) {
    console.error("GenerateTokens: Error generating tokens:", error);
    throw error;
  }
};

// src/routes/auth.ts
var authRoutes = new Elysia({ prefix: "/auth" }).post("/register", async ({ body }) => {
  try {
    const { username, email, password, displayName } = body;
    console.log("Registration attempt for email:", email, "username:", username);
    const existingUser = await User.findOne({
      $or: [{ email }, { username }]
    });
    if (existingUser) {
      console.log("User already exists:", existingUser.email === email ? "email" : "username");
      return {
        success: false,
        error: existingUser.email === email ? "Email already exists" : "Username already exists"
      };
    }
    const user = new User({
      username,
      email,
      password,
      displayName
    });
    await user.save();
    console.log("User registered successfully:", user.email);
    const tokens = generateTokens(user);
    return {
      success: true,
      data: {
        user: {
          id: user._id.toString(),
          username: user.username,
          email: user.email,
          displayName: user.displayName,
          role: user.role,
          avatar: user.avatar
        },
        ...tokens
      }
    };
  } catch (error) {
    console.error("Registration error:", error);
    return {
      success: false,
      error: "Registration failed"
    };
  }
}, {
  body: t.Object({
    username: t.String({ minLength: 3, maxLength: 30 }),
    email: t.String({ format: "email" }),
    password: t.String({ minLength: 6 }),
    displayName: t.String({ minLength: 1, maxLength: 50 })
  })
}).post("/login", async ({ body }) => {
  try {
    const { email, password } = body;
    console.log("Login attempt for email:", email);
    const user = await User.findOne({ email });
    console.log("User found:", user ? "Yes" : "No");
    if (!user) {
      console.log("User not found for email:", email);
      return {
        success: false,
        error: "Invalid credentials"
      };
    }
    const isPasswordValid = await user.comparePassword(password);
    console.log("Password valid:", isPasswordValid);
    if (!isPasswordValid) {
      console.log("Password comparison failed");
      return {
        success: false,
        error: "Invalid credentials"
      };
    }
    console.log("Generating tokens...");
    const tokens = generateTokens(user);
    console.log("Tokens generated successfully:", !!tokens.accessToken, !!tokens.refreshToken);
    console.log("Login successful for user:", user.email);
    const response = {
      success: true,
      data: {
        user: {
          id: user._id.toString(),
          username: user.username,
          email: user.email,
          displayName: user.displayName,
          role: user.role,
          avatar: user.avatar,
          isLive: user.isLive
        },
        ...tokens
      }
    };
    console.log("Sending response:", JSON.stringify(response, null, 2));
    return response;
  } catch (error) {
    console.error("Login error:", error);
    return {
      success: false,
      error: "Login failed"
    };
  }
}, {
  body: t.Object({
    email: t.String({ format: "email" }),
    password: t.String({ minLength: 1 })
  })
}).get("/me", async (context) => {
  const authResult = await authMiddleware(context);
  if (!authResult.success) {
    context.set.status = 401;
    return authResult;
  }
  return {
    success: true,
    data: { user: authResult.user }
  };
}).post("/stream-key", async (context) => {
  const authResult = await authMiddleware(context);
  if (!authResult.success) {
    context.set.status = 401;
    return authResult;
  }
  try {
    const user = await User.findById(authResult.user.id);
    if (!user) {
      return {
        success: false,
        error: "User not found"
      };
    }
    const streamKey = user.generateStreamKey();
    await user.save();
    return {
      success: true,
      data: { streamKey }
    };
  } catch (error) {
    console.error("Stream key generation error:", error);
    return {
      success: false,
      error: "Failed to generate stream key"
    };
  }
});
// src/routes/streams.ts
var streamRoutes = new Elysia({ prefix: "/streams" }).get("/", async ({ query }) => {
  try {
    const { category, page = 1, limit = 20, live_only } = query;
    const filter = {};
    if (category) {
      filter.category = category;
    }
    if (live_only === "true") {
      filter.isLive = true;
    }
    const skip = (Number(page) - 1) * Number(limit);
    const streams = await Stream.find(filter).populate("streamerId", "username displayName avatar").sort({ isLive: -1, viewerCount: -1, createdAt: -1 }).skip(skip).limit(Number(limit));
    const guestStreams = await GuestStream.find(filter).sort({ isLive: -1, viewerCount: -1, createdAt: -1 }).skip(skip).limit(Number(limit));
    const transformedGuestStreams = guestStreams.map((guestStream) => ({
      _id: guestStream._id,
      title: guestStream.title,
      description: guestStream.description,
      category: guestStream.category,
      tags: guestStream.tags,
      isLive: guestStream.isLive,
      viewerCount: guestStream.viewerCount,
      thumbnail: guestStream.thumbnail,
      startedAt: guestStream.startedAt,
      endedAt: guestStream.endedAt,
      createdAt: guestStream.createdAt,
      updatedAt: guestStream.updatedAt,
      isGuestStream: true,
      streamerId: {
        _id: guestStream.guestId,
        username: guestStream.guestDisplayName,
        displayName: guestStream.guestDisplayName,
        avatar: null
      }
    }));
    const allStreams = [...streams, ...transformedGuestStreams].sort((a12, b) => {
      if (a12.isLive !== b.isLive)
        return b.isLive ? 1 : -1;
      if (a12.viewerCount !== b.viewerCount)
        return b.viewerCount - a12.viewerCount;
      return new Date(b.createdAt).getTime() - new Date(a12.createdAt).getTime();
    }).slice(0, Number(limit));
    const total = await Stream.countDocuments(filter) + await GuestStream.countDocuments(filter);
    return {
      success: true,
      data: {
        streams: allStreams,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total,
          pages: Math.ceil(total / Number(limit))
        }
      }
    };
  } catch (error) {
    console.error("Get streams error:", error);
    return {
      success: false,
      error: "Failed to fetch streams"
    };
  }
}, {
  query: t.Object({
    category: t.Optional(t.String()),
    page: t.Optional(t.String()),
    limit: t.Optional(t.String()),
    live_only: t.Optional(t.String())
  })
}).get("/:id", async ({ params }) => {
  try {
    let stream = await Stream.findById(params.id).populate("streamerId", "username displayName avatar bio followers");
    if (stream) {
      return {
        success: true,
        data: { stream }
      };
    }
    const guestStream = await GuestStream.findById(params.id);
    if (guestStream) {
      if (new Date > guestStream.expiresAt) {
        await GuestStream.findByIdAndDelete(params.id);
        return {
          success: false,
          error: "Stream not found"
        };
      }
      const transformedGuestStream = {
        _id: guestStream._id,
        title: guestStream.title,
        description: guestStream.description,
        category: guestStream.category,
        tags: guestStream.tags,
        isLive: guestStream.isLive,
        viewerCount: guestStream.viewerCount,
        thumbnail: guestStream.thumbnail,
        startedAt: guestStream.startedAt,
        endedAt: guestStream.endedAt,
        createdAt: guestStream.createdAt,
        updatedAt: guestStream.updatedAt,
        isGuestStream: true,
        streamerId: {
          _id: guestStream.guestId,
          username: guestStream.guestDisplayName,
          displayName: guestStream.guestDisplayName,
          avatar: null,
          bio: "",
          followers: []
        }
      };
      return {
        success: true,
        data: { stream: transformedGuestStream }
      };
    }
    return {
      success: false,
      error: "Stream not found"
    };
  } catch (error) {
    console.error("Get stream error:", error);
    return {
      success: false,
      error: "Failed to fetch stream"
    };
  }
}).post("/", async (context) => {
  const authResult = await authMiddleware(context);
  if (!authResult.success) {
    context.set.status = 401;
    return authResult;
  }
  try {
    const { title, description, category, tags } = context.body;
    const user = await User.findById(authResult.user.id);
    if (!user || !user.streamKey) {
      return {
        success: false,
        error: "Stream key required. Generate one first."
      };
    }
    const existingStream = await Stream.findOne({
      streamerId: authResult.user.id,
      isLive: true
    });
    if (existingStream) {
      return {
        success: false,
        error: "You already have an active stream"
      };
    }
    const stream = new Stream({
      streamerId: authResult.user.id,
      title,
      description,
      category,
      tags: tags || [],
      streamKey: user.streamKey
    });
    await stream.save();
    return {
      success: true,
      data: { stream }
    };
  } catch (error) {
    console.error("Create stream error:", error);
    return {
      success: false,
      error: "Failed to create stream"
    };
  }
}, {
  body: t.Object({
    title: t.String({ minLength: 1, maxLength: 100 }),
    description: t.Optional(t.String({ maxLength: 500 })),
    category: t.String(),
    tags: t.Optional(t.Array(t.String()))
  })
}).put("/:id/live", async (context) => {
  const authResult = await authMiddleware(context);
  if (!authResult.success) {
    context.set.status = 401;
    return authResult;
  }
  try {
    const { isLive } = context.body;
    const stream = await Stream.findOne({
      _id: context.params.id,
      streamerId: authResult.user.id
    });
    if (!stream) {
      return {
        success: false,
        error: "Stream not found"
      };
    }
    stream.isLive = isLive;
    if (isLive) {
      stream.startedAt = new Date;
      await User.findByIdAndUpdate(authResult.user.id, { isLive: true });
    } else {
      stream.endedAt = new Date;
      stream.viewerCount = 0;
      await User.findByIdAndUpdate(authResult.user.id, { isLive: false });
    }
    await stream.save();
    return {
      success: true,
      data: { stream }
    };
  } catch (error) {
    console.error("Update stream status error:", error);
    return {
      success: false,
      error: "Failed to update stream status"
    };
  }
}, {
  body: t.Object({
    isLive: t.Boolean()
  })
});
// src/routes/guest-streams.ts
var guestStreamRoutes = new Elysia({ prefix: "/guest-streams" }).post("/", async ({ body }) => {
  try {
    const { title, description, category, tags, guestDisplayName } = body;
    const guestId = `guest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const streamKey = `gsk_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;
    const guestStream = new GuestStream({
      guestId,
      title,
      description,
      category,
      tags: tags || [],
      streamKey,
      guestDisplayName
    });
    await guestStream.save();
    return {
      success: true,
      data: {
        stream: guestStream,
        streamKey
      }
    };
  } catch (error) {
    console.error("Create guest stream error:", error);
    return {
      success: false,
      error: "Failed to create guest stream"
    };
  }
}, {
  body: t.Object({
    title: t.String({ minLength: 1, maxLength: 100 }),
    description: t.Optional(t.String({ maxLength: 500 })),
    category: t.String(),
    tags: t.Optional(t.Array(t.String())),
    guestDisplayName: t.String({ minLength: 1, maxLength: 30 })
  })
}).get("/:id", async ({ params }) => {
  try {
    const guestStream = await GuestStream.findById(params.id);
    if (!guestStream) {
      return {
        success: false,
        error: "Guest stream not found"
      };
    }
    if (new Date > guestStream.expiresAt) {
      await GuestStream.findByIdAndDelete(params.id);
      return {
        success: false,
        error: "Guest stream has expired"
      };
    }
    return {
      success: true,
      data: { stream: guestStream }
    };
  } catch (error) {
    console.error("Get guest stream error:", error);
    return {
      success: false,
      error: "Failed to fetch guest stream"
    };
  }
}).put("/:id/live", async ({ params, body }) => {
  try {
    const { isLive } = body;
    const guestStream = await GuestStream.findById(params.id);
    if (!guestStream) {
      return {
        success: false,
        error: "Guest stream not found"
      };
    }
    if (new Date > guestStream.expiresAt) {
      await GuestStream.findByIdAndDelete(params.id);
      return {
        success: false,
        error: "Guest stream has expired"
      };
    }
    guestStream.isLive = isLive;
    if (isLive) {
      guestStream.startedAt = new Date;
    } else {
      guestStream.endedAt = new Date;
      guestStream.viewerCount = 0;
    }
    await guestStream.save();
    return {
      success: true,
      data: { stream: guestStream }
    };
  } catch (error) {
    console.error("Update guest stream status error:", error);
    return {
      success: false,
      error: "Failed to update guest stream status"
    };
  }
}, {
  body: t.Object({
    isLive: t.Boolean()
  })
}).delete("/:id", async ({ params }) => {
  try {
    const guestStream = await GuestStream.findByIdAndDelete(params.id);
    if (!guestStream) {
      return {
        success: false,
        error: "Guest stream not found"
      };
    }
    return {
      success: true,
      data: { message: "Guest stream deleted successfully" }
    };
  } catch (error) {
    console.error("Delete guest stream error:", error);
    return {
      success: false,
      error: "Failed to delete guest stream"
    };
  }
});
// node_modules/ws/wrapper.mjs
var import_stream8 = __toESM(require_stream(), 1);
var import_receiver = __toESM(require_receiver(), 1);
var import_sender = __toESM(require_sender(), 1);
var import_websocket = __toESM(require_websocket(), 1);
var import_websocket_server = __toESM(require_websocket_server(), 1);

// src/services/websocket.ts
var import_jsonwebtoken2 = __toESM(require_jsonwebtoken(), 1);
class WebSocketService {
  wss;
  clients = new Map;
  streamViewers = new Map;
  constructor(port) {
    this.wss = new import_websocket_server.default({ port });
    this.setupWebSocketServer();
  }
  setupWebSocketServer() {
    this.wss.on("connection", (ws, request) => {
      console.log("New WebSocket connection");
      ws.on("message", async (data) => {
        try {
          const message = JSON.parse(data.toString());
          await this.handleMessage(ws, message);
        } catch (error) {
          console.error("WebSocket message error:", error);
          ws.send(JSON.stringify({
            type: "error",
            message: "Invalid message format"
          }));
        }
      });
      ws.on("close", () => {
        this.handleDisconnection(ws);
      });
      ws.on("error", (error) => {
        console.error("WebSocket error:", error);
      });
    });
    console.log(`\uD83D\uDE80 WebSocket server running on port ${this.wss.options.port}`);
  }
  async handleMessage(ws, message) {
    switch (message.type) {
      case "authenticate":
        await this.handleAuthentication(ws, message);
        break;
      case "join_stream":
        await this.handleJoinStream(ws, message);
        break;
      case "leave_stream":
        await this.handleLeaveStream(ws, message);
        break;
      case "chat_message":
        await this.handleChatMessage(ws, message);
        break;
      case "webrtc_offer":
      case "webrtc_answer":
      case "webrtc_ice_candidate":
        await this.handleWebRTCSignaling(ws, message);
        break;
      default:
        ws.send(JSON.stringify({
          type: "error",
          message: "Unknown message type"
        }));
    }
  }
  async handleAuthentication(ws, message) {
    try {
      const { token } = message;
      if (!token) {
        ws.send(JSON.stringify({
          type: "auth_error",
          message: "Token required"
        }));
        return;
      }
      const decoded = import_jsonwebtoken2.default.verify(token, env3.JWT_SECRET);
      const clientId = `${decoded.userId}_${Date.now()}`;
      this.clients.set(clientId, {
        ws,
        userId: decoded.userId,
        username: decoded.username,
        isStreamer: false
      });
      ws.send(JSON.stringify({
        type: "authenticated",
        clientId
      }));
    } catch (error) {
      ws.send(JSON.stringify({
        type: "auth_error",
        message: "Invalid token"
      }));
    }
  }
  async handleJoinStream(ws, message) {
    try {
      const { streamId } = message;
      const client = this.findClientByWs(ws);
      if (!client) {
        ws.send(JSON.stringify({
          type: "error",
          message: "Not authenticated"
        }));
        return;
      }
      const stream = await Stream.findById(streamId).populate("streamerId");
      if (!stream || !stream.isLive) {
        ws.send(JSON.stringify({
          type: "error",
          message: "Stream not found or not live"
        }));
        return;
      }
      client.streamId = streamId;
      client.isStreamer = stream.streamerId._id.toString() === client.userId;
      if (!this.streamViewers.has(streamId)) {
        this.streamViewers.set(streamId, new Set);
      }
      this.streamViewers.get(streamId).add(client.userId);
      await Stream.findByIdAndUpdate(streamId, {
        viewerCount: this.streamViewers.get(streamId).size
      });
      this.broadcastToStream(streamId, {
        type: "user_joined",
        userId: client.userId,
        username: client.username,
        viewerCount: this.streamViewers.get(streamId).size
      });
      ws.send(JSON.stringify({
        type: "joined_stream",
        streamId,
        isStreamer: client.isStreamer,
        viewerCount: this.streamViewers.get(streamId).size
      }));
    } catch (error) {
      console.error("Join stream error:", error);
      ws.send(JSON.stringify({
        type: "error",
        message: "Failed to join stream"
      }));
    }
  }
  async handleLeaveStream(ws, message) {
    const client = this.findClientByWs(ws);
    if (!client || !client.streamId)
      return;
    const streamId = client.streamId;
    this.streamViewers.get(streamId)?.delete(client.userId);
    if (this.streamViewers.get(streamId)?.size === 0) {
      this.streamViewers.delete(streamId);
    }
    await Stream.findByIdAndUpdate(streamId, {
      viewerCount: this.streamViewers.get(streamId)?.size || 0
    });
    this.broadcastToStream(streamId, {
      type: "user_left",
      userId: client.userId,
      username: client.username,
      viewerCount: this.streamViewers.get(streamId)?.size || 0
    });
    client.streamId = undefined;
    client.isStreamer = false;
  }
  async handleChatMessage(ws, message) {
    try {
      const client = this.findClientByWs(ws);
      if (!client || !client.streamId) {
        ws.send(JSON.stringify({
          type: "error",
          message: "Not in a stream"
        }));
        return;
      }
      const { text } = message;
      if (!text || text.trim().length === 0) {
        return;
      }
      const chatMessage = new ChatMessage({
        streamId: client.streamId,
        userId: client.userId,
        username: client.username,
        message: text.trim()
      });
      await chatMessage.save();
      this.broadcastToStream(client.streamId, {
        type: "chat_message",
        id: chatMessage._id,
        userId: client.userId,
        username: client.username,
        message: text.trim(),
        timestamp: chatMessage.timestamp
      });
    } catch (error) {
      console.error("Chat message error:", error);
      ws.send(JSON.stringify({
        type: "error",
        message: "Failed to send message"
      }));
    }
  }
  async handleWebRTCSignaling(ws, message) {
    const client = this.findClientByWs(ws);
    if (!client || !client.streamId) {
      return;
    }
    this.broadcastToStream(client.streamId, {
      ...message,
      fromUserId: client.userId,
      fromUsername: client.username
    }, client.userId);
  }
  findClientByWs(ws) {
    for (const client of this.clients.values()) {
      if (client.ws === ws) {
        return client;
      }
    }
    return;
  }
  handleDisconnection(ws) {
    const client = this.findClientByWs(ws);
    if (client) {
      if (client.streamId) {
        this.handleLeaveStream(ws, { streamId: client.streamId });
      }
      for (const [clientId, c] of this.clients.entries()) {
        if (c.ws === ws) {
          this.clients.delete(clientId);
          break;
        }
      }
    }
    console.log("WebSocket connection closed");
  }
  broadcastToStream(streamId, message, excludeUserId) {
    for (const client of this.clients.values()) {
      if (client.streamId === streamId && client.userId !== excludeUserId) {
        if (client.ws.readyState === import_websocket.default.OPEN) {
          client.ws.send(JSON.stringify(message));
        }
      }
    }
  }
  getViewerCount(streamId) {
    return this.streamViewers.get(streamId)?.size || 0;
  }
}

// src/index.ts
var app = new Elysia().use(cors({
  origin: [env3.FRONTEND_URL, "http://localhost:3000"],
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"]
})).use(swagger({
  documentation: {
    info: {
      title: "Streaming Platform API",
      version: "1.0.0",
      description: "API for live streaming platform with WebRTC and real-time chat"
    }
  }
})).get("/", () => ({
  message: "Streaming Platform API",
  version: "1.0.0",
  status: "running"
})).use(authRoutes).use(streamRoutes).use(guestStreamRoutes).listen(env3.PORT);
var startServer = async () => {
  try {
    await connectDatabase();
    const wsService = new WebSocketService(Number(env3.PORT) + 1000);
    console.log(`\uD83D\uDE80 HTTP Server running at http://localhost:${env3.PORT}`);
    console.log(`\uD83D\uDCC4 API Documentation available at http://localhost:${env3.PORT}/swagger`);
    console.log(`\uD83D\uDD0C WebSocket server running on port ${Number(env3.PORT) + 1000}`);
  } catch (error) {
    console.error("❌ Failed to start server:", error);
    process.exit(1);
  }
};
startServer();
